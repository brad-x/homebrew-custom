From 0272e162b73b402fb8d69a172a85463a821047be Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sat, 10 Oct 2020 19:52:38 -0700
Subject: [PATCH 001/180] block: feature detection for host block support

On Darwin (iOS), there are no system level APIs for directly accessing
host block devices. We detect this at configure time.
---
 block/file-posix.c   | 33 ++++++++++++++++++++++-----------
 meson.build          |  6 +++++-
 qapi/block-core.json | 10 +++++++---
 3 files changed, 34 insertions(+), 15 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index 05079b40caee..d1ab3180ff16 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -42,6 +42,8 @@
 #include "scsi/constants.h"
 
 #if defined(__APPLE__) && (__MACH__)
+#include <sys/ioctl.h>
+#if defined(HAVE_HOST_BLOCK_DEVICE)
 #include <paths.h>
 #include <sys/param.h>
 #include <IOKit/IOKitLib.h>
@@ -52,6 +54,7 @@
 //#include <IOKit/storage/IOCDTypes.h>
 #include <IOKit/storage/IODVDMedia.h>
 #include <CoreFoundation/CoreFoundation.h>
+#endif /* defined(HAVE_HOST_BLOCK_DEVICE) */
 #endif
 
 #ifdef __sun__
@@ -181,7 +184,17 @@ typedef struct BDRVRawReopenState {
     bool check_cache_dropped;
 } BDRVRawReopenState;
 
-static int fd_open(BlockDriverState *bs);
+static int fd_open(BlockDriverState *bs)
+{
+    BDRVRawState *s = bs->opaque;
+
+    /* this is just to ensure s->fd is sane (its called by io ops) */
+    if (s->fd >= 0) {
+        return 0;
+    }
+    return -EIO;
+}
+
 static int64_t raw_getlength(BlockDriverState *bs);
 
 typedef struct RawPosixAIOData {
@@ -3032,6 +3045,7 @@ static BlockStatsSpecific *raw_get_specific_stats(BlockDriverState *bs)
     return stats;
 }
 
+#if defined(HAVE_HOST_BLOCK_DEVICE)
 static BlockStatsSpecific *hdev_get_specific_stats(BlockDriverState *bs)
 {
     BlockStatsSpecific *stats = g_new(BlockStatsSpecific, 1);
@@ -3041,6 +3055,7 @@ static BlockStatsSpecific *hdev_get_specific_stats(BlockDriverState *bs)
 
     return stats;
 }
+#endif /* HAVE_HOST_BLOCK_DEVICE */
 
 static QemuOptsList raw_create_opts = {
     .name = "raw-create-opts",
@@ -3265,6 +3280,8 @@ BlockDriver bdrv_file = {
 /***********************************************/
 /* host device */
 
+#if defined(HAVE_HOST_BLOCK_DEVICE)
+
 #if defined(__APPLE__) && defined(__MACH__)
 static kern_return_t GetBSDPath(io_iterator_t mediaIterator, char *bsdPath,
                                 CFIndex maxPathSize, int flags);
@@ -3557,16 +3574,6 @@ hdev_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
 }
 #endif /* linux */
 
-static int fd_open(BlockDriverState *bs)
-{
-    BDRVRawState *s = bs->opaque;
-
-    /* this is just to ensure s->fd is sane (its called by io ops) */
-    if (s->fd >= 0)
-        return 0;
-    return -EIO;
-}
-
 static coroutine_fn int
 hdev_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)
 {
@@ -3890,6 +3897,8 @@ static BlockDriver bdrv_host_cdrom = {
 };
 #endif /* __FreeBSD__ */
 
+#endif /* HAVE_HOST_BLOCK_DEVICE */
+
 static void bdrv_file_init(void)
 {
     /*
@@ -3897,6 +3906,7 @@ static void bdrv_file_init(void)
      * registered last will get probed first.
      */
     bdrv_register(&bdrv_file);
+#if defined(HAVE_HOST_BLOCK_DEVICE)
     bdrv_register(&bdrv_host_device);
 #ifdef __linux__
     bdrv_register(&bdrv_host_cdrom);
@@ -3904,6 +3914,7 @@ static void bdrv_file_init(void)
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
     bdrv_register(&bdrv_host_cdrom);
 #endif
+#endif /* HAVE_HOST_BLOCK_DEVICE */
 }
 
 block_init(bdrv_file_init);
diff --git a/meson.build b/meson.build
index 81d760d6e84f..0e53876f69c1 100644
--- a/meson.build
+++ b/meson.build
@@ -181,7 +181,7 @@ if targetos == 'windows'
                                       include_directories: include_directories('.'))
 elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
-  iokit = dependency('appleframeworks', modules: 'IOKit')
+  iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
             cc.find_library('nsl'),
@@ -1056,6 +1056,9 @@ if get_option('cfi')
   add_global_link_arguments(cfi_flags, native: false, language: ['c', 'cpp', 'objc'])
 endif
 
+have_host_block_device = (targetos != 'darwin' or
+    cc.has_header('IOKit/storage/IOMedia.h'))
+
 #################
 # config-host.h #
 #################
@@ -1149,6 +1152,7 @@ config_host_data.set('HAVE_PTY_H', cc.has_header('pty.h'))
 config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
 config_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))
+config_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)
 
 config_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))
 
diff --git a/qapi/block-core.json b/qapi/block-core.json
index 9f555d5c1d83..0c2cd9e68926 100644
--- a/qapi/block-core.json
+++ b/qapi/block-core.json
@@ -959,7 +959,8 @@
   'discriminator': 'driver',
   'data': {
       'file': 'BlockStatsSpecificFile',
-      'host_device': 'BlockStatsSpecificFile',
+      'host_device': { 'type': 'BlockStatsSpecificFile',
+                       'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
       'nvme': 'BlockStatsSpecificNvme' } }
 
 ##
@@ -2863,7 +2864,9 @@
 { 'enum': 'BlockdevDriver',
   'data': [ 'blkdebug', 'blklogwrites', 'blkreplay', 'blkverify', 'bochs',
             'cloop', 'compress', 'copy-on-read', 'dmg', 'file', 'ftp', 'ftps',
-            'gluster', 'host_cdrom', 'host_device', 'http', 'https', 'iscsi',
+            'gluster', 'host_cdrom',
+            {'name': 'host_device', 'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
+            'http', 'https', 'iscsi',
             'luks', 'nbd', 'nfs', 'null-aio', 'null-co', 'nvme', 'parallels',
             'preallocate', 'qcow', 'qcow2', 'qed', 'quorum', 'raw', 'rbd',
             { 'name': 'replication', 'if': 'defined(CONFIG_REPLICATION)' },
@@ -4066,7 +4069,8 @@
       'ftps':       'BlockdevOptionsCurlFtps',
       'gluster':    'BlockdevOptionsGluster',
       'host_cdrom': 'BlockdevOptionsFile',
-      'host_device':'BlockdevOptionsFile',
+      'host_device': { 'type': 'BlockdevOptionsFile',
+                       'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
       'http':       'BlockdevOptionsCurlHttp',
       'https':      'BlockdevOptionsCurlHttps',
       'iscsi':      'BlockdevOptionsIscsi',

From e0a033d9d474319b252a29da42eb397bacb1c4a1 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Thu, 21 Jan 2021 16:12:00 -0800
Subject: [PATCH 002/180] block: check for sys/disk.h

Some BSD platforms do not have this header.
---
 block.c     | 2 +-
 meson.build | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/block.c b/block.c
index a1f3cecd7552..b2705ad225c0 100644
--- a/block.c
+++ b/block.c
@@ -54,7 +54,7 @@
 #ifdef CONFIG_BSD
 #include <sys/ioctl.h>
 #include <sys/queue.h>
-#ifndef __DragonFly__
+#if defined(HAVE_SYS_DISK_H)
 #include <sys/disk.h>
 #endif
 #endif
diff --git a/meson.build b/meson.build
index 0e53876f69c1..ba0db9fa1f81 100644
--- a/meson.build
+++ b/meson.build
@@ -1153,6 +1153,7 @@ config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
 config_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))
 config_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)
+config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h'))
 
 config_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))
 

From f3140144225066c74daf51b7c5faf6e2a1d78fb4 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sun, 7 Mar 2021 16:52:56 -0800
Subject: [PATCH 003/180] block: detect DKIOCGETBLOCKCOUNT/SIZE before use

iOS hosts do not have these defined so we fallback to the
default behaviour.

Co-authored-by: Warner Losh <imp@bsdimp.com>
---
 block/file-posix.c | 18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index d1ab3180ff16..9b6d7ddda3d5 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -2326,8 +2326,10 @@ static int64_t raw_getlength(BlockDriverState *bs)
 again:
 #endif
     if (!fstat(fd, &sb) && (S_IFCHR & sb.st_mode)) {
+        size = 0;
 #ifdef DIOCGMEDIASIZE
         if (ioctl(fd, DIOCGMEDIASIZE, (off_t *)&size))
+            size = 0;
 #elif defined(DIOCGPART)
         {
                 struct partinfo pi;
@@ -2336,9 +2338,7 @@ static int64_t raw_getlength(BlockDriverState *bs)
                 else
                         size = 0;
         }
-        if (size == 0)
-#endif
-#if defined(__APPLE__) && defined(__MACH__)
+#elif defined(DKIOCGETBLOCKCOUNT) && defined(DKIOCGETBLOCKSIZE)
         {
             uint64_t sectors = 0;
             uint32_t sector_size = 0;
@@ -2346,19 +2346,15 @@ static int64_t raw_getlength(BlockDriverState *bs)
             if (ioctl(fd, DKIOCGETBLOCKCOUNT, &sectors) == 0
                && ioctl(fd, DKIOCGETBLOCKSIZE, &sector_size) == 0) {
                 size = sectors * sector_size;
-            } else {
-                size = lseek(fd, 0LL, SEEK_END);
-                if (size < 0) {
-                    return -errno;
-                }
             }
         }
-#else
-        size = lseek(fd, 0LL, SEEK_END);
+#endif
+        if (size == 0) {
+            size = lseek(fd, 0LL, SEEK_END);
+        }
         if (size < 0) {
             return -errno;
         }
-#endif
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
         switch(s->type) {
         case FTYPE_CD:

From 69819144f1909230ec140f55c9c48baa08a1601a Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Thu, 21 Jan 2021 16:31:09 -0800
Subject: [PATCH 004/180] slirp: feature detection for smbd

Replace Windows specific macro with a more generic feature detection
macro. Allows slirp smb feature to be disabled manually as well.
---
 configure   | 26 +++++++++++++++++++++++---
 meson.build |  2 +-
 net/slirp.c | 16 ++++++++--------
 3 files changed, 32 insertions(+), 12 deletions(-)

diff --git a/configure b/configure
index 34fccaa2bae6..8335a3e6a0d8 100755
--- a/configure
+++ b/configure
@@ -465,6 +465,7 @@ fuse_lseek="auto"
 multiprocess="auto"
 
 malloc_trim="auto"
+slirp_smbd="auto"
 
 # parse CC options second
 for opt do
@@ -834,8 +835,6 @@ do
     fi
 done
 
-: ${smbd=${SMBD-/usr/sbin/smbd}}
-
 # Default objcc to clang if available, otherwise use CC
 if has clang; then
   objcc=clang
@@ -1560,6 +1559,10 @@ for opt do
   ;;
   --disable-multiprocess) multiprocess="disabled"
   ;;
+  --enable-slirp-smbd) slirp_smbd=yes
+  ;;
+  --disable-slirp-smbd) slirp_smbd=no
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -1913,6 +1916,7 @@ disabled with --disable-FEATURE, default is enabled if available
   fuse            FUSE block device export
   fuse-lseek      SEEK_HOLE/SEEK_DATA support for FUSE exports
   multiprocess    Out of process device emulation support
+  slirp-smbd      use smbd (at path --smbd=*) in slirp networking
 
 NOTE: The object files are built at the place where configure is launched
 EOF
@@ -5252,6 +5256,19 @@ case "$slirp" in
     ;;
 esac
 
+# Check for slirp smbd dupport
+: ${smbd=${SMBD-/usr/sbin/smbd}}
+if test "$slirp_smbd" != "no" ; then
+  if test "$mingw32" = "yes" ; then
+    if test "$slirp_smbd" = "yes" ; then
+      error_exit "Host smbd not supported on this platform."
+    fi
+    slirp_smbd=no
+  else
+    slirp_smbd=yes
+  fi
+fi
+
 ##########################################
 # check for usable __NR_keyctl syscall
 
@@ -5527,7 +5544,10 @@ fi
 if test "$guest_agent" = "yes" ; then
   echo "CONFIG_GUEST_AGENT=y" >> $config_host_mak
 fi
-echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
+if test "$slirp_smbd" = "yes" ; then
+  echo "CONFIG_SLIRP_SMBD=y" >> $config_host_mak
+  echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
+fi
 if test "$vde" = "yes" ; then
   echo "CONFIG_VDE=y" >> $config_host_mak
   echo "VDE_LIBS=$vde_libs" >> $config_host_mak
diff --git a/meson.build b/meson.build
index ba0db9fa1f81..cad70a8fc501 100644
--- a/meson.build
+++ b/meson.build
@@ -2424,7 +2424,7 @@ summary_info += {'genisoimage':       config_host['GENISOIMAGE']}
 if targetos == 'windows' and config_host.has_key('CONFIG_GUEST_AGENT')
   summary_info += {'wixl':            wixl.found() ? wixl.full_path() : false}
 endif
-if slirp_opt != 'disabled'
+if slirp_opt != 'disabled' and 'CONFIG_SLIRP_SMBD' in config_host
   summary_info += {'smbd':            config_host['CONFIG_SMBD_COMMAND']}
 endif
 summary(summary_info, bool_yn: true, section: 'Host binaries')
diff --git a/net/slirp.c b/net/slirp.c
index be914c0be058..b3ded2aac155 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -27,7 +27,7 @@
 #include "net/slirp.h"
 
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 #include <pwd.h>
 #include <sys/wait.h>
 #endif
@@ -90,7 +90,7 @@ typedef struct SlirpState {
     Slirp *slirp;
     Notifier poll_notifier;
     Notifier exit_notifier;
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     gchar *smb_dir;
 #endif
     GSList *fwd;
@@ -103,7 +103,7 @@ static QTAILQ_HEAD(, SlirpState) slirp_stacks =
 static int slirp_hostfwd(SlirpState *s, const char *redir_str, Error **errp);
 static int slirp_guestfwd(SlirpState *s, const char *config_str, Error **errp);
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 static int slirp_smb(SlirpState *s, const char *exported_dir,
                      struct in_addr vserver_addr, Error **errp);
 static void slirp_smb_cleanup(SlirpState *s);
@@ -367,7 +367,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
     struct in6_addr ip6_prefix;
     struct in6_addr ip6_host;
     struct in6_addr ip6_dns;
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     struct in_addr smbsrv = { .s_addr = 0 };
 #endif
     NetClientState *nc;
@@ -477,7 +477,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
         return -1;
     }
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     if (vsmbserver && !inet_aton(vsmbserver, &smbsrv)) {
         error_setg(errp, "Failed to parse SMB address");
         return -1;
@@ -592,7 +592,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
             }
         }
     }
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     if (smb_export) {
         if (slirp_smb(s, smb_export, smbsrv, errp) < 0) {
             goto error;
@@ -784,7 +784,7 @@ void hmp_hostfwd_add(Monitor *mon, const QDict *qdict)
 
 }
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 
 /* automatic user mode samba server configuration */
 static void slirp_smb_cleanup(SlirpState *s)
@@ -899,7 +899,7 @@ static int slirp_smb(SlirpState* s, const char *exported_dir,
     return 0;
 }
 
-#endif /* !defined(_WIN32) */
+#endif /* defined(CONFIG_SLIRP_SMBD) */
 
 static int guestfwd_can_read(void *opaque)
 {

From bcdcc525e45e75d02fc55adbca9434e753c85f68 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 7 Mar 2021 17:24:50 -0800
Subject: [PATCH 005/180] meson: option to build as shared library

On iOS, we cannot fork() new processes, so the best way to load QEMU into an
app is through a shared library. We add a new configure option
`--enable-shared-lib` that will build the bulk of QEMU into a shared lib.
The usual executables will then link to the library.
---
 configure         | 14 ++++++++++++--
 meson.build       | 40 ++++++++++++++++++++++++++++++++++------
 meson_options.txt |  2 ++
 3 files changed, 48 insertions(+), 8 deletions(-)

diff --git a/configure b/configure
index 8335a3e6a0d8..351c3e012d08 100755
--- a/configure
+++ b/configure
@@ -463,6 +463,7 @@ gettext="auto"
 fuse="auto"
 fuse_lseek="auto"
 multiprocess="auto"
+shared_lib="false"
 
 malloc_trim="auto"
 slirp_smbd="auto"
@@ -1563,6 +1564,10 @@ for opt do
   ;;
   --disable-slirp-smbd) slirp_smbd=no
   ;;
+  --enable-shared-lib) shared_lib=true
+  ;;
+  --disable-shared-lib) shared_lib=false
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -1790,6 +1795,7 @@ Advanced options (experts only):
                            enable plugins via shared library loading
   --disable-containers     don't use containers for cross-building
   --gdb=GDB-path           gdb to use for gdbstub tests [$gdb_bin]
+  --enable-shared-lib      build QEMU as a shared library
 
 Optional features, enabled with --enable-FEATURE and
 disabled with --disable-FEATURE, default is enabled if available
@@ -6364,7 +6370,11 @@ echo "ranlib = [$(meson_quote $ranlib)]" >> $cross
 if has $sdl2_config; then
   echo "sdl2-config = [$(meson_quote $sdl2_config)]" >> $cross
 fi
-echo "strip = [$(meson_quote $strip)]" >> $cross
+if test "$shared_lib" = "true"; then
+  echo "strip = [$(meson_quote $strip), '-x']" >> $cross
+else
+  echo "strip = [$(meson_quote $strip)]" >> $cross
+fi
 echo "windres = [$(meson_quote $windres)]" >> $cross
 if test "$cross_compile" = "yes"; then
     cross_arg="--cross-file config-meson.cross"
@@ -6446,7 +6456,7 @@ NINJA=$ninja $meson setup \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
         $(if test "$default_features" = no; then echo "-Dauto_features=disabled"; fi) \
-	-Dtcg_interpreter=$tcg_interpreter \
+	-Dtcg_interpreter=$tcg_interpreter -Dshared_lib=$shared_lib \
         $cross_arg \
         "$PWD" "$source_path"
 
diff --git a/meson.build b/meson.build
index cad70a8fc501..40ce117aa118 100644
--- a/meson.build
+++ b/meson.build
@@ -2185,14 +2185,31 @@ foreach target : target_dirs
   arch_srcs += target_specific.sources()
   arch_deps += target_specific.dependencies()
 
-  lib = static_library('qemu-' + target,
+  if get_option('shared_lib')
+    build_lib_args = {
+      'target_type': 'shared_library',
+      'install': true,
+      'dependencies': arch_deps + deps,
+      'link_language': link_language,
+      'link_depends': [block_syms, qemu_syms],
+      'link_args': link_args + cc.get_supported_link_arguments(['-Wl,-U,_qemu_main'])
+    }
+  else
+    build_lib_args = {
+      'target_type': 'static_library',
+      'install': false,
+      'dependencies': arch_deps,
+      'name_suffix': 'fa'
+    }
+  endif
+
+  lib = build_target('qemu-' + target,
                  sources: arch_srcs + genh,
-                 dependencies: arch_deps,
                  objects: objects,
                  include_directories: target_inc,
                  c_args: c_args,
                  build_by_default: false,
-                 name_suffix: 'fa')
+                 kwargs: build_lib_args)
 
   if target.endswith('-softmmu')
     execs = [{
@@ -2226,6 +2243,17 @@ foreach target : target_dirs
       'dependencies': []
     }]
   endif
+  if get_option('shared_lib')
+    build_exe_args = {
+      'link_with': lib,
+      'link_args': link_args + cc.get_supported_link_arguments(['-Wl,--exclude-libs,ALL'])
+    }
+  else
+    build_exe_args = {
+      'objects': lib.extract_all_objects(recursive: true),
+      'link_args': link_args
+    }
+  endif
   foreach exe: execs
     exe_name = exe['name']
     exe_sign = 'CONFIG_HVF' in config_target
@@ -2237,11 +2265,10 @@ foreach target : target_dirs
                install: true,
                c_args: c_args,
                dependencies: arch_deps + deps + exe['dependencies'],
-               objects: lib.extract_all_objects(recursive: true),
                link_language: link_language,
                link_depends: [block_syms, qemu_syms] + exe.get('link_depends', []),
-               link_args: link_args,
-               gui_app: exe['gui'])
+               gui_app: exe['gui'],
+               kwargs: build_exe_args)
 
     if exe_sign
       emulators += {exe['name'] : custom_target(exe['name'],
@@ -2408,6 +2435,7 @@ endif
 summary_info += {'Doc directory':     get_option('docdir')}
 summary_info += {'Build directory':   meson.current_build_dir()}
 summary_info += {'Source path':       meson.current_source_dir()}
+summary_info += {'build shared lib':  get_option('shared_lib')}
 summary_info += {'GIT submodules':    config_host['GIT_SUBMODULES']}
 summary(summary_info, bool_yn: true, section: 'Directories')
 
diff --git a/meson_options.txt b/meson_options.txt
index 9734019995a0..4594d42769d6 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -6,6 +6,8 @@ option('qemu_firmwarepath', type : 'string', value : '',
        description: 'search PATH for firmware files')
 option('sphinx_build', type : 'string', value : '',
        description: 'Use specified sphinx-build [$sphinx_build] for building document (default to be empty)')
+option('shared_lib', type : 'boolean', value : false,
+       description: 'build QEMU as a shared library')
 
 option('default_devices', type : 'boolean', value : true,
        description: 'Include a default selection of devices in emulators')

From 4ef61a5fd79e3635a09dda3cedd797dd43438e77 Mon Sep 17 00:00:00 2001
From: Gerd Hoffmann <kraxel@redhat.com>
Date: Fri, 8 Jun 2018 13:19:58 +0200
Subject: [PATCH 006/180] hw/display: add virtio-ramfb device

Like virtio-vga, but using ramfb instead of legacy vga.
Useful for booting from OVMF into Windows ARM which expects a linear FB.
---
 hw/display/meson.build    |   1 +
 hw/display/virtio-ramfb.c | 188 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 189 insertions(+)
 create mode 100644 hw/display/virtio-ramfb.c

diff --git a/hw/display/meson.build b/hw/display/meson.build
index 9d79e3951d9e..14f5fa39f4c1 100644
--- a/hw/display/meson.build
+++ b/hw/display/meson.build
@@ -60,6 +60,7 @@ if config_all_devices.has_key('CONFIG_VIRTIO_GPU')
   virtio_gpu_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRGL'],
                     if_true: [files('virtio-gpu-3d.c'), pixman, virgl])
   virtio_gpu_ss.add(when: 'CONFIG_VHOST_USER_GPU', if_true: files('vhost-user-gpu.c'))
+  virtio_gpu_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('virtio-ramfb.c'))
   hw_display_modules += {'virtio-gpu': virtio_gpu_ss}
 endif
 
diff --git a/hw/display/virtio-ramfb.c b/hw/display/virtio-ramfb.c
new file mode 100644
index 000000000000..d08bb90a14d4
--- /dev/null
+++ b/hw/display/virtio-ramfb.c
@@ -0,0 +1,188 @@
+#include "qemu/osdep.h"
+#include "hw/pci/pci.h"
+#include "ui/console.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-gpu-pci.h"
+#include "qapi/error.h"
+#include "hw/display/ramfb.h"
+#include "qom/object.h"
+
+/*
+ * virtio-ramfb-base: This extends VirtioPCIProxy.
+ */
+#define TYPE_VIRTIO_RAMFB_BASE "virtio-ramfb-base"
+OBJECT_DECLARE_TYPE(VirtIORAMFBBase, VirtIORAMFBBaseClass,
+                    VIRTIO_RAMFB_BASE)
+
+struct VirtIORAMFBBase {
+    VirtIOPCIProxy parent_obj;
+
+    VirtIOGPUBase *vgpu;
+    RAMFBState    *ramfb;
+};
+
+struct VirtIORAMFBBaseClass {
+    VirtioPCIClass parent_class;
+
+    DeviceReset parent_reset;
+};
+
+static void virtio_ramfb_invalidate_display(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->enable) {
+        g->hw_ops->invalidate(g);
+    }
+}
+
+static void virtio_ramfb_update_display(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->enable) {
+        g->hw_ops->gfx_update(g);
+    } else {
+        ramfb_display_update(g->scanout[0].con, vramfb->ramfb);
+    }
+}
+
+static int virtio_ramfb_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->ui_info) {
+        return g->hw_ops->ui_info(g, idx, info);
+    }
+    return -1;
+}
+
+static void virtio_ramfb_gl_block(void *opaque, bool block)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->gl_block) {
+        g->hw_ops->gl_block(g, block);
+    }
+}
+
+static const GraphicHwOps virtio_ramfb_ops = {
+    .invalidate = virtio_ramfb_invalidate_display,
+    .gfx_update = virtio_ramfb_update_display,
+    .ui_info = virtio_ramfb_ui_info,
+    .gl_block = virtio_ramfb_gl_block,
+};
+
+static const VMStateDescription vmstate_virtio_ramfb = {
+    .name = "virtio-ramfb",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    .fields = (VMStateField[]) {
+        /* no pci stuff here, saving the virtio device will handle that */
+        /* FIXME */
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+/* RAMFB device wrapper around PCI device around virtio GPU */
+static void virtio_ramfb_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
+{
+    VirtIORAMFBBase *vramfb = VIRTIO_RAMFB_BASE(vpci_dev);
+    VirtIOGPUBase *g = vramfb->vgpu;
+    int i;
+
+    /* init virtio bits */
+    virtio_pci_force_virtio_1(vpci_dev);
+    if (!qdev_realize(DEVICE(g), BUS(&vpci_dev->bus), errp)) {
+        return;
+    }
+
+    /* init ramfb */
+    vramfb->ramfb = ramfb_setup(errp);
+    graphic_console_set_hwops(g->scanout[0].con, &virtio_ramfb_ops, vramfb);
+
+    for (i = 0; i < g->conf.max_outputs; i++) {
+        object_property_set_link(OBJECT(g->scanout[i].con), "device",
+                                 OBJECT(vpci_dev), &error_abort);
+    }
+}
+
+static void virtio_ramfb_reset(DeviceState *dev)
+{
+    VirtIORAMFBBaseClass *klass = VIRTIO_RAMFB_BASE_GET_CLASS(dev);
+
+    /* reset virtio-gpu */
+    klass->parent_reset(dev);
+}
+
+static Property virtio_ramfb_base_properties[] = {
+    DEFINE_VIRTIO_GPU_PCI_PROPERTIES(VirtIOPCIProxy),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_ramfb_base_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioPCIClass *k = VIRTIO_PCI_CLASS(klass);
+    VirtIORAMFBBaseClass *v = VIRTIO_RAMFB_BASE_CLASS(klass);
+    PCIDeviceClass *pcidev_k = PCI_DEVICE_CLASS(klass);
+
+    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
+    device_class_set_props(dc, virtio_ramfb_base_properties);
+    dc->vmsd = &vmstate_virtio_ramfb;
+    dc->hotpluggable = false;
+    device_class_set_parent_reset(dc, virtio_ramfb_reset,
+                                  &v->parent_reset);
+
+    k->realize = virtio_ramfb_realize;
+    pcidev_k->class_id = PCI_CLASS_DISPLAY_OTHER;
+}
+
+static TypeInfo virtio_ramfb_base_info = {
+    .name          = TYPE_VIRTIO_RAMFB_BASE,
+    .parent        = TYPE_VIRTIO_PCI,
+    .instance_size = sizeof(VirtIORAMFBBase),
+    .class_size    = sizeof(VirtIORAMFBBaseClass),
+    .class_init    = virtio_ramfb_base_class_init,
+    .abstract      = true,
+};
+
+#define TYPE_VIRTIO_RAMFB "virtio-ramfb"
+
+typedef struct VirtIORAMFB VirtIORAMFB;
+DECLARE_INSTANCE_CHECKER(VirtIORAMFB, VIRTIO_RAMFB,
+                         TYPE_VIRTIO_RAMFB)
+
+struct VirtIORAMFB {
+    VirtIORAMFBBase parent_obj;
+
+    VirtIOGPU     vdev;
+};
+
+static void virtio_ramfb_inst_initfn(Object *obj)
+{
+    VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
+
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+}
+
+static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {
+    .generic_name  = TYPE_VIRTIO_RAMFB,
+    .parent        = TYPE_VIRTIO_RAMFB_BASE,
+    .instance_size = sizeof(VirtIORAMFB),
+    .instance_init = virtio_ramfb_inst_initfn,
+};
+
+static void virtio_ramfb_register_types(void)
+{
+    type_register_static(&virtio_ramfb_base_info);
+    virtio_pci_types_register(&virtio_ramfb_info);
+}
+
+type_init(virtio_ramfb_register_types)

From ff51693eefc8a412e78620a9269c5ca5aed3559d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>
Date: Mon, 25 Jan 2021 11:34:26 +0400
Subject: [PATCH 007/180] slirp: update to git master
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

git cherry-diff:

Commits on bacb71f1c3ed5f40e393afd8be81bedfba13a401 branch that is not on 8f43a99191afb47ca3f3c6972f6306209f367ece branch
+ 1021b0dc38d39f1dc95a296fe3e05a24a087cdc6 disable_dns option
+ 0f94ceec752592e4ac632a24e3c64a97dd09bf4c limit vnameserver_addr to port 53
+ b57bafa852ef16b133907a13678ec69e9531f177 libslirp.h: fix SlirpConfig v3 documentation
+ 1abf18b2b5edb462797629ed47ad4515a195686e Update CHANGELOG
+ ff4ecf9b6c6542b24b4ac6ea178be9d44e159f79 Release v4.3.0
+ 21f1d933050a40d62612c6274c32de60b811d9ea changelog: post-release
+ 376187c4b14c795763d472214812826eebe7e9c2 Release v4.3.1
+ 73336e08902a7e826f7d960453df037380266186 changelog: post-release
+ 5c1c9d43be61571608e9b14615045b67b830daf5 udp, udp6, icmp: handle TTL value
+ 73ed49ab71998d4288e71e954ef6214b70f23d79 icmp, icmp6: Add icmp_forward_error and icmp6_forward_error
+ 7a4840a57ec7dbc37cca1ab96f058a9610b26950 udp, udp6, icmp, icmp6: Enable forwarding errors on Linux
+ e9b2bc19ae652a2907f247e621b2e4773bdd2aab TCPIPHDR_DELTA: Fix potential negative value
+ 39f9a363eec082f04513413046321abd04163148 .gitlab-ci: add a Coverity stage
+ 1b0093b973cfa0dc041522e5d4e6f576b2df642e sosendoob: better document what urgc is used for
+ 5b9ad89ebbb8afa50162c9156fabd5fc56291088 Add G_GNUC_PRINTF to local function slirp_vsnprintf
+ 8a808aa493980e212b4d5f5465330905c8294e59 meson: remove meson-dist script
+ 0b669b5fbe4d3c25a682a67f1059d8633c963b3d meson: support compiling as subproject
+ 9f82a47b81f2864422b82c1e40e51a2ed9c6ac32 Add DNS resolving for iOS
+ c0eac03e8ce1b9a743231f2fe21e7cb579fc9339 Remove the QEMU-special make build-system
+ 1bfd4d9368f9fa2e4f0731e1266bec05bbc83a80 socket: consume empty packets
+ 92413be68914f8cae2f5bad4bf3ab8491dcbc5d7 Release v4.4.0
+ 07e8cfac69766081871ab620d9f16a630543d302 changelog: post-release
+ 4c4e035813313d02b63fdeb920d56fb2fdc0a5b1 Remove some needless (void)casts
+ eee9db9d115d91aa82f33685c4e76d656db92976 fork_exec_child_setup: improve signal handling
+ 216f434a018b3af182a4f31bbe5a00daee170343 Fix unused variables

Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
Message-Id: <20210125073427.3970606-2-marcandre.lureau@redhat.com>
---
 slirp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/slirp b/slirp
index 8f43a99191af..5dce846e3ee8 160000
--- a/slirp
+++ b/slirp
@@ -1 +1 @@
-Subproject commit 8f43a99191afb47ca3f3c6972f6306209f367ece
+Subproject commit 5dce846e3ee82d93462bc637bb0db2fd49f0fc5a

From da1d34255cc4f5ec142286b34dda5b9b231cf1ec Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>
Date: Mon, 25 Jan 2021 11:34:27 +0400
Subject: [PATCH 008/180] build-sys: make libslirp a meson subproject
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Remove the manual build.

Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
Message-Id: <20210125073427.3970606-3-marcandre.lureau@redhat.com>
---
 .gitmodules          |  6 ++---
 configure            |  2 +-
 meson.build          | 63 +++-----------------------------------------
 slirp                |  1 -
 subprojects/libslirp |  1 +
 5 files changed, 9 insertions(+), 64 deletions(-)
 delete mode 160000 slirp
 create mode 160000 subprojects/libslirp

diff --git a/.gitmodules b/.gitmodules
index 08b1b48a09f4..c28831c50ab4 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -49,9 +49,9 @@
 [submodule "roms/edk2"]
 	path = roms/edk2
 	url = https://gitlab.com/qemu-project/edk2.git
-[submodule "slirp"]
-	path = slirp
-	url = https://gitlab.com/qemu-project/libslirp.git
+[submodule "subprojects/libslirp"]
+	path = subprojects/libslirp
+	url = https://git.qemu.org/git/libslirp.git
 [submodule "roms/opensbi"]
 	path = roms/opensbi
 	url = 	https://gitlab.com/qemu-project/opensbi.git
diff --git a/configure b/configure
index 351c3e012d08..a2736ecf161b 100755
--- a/configure
+++ b/configure
@@ -5257,7 +5257,7 @@ case "$slirp" in
   auto | enabled | internal)
     # Simpler to always update submodule, even if not needed.
     if test "$git_submodules_action" != "ignore"; then
-      git_submodules="${git_submodules} slirp"
+      git_submodules="${git_submodules} subprojects/libslirp"
     fi
     ;;
 esac
diff --git a/meson.build b/meson.build
index 40ce117aa118..892314dcbf6c 100644
--- a/meson.build
+++ b/meson.build
@@ -1504,7 +1504,7 @@ slirp_opt = 'disabled'
 if have_system
   slirp_opt = get_option('slirp')
   if slirp_opt in ['enabled', 'auto', 'system']
-    have_internal = fs.exists(meson.current_source_dir() / 'slirp/meson.build')
+    have_internal = fs.exists(meson.current_source_dir() / 'subprojects/libslirp/meson.build')
     slirp = dependency('slirp', kwargs: static_kwargs,
                        method: 'pkg-config',
                        required: slirp_opt == 'system' or
@@ -1518,64 +1518,9 @@ if have_system
     endif
   endif
   if slirp_opt == 'internal'
-    slirp_deps = []
-    if targetos == 'windows'
-      slirp_deps = cc.find_library('iphlpapi')
-    endif
-    slirp_conf = configuration_data()
-    slirp_conf.set('SLIRP_MAJOR_VERSION', meson.project_version().split('.')[0])
-    slirp_conf.set('SLIRP_MINOR_VERSION', meson.project_version().split('.')[1])
-    slirp_conf.set('SLIRP_MICRO_VERSION', meson.project_version().split('.')[2])
-    slirp_conf.set_quoted('SLIRP_VERSION_STRING', meson.project_version())
-    slirp_cargs = ['-DG_LOG_DOMAIN="Slirp"']
-    slirp_files = [
-      'slirp/src/arp_table.c',
-      'slirp/src/bootp.c',
-      'slirp/src/cksum.c',
-      'slirp/src/dhcpv6.c',
-      'slirp/src/dnssearch.c',
-      'slirp/src/if.c',
-      'slirp/src/ip6_icmp.c',
-      'slirp/src/ip6_input.c',
-      'slirp/src/ip6_output.c',
-      'slirp/src/ip_icmp.c',
-      'slirp/src/ip_input.c',
-      'slirp/src/ip_output.c',
-      'slirp/src/mbuf.c',
-      'slirp/src/misc.c',
-      'slirp/src/ncsi.c',
-      'slirp/src/ndp_table.c',
-      'slirp/src/sbuf.c',
-      'slirp/src/slirp.c',
-      'slirp/src/socket.c',
-      'slirp/src/state.c',
-      'slirp/src/stream.c',
-      'slirp/src/tcp_input.c',
-      'slirp/src/tcp_output.c',
-      'slirp/src/tcp_subr.c',
-      'slirp/src/tcp_timer.c',
-      'slirp/src/tftp.c',
-      'slirp/src/udp.c',
-      'slirp/src/udp6.c',
-      'slirp/src/util.c',
-      'slirp/src/version.c',
-      'slirp/src/vmstate.c',
-    ]
-
-    configure_file(
-      input : 'slirp/src/libslirp-version.h.in',
-      output : 'libslirp-version.h',
-      configuration: slirp_conf)
-
-    slirp_inc = include_directories('slirp', 'slirp/src')
-    libslirp = static_library('slirp',
-                              build_by_default: false,
-                              sources: slirp_files,
-                              c_args: slirp_cargs,
-                              include_directories: slirp_inc)
-    slirp = declare_dependency(link_with: libslirp,
-                               dependencies: slirp_deps,
-                               include_directories: slirp_inc)
+    libslirp = subproject('libslirp',
+                          default_options: ['default_library=static'])
+    slirp = libslirp.get_variable('libslirp_dep')
   endif
 endif
 
diff --git a/slirp b/slirp
deleted file mode 160000
index 5dce846e3ee8..000000000000
--- a/slirp
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 5dce846e3ee82d93462bc637bb0db2fd49f0fc5a
diff --git a/subprojects/libslirp b/subprojects/libslirp
new file mode 160000
index 000000000000..bacb71f1c3ed
--- /dev/null
+++ b/subprojects/libslirp
@@ -0,0 +1 @@
+Subproject commit bacb71f1c3ed5f40e393afd8be81bedfba13a401

From cf8a85ad1822ea6153eff5bda9c14b96d1c0bd0d Mon Sep 17 00:00:00 2001
From: Roman Bolshakov <r.bolshakov@yadro.com>
Date: Wed, 10 Feb 2021 13:55:27 +0300
Subject: [PATCH 009/180] util/osdep: Avoid mprotect() RWX->NONE on Big Sur
 11.2

There's a change in mprotect() behaviour [1] in the latest macOS on M1
and it's not yet clear if it's going to be fixed by Apple. For now we
can avoid unsupported mprotect() calls. QEMU and qtests work fine
without it.

1. https://gist.github.com/hikalium/75ae822466ee4da13cbbe486498a191f

Buglink: https://bugs.launchpad.net/qemu/+bug/1914849
Apple-Feedback: FB8994773
Signed-off-by: Roman Bolshakov <r.bolshakov@yadro.com>
Message-Id: <20210210105527.74943-1-r.bolshakov@yadro.com>
---
 util/osdep.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/util/osdep.c b/util/osdep.c
index 66d01b9160fb..1edd7b1caf9c 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -111,6 +111,12 @@ int qemu_mprotect_none(void *addr, size_t size)
 #ifdef _WIN32
     return qemu_mprotect__osdep(addr, size, PAGE_NOACCESS);
 #else
+# if defined(__APPLE__) && defined(__arm64__)
+    if (__builtin_available(macOS 11.2, *)) {
+        /* mprotect() in macOS 11.2 can't switch RWX to NONE */
+        return 0;
+    }
+# endif
     return qemu_mprotect__osdep(addr, size, PROT_NONE);
 #endif
 }

From 37aa4a189406effcd6d19844f33f068f5a109d6c Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 4 Jan 2021 14:04:27 -0800
Subject: [PATCH 010/180] tcg: custom APRR implementation

---
 accel/tcg/cpu-exec.c        |   1 +
 accel/tcg/translate-all.c   |   1 +
 include/qemu/osdep.h        |  28 ----------
 include/tcg/tcg-apple-jit.h | 100 ++++++++++++++++++++++++++++++++++++
 tcg/tcg.c                   |   1 +
 util/osdep.c                |   4 ++
 6 files changed, 107 insertions(+), 28 deletions(-)
 create mode 100644 include/tcg/tcg-apple-jit.h

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index 16e4fe3ccd87..6b2c66468368 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -26,6 +26,7 @@
 #include "disas/disas.h"
 #include "exec/exec-all.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #include "qemu/atomic.h"
 #include "qemu/compiler.h"
 #include "sysemu/qtest.h"
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index bbd919a39328..e03d48ae7abc 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -27,6 +27,7 @@
 #include "disas/disas.h"
 #include "exec/exec-all.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #if defined(CONFIG_USER_ONLY)
 #include "qemu.h"
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index ba15be9c569c..5bd1a6776915 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -119,10 +119,6 @@ extern int daemon(int, int);
 #include "sysemu/os-posix.h"
 #endif
 
-#ifdef __APPLE__
-#include <AvailabilityMacros.h>
-#endif
-
 #include "glib-compat.h"
 #include "qemu/typedefs.h"
 
@@ -686,30 +682,6 @@ char *qemu_get_host_name(Error **errp);
  */
 size_t qemu_get_host_physmem(void);
 
-/*
- * Toggle write/execute on the pages marked MAP_JIT
- * for the current thread.
- */
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_11_0
-static inline void qemu_thread_jit_execute(void)
-{
-    if (__builtin_available(macOS 11.0, *)) {
-        pthread_jit_write_protect_np(true);
-    }
-}
-
-static inline void qemu_thread_jit_write(void)
-{
-    if (__builtin_available(macOS 11.0, *)) {
-        pthread_jit_write_protect_np(false);
-    }
-}
-#else
-static inline void qemu_thread_jit_write(void) {}
-static inline void qemu_thread_jit_execute(void) {}
-#endif
-
 /**
  * Platforms which do not support system() return ENOSYS
  */
diff --git a/include/tcg/tcg-apple-jit.h b/include/tcg/tcg-apple-jit.h
new file mode 100644
index 000000000000..7f25dab809a3
--- /dev/null
+++ b/include/tcg/tcg-apple-jit.h
@@ -0,0 +1,100 @@
+/*
+ * Apple Silicon functions for JIT handling
+ *
+ * Copyright (c) 2020 osy
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TCG_APPLE_JIT_H
+#define TCG_APPLE_JIT_H
+
+/*
+ * APRR handling
+ * Credits to: https://siguza.github.io/APRR/
+ * Reversed from /usr/lib/system/libsystem_pthread.dylib
+ */
+
+#if defined(__aarch64__) && defined(CONFIG_DARWIN)
+
+#define _COMM_PAGE_START_ADDRESS        (0x0000000FFFFFC000ULL) /* In TTBR0 */
+#define _COMM_PAGE_APRR_SUPPORT         (_COMM_PAGE_START_ADDRESS + 0x10C)
+#define _COMM_PAGE_APPR_WRITE_ENABLE    (_COMM_PAGE_START_ADDRESS + 0x110)
+#define _COMM_PAGE_APRR_WRITE_DISABLE   (_COMM_PAGE_START_ADDRESS + 0x118)
+
+static __attribute__((__always_inline__)) bool jit_write_protect_supported(void)
+{
+    /* Access shared kernel page at fixed memory location. */
+    uint8_t aprr_support = *(volatile uint8_t *)_COMM_PAGE_APRR_SUPPORT;
+    return aprr_support > 0;
+}
+
+/* write protect enable = write disable */
+static __attribute__((__always_inline__)) void jit_write_protect(int enabled)
+{
+    /* Access shared kernel page at fixed memory location. */
+    uint8_t aprr_support = *(volatile uint8_t *)_COMM_PAGE_APRR_SUPPORT;
+    if (aprr_support == 0 || aprr_support > 3) {
+        return;
+    } else if (aprr_support == 1) {
+        __asm__ __volatile__ (
+            "mov x0, %0\n"
+            "ldr x0, [x0]\n"
+            "msr S3_4_c15_c2_7, x0\n"
+            "isb sy\n"
+            :: "r" (enabled ? _COMM_PAGE_APRR_WRITE_DISABLE
+                            : _COMM_PAGE_APPR_WRITE_ENABLE)
+            : "memory", "x0"
+        );
+    } else {
+        __asm__ __volatile__ (
+            "mov x0, %0\n"
+            "ldr x0, [x0]\n"
+            "msr S3_6_c15_c1_5, x0\n"
+            "isb sy\n"
+            :: "r" (enabled ? _COMM_PAGE_APRR_WRITE_DISABLE
+                            : _COMM_PAGE_APPR_WRITE_ENABLE)
+            : "memory", "x0"
+        );
+    }
+}
+
+#else /* defined(__aarch64__) && defined(CONFIG_DARWIN) */
+
+static __attribute__((__always_inline__)) bool jit_write_protect_supported(void)
+{
+    return false;
+}
+
+static __attribute__((__always_inline__)) void jit_write_protect(int enabled)
+{
+}
+
+#endif
+
+static inline void qemu_thread_jit_execute(void)
+{
+    if (jit_write_protect_supported()) {
+        jit_write_protect(true);
+    }
+}
+
+static inline void qemu_thread_jit_write(void)
+{
+    if (jit_write_protect_supported()) {
+        jit_write_protect(false);
+    }
+}
+
+#endif /* define TCG_APPLE_JIT_H */
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 63a12b197bff..457a40837feb 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -49,6 +49,7 @@
 #include "hw/boards.h"
 #endif
 
+#include "tcg/tcg-apple-jit.h"
 #include "tcg/tcg-op.h"
 
 #if UINTPTR_MAX == UINT32_MAX
diff --git a/util/osdep.c b/util/osdep.c
index 1edd7b1caf9c..cb20608292ef 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -39,6 +39,10 @@ extern int madvise(char *, size_t, int);
 #include "qemu/error-report.h"
 #include "monitor/monitor.h"
 
+#ifdef CONFIG_DARWIN
+#include "tcg/tcg-apple-jit.h"
+#endif
+
 static bool fips_enabled = false;
 
 static const char *hw_version = QEMU_HW_VERSION;

From 4373fc4514e2c793d121fe9f0b021d6fefb163df Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sun, 3 Jan 2021 08:58:11 -0800
Subject: [PATCH 011/180] coroutine: add libucontext as external library

iOS does not support ucontext natively for aarch64 and the sigaltstack is
also unsupported (even worse, it fails silently, see:
https://openradar.appspot.com/13002712 )

As a workaround we include a library implementation of ucontext and add it
as a build option.
---
 .gitmodules               |  3 +++
 configure                 | 23 ++++++++++++++++++++---
 meson.build               | 12 +++++++++++-
 meson_options.txt         |  2 ++
 subprojects/libucontext   |  1 +
 util/coroutine-ucontext.c |  9 +++++++++
 6 files changed, 46 insertions(+), 4 deletions(-)
 create mode 160000 subprojects/libucontext

diff --git a/.gitmodules b/.gitmodules
index c28831c50ab4..33f90687266b 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -64,3 +64,6 @@
 [submodule "roms/vbootrom"]
 	path = roms/vbootrom
 	url = https://gitlab.com/qemu-project/vbootrom.git
+[submodule "libucontext"]
+	path = subprojects/libucontext
+	url = https://github.com/utmapp/libucontext.git
diff --git a/configure b/configure
index a2736ecf161b..34f237ae653e 100755
--- a/configure
+++ b/configure
@@ -1781,7 +1781,7 @@ Advanced options (experts only):
   --oss-lib                path to OSS library
   --cpu=CPU                Build for host CPU [$cpu]
   --with-coroutine=BACKEND coroutine backend. Supported options:
-                           ucontext, sigaltstack, windows
+                           ucontext, libucontext, sigaltstack, windows
   --enable-gcov            enable test coverage analysis with gcov
   --disable-blobs          disable installing provided firmware blobs
   --with-vss-sdk=SDK-path  enable Windows VSS support in QEMU Guest Agent
@@ -4504,6 +4504,8 @@ if test "$coroutine" = ""; then
     coroutine=win32
   elif test "$ucontext_works" = "yes"; then
     coroutine=ucontext
+  elif test "$ios" = "yes"; then
+    coroutine=libucontext
   else
     coroutine=sigaltstack
   fi
@@ -4527,12 +4529,27 @@ else
       error_exit "only the 'windows' coroutine backend is valid for Windows"
     fi
     ;;
+  libucontext)
+  ;;
   *)
     error_exit "unknown coroutine backend $coroutine"
     ;;
   esac
 fi
 
+case $coroutine in
+libucontext)
+  git_submodules="${git_submodules} subprojects/libucontext"
+  mkdir -p libucontext
+  coroutine_impl=ucontext
+  libucontext="enabled"
+  ;;
+*)
+  coroutine_impl=$coroutine
+  libucontext="disabled"
+  ;;
+esac
+
 if test "$coroutine_pool" = ""; then
   coroutine_pool=yes
 fi
@@ -5884,7 +5901,7 @@ if test "$qom_cast_debug" = "yes" ; then
   echo "CONFIG_QOM_CAST_DEBUG=y" >> $config_host_mak
 fi
 
-echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
+echo "CONFIG_COROUTINE_BACKEND=$coroutine_impl" >> $config_host_mak
 if test "$coroutine_pool" = "yes" ; then
   echo "CONFIG_COROUTINE_POOL=1" >> $config_host_mak
 else
@@ -6451,7 +6468,7 @@ NINJA=$ninja $meson setup \
         -Dlibnfs=$libnfs -Diconv=$iconv -Dcurses=$curses -Dlibudev=$libudev\
         -Drbd=$rbd -Dlzo=$lzo -Dsnappy=$snappy -Dlzfse=$lzfse \
         -Dzstd=$zstd -Dseccomp=$seccomp -Dvirtfs=$virtfs -Dcap_ng=$cap_ng \
-        -Dattr=$attr -Ddefault_devices=$default_devices \
+        -Dattr=$attr -Ddefault_devices=$default_devices -Ducontext=$libucontext \
         -Ddocs=$docs -Dsphinx_build=$sphinx_build -Dinstall_blobs=$blobs \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
diff --git a/meson.build b/meson.build
index 892314dcbf6c..d9f0d44535cb 100644
--- a/meson.build
+++ b/meson.build
@@ -1571,9 +1571,18 @@ if not fdt.found() and fdt_required.length() > 0
   error('fdt not available but required by targets ' + ', '.join(fdt_required))
 endif
 
+ucontext = dependency('libucontext', kwargs: static_kwargs, required : false)
+if not ucontext.found() and get_option('ucontext').enabled()
+  libucontext_proj = subproject('libucontext',
+                                default_options: ['default_library=static',
+                                                  'freestanding=true'])
+  ucontext = libucontext_proj.get_variable('libucontext_dep')
+endif
+
 config_host_data.set('CONFIG_CAPSTONE', capstone.found())
 config_host_data.set('CONFIG_FDT', fdt.found())
 config_host_data.set('CONFIG_SLIRP', slirp.found())
+config_host_data.set('CONFIG_LIBUCONTEXT', ucontext.found())
 
 #####################
 # Generated sources #
@@ -1821,7 +1830,7 @@ util_ss.add_all(trace_ss)
 util_ss = util_ss.apply(config_all, strict: false)
 libqemuutil = static_library('qemuutil',
                              sources: util_ss.sources() + stub_ss.sources() + genh,
-                             dependencies: [util_ss.dependencies(), m, glib, socket, malloc])
+                             dependencies: [util_ss.dependencies(), m, glib, socket, malloc, ucontext])
 qemuutil = declare_dependency(link_with: libqemuutil,
                               sources: genh + version_res)
 
@@ -2545,6 +2554,7 @@ summary(summary_info, bool_yn: true, section: 'Targets and accelerators')
 
 # Block layer
 summary_info = {}
+summary_info += {'libucontext support': ucontext.found()}
 summary_info += {'coroutine backend': config_host['CONFIG_COROUTINE_BACKEND']}
 summary_info += {'coroutine pool':    config_host['CONFIG_COROUTINE_POOL'] == '1'}
 if have_block
diff --git a/meson_options.txt b/meson_options.txt
index 4594d42769d6..6c29ea93300a 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -110,6 +110,8 @@ option('fuse', type: 'feature', value: 'auto',
        description: 'FUSE block device export')
 option('fuse_lseek', type : 'feature', value : 'auto',
        description: 'SEEK_HOLE/SEEK_DATA support for FUSE exports')
+option('ucontext', type : 'feature', value : 'disabled',
+       description: 'libucontext support')
 
 option('vhost_user_blk_server', type: 'feature', value: 'auto',
        description: 'build vhost-user-blk server')
diff --git a/subprojects/libucontext b/subprojects/libucontext
new file mode 160000
index 000000000000..9b1d8f01a6e9
--- /dev/null
+++ b/subprojects/libucontext
@@ -0,0 +1 @@
+Subproject commit 9b1d8f01a6e99166f9808c79966abe10786de8b6
diff --git a/util/coroutine-ucontext.c b/util/coroutine-ucontext.c
index 904b375192ca..220c57a743af 100644
--- a/util/coroutine-ucontext.c
+++ b/util/coroutine-ucontext.c
@@ -23,7 +23,16 @@
 #undef _FORTIFY_SOURCE
 #endif
 #include "qemu/osdep.h"
+#if defined(CONFIG_LIBUCONTEXT)
+#include <libucontext/libucontext.h>
+#define ucontext_t libucontext_ucontext_t
+#define getcontext libucontext_getcontext
+#define setcontext libucontext_setcontext
+#define swapcontext libucontext_swapcontext
+#define makecontext libucontext_makecontext
+#else
 #include <ucontext.h>
+#endif
 #include "qemu/coroutine_int.h"
 
 #ifdef CONFIG_VALGRIND_H

From e16a18d2d9240b234a56055857baa8035ded1fbd Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Sat, 27 Mar 2021 15:46:31 -0600
Subject: [PATCH 012/180] get building for an iOS target, as well

---
 block/file-posix.c      | 21 +++++++++++++++++++++
 configure               | 41 ++++++++++++++++++++++++++++++++++++++++-
 include/qemu/osdep.h    |  2 +-
 meson.build             |  7 +++----
 tests/qtest/meson.build |  4 ++--
 5 files changed, 67 insertions(+), 8 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index 9b6d7ddda3d5..e0b0e56db375 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -279,6 +279,13 @@ static int raw_normalize_devicepath(const char **filename, Error **errp)
 }
 #endif
 
+#if defined(CONFIG_IOS)
+static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
+{
+    return -ENOTSUP; /* not supported on iOS */
+}
+#else /* CONFIG_IOS */
+
 /*
  * Get logical block size via ioctl. On success store it in @sector_size_p.
  */
@@ -312,6 +319,8 @@ static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
     return success ? 0 : -errno;
 }
 
+#endif
+
 /**
  * Get physical block size of @fd.
  * On success, store it in @blk_size and return 0.
@@ -1408,12 +1417,24 @@ static bool preadv_present = true;
 static ssize_t
 qemu_preadv(int fd, const struct iovec *iov, int nr_iov, off_t offset)
 {
+#ifdef CONFIG_DARWIN /* preadv introduced in macOS 11 */
+    if (!__builtin_available(macOS 11, iOS 14, watchOS 7, tvOS 14, *)) {
+        preadv_present = false;
+        return -ENOSYS;
+    } else
+#endif
     return preadv(fd, iov, nr_iov, offset);
 }
 
 static ssize_t
 qemu_pwritev(int fd, const struct iovec *iov, int nr_iov, off_t offset)
 {
+#ifdef CONFIG_DARWIN /* pwritev introduced in macOS 11 */
+    if (!__builtin_available(macOS 11, iOS 14, watchOS 7, tvOS 14, *)) {
+        preadv_present = false;
+        return -ENOSYS;
+    } else
+#endif
     return pwritev(fd, iov, nr_iov, offset);
 }
 
diff --git a/configure b/configure
index 34f237ae653e..ac874fda5b02 100755
--- a/configure
+++ b/configure
@@ -571,6 +571,21 @@ EOF
   compile_object
 }
 
+check_ios() {
+  cat > $TMPC <<EOF
+#ifdef __APPLE__
+#import "TargetConditionals.h"
+#if !TARGET_OS_IPHONE
+#error TARGET_OS_IPHONE not true
+#endif
+#endif
+int main(void) { return 0; }
+EOF
+  compile_object
+}
+
+
+
 check_include() {
 cat > $TMPC <<EOF
 #include <$1>
@@ -613,7 +628,11 @@ elif check_define __DragonFly__ ; then
 elif check_define __NetBSD__; then
   targetos='NetBSD'
 elif check_define __APPLE__; then
-  targetos='Darwin'
+  if check_ios ; then
+    targetos='iOS'
+  else
+    targetos='Darwin'
+  fi
 else
   # This is a fatal error, but don't report it yet, because we
   # might be going to just print the --help text, or it might
@@ -629,6 +648,22 @@ case $targetos in
 Darwin)
   HOST_DSOSUF=".dylib"
   ;;
+iOS)
+  bsd="yes"
+  darwin="yes"
+  ios="yes"
+  if [ "$cpu" = "x86_64" ] ; then
+    QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
+    QEMU_LDFLAGS="-arch x86_64 $QEMU_LDFLAGS"
+  fi
+  host_block_device_support="no"
+  audio_drv_list=""
+  audio_possible_drivers=""
+  QEMU_LDFLAGS="-framework CoreFoundation $QEMU_LDFLAGS"
+  # Disable attempts to use ObjectiveC features in os/object.h since they
+  # won't work when we're compiling with gcc as a C compiler.
+  QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
+;;
 SunOS)
   # $(uname -m) returns i86pc even on an x86_64 box, so default based on isainfo
   if test -z "$cpu" && test "$(isainfo -k)" = "amd64"; then
@@ -5549,6 +5584,10 @@ if test "$darwin" = "yes" ; then
   echo "CONFIG_DARWIN=y" >> $config_host_mak
 fi
 
+if test "$ios" = "yes" ; then
+  echo "CONFIG_IOS=y" >> $config_host_mak
+fi
+
 if test "$solaris" = "yes" ; then
   echo "CONFIG_SOLARIS=y" >> $config_host_mak
 fi
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index 5bd1a6776915..76cfa8f83562 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -685,7 +685,7 @@ size_t qemu_get_host_physmem(void);
 /**
  * Platforms which do not support system() return ENOSYS
  */
-#ifndef HAVE_SYSTEM_FUNCTION
+#if !defined(HAVE_SYSTEM_FUNCTION) || defined(CONFIG_IOS)
 #define system platform_does_not_support_system
 static inline int platform_does_not_support_system(const char *command)
 {
diff --git a/meson.build b/meson.build
index d9f0d44535cb..bcb175d82265 100644
--- a/meson.build
+++ b/meson.build
@@ -181,7 +181,7 @@ if targetos == 'windows'
                                       include_directories: include_directories('.'))
 elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
-  iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
+  iokit = dependency('appleframeworks', modules: 'IOKit', required: 'CONFIG_IOS' not in config_host)
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
             cc.find_library('nsl'),
@@ -1056,8 +1056,7 @@ if get_option('cfi')
   add_global_link_arguments(cfi_flags, native: false, language: ['c', 'cpp', 'objc'])
 endif
 
-have_host_block_device = (targetos != 'darwin' or
-    cc.has_header('IOKit/storage/IOMedia.h'))
+have_host_block_device = (targetos != 'darwin' or (cc.has_header('IOKit/storage/IOMedia.h') and ('CONFIG_IOS' not in config_host)))
 
 #################
 # config-host.h #
@@ -1153,7 +1152,7 @@ config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
 config_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))
 config_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)
-config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h'))
+config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h') and ('CONFIG_IOS' not in config_host))
 
 config_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))
 
diff --git a/tests/qtest/meson.build b/tests/qtest/meson.build
index ba6ecaed3256..dad92c996a72 100644
--- a/tests/qtest/meson.build
+++ b/tests/qtest/meson.build
@@ -47,12 +47,11 @@ qtests_i386 = \
   (config_all_devices.has_key('CONFIG_TPM_TIS_ISA') ? ['tpm-tis-test'] : []) +              \
   (config_all_devices.has_key('CONFIG_TPM_TIS_ISA') ? ['tpm-tis-swtpm-test'] : []) +        \
   (config_all_devices.has_key('CONFIG_RTL8139_PCI') ? ['rtl8139-test'] : []) +              \
+  (not config_host.has_key('CONFIG_IOS') ? ['bios-tables-test', 'hd-geo-test'] : []) +      \
   qtests_pci +                                                                              \
   ['fdc-test',
    'ide-test',
-   'hd-geo-test',
    'boot-order-test',
-   'bios-tables-test',
    'rtc-test',
    'i440fx-test',
    'fuzz-test',
@@ -160,6 +159,7 @@ qtests_aarch64 = \
   (cpu != 'arm' ? ['bios-tables-test'] : []) +                                                  \
   (config_all_devices.has_key('CONFIG_TPM_TIS_SYSBUS') ? ['tpm-tis-device-test'] : []) +        \
   (config_all_devices.has_key('CONFIG_TPM_TIS_SYSBUS') ? ['tpm-tis-device-swtpm-test'] : []) +  \
+  (cpu != 'arm' and not config_host.has_key('CONFIG_IOS') ? ['bios-tables-test'] : []) + \
   ['arm-cpu-features',
    'numa-test',
    'boot-serial-test',

From 4de86e6de1f071d33ce130db1062ebac8fe90a5e Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Mon, 29 Mar 2021 13:26:08 -0600
Subject: [PATCH 013/180] TCTI: add TCTI TCG backend for acceleration on
 non-JIT AArch64

---
 accel/tcg/translate-all.c             |    6 +-
 configure                             |   10 +-
 disas.c                               |    2 +
 include/disas/dis-asm.h               |    1 +
 include/exec/exec-all.h               |    4 +
 include/tcg/tcg.h                     |    2 +-
 meson.build                           |   24 +
 meson_options.txt                     |    2 +
 scripts/mtest2make.py                 |   24 +-
 tcg/aarch64-tcti/README.md            | 1026 +++++++++++++++++++
 tcg/aarch64-tcti/tcg-target-con-set.h |   21 +
 tcg/aarch64-tcti/tcg-target-con-str.h |   11 +
 tcg/aarch64-tcti/tcg-target.c.inc     | 1347 +++++++++++++++++++++++++
 tcg/aarch64-tcti/tcg-target.h         |  220 ++++
 tcg/aarch64-tcti/tcti-gadget-gen.py   |  788 +++++++++++++++
 tcg/tcg.c                             |   14 +-
 16 files changed, 3476 insertions(+), 26 deletions(-)
 create mode 100644 tcg/aarch64-tcti/README.md
 create mode 100644 tcg/aarch64-tcti/tcg-target-con-set.h
 create mode 100644 tcg/aarch64-tcti/tcg-target-con-str.h
 create mode 100644 tcg/aarch64-tcti/tcg-target.c.inc
 create mode 100644 tcg/aarch64-tcti/tcg-target.h
 create mode 100755 tcg/aarch64-tcti/tcti-gadget-gen.py

diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index e03d48ae7abc..bef19e744841 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -1130,7 +1130,7 @@ static bool alloc_code_gen_buffer_anon(size_t size, int prot,
     return true;
 }
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 #ifdef CONFIG_POSIX
 #include "qemu/memfd.h"
 
@@ -1257,7 +1257,7 @@ static bool alloc_code_gen_buffer_splitwx_vmremap(size_t size, Error **errp)
 
 static bool alloc_code_gen_buffer_splitwx(size_t size, Error **errp)
 {
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 # ifdef CONFIG_DARWIN
     return alloc_code_gen_buffer_splitwx_vmremap(size, errp);
 # endif
@@ -1290,7 +1290,7 @@ static bool alloc_code_gen_buffer(size_t size, int splitwx, Error **errp)
 
     prot = PROT_READ | PROT_WRITE | PROT_EXEC;
     flags = MAP_PRIVATE | MAP_ANONYMOUS;
-#ifdef CONFIG_TCG_INTERPRETER
+#if defined(CONFIG_TCG_INTERPRETER) || defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* The tcg interpreter does not need execute permission. */
     prot = PROT_READ | PROT_WRITE;
 #elif defined(CONFIG_DARWIN)
diff --git a/configure b/configure
index ac874fda5b02..b80b9e619641 100755
--- a/configure
+++ b/configure
@@ -362,6 +362,7 @@ tsan="no"
 fortify_source="$default_feature"
 strip_opt="yes"
 tcg_interpreter="false"
+tcg_threaded_interpreter="false"
 bigendian="no"
 mingw32="no"
 gcov="no"
@@ -1149,6 +1150,10 @@ for opt do
   ;;
   --enable-tcg-interpreter) tcg_interpreter="true"
   ;;
+  --disable-tcg-tcti) tcg_threaded_interpreter="false"
+  ;;
+  --enable-tcg-tcti) tcg_threaded_interpreter="true"
+  ;;
   --disable-cap-ng)  cap_ng="disabled"
   ;;
   --enable-cap-ng) cap_ng="enabled"
@@ -6512,9 +6517,8 @@ NINJA=$ninja $meson setup \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
         $(if test "$default_features" = no; then echo "-Dauto_features=disabled"; fi) \
-	-Dtcg_interpreter=$tcg_interpreter -Dshared_lib=$shared_lib \
-        $cross_arg \
-        "$PWD" "$source_path"
+	-Dtcg_interpreter=$tcg_interpreter -Dtcg_threaded_interpreter=$tcg_threaded_interpreter\
+	-Dshared_lib=$shared_lib $cross_arg "$PWD" "$source_path"
 
 if test "$?" -ne 0 ; then
     error_exit "meson setup failed"
diff --git a/disas.c b/disas.c
index a61f95b580b8..cea0f9019e49 100644
--- a/disas.c
+++ b/disas.c
@@ -152,6 +152,8 @@ static void initialize_debug_host(CPUDebug *s)
 #endif
 #if defined(CONFIG_TCG_INTERPRETER)
     s->info.print_insn = print_insn_tci;
+#elif defined(CONFIG_TCG_THREADED_INTERPRETER)
+    s->info.print_insn = print_insn_tcti;
 #elif defined(__i386__)
     s->info.mach = bfd_mach_i386_i386;
     s->info.print_insn = print_insn_i386;
diff --git a/include/disas/dis-asm.h b/include/disas/dis-asm.h
index 13fa1edd411e..ded69ba2ffaa 100644
--- a/include/disas/dis-asm.h
+++ b/include/disas/dis-asm.h
@@ -411,6 +411,7 @@ typedef struct disassemble_info {
 typedef int (*disassembler_ftype) (bfd_vma, disassemble_info *);
 
 int print_insn_tci(bfd_vma, disassemble_info*);
+int print_insn_tcti(bfd_vma, disassemble_info*);
 int print_insn_big_mips         (bfd_vma, disassemble_info*);
 int print_insn_little_mips      (bfd_vma, disassemble_info*);
 int print_insn_nanomips         (bfd_vma, disassemble_info*);
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index b7b3c0ef12d9..0b879e939abd 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -543,7 +543,11 @@ void tb_set_jmp_target(TranslationBlock *tb, int n, uintptr_t addr);
 #if defined(CONFIG_TCG_INTERPRETER)
 extern __thread uintptr_t tci_tb_ptr;
 # define GETPC() tci_tb_ptr
+#elif defined(CONFIG_TCG_THREADED_INTERPRETER)
+extern __thread uintptr_t tcti_call_return_address;
+# define GETPC() tcti_call_return_address
 #else
+/* Note that this is correct for TCTI also; whose gadget behaves like native code. */
 # define GETPC() \
     ((uintptr_t)__builtin_extract_return_addr(__builtin_return_address(0)))
 #endif
diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 0f0695e90da2..cfcd069bf3f6 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -1296,7 +1296,7 @@ static inline unsigned get_mmuidx(TCGMemOpIdx oi)
 #define TB_EXIT_IDXMAX    1
 #define TB_EXIT_REQUESTED 3
 
-#ifdef CONFIG_TCG_INTERPRETER
+#if defined(CONFIG_TCG_INTERPRETER) || defined(CONFIG_TCG_THREADED_INTERPRETER)
 uintptr_t tcg_qemu_tb_exec(CPUArchState *env, const void *tb_ptr);
 #else
 typedef uintptr_t tcg_prologue_fn(CPUArchState *env, const void *tb_ptr);
diff --git a/meson.build b/meson.build
index bcb175d82265..f3dddc075a47 100644
--- a/meson.build
+++ b/meson.build
@@ -58,6 +58,7 @@ python = import('python').find_installation()
 supported_oses = ['windows', 'freebsd', 'netbsd', 'openbsd', 'darwin', 'sunos', 'linux']
 supported_cpus = ['ppc', 'ppc64', 's390x', 'riscv32', 'riscv64', 'x86', 'x86_64',
   'arm', 'aarch64', 'mips', 'mips64', 'sparc', 'sparc64']
+tcti_supported_cpus = ['aarch64']
 
 cpu = host_machine.cpu_family()
 targetos = host_machine.system()
@@ -246,6 +247,25 @@ if not get_option('tcg').disabled()
   endif
   if get_option('tcg_interpreter')
     tcg_arch = 'tci'
+  elif get_option('tcg_threaded_interpreter')
+    if cpu not in tcti_supported_cpus
+      error('Unsupported CPU @0@ for TCTI, try --enable-tcg-interpreter'.format(cpu))
+    else
+      warning('TCTI is extremely experimental and incomplete! Things might break!')
+      tcg_arch = '@0@-tcti'.format(cpu)
+    endif
+
+    # Tell our compiler how to generate our TCTI gadgets.
+    gadget_generator = 'tcg/@0@/tcti-gadget-gen.py'.format(tcg_arch)
+    tcti_gadgets = custom_target('tcti-gadgets.c.inc',
+                                output: 'tcti-gadgets.c.inc',
+                                input: gadget_generator,
+                                command: [find_program(gadget_generator), '@OUTPUT@'],
+                                build_by_default: true,
+                                build_always_stale: false)
+
+    genh += tcti_gadgets
+    
   elif config_host['ARCH'] == 'sparc64'
     tcg_arch = 'sparc'
   elif config_host['ARCH'] == 's390x'
@@ -1280,6 +1300,8 @@ foreach target : target_dirs
       config_all += { sym: 'y' }
       if sym == 'CONFIG_TCG' and tcg_arch == 'tci'
         config_target += { 'CONFIG_TCG_INTERPRETER': 'y' }
+      elif sym == 'CONFIG_TCG' and tcg_arch.endswith('tcti')
+        config_target += { 'CONFIG_TCG_THREADED_INTERPRETER': 'y' }
       elif sym == 'CONFIG_XEN' and have_xen_pci_passthrough
         config_target += { 'CONFIG_XEN_PCI_PASSTHROUGH': 'y' }
       endif
@@ -2539,6 +2561,8 @@ summary_info += {'TCG support':       config_all.has_key('CONFIG_TCG')}
 if config_all.has_key('CONFIG_TCG')
   if get_option('tcg_interpreter')
     summary_info += {'TCG backend':   'TCI (TCG with bytecode interpreter, experimental and slow)'}
+  elif get_option('tcg_threaded_interpreter')
+    summary_info += {'TCG backend':   'TCTI (TCG with threaded-dispatch bytecode interpreter, experimental and slow; but faster than TCI)'}
   else
     summary_info += {'TCG backend':   'native (@0@)'.format(cpu)}
   endif
diff --git a/meson_options.txt b/meson_options.txt
index 6c29ea93300a..5aa68672c2ff 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -43,6 +43,8 @@ option('tcg', type: 'feature', value: 'auto',
        description: 'TCG support')
 option('tcg_interpreter', type: 'boolean', value: false,
        description: 'TCG with bytecode interpreter (experimental and slow)')
+option('tcg_threaded_interpreter', type: 'boolean', value: false,
+       description: 'TCG with threaded-dispatch bytecode interpreter (experimental and slow, but less slow than TCI)')
 option('cfi', type: 'boolean', value: 'false',
        description: 'Control-Flow Integrity (CFI)')
 option('cfi_debug', type: 'boolean', value: 'false',
diff --git a/scripts/mtest2make.py b/scripts/mtest2make.py
index cbbcba100d86..48bf9acafc99 100644
--- a/scripts/mtest2make.py
+++ b/scripts/mtest2make.py
@@ -75,18 +75,18 @@ def process_tests(test, targets, suites):
     print('run-test-%d: $(.test.deps.%d)' % (i,i))
     print('\t@$(call .test.run,%d,$(.test.output-format))' % (i,))
 
-    test_suites = test['suite'] or ['default']
-    is_slow = any(s.endswith('-slow') for s in test_suites)
-    for s in test_suites:
-        # The suite name in the introspection info is "PROJECT:SUITE"
-        s = s.split(':')[1]
-        if s.endswith('-slow'):
-            s = s[:-5]
-        if is_slow:
-            suites[s].slow_tests.append(i)
-        else:
-            suites[s].tests.append(i)
-        suites[s].executables.add(executable)
+    #test_suites = test['suite'] or ['default']
+    #is_slow = any(s.endswith('-slow') for s in test_suites)
+    #for s in test_suites:
+    #    # The suite name in the introspection info is "PROJECT:SUITE"
+    #    s = s.split(':')[1]
+    #    if s.endswith('-slow'):
+    #        s = s[:-5]
+    #    if is_slow:
+    #        suites[s].slow_tests.append(i)
+    #    else:
+    #        suites[s].tests.append(i)
+    #    suites[s].executables.add(executable)
 
 def emit_prolog(suites, prefix):
     all_tap = ' '.join(('%s-report-%s.tap' % (prefix, k) for k in suites.keys()))
diff --git a/tcg/aarch64-tcti/README.md b/tcg/aarch64-tcti/README.md
new file mode 100644
index 000000000000..eb848e5a9e57
--- /dev/null
+++ b/tcg/aarch64-tcti/README.md
@@ -0,0 +1,1026 @@
+# QEMU Tiny-Code Threaded Interpreter (AArch64)
+
+A TCG backend that chains together JOP/ROP-ish gadgets to massively reduce interpreter overhead vs TCI.
+Platform-dependent; but usable when JIT isn't available; e.g. on platforms that lack WX mappings. The general idea squish the addresses of a gadget sequence into a "queue" and then write each gadget so it ends in a "dequeue-jump".
+
+Execution occurs by jumping into the first gadget, and letting it just play back some linear-overhead native code sequences for a while.
+
+Since TCG-TCI is optimized for sets of 16 GP registers and aarch64 has 30, we could easily keep JIT/QEMU and guest state separate, and since 16\*16 is reasonably small we could actually have a set of reasonable gadgets for each combination of operands.
+
+
+## Register Convention
+
+| Regs    | Use                   |
+| :------ | :-------------------- |
+| x1-x15  | Guest Registers       |
+| x24     | TCTI temporary        |
+| x25     | saved IP during call  |
+| x26     | TCTI temporary        |
+| x27     | TCTI temporary        |
+| x28     | Thread-stream pointer |
+| x30     | Link register         |
+| SP      | Stack Pointer, host   |
+| PC      | Program Counter, host |
+
+In pseudocode:
+
+| Symbol | Meaning                             |
+| :----- | :---------------------------------- |
+| Rd     | stand-in for destination register   |
+| Rn     | stand-in for first source register  |
+| Rm     | stand-in for second source register |
+
+## Gadget Structure
+
+### End of gadget
+
+Each gadget ends by advancing our bytecode pointer, and then executing from thew new location.
+
+```asm
+# Load our next gadget address from our bytecode stream, advancing it, and jump to the next gadget.
+
+ldr x27, [x28], #8\n
+br x27
+```
+
+## Calling into QEMU's C codebase
+
+When calling into C, we lose control over which registers are used. Accordingly, we'll need to save
+registers relevant to TCTI:
+
+```asm
+str x25,      [sp, #-16]!
+stp x14, x15, [sp, #-16]!
+stp x12, x13, [sp, #-16]!
+stp x10, x11, [sp, #-16]!
+stp x8,  x9,  [sp, #-16]!
+stp x6,  x7,  [sp, #-16]!
+stp x4,  x5,  [sp, #-16]!
+stp x2,  x3,  [sp, #-16]!
+stp x0,  x1,  [sp, #-16]!
+stp x28, lr,  [sp, #-16]!
+```
+
+Upon returning to the gadget stream, we'll then restore them.
+
+```asm
+ldp x28, lr, [sp], #16
+ldp x0,  x1, [sp], #16
+ldp x2,  x3, [sp], #16
+ldp x4,  x5, [sp], #16
+ldp x6,  x7, [sp], #16
+ldp x8,  x9, [sp], #16
+ldp x10, x11, [sp], #16
+ldp x12, x13, [sp], #16
+ldp x14, x15, [sp], #16
+ldr x25,      [sp], #16
+```
+
+## TCG Operations
+
+Each operation needs an implementation for every platform; and probably a set of gadgets for each possible set of operands.
+
+At 14 GP registers, that means that
+
+1 operand =\> 16 gadgets
+2 operands =\> 256 gadgets
+3 operands =\> 4096 gadgets
+
+### call
+
+Calls a helper function by address.
+
+**IR Format**: `br <ptr address>`  
+**Gadget type:** single
+
+```asm
+    # Get our C runtime function's location as a pointer-sized immediate...
+    "ldr x27, [x28], #8",
+
+    # Store our TB return address for our helper. This is necessary so the GETPC()
+    # macro works correctly as used in helper functions.
+    "str x28, [x25]",
+
+    # Prepare ourselves to call into our C runtime...
+    *C_CALL_PROLOGUE,
+
+    # ... perform the call itself ...
+    "blr x27",
+
+    # Save the result of our call for later.
+    "mov x27, x0",
+
+    # ... and restore our environment.
+    *C_CALL_EPILOGUE,
+
+    # Restore our return value.
+    "mov x0, x27"
+```
+
+### br
+
+Branches to a given immediate address. Branches are
+
+**IR Format**: `br <ptr address>`  
+**Gadget type:** single
+
+```asm
+# Use our immediate argument as our new bytecode-pointer location.
+ldr x28, [x28]
+```
+
+### setcond_i32
+
+Performs a comparison between two 32-bit operands.
+
+**IR Format**: `setcond32 <cond>, Rd, Rn, Rm`  
+**Gadget type:** treated as 10 operations with variants for every `Rd`/`Rn`/`Rm` (40,960)
+
+```asm
+subs Wd, Wn, Wm
+cset Wd, <cond>
+```
+
+| QEMU Cond | AArch64 Cond |
+| :-------- | :----------- |
+| EQ        | EQ           |
+| NE        | NE           |
+| LT        | LT           |
+| GE        | GE           |
+| LE        | LE           |
+| GT        | GT           |
+| LTU       | LO           |
+| GEU       | HS           |
+| LEU       | LS           |
+| GTU       | HI           |
+
+### setcond_i64
+
+Performs a comparison between two 32-bit operands.
+
+**IR Format**: `setcond64 <cond>, Rd, Rn, Rm`  
+**Gadget type:** treated as 10 operations with variants for every `Rd`/`Rn`/`Rm` (40,960)
+
+```asm
+subs Xd, Xn, Xm
+cset Xd, <cond>
+```
+
+Comparison chart is the same as the `_i32` variant.
+
+### brcond_i32
+
+Compares two 32-bit numbers, and branches if the comparison is true.
+
+**IR Format**: `brcond Rn, Rm, <cond>`  
+**Gadget type:** treated as 10 operations with variants for every `Rn`/`Rm` (2560)
+
+```asm
+# Perform our comparison and conditional branch.
+subs Wrz, Wn, Wm
+br<cond> taken
+
+    # Consume the branch target, without using it.
+    add x28, x28, #8
+
+    # Perform our end-of-instruction epilogue.
+    <epilogue here>
+
+taken:
+
+    # Update our bytecode pointer to take the label.
+    ldr x28, [x28]
+```
+
+Comparison chart is the same as in `setcond_i32` .
+
+### brcond_i64
+
+Compares two 64-bit numbers, and branches if the comparison is true.
+
+**IR Format**: `brcond Rn, Rm, <cond>`  
+**Gadget type:** treated as 10 operations with variants for every `Rn`/`Rm` (2560)
+
+```asm
+# Perform our comparison and conditional branch.
+subs Xrz, Xn, Xm
+br<cond> taken
+
+    # Consume the branch target, without using it.
+    add x28, x28, #8
+
+    # Perform our end-of-instruction epilogue.
+    <epilogue here>
+
+taken:
+
+    # Update our bytecode pointer to take the label.
+    ldr x28, [x28]
+```
+
+Comparison chart is the same as in `setcond_i32` .
+
+### mov_i32
+
+Moves a value from a register to another register.
+
+**IR Format**: `mov Rd, Rn`  
+**Gadget type:** gadget per `Rd` + `Rn` combo (256)
+
+```asm
+mov Rd, Rn
+```
+
+### mov_i64
+
+Moves a value from a register to another register.
+
+**IR Format**: `mov Rd, Rn`  
+**Gadget type:** gadget per `Rd` + `Rn` combo (256)
+
+```asm
+mov Xd, Xn
+```
+
+### tci_movi_i32
+
+Moves an 32b immediate into a register.
+
+**IR Format**: `mov Rd, #imm32`  
+**Gadget type:** gadget per `Rd` (16)
+
+```asm
+ldr w27, [x28], #4
+mov Wd, w27
+```
+
+### tci_movi_i64
+
+Moves an 64b immediate into a register.
+
+**IR Format**: `mov Rd, #imm64`  
+**Gadget type:** gadget per `Rd` (16)
+
+```asm
+ldr x27, [x28], #4
+mov Xd, x27
+```
+
+### ld8u_i32 / ld8u_i64
+
+Load byte from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrb Xd, [Xn, x27]
+```
+
+### ld8s_i32 / ld8s_i64
+
+Load byte from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsb Xd, [Xn, x27]
+```
+
+### ld16u_i32 / ld16u_i64
+
+Load 16b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrh Wd, [Xn, x27]
+```
+
+### ld16s_i32 / ld16s_i64
+
+Load 16b from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsh Xd, [Xn, x27]
+```
+
+### ld32u_i32 / ld32u_i64
+
+Load 32b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldr Wd, [Xn, x27]
+```
+
+### ld32s_i64
+
+Load 32b from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsw Xd, [Xn, x27]
+```
+
+### ld_i64
+
+Load 64b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldr Xd, [Xn, x27]
+```
+
+### st8_i32 / st8_i64
+
+Stores byte from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+strb Wd, [Xn, x27]
+```
+
+### st16_i32 / st16_i64
+
+Stores 16b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+strh Wd, [Xn, x27]
+```
+
+### st_i32 / st32_i64
+
+Stores 32b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+str Wd, [Xn, x27]
+```
+
+### st_i64
+
+Stores 64b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+str Xd, [Xn, x27]
+```
+
+### qemu_ld_i32
+
+Loads 32b from _guest_ memory to register.
+
+**IR Format**: `ld Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+### qemu_ld_i64
+
+Loads 64b from _guest_ memory to register.
+
+**IR Format**: `ld Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+### qemu_st_i32
+
+Stores 32b from a register to _guest_ memory.
+
+**IR Format**: `st Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl
+
+### qemu_st_i64
+
+Stores 64b from a register to _guest_ memory.
+
+**IR Format**: `st Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+#### Note
+
+See note on `qemu_ld_i32`.
+
+### add_i32
+
+Adds two 32-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+add Wd, Wn, Wm
+```
+
+### add_i64
+
+Adds two 64-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+add Xd, Xn, Xm
+```
+
+### sub_i32
+
+Subtracts two 32-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+Sub Wd, Wn, Wm
+```
+
+### sub_i64
+
+Subtracts two 64-bit numbers.
+
+**IR Format**: `sub Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sub Xd, Xn, Xm
+```
+
+### mul_i32
+
+Multiplies two 32-bit numbers.
+
+**IR Format**: `mul Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+mul Wd, Wn, Wm
+```
+
+### mul_i64
+
+Multiplies two 64-bit numbers.
+
+**IR Format**: `mul Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+mul Xd, Xn, Xm
+```
+
+### div_i32
+
+Divides two 32-bit numbers; considering them signed.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv Wd, Wn, Wm
+```
+
+### div_i64
+
+Divides two 64-bit numbers; considering them signed.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv Xd, Xn, Xm
+```
+
+### divu_i32
+
+Divides two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv Wd, Wn, Wm
+```
+
+### divu_i64
+
+Divides two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv Xd, Xn, Xm
+```
+
+### rem_i32
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them signed.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv    w27, Wn, Wm
+msub    Wd, w27, Wm, Wn
+```
+
+### rem_i64
+
+Computes the division remainder (modulus) of two 64-bit numbers; considering them signed.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv    x27, Xn, Xm
+msub    Xd, x27, Xm, Xn
+```
+
+### remu_i32
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv    w27, Wn, Wm
+msub    Wd, w27, Wm, Wn
+```
+
+### remu_i64
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv    x27, Xn, Xm
+msub    Xd, x27, Xm, Xn
+```
+
+### not_i32
+
+Logically inverts a 32-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+mvn Wd, Wn
+```
+
+### not_i64
+
+Logically inverts a 64-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+mvn Xd, Xn
+```
+
+### neg_i32
+
+Arithmetically inverts (two's compliment) a 32-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+neg Wd, Wn
+```
+
+### neg_i64
+
+Arithmetically inverts (two's compliment) a 64-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+neg Xd, Xn
+```
+
+### and_i32
+
+Logically ANDs two 32-bit numbers.
+
+**IR Format**: `and Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+and Wd, Wn, Wm
+```
+
+### and_i64
+
+Logically ANDs two 64-bit numbers.
+
+**IR Format**: `and Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+and Xd, Xn, Xm
+```
+
+### or_i32
+
+Logically ORs two 32-bit numbers.
+
+**IR Format**: `or Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+or Wd, Wn, Wm
+```
+
+### or_i64
+
+Logically ORs two 64-bit numbers.
+
+**IR Format**: `or Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+or Xd, Xn, Xm
+```
+
+### xor_i32
+
+Logically XORs two 32-bit numbers.
+
+**IR Format**: `xor Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+eor Wd, Wn, Wm
+```
+
+### xor_i64
+
+Logically XORs two 64-bit numbers.
+
+**IR Format**: `xor Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+eor Xd, Xn, Xm
+```
+
+### shl_i32
+
+Logically shifts a 32-bit number left.
+
+**IR Format**: `shl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsl Wd, Wn, Wm
+```
+
+### shl_i64
+
+Logically shifts a 64-bit number left.
+
+**IR Format**: `shl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsl Xd, Xn, Xm
+```
+
+### shr_i32
+
+Logically shifts a 32-bit number right.
+
+**IR Format**: `shr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsr Wd, Wn, Wm
+```
+
+### shr_i64
+
+Logically shifts a 64-bit number right.
+
+**IR Format**: `shr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsr Xd, Xn, Xm
+```
+
+### sar_i32
+
+Arithmetically shifts a 32-bit number right.
+
+**IR Format**: `sar Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+asr Wd, Wn, Wm
+```
+
+### sar_i64
+
+Arithmetically shifts a 64-bit number right.
+
+**IR Format**: `sar Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+asr Xd, Xn, Xm
+```
+
+### rotl_i32
+
+Rotates a 32-bit number left.
+
+**IR Format**: `rotl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+rol Wd, Wn, Wm
+```
+
+### rotl_i64
+
+Rotates a 64-bit number left.
+
+**IR Format**: `rotl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+rol Xd, Xn, Xm
+```
+
+### rotr_i32
+
+Rotates a 32-bit number right.
+
+**IR Format**: `rotr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+ror Wd, Wn, Wm
+```
+
+### rotr_i64
+
+Rotates a 64-bit number right.
+
+**IR Format**: `rotr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+ror Xd, Xn, Xm
+```
+
+### deposit_i32
+
+Optional; not currently implementing.
+
+### deposit_i64
+
+Optional; not currently implementing.
+
+### ext8s_i32
+
+Sign extends the lower 8b of a register into a 32b destination.
+
+**IR Format**: `ext8s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtb Wd, Wn
+```
+
+### ext8s_i64
+
+Sign extends the lower 8b of a register into a 64b destination.
+
+**IR Format**: `ext8s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtb Xd, Wn
+```
+
+### ext8u_i32
+
+Zero extends the lower 8b of a register into a 32b destination.
+
+**IR Format**: `ext8u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xff
+```
+
+### ext8u_i64
+
+Zero extends the lower 8b of a register into a 64b destination.
+
+**IR Format**: `ext8u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xff
+```
+
+### ext16s_i32
+
+Sign extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxth Xd, Wn
+```
+
+### ext16s_i64
+
+Sign extends the lower 16b of a register into a 64b destination.
+
+**IR Format**: `ext16s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxth Xd, Wn
+```
+
+### ext16u_i32
+
+Zero extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Wd, Wn, #0xffff
+```
+
+### ext16u_i64
+
+Zero extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Wd, Wn, #0xffff
+```
+
+### ext32s_i64
+
+Sign extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### ext32u_i64
+
+Zero extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### ext_i32_i64
+
+Sign extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### extu_i32_i64
+
+Zero extends the lower 32b of a register into a 32b destination.
+
+**IR Format**: `ext32u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xffffffff
+```
+
+### bswap16_i32
+
+Byte-swaps a 16b quantity.
+
+**IR Format**: `bswap16 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     w27, Wn
+lsr     Wd, w27, #16
+```
+
+### bswap16_i64
+
+Byte-swaps a 16b quantity.
+
+**IR Format**: `bswap16 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     w27, Wn
+lsr     Wd, w27, #16
+```
+
+### bswap32_i32
+
+Byte-swaps a 32b quantity.
+
+**IR Format**: `bswap32 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Wd, Wn
+```
+
+### bswap32_i64
+
+Byte-swaps a 32b quantity.
+
+**IR Format**: `bswap32 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Wd, Wn
+```
+
+### bswap64_i64
+
+Byte-swaps a 64b quantity.
+
+**IR Format**: `bswap64 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Xd, Xn
+```
+
+### exit_tb
+
+Exits the translation block. Has no gadget; but instead inserts the address of the translation block epilogue.
+
+
+### mb
+
+Memory barrier.
+
+**IR Format**: `mb <type>`  
+**Gadget type:** gadget per type
+
+```asm
+# !!! TODO
+```
+
+#### Note
+
+We still need to look up out how to map QEMU MB types map to AArch64 ones. This might take nuance.
diff --git a/tcg/aarch64-tcti/tcg-target-con-set.h b/tcg/aarch64-tcti/tcg-target-con-set.h
new file mode 100644
index 000000000000..f51b7bcb13e7
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target-con-set.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * TCI target-specific constraint sets.
+ * Copyright (c) 2021 Linaro
+ */
+
+/*
+ * C_On_Im(...) defines a constraint set with <n> outputs and <m> inputs.
+ * Each operand should be a sequence of constraint letters as defined by
+ * tcg-target-con-str.h; the constraint combination is inclusive or.
+ */
+C_O0_I2(r, r)
+C_O0_I3(r, r, r)
+C_O0_I4(r, r, r, r)
+C_O1_I1(r, r)
+C_O1_I2(r, 0, r)
+C_O1_I2(r, r, r)
+C_O1_I4(r, r, r, r, r)
+C_O2_I1(r, r, r)
+C_O2_I2(r, r, r, r)
+C_O2_I4(r, r, r, r, r, r)
diff --git a/tcg/aarch64-tcti/tcg-target-con-str.h b/tcg/aarch64-tcti/tcg-target-con-str.h
new file mode 100644
index 000000000000..87c0f19e9c2e
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target-con-str.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Define TCI target-specific operand constraints.
+ * Copyright (c) 2021 Linaro
+ */
+
+/*
+ * Define constraint letters for register sets:
+ * REGS(letter, register_mask)
+ */
+REGS('r', MAKE_64BIT_MASK(0, TCG_TARGET_NB_REGS))
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
new file mode 100644
index 000000000000..d7bb67a92140
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -0,0 +1,1347 @@
+/*
+ * Tiny Code Threaded Intepreter for QEMU
+ *
+ * Copyright (c) 2021 Kate Temkin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define TCTI_GADGET_IMMEDIATE_ARRAY_LEN 64
+
+// Grab our gadget definitions.
+// FIXME: use the system path instead of hardcoding this?
+#include "tcti-gadgets.c.inc"
+
+/* Marker for missing code. */
+#define TODO() \
+    do { \
+        fprintf(stderr, "TODO %s:%u: %s()\n", \
+                __FILE__, __LINE__, __func__); \
+        tcg_abort(); \
+    } while (0)
+
+
+/* Enable TCTI assertions only when debugging TCG (and without NDEBUG defined).
+ * Without assertions, the interpreter runs much faster. */
+#if defined(CONFIG_DEBUG_TCG)
+# define tcti_assert(cond) assert(cond)
+#else
+# define tcti_assert(cond) ((void)0)
+#endif
+
+/* Bitfield n...m (in 32 bit value). */
+#define BITS(n, m) (((0xffffffffU << (31 - n)) >> (31 - n + m)) << m)
+
+/**
+ * Macro that defines a look-up tree for named QEMU_LD gadgets.
+ */ 
+#define LD_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_ld_ub_   ## suffix; break; \
+        case MO_SB:   variable = gadget_qemu_ld_sb_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_ld_leuw_ ## suffix; break; \
+        case MO_LESW: variable = gadget_qemu_ld_lesw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_ld_leul_ ## suffix; break; \
+        case MO_LESL: variable = gadget_qemu_ld_lesl_ ## suffix; break; \
+        case MO_LEQ:  variable = gadget_qemu_ld_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_ld_beuw_ ## suffix; break; \
+        case MO_BESW: variable = gadget_qemu_ld_besw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_ld_beul_ ## suffix; break; \
+        case MO_BESL: variable = gadget_qemu_ld_besl_ ## suffix; break; \
+        case MO_BEQ:  variable = gadget_qemu_ld_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define LD_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            LD_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            LD_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+
+/**
+ * Macro that defines a look-up tree for named QEMU_ST gadgets.
+ */ 
+#define ST_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_st_ub_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_st_leuw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_st_leul_ ## suffix; break; \
+        case MO_LEQ:  variable = gadget_qemu_st_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_st_beuw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_st_beul_ ## suffix; break; \
+        case MO_BEQ:  variable = gadget_qemu_st_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define ST_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            ST_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            ST_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
+{
+    switch (op) {
+    case INDEX_op_ld8u_i32:
+    case INDEX_op_ld8s_i32:
+    case INDEX_op_ld16u_i32:
+    case INDEX_op_ld16s_i32:
+    case INDEX_op_ld_i32:
+    case INDEX_op_ld8u_i64:
+    case INDEX_op_ld8s_i64:
+    case INDEX_op_ld16u_i64:
+    case INDEX_op_ld16s_i64:
+    case INDEX_op_ld32u_i64:
+    case INDEX_op_ld32s_i64:
+    case INDEX_op_ld_i64:
+    case INDEX_op_not_i32:
+    case INDEX_op_not_i64:
+    case INDEX_op_neg_i32:
+    case INDEX_op_neg_i64:
+    case INDEX_op_ext8s_i32:
+    case INDEX_op_ext8s_i64:
+    case INDEX_op_ext16s_i32:
+    case INDEX_op_ext16s_i64:
+    case INDEX_op_ext8u_i32:
+    case INDEX_op_ext8u_i64:
+    case INDEX_op_ext16u_i32:
+    case INDEX_op_ext16u_i64:
+    case INDEX_op_ext32s_i64:
+    case INDEX_op_ext32u_i64:
+    case INDEX_op_ext_i32_i64:
+    case INDEX_op_extu_i32_i64:
+    case INDEX_op_bswap16_i32:
+    case INDEX_op_bswap16_i64:
+    case INDEX_op_bswap32_i32:
+    case INDEX_op_bswap32_i64:
+    case INDEX_op_bswap64_i64:
+        return C_O1_I1(r, r);
+
+    case INDEX_op_st8_i32:
+    case INDEX_op_st16_i32:
+    case INDEX_op_st_i32:
+    case INDEX_op_st8_i64:
+    case INDEX_op_st16_i64:
+    case INDEX_op_st32_i64:
+    case INDEX_op_st_i64:
+        return C_O0_I2(r, r);
+
+    case INDEX_op_div_i32:
+    case INDEX_op_div_i64:
+    case INDEX_op_divu_i32:
+    case INDEX_op_divu_i64:
+    case INDEX_op_rem_i32:
+    case INDEX_op_rem_i64:
+    case INDEX_op_remu_i32:
+    case INDEX_op_remu_i64:
+    case INDEX_op_add_i32:
+    case INDEX_op_add_i64:
+    case INDEX_op_sub_i32:
+    case INDEX_op_sub_i64:
+    case INDEX_op_mul_i32:
+    case INDEX_op_mul_i64:
+    case INDEX_op_and_i32:
+    case INDEX_op_and_i64:
+    case INDEX_op_andc_i32:
+    case INDEX_op_andc_i64:
+    case INDEX_op_eqv_i32:
+    case INDEX_op_eqv_i64:
+    case INDEX_op_nand_i32:
+    case INDEX_op_nand_i64:
+    case INDEX_op_nor_i32:
+    case INDEX_op_nor_i64:
+    case INDEX_op_or_i32:
+    case INDEX_op_or_i64:
+    case INDEX_op_orc_i32:
+    case INDEX_op_orc_i64:
+    case INDEX_op_xor_i32:
+    case INDEX_op_xor_i64:
+    case INDEX_op_shl_i32:
+    case INDEX_op_shl_i64:
+    case INDEX_op_shr_i32:
+    case INDEX_op_shr_i64:
+    case INDEX_op_sar_i32:
+    case INDEX_op_sar_i64:
+    case INDEX_op_rotl_i32:
+    case INDEX_op_rotl_i64:
+    case INDEX_op_rotr_i32:
+    case INDEX_op_rotr_i64:
+    case INDEX_op_setcond_i32:
+    case INDEX_op_setcond_i64:
+        return C_O1_I2(r, r, r);
+
+    case INDEX_op_brcond_i32:
+    case INDEX_op_brcond_i64:
+        return C_O0_I2(r, r);
+
+    case INDEX_op_qemu_ld_i32:
+    case INDEX_op_qemu_ld_i64:
+        return C_O1_I2(r, r, r);
+    case INDEX_op_qemu_st_i32:
+    case INDEX_op_qemu_st_i64:
+        return C_O0_I3(r, r, r);
+
+    default:
+        g_assert_not_reached();
+    }
+}
+
+static const int tcg_target_reg_alloc_order[] = {
+    TCG_REG_R0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+    TCG_REG_R6,
+    TCG_REG_R7,
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
+    /*
+    TCG_REG_R14,  // AREG0
+    TCG_REG_R15,  // SP
+    */
+};
+
+#if MAX_OPC_PARAM_IARGS != 6
+# error Fix needed, number of supported input arguments changed!
+#endif
+
+static const int tcg_target_call_iarg_regs[] = {
+    TCG_REG_R0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+};
+
+static const int tcg_target_call_oarg_regs[] = {
+    TCG_REG_R0,
+};
+
+#ifdef CONFIG_DEBUG_TCG
+static const char *const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {
+    "r00",
+    "r01",
+    "r02",
+    "r03",
+    "r04",
+    "r05",
+    "r06",
+    "r07",
+    "r08",
+    "r09",
+    "r10",
+    "r11",
+    "r12",
+    "r13",
+    "r14",
+    "r15",
+};
+#endif
+
+static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+                        intptr_t value, intptr_t addend)
+{
+    /* tcg_out_reloc always uses the same type, addend. */
+    tcg_debug_assert(type == sizeof(tcg_target_long));
+    tcg_debug_assert(addend == 0);
+    tcg_debug_assert(value != 0);
+    if (TCG_TARGET_REG_BITS == 32) {
+        tcg_patch32(code_ptr, value);
+    } else {
+        tcg_patch64(code_ptr, value);
+    }
+    return true;
+}
+
+#if defined(CONFIG_DEBUG_TCG_INTERPRETER)
+/* Show current bytecode. Used by tcg interpreter. */
+void tci_disas(uint8_t opc)
+{
+    const TCGOpDef *def = &tcg_op_defs[opc];
+    fprintf(stderr, "TCG %s %u, %u, %u\n",
+            def->name, def->nb_oargs, def->nb_iargs, def->nb_cargs);
+}
+#endif
+
+/* Write value (native size). */
+static void tcg_out_immediate(TCGContext *s, tcg_target_ulong v)
+{
+    if (TCG_TARGET_REG_BITS == 32) {
+        //tcg_out32(s, v);
+        tcg_out64(s, v);
+    } else {
+        tcg_out64(s, v);
+    }
+}
+
+void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_rx, uintptr_t jmp_rw, uintptr_t addr)
+{
+    /* Get a pointer to our immediate, which exists after a single pointer. */
+    uintptr_t immediate_addr = jmp_rw;
+
+    /* Patch it to be match our target address. */
+    qatomic_set((uint64_t *)immediate_addr, addr);
+}
+
+
+/**
+ * TCTI Thunk Helpers
+ */
+
+#ifdef CONFIG_SOFTMMU
+
+// TODO: relocate these prototypes?
+tcg_target_ulong helper_ret_ldub_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+
+tcg_target_ulong helper_ret_ldub_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int8_t)helper_ret_ldub_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_le_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int16_t)helper_le_lduw_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_le_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int32_t)helper_le_ldul_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_be_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int16_t)helper_be_lduw_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int32_t)helper_be_ldul_mmu(env, addr, oi, retaddr);
+}
+
+#else
+#error TCTI currently only supports use of the soft MMU.
+#endif
+
+
+/**
+ * TCTI Emmiter Helpers
+ */
+
+
+/* Write gadget pointer. */
+static void tcg_out_nullary_gadget(TCGContext *s, void *gadget)
+{
+    tcg_out_immediate(s, (tcg_target_ulong)gadget);
+}
+
+/* Write gadget pointer, plus 64b immediate. */
+static void tcg_out_imm64_gadget(TCGContext *s, void *gadget, tcg_target_ulong immediate)
+{
+    tcg_out_nullary_gadget(s, gadget);
+    tcg_out64(s, immediate);
+}
+
+
+/* Write gadget pointer (one register). */
+static void tcg_out_unary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS], unsigned reg0)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0]);
+}
+
+
+/* Write gadget pointer (two registers). */
+static void tcg_out_binary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1]);
+}
+
+
+/* Write gadget pointer (three registers). */
+static void tcg_out_ternary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1, unsigned reg2)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1][reg2]);
+}
+
+
+/**
+ * Version of our LDST generator that defers to more optimized gadgets selectively.
+ */
+static void tcg_out_ldst_gadget_inner(TCGContext *s, 
+    void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], 
+    void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    unsigned reg0, unsigned reg1, uint32_t offset)
+{
+    int64_t extended_offset = (int32_t)offset;
+    bool is_negative = (extended_offset < 0);
+
+    // Optimal case: we have a gadget that handles our specific offset, so we don't need to encode
+    // an immediate. This saves us a bunch of speed. :)
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        uint64_t shifted_offset = (extended_offset >> 3);
+        bool aligned_to_8B = ((extended_offset & 0b111) == 0);
+
+        bool have_optimized_gadget = (extended_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN);
+        bool have_shifted_gadget   = (shifted_offset  < TCTI_GADGET_IMMEDIATE_ARRAY_LEN);
+
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (have_optimized_gadget) {
+            tcg_out_nullary_gadget(s, gadget_pos_imm[reg0][reg1][extended_offset]);
+            return;
+        } 
+
+        // Special case: it's frequent to have low-numbered positive offsets that are aligned
+        // to 16B boundaries
+        else if(aligned_to_8B && have_shifted_gadget) {
+            tcg_out_nullary_gadget(s, gadget_shifted_imm[reg0][reg1][shifted_offset]);
+            return;
+        }
+    } 
+    else {
+        uint64_t negated_offset = -(extended_offset);
+
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (negated_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN) {
+            tcg_out_nullary_gadget(s, gadget_neg_imm[reg0][reg1][negated_offset]);
+            return;
+        }
+    }
+
+    // Less optimal case: we don't have a gadget specifically for this. Emit the general case immediate.
+    tcg_out_binary_gadget(s, gadget_base, reg0, reg1);
+    tcg_out64(s, extended_offset); //tcg_out32(s, offset);
+}
+
+/* Shorthand for the above, that prevents us from having to specify the name three times. */
+#define tcg_out_ldst_gadget(s, name, a, b, c) \
+    tcg_out_ldst_gadget_inner(s, name, \
+        name ## _imm,  \
+        name ## _sh8_imm,  \
+        name ## _neg_imm, \
+    a, b, c)
+
+
+
+/* Write label. */
+static void tcti_out_label(TCGContext *s, TCGLabel *label)
+{
+    if (label->has_value) {
+        tcg_out64(s, label->u.value);
+        tcg_debug_assert(label->u.value);
+    } else {
+        tcg_out_reloc(s, s->code_ptr, sizeof(tcg_target_ulong), label, 0);
+        s->code_ptr += sizeof(tcg_target_ulong);
+    }
+}
+
+/**
+ * Generate a register-to-register MOV.
+ */
+static bool tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
+{
+    tcg_debug_assert(ret != arg);
+
+    if (type == TCG_TYPE_I32) {
+        tcg_out_binary_gadget(s, gadget_mov_i32, ret, arg);
+    } else {
+        tcg_out_binary_gadget(s, gadget_mov_i64, ret, arg);
+    }
+
+
+    return true;
+}
+
+
+static void tcg_out_movi_i32(TCGContext *s, TCGReg t0, tcg_target_long arg)
+{
+    bool is_negative = (arg < 0);
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (arg < ARRAY_SIZE(gadget_movi_imm_i32[t0])) {
+            tcg_out_nullary_gadget(s, gadget_movi_imm_i32[t0][arg]);
+            return;
+        }
+    } 
+    else {
+
+    }
+
+    // Emit the mov and its immediate.
+    tcg_out_unary_gadget(s, gadget_movi_i32, t0);
+    tcg_out64(s, arg); // TODO: make 32b?
+}
+
+
+static void tcg_out_movi_i64(TCGContext *s, TCGReg t0, tcg_target_long arg)
+{
+    uint8_t is_negative = arg < 0;
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (arg < ARRAY_SIZE(gadget_movi_imm_i64[t0])) {
+            tcg_out_nullary_gadget(s, gadget_movi_imm_i64[t0][arg]);
+            return;
+        }
+    } 
+    else {
+
+    }
+
+    // TODO: optimize the negative case, too?
+
+    // Less optimal case: emit the mov and its immediate.
+    tcg_out_unary_gadget(s, gadget_movi_i64, t0);
+    tcg_out64(s, arg);
+}
+
+
+/**
+ * Generate an immediate-to-register MOV.
+ */
+static void tcg_out_movi(TCGContext *s, TCGType type, TCGReg t0, tcg_target_long arg)
+{
+    if (type == TCG_TYPE_I32) {
+        tcg_out_movi_i32(s, t0, arg);
+    } else {
+        tcg_out_movi_i64(s, t0, arg);
+    }
+}
+
+/**
+ * Generate a CALL.
+ */
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
+{
+    tcg_out_nullary_gadget(s, gadget_call);
+    tcg_out64(s, (uintptr_t)arg);
+}
+
+/**
+ * Generates LD instructions.
+ */
+static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,
+                       intptr_t arg2)
+{
+
+    if (type == TCG_TYPE_I32) {
+        tcg_out_ldst_gadget(s, gadget_ld32u, ret, arg1, arg2); 
+    } else {
+        tcg_out_ldst_gadget(s, gadget_ld_i64, ret, arg1, arg2); 
+    }
+}
+
+
+/**
+ * Generate every other operation.
+ */
+//static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args)
+void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args)
+{
+    switch (opc) {
+
+    // Exit translation, and return back to QEMU.
+    case INDEX_op_exit_tb:
+        // Emit a simple gadget with a known return code.
+        tcg_out_imm64_gadget(s, gadget_exit_tb, args[0]);
+        break;
+
+    // Jump to a translation block.
+    case INDEX_op_goto_tb:
+
+        // If we're using a direct jump, we'll emit a "relocation" that can be usd
+        // to patch our gadget stream with the target address, later.
+        if (s->tb_jmp_insn_offset) {
+            // Emit our gadget.
+            tcg_out_nullary_gadget(s, gadget_br);
+
+            // Place our current instruction into our "relocation table", so it can
+            // be patched once we know where the branch will target...
+            s->tb_jmp_insn_offset[args[0]] = tcg_current_code_size(s);
+
+            // ... and emit our relocation.
+            tcg_out64(s, args[0]);
+
+
+        } else {
+            /* Indirect jump method. */
+            TODO();
+        }
+        set_jmp_reset_offset(s, args[0]);
+        break;
+
+    // Simple branch.
+    case INDEX_op_br:
+        tcg_out_nullary_gadget(s, gadget_br);
+        tcti_out_label(s, arg_label(args[0]));
+        break;
+
+
+    // Set condition flag.
+    // a0 = Rd, a1 = Rn, a2 = Rm
+    case INDEX_op_setcond_i32:
+    {
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[3]) {
+            case TCG_COND_EQ:  gadget = gadget_setcond_i32_eq; break;
+            case TCG_COND_NE:  gadget = gadget_setcond_i32_ne; break;
+            case TCG_COND_LT:  gadget = gadget_setcond_i32_lt; break;
+            case TCG_COND_GE:  gadget = gadget_setcond_i32_ge; break;
+            case TCG_COND_LE:  gadget = gadget_setcond_i32_le; break;
+            case TCG_COND_GT:  gadget = gadget_setcond_i32_gt; break;
+            case TCG_COND_LTU: gadget = gadget_setcond_i32_lo; break;
+            case TCG_COND_GEU: gadget = gadget_setcond_i32_hs; break;
+            case TCG_COND_LEU: gadget = gadget_setcond_i32_ls; break;
+            case TCG_COND_GTU: gadget = gadget_setcond_i32_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        tcg_out_ternary_gadget(s, gadget, args[0], args[1], args[2]);
+        break;
+    }
+
+    case INDEX_op_setcond_i64:
+    {
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[3]) {
+            case TCG_COND_EQ:  gadget = gadget_setcond_i64_eq; break;
+            case TCG_COND_NE:  gadget = gadget_setcond_i64_ne; break;
+            case TCG_COND_LT:  gadget = gadget_setcond_i64_lt; break;
+            case TCG_COND_GE:  gadget = gadget_setcond_i64_ge; break;
+            case TCG_COND_LE:  gadget = gadget_setcond_i64_le; break;
+            case TCG_COND_GT:  gadget = gadget_setcond_i64_gt; break;
+            case TCG_COND_LTU: gadget = gadget_setcond_i64_lo; break;
+            case TCG_COND_GEU: gadget = gadget_setcond_i64_hs; break;
+            case TCG_COND_LEU: gadget = gadget_setcond_i64_ls; break;
+            case TCG_COND_GTU: gadget = gadget_setcond_i64_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        tcg_out_ternary_gadget(s, gadget, args[0], args[1], args[2]);
+        break;
+    }
+
+    /**
+     * Load instructions.
+     */
+
+    case INDEX_op_ld8u_i32:
+    case INDEX_op_ld8u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld8u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld8s_i32:
+        tcg_out_ldst_gadget(s, gadget_ld8s_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld8s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld8s_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16u_i32:
+    case INDEX_op_ld16u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld16u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16s_i32:
+        tcg_out_ldst_gadget(s, gadget_ld16s_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld16s_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld_i32:
+    case INDEX_op_ld32u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld32u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld_i64:
+        tcg_out_ldst_gadget(s, gadget_ld_i64, args[0], args[1], args[2]); 
+        break;
+    
+    case INDEX_op_ld32s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld32s_i64, args[0], args[1], args[2]); 
+        break;
+
+
+    /**
+     * Store instructions.
+     */
+    case INDEX_op_st8_i32:
+    case INDEX_op_st8_i64:
+        tcg_out_ldst_gadget(s, gadget_st8, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st16_i32:
+    case INDEX_op_st16_i64:
+        tcg_out_ldst_gadget(s, gadget_st16, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st_i32:
+    case INDEX_op_st32_i64:
+        tcg_out_ldst_gadget(s, gadget_st_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st_i64:
+        tcg_out_ldst_gadget(s, gadget_st_i64, args[0], args[1], args[2]); 
+        break;
+
+    /**
+     * Arithmetic instructions.
+     */
+
+    case INDEX_op_add_i32: 
+        tcg_out_ternary_gadget(s, gadget_add_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sub_i32:
+        tcg_out_ternary_gadget(s, gadget_sub_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_mul_i32:
+        tcg_out_ternary_gadget(s, gadget_mul_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_and_i32:
+        tcg_out_ternary_gadget(s, gadget_and_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_andc_i32:     /* Optional (TCG_TARGET_HAS_andc_i32). */
+        tcg_out_ternary_gadget(s, gadget_andc_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_orc_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_orc_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_eqv_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_eqv_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_or_i32:
+        tcg_out_ternary_gadget(s, gadget_or_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_xor_i32:
+        tcg_out_ternary_gadget(s, gadget_xor_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shl_i32:
+        tcg_out_ternary_gadget(s, gadget_shl_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shr_i32:
+        tcg_out_ternary_gadget(s, gadget_shr_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sar_i32:
+        tcg_out_ternary_gadget(s, gadget_sar_i32, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_rotr_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+    //    tcg_out_ternary_gadget(s, gadget_rotr_i32, args[0], args[1], args[2]); 
+    //    break;
+
+    //case INDEX_op_rotl_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+    //    tcg_out_ternary_gadget(s, gadget_rotl_i32, args[0], args[1], args[2]); 
+
+    case INDEX_op_add_i64:
+        tcg_out_ternary_gadget(s, gadget_add_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sub_i64:
+        tcg_out_ternary_gadget(s, gadget_sub_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_mul_i64:
+        tcg_out_ternary_gadget(s, gadget_mul_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_and_i64:
+        tcg_out_ternary_gadget(s, gadget_and_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_andc_i64:     /* Optional (TCG_TARGET_HAS_andc_i64). */
+        tcg_out_ternary_gadget(s, gadget_andc_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_orc_i64:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_orc_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_eqv_i64:      /* Optional (TCG_TARGET_HAS_eqv_i64). */
+        tcg_out_ternary_gadget(s, gadget_eqv_i64, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_nand_i64:     /* Optional (TCG_TARGET_HAS_nand_i64). */
+    //case INDEX_op_nor_i64:      /* Optional (TCG_TARGET_HAS_nor_i64). */
+
+    case INDEX_op_or_i64:
+        tcg_out_ternary_gadget(s, gadget_or_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_xor_i64:
+        tcg_out_ternary_gadget(s, gadget_xor_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shl_i64:
+        tcg_out_ternary_gadget(s, gadget_shl_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shr_i64:
+        tcg_out_ternary_gadget(s, gadget_shr_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sar_i64:
+        tcg_out_ternary_gadget(s, gadget_sar_i64, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_rotl_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+    //    tcg_out_ternary_gadget(s, gadget_rotl_i64, args[0], args[1], args[2]); 
+    //    break;
+
+    //case INDEX_op_rotr_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+    //    tcg_out_ternary_gadget(s, gadget_rotr_i64, args[0], args[1], args[2]); 
+    //    break;
+
+    case INDEX_op_div_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_div_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_divu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_divu_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_rem_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_rem_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_remu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_remu_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_brcond_i64:
+    {
+        static uint8_t last_brcond_i64 = 0;
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[2]) {
+            case TCG_COND_EQ:  gadget = gadget_brcond_i64_eq; break;
+            case TCG_COND_NE:  gadget = gadget_brcond_i64_ne; break;
+            case TCG_COND_LT:  gadget = gadget_brcond_i64_lt; break;
+            case TCG_COND_GE:  gadget = gadget_brcond_i64_ge; break;
+            case TCG_COND_LE:  gadget = gadget_brcond_i64_le; break;
+            case TCG_COND_GT:  gadget = gadget_brcond_i64_gt; break;
+            case TCG_COND_LTU: gadget = gadget_brcond_i64_lo; break;
+            case TCG_COND_GEU: gadget = gadget_brcond_i64_hs; break;
+            case TCG_COND_LEU: gadget = gadget_brcond_i64_ls; break;
+            case TCG_COND_GTU: gadget = gadget_brcond_i64_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        // We'll select the which branch to used based on a cycling counter.
+        // This means we'll pick one of 16 identical brconds. Spreading this out
+        // helps the processor's branch prediction be less "squished", as not every
+        // branch is going throuh the same instruction.
+        tcg_out_ternary_gadget(s, gadget, last_brcond_i64, args[0], args[1]);
+        last_brcond_i64 = (last_brcond_i64 + 1) % TCG_TARGET_NB_REGS;
+
+        // Branch target immediate.
+        tcti_out_label(s, arg_label(args[3]));
+        break;
+    }
+
+
+    case INDEX_op_bswap16_i32:  /* Optional (TCG_TARGET_HAS_bswap16_i32). */
+    case INDEX_op_bswap16_i64:  /* Optional (TCG_TARGET_HAS_bswap16_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap16, args[0], args[1]);
+        break;
+
+    case INDEX_op_bswap32_i32:  /* Optional (TCG_TARGET_HAS_bswap32_i32). */
+    case INDEX_op_bswap32_i64:  /* Optional (TCG_TARGET_HAS_bswap32_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap32, args[0], args[1]);
+        break;
+
+    case INDEX_op_bswap64_i64:  /* Optional (TCG_TARGET_HAS_bswap64_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap64, args[0], args[1]);
+        break;
+
+    case INDEX_op_not_i64:      /* Optional (TCG_TARGET_HAS_not_i64). */
+        tcg_out_binary_gadget(s, gadget_not_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_neg_i64:      /* Optional (TCG_TARGET_HAS_neg_i64). */
+        tcg_out_binary_gadget(s, gadget_neg_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8s_i64:    /* Optional (TCG_TARGET_HAS_ext8s_i64). */
+        tcg_out_binary_gadget(s, gadget_ext8s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8u_i32:    /* Optional (TCG_TARGET_HAS_ext8u_i32). */
+    case INDEX_op_ext8u_i64:    /* Optional (TCG_TARGET_HAS_ext8u_i64). */
+        tcg_out_binary_gadget(s, gadget_ext8u, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16s_i64:   /* Optional (TCG_TARGET_HAS_ext16s_i64). */
+        tcg_out_binary_gadget(s, gadget_ext16s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16u_i32:   /* Optional (TCG_TARGET_HAS_ext16u_i32). */
+    case INDEX_op_ext16u_i64:   /* Optional (TCG_TARGET_HAS_ext16u_i64). */
+        tcg_out_binary_gadget(s, gadget_ext16u, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext32s_i64:   /* Optional (TCG_TARGET_HAS_ext32s_i64). */
+    case INDEX_op_ext_i32_i64:
+        tcg_out_binary_gadget(s, gadget_ext32s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext32u_i64:   /* Optional (TCG_TARGET_HAS_ext32u_i64). */
+    case INDEX_op_extu_i32_i64:
+        tcg_out_binary_gadget(s, gadget_ext32u_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_neg_i32:      /* Optional (TCG_TARGET_HAS_neg_i32). */
+        tcg_out_binary_gadget(s, gadget_neg_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_not_i32:      /* Optional (TCG_TARGET_HAS_not_i32). */
+        tcg_out_binary_gadget(s, gadget_not_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8s_i32:    /* Optional (TCG_TARGET_HAS_ext8s_i32). */
+        tcg_out_binary_gadget(s, gadget_ext8s_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16s_i32:   /* Optional (TCG_TARGET_HAS_ext16s_i32). */
+        tcg_out_binary_gadget(s, gadget_ext16s_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_div_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_div_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_divu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_divu_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_rem_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_rem_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_remu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_remu_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_brcond_i32:
+    {
+        static uint8_t last_brcond_i32 = 0;
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[2]) {
+            case TCG_COND_EQ:  gadget = gadget_brcond_i32_eq; break;
+            case TCG_COND_NE:  gadget = gadget_brcond_i32_ne; break;
+            case TCG_COND_LT:  gadget = gadget_brcond_i32_lt; break;
+            case TCG_COND_GE:  gadget = gadget_brcond_i32_ge; break;
+            case TCG_COND_LE:  gadget = gadget_brcond_i32_le; break;
+            case TCG_COND_GT:  gadget = gadget_brcond_i32_gt; break;
+            case TCG_COND_LTU: gadget = gadget_brcond_i32_lo; break;
+            case TCG_COND_GEU: gadget = gadget_brcond_i32_hs; break;
+            case TCG_COND_LEU: gadget = gadget_brcond_i32_ls; break;
+            case TCG_COND_GTU: gadget = gadget_brcond_i32_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        // We'll select the which branch to used based on a cycling counter.
+        // This means we'll pick one of 16 identical brconds. Spreading this out
+        // helps the processor's branch prediction be less "squished", as not every
+        // branch is going throuh the same instruction.
+        tcg_out_ternary_gadget(s, gadget, last_brcond_i32, args[0], args[1]);
+        last_brcond_i32 = (last_brcond_i32 + 1) % TCG_TARGET_NB_REGS;
+
+        // Branch target immediate.
+        tcti_out_label(s, arg_label(args[3]));
+
+        break;
+    }
+
+    case INDEX_op_qemu_ld_i32:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
+            case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
+            case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
+            default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+        }
+
+        // Args:
+        // - an immediate32 encodes our operation index 
+        tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
+        break;
+    }
+
+    case INDEX_op_qemu_ld_i64:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        // Special optimization case: if we have an operation/target of 0x3A, 
+        // this is a common case. Delegate to our special-case handler.
+        if (args[2] == 0x3a) {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+
+                case -64: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off64_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off64_i64;
+                    break;
+                case -96: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off96_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off96_i64;
+                    break;
+                case -128: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off128_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off128_i64;
+                    break;
+
+                default: 
+                    gadget = gadget_qemu_ld_leq_slowpath_mode3a_off0_i64;
+                    break;
+            }
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } 
+        // Otherwise, handle the generic case.
+        else {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
+                case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
+                case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
+                default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+            }
+            // Args:
+            // - an immediate32 encodes our operation index 
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+            tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
+        }
+
+        break;
+    }
+
+    case INDEX_op_qemu_st_i32:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
+            case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
+            case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
+            default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+        }
+
+        // Args:
+        // - our gadget encodes the target and address registers
+        // - an immediate32 encodes our operation index 
+        tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        tcg_out64(s, args[2]); // FIXME: double encoded
+        break;
+    }
+
+    case INDEX_op_qemu_st_i64:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        // Special optimization case: if we have an operation/target of 0x3A, 
+        // this is a common case. Delegate to our special-case handler.
+        if (args[2] == 0x3a) {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+
+                case -64: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off64_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off64_i64;
+                    break;
+                case -96: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off96_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off96_i64;
+                    break;
+                case -128: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off128_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off128_i64;
+                    break;
+
+                default: 
+                    gadget = gadget_qemu_st_leq_slowpath_mode3a_off0_i64;
+                    break;
+            }
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } 
+        // Otherwise, handle the generic case.
+        else {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
+                case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
+                case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
+                default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+            }
+
+            // Args:
+            // - our gadget encodes the target and address registers
+            // - an immediate32 encodes our operation index 
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+            tcg_out64(s, args[2]); // FIXME: double encoded
+        }
+
+        break;
+    }
+
+    // Memory barriers.
+    case INDEX_op_mb:
+    {
+        static void* sync[] = {
+            [0 ... TCG_MO_ALL]            = gadget_mb_all,
+            [TCG_MO_ST_ST]                = gadget_mb_st,
+            [TCG_MO_LD_LD]                = gadget_mb_ld,
+            [TCG_MO_LD_ST]                = gadget_mb_ld,
+            [TCG_MO_LD_ST | TCG_MO_LD_LD] = gadget_mb_ld,
+        };
+        tcg_out_nullary_gadget(s, sync[args[0] & TCG_MO_ALL]);
+
+        break;
+    }
+
+    case INDEX_op_mov_i32:  /* Always emitted via tcg_out_mov.  */
+    case INDEX_op_mov_i64:
+    case INDEX_op_call:     /* Always emitted via tcg_out_call.  */
+    default:
+        tcg_abort();
+    }
+}
+
+/**
+ * Generate immediate stores.
+ */
+static void tcg_out_st(TCGContext *s, TCGType type, TCGReg arg, TCGReg arg1,
+                       intptr_t arg2)
+{
+    if (type == TCG_TYPE_I32) {
+        tcg_out_ldst_gadget(s, gadget_st_i32, arg, arg1, arg2); 
+    } else {
+        tcg_out_ldst_gadget(s, gadget_st_i64, arg, arg1, arg2); 
+    }
+}
+
+static inline bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
+                               TCGReg base, intptr_t ofs)
+{
+    return false;
+}
+
+/* Test if a constant matches the constraint. */
+static int tcg_target_const_match(tcg_target_long val, TCGType type,
+                                  const TCGArgConstraint *arg_ct)
+{
+    /* No need to return 0 or 1, 0 or != 0 is good enough. */
+    return arg_ct->ct & TCG_CT_CONST;
+}
+
+static void tcg_target_init(TCGContext *s)
+{
+    /* The current code uses uint8_t for tcg operations. */
+    tcg_debug_assert(tcg_op_defs_max <= UINT8_MAX);
+
+    /* Registers available for 32 bit operations. */
+    tcg_target_available_regs[TCG_TYPE_I32] = BIT(TCG_TARGET_NB_REGS) - 1;
+    /* Registers available for 64 bit operations. */
+    tcg_target_available_regs[TCG_TYPE_I64] = BIT(TCG_TARGET_NB_REGS) - 1;
+
+    /* TODO: Which registers should be set here? */
+    tcg_target_call_clobber_regs = BIT(TCG_TARGET_NB_REGS) - 1;
+
+    s->reserved_regs = 0;
+    tcg_regset_set_reg(s->reserved_regs, TCG_REG_CALL_STACK);
+
+    /* We use negative offsets from "sp" so that we can distinguish
+       stores that might pretend to be call arguments.  */
+    tcg_set_frame(s, TCG_REG_CALL_STACK, -CPU_TEMP_BUF_NLONGS * sizeof(long), CPU_TEMP_BUF_NLONGS * sizeof(long));
+}
+
+/* Generate global QEMU prologue and epilogue code. */
+static inline void tcg_target_qemu_prologue(TCGContext *s)
+{
+    // No prologue; as we're interpreted.
+}
+
+
+/**
+ * TCTI 'interpreter' bootstrap.
+ */
+
+// Store the current return address during helper calls.
+__thread uintptr_t tcti_call_return_address;
+
+/* Dispatch the bytecode stream contained in our translation buffer. */
+uintptr_t QEMU_DISABLE_CFI tcg_qemu_tb_exec(CPUArchState *env, const void *v_tb_ptr)
+{
+    // Create our per-CPU temporary storage.
+    long tcg_temps[CPU_TEMP_BUF_NLONGS];
+
+    uint64_t return_value = 0;
+    uintptr_t sp_value    = (uintptr_t)(tcg_temps + CPU_TEMP_BUF_NLONGS);
+    uintptr_t pc_mirror   = (uintptr_t)&tcti_call_return_address;
+
+    // Ensure our target configuration hasn't changed.
+    tcti_assert(TCG_AREG0 == TCG_REG_R14);
+    tcti_assert(TCG_REG_CALL_STACK == TCG_REG_R15);
+
+    asm(
+        // Our threaded-dispatch prologue needs to set up things for our machine to run.
+        // This means:
+        //   - Set up TCG_AREG0 (R14) to point to our architectural state.
+        //   - Set up TCG_REG_CALL_STACK (R15) to point to our temporary buffer.
+        //   - Point x28 (our bytecode "instruction pointer") to the relevant stream address.
+        "ldr x14, %[areg0]\n"
+        "ldr x15, %[sp_value]\n"
+        "ldr x25, %[pc_mirror]\n"
+        "ldr x28, %[start_tb_ptr]\n"
+
+        // To start our code, we'll -call- the gadget at the first bytecode pointer.
+        // Note that we call/branch-with-link, here; so our TB_EXIT gadget can RET in order
+        // to return to this point when things are complete.
+        "ldr x27, [x28], #8\n"
+        "blr x27\n"
+
+        // Finally, we'll copy out our final return value.
+        "str x0, %[return_value]\n"
+
+        : [return_value] "=m" (return_value)
+
+        : [areg0]        "m"  (env), 
+          [sp_value]     "m"  (sp_value), 
+          [start_tb_ptr] "m"  (v_tb_ptr),
+          [pc_mirror]    "m"  (pc_mirror)
+
+        // We touch _every_ one of the lower registers, as we use these to execute directly.
+        : "x0", "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7",
+          "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
+
+        // We also use x26/x27 for temporary values, and x28 as our bytecode poitner.
+        "x25", "x26", "x27", "x28", "cc", "memory"
+    );
+
+    return return_value;
+}
+
+
+/**
+ *  Disassembly output support.
+ */
+#include <dlfcn.h>
+
+
+/* Disassemble TCI bytecode. */
+int print_insn_tcti(bfd_vma addr, disassemble_info *info)
+{
+    Dl_info symbol_info = {};
+    char symbol_name[48] ;
+
+    int status;
+    uint64_t block;
+
+    // Read the relevant pointer.
+    status = info->read_memory_func(addr, (void *)&block, sizeof(block), info);
+    if (status != 0) {
+        info->memory_error_func(status, addr, info);
+        return -1;
+    }
+
+    // Most of our disassembly stream will be gadgets. Try to get their names, for nice output.
+    dladdr((void *)block, &symbol_info);
+
+    if(symbol_info.dli_sname != 0) {
+        strlcpy(symbol_name, symbol_info.dli_sname, 47);
+        info->fprintf_func(info->stream, "%s", symbol_name);
+    } else {
+        info->fprintf_func(info->stream, "%016llx", block);
+    }
+
+    return sizeof(block);
+}
+
+
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
new file mode 100644
index 000000000000..fa2ae5c40a3e
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -0,0 +1,220 @@
+/*
+ * Tiny Code Generator for QEMU
+ *
+ * Copyright (c) 2009, 2011 Stefan Weil
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/*
+ * This code implements a TCG which does not generate machine code for some
+ * real target machine but which generates virtual machine code for an
+ * interpreter. Interpreted pseudo code is slow, but it works on any host.
+ *
+ * Some remarks might help in understanding the code:
+ *
+ * "target" or "TCG target" is the machine which runs the generated code.
+ * This is different to the usual meaning in QEMU where "target" is the
+ * emulated machine. So normally QEMU host is identical to TCG target.
+ * Here the TCG target is a virtual machine, but this virtual machine must
+ * use the same word size like the real machine.
+ * Therefore, we need both 32 and 64 bit virtual machines (interpreter).
+ */
+
+#ifndef TCG_TARGET_H
+#define TCG_TARGET_H
+
+#if UINTPTR_MAX == UINT32_MAX
+# error We only support AArch64 running in 64B mode.
+#elif UINTPTR_MAX == UINT64_MAX
+# define TCG_TARGET_REG_BITS 64
+#else
+# error Unknown pointer size for tcti target
+#endif
+
+#define TCG_TARGET_INSN_UNIT_SIZE        1
+#define TCG_TARGET_TLB_DISPLACEMENT_BITS 32
+
+// We're an interpreted target; even if we're JIT-compiling to our interpreter's
+// weird psuedo-native bytecode. We'll indicate that we're intepreted.
+#define TCG_TARGET_INTERPRETER 1
+
+//
+// Supported optional instructions.
+//
+
+// Divs.
+#define TCG_TARGET_HAS_div_i32          1
+#define TCG_TARGET_HAS_rem_i32          1
+#define TCG_TARGET_HAS_div_i64          1
+#define TCG_TARGET_HAS_rem_i64          1
+
+// Extends.
+#define TCG_TARGET_HAS_ext8s_i32        1
+#define TCG_TARGET_HAS_ext16s_i32       1
+#define TCG_TARGET_HAS_ext8u_i32        1
+#define TCG_TARGET_HAS_ext16u_i32       1
+#define TCG_TARGET_HAS_ext8s_i64        1
+#define TCG_TARGET_HAS_ext16s_i64       1
+#define TCG_TARGET_HAS_ext32s_i64       1
+#define TCG_TARGET_HAS_ext8u_i64        1
+#define TCG_TARGET_HAS_ext16u_i64       1
+#define TCG_TARGET_HAS_ext32u_i64       1
+
+// Logicals.
+#define TCG_TARGET_HAS_neg_i32          1
+#define TCG_TARGET_HAS_not_i32          1
+#define TCG_TARGET_HAS_neg_i64          1
+#define TCG_TARGET_HAS_not_i64          1
+
+#define TCG_TARGET_HAS_andc_i32         1
+#define TCG_TARGET_HAS_orc_i32          1
+#define TCG_TARGET_HAS_eqv_i32          1
+#define TCG_TARGET_HAS_andc_i64         1
+#define TCG_TARGET_HAS_eqv_i64          1
+#define TCG_TARGET_HAS_orc_i64          1
+
+// We don't curretly support rotates, since AArch64 lacks ROL.
+// We'll fix this later.
+#define TCG_TARGET_HAS_rot_i32          0
+#define TCG_TARGET_HAS_rot_i64          0
+
+// Swaps.
+#define TCG_TARGET_HAS_bswap16_i32      1
+#define TCG_TARGET_HAS_bswap32_i32      1
+#define TCG_TARGET_HAS_bswap16_i64      1
+#define TCG_TARGET_HAS_bswap32_i64      1
+#define TCG_TARGET_HAS_bswap64_i64      1
+#define TCG_TARGET_HAS_MEMORY_BSWAP     1
+
+// Specify we'll handle direct jumps.
+#define TCG_TARGET_HAS_direct_jump      1
+
+//
+// Potential TODOs.
+//
+
+// TODO: implement DEPOSIT as BFI.
+#define TCG_TARGET_HAS_deposit_i32      0
+#define TCG_TARGET_HAS_deposit_i64      0
+
+// TODO: implement EXTRACT as BFX.
+#define TCG_TARGET_HAS_extract_i32      0
+#define TCG_TARGET_HAS_sextract_i32     0
+#define TCG_TARGET_HAS_extract_i64      0
+#define TCG_TARGET_HAS_sextract_i64     0
+
+// TODO: it might be worth writing a gadget for this
+#define TCG_TARGET_HAS_movcond_i32      0
+#define TCG_TARGET_HAS_movcond_i64      0
+
+//
+// Unsupported instructions.
+//
+
+// ARMv8 doesn't have instructions for NAND/NOR.
+#define TCG_TARGET_HAS_nand_i32         0
+#define TCG_TARGET_HAS_nor_i32          0
+#define TCG_TARGET_HAS_nor_i64          0
+#define TCG_TARGET_HAS_nand_i64         0
+
+// aarch64's CLZ is implemented without a condition, so it
+#define TCG_TARGET_HAS_clz_i32          0
+#define TCG_TARGET_HAS_ctz_i32          0
+#define TCG_TARGET_HAS_ctpop_i32        0
+#define TCG_TARGET_HAS_clz_i64          0
+#define TCG_TARGET_HAS_ctz_i64          0
+#define TCG_TARGET_HAS_ctpop_i64        0
+
+
+// GOTO_PTR is too complex to emit a simple gadget for.
+// We'll let C handle it, since the overhead is similar.
+#define TCG_TARGET_HAS_goto_ptr         0
+
+// We don't have a simple gadget for this, since we're always assuming softmmu.
+#define TCG_TARGET_HAS_qemu_st8_i32     0
+
+// No AArch64 equivalent.a
+#define TCG_TARGET_HAS_extrl_i64_i32    0
+#define TCG_TARGET_HAS_extrh_i64_i32    0
+
+#define TCG_TARGET_HAS_extract2_i64     0
+
+// These should always be zero on our 64B platform.
+#define TCG_TARGET_HAS_muls2_i64        0
+#define TCG_TARGET_HAS_add2_i32         0
+#define TCG_TARGET_HAS_sub2_i32         0
+#define TCG_TARGET_HAS_mulu2_i32        0
+#define TCG_TARGET_HAS_add2_i64         0
+#define TCG_TARGET_HAS_sub2_i64         0
+#define TCG_TARGET_HAS_mulu2_i64        0
+#define TCG_TARGET_HAS_muluh_i64        0
+#define TCG_TARGET_HAS_mulsh_i64        0
+#define TCG_TARGET_HAS_extract2_i32     0
+#define TCG_TARGET_HAS_muls2_i32        0
+#define TCG_TARGET_HAS_muluh_i32        0
+#define TCG_TARGET_HAS_mulsh_i32        0
+
+//
+// Platform metadata.
+//
+
+// Number of registers available.
+// It might make sense to up these, since we can also use x16 -> x25?
+#define TCG_TARGET_NB_REGS 16
+
+/* List of registers which are used by TCG. */
+typedef enum {
+    TCG_REG_R0 = 0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+    TCG_REG_R6,
+    TCG_REG_R7,
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
+    TCG_REG_R14,
+    TCG_REG_R15,
+
+    TCG_AREG0          = TCG_REG_R14,
+    TCG_REG_CALL_STACK = TCG_REG_R15,
+} TCGReg;
+
+// Specify the shape of the stack our runtime will use.
+#define TCG_TARGET_CALL_STACK_OFFSET    0
+#define TCG_TARGET_STACK_ALIGN          16
+
+// We're interpreted, so we'll use our own code to run TB_EXEC.
+#define HAVE_TCG_QEMU_TB_EXEC
+
+// We'll need to enforce memory ordering with barriers.
+#define TCG_TARGET_DEFAULT_MO  (0)
+
+void tci_disas(uint8_t opc);
+
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+
+
+#endif /* TCG_TARGET_H */
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
new file mode 100755
index 000000000000..1296f6d0c2d7
--- /dev/null
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -0,0 +1,788 @@
+#!/usr/bin/env python3
+""" Gadget-code generator for QEMU TCTI on AArch64. 
+
+Generates a C-code include file containing 'gadgets' for use by TCTI.
+"""
+
+import sys
+import itertools
+
+# Get a handle on the file we'll be working with, and redirect print to it.
+if len(sys.argv) > 1:
+    out_file = open(sys.argv[1], "w")
+
+    # Hook our print function, so it always outputs to the relevant file.
+    core_print = print
+    print = lambda *a, **k : core_print(*a, **k, file=out_file)
+
+# Epilogue code follows at the end of each gadget, and handles continuing execution.
+EPILOGUE = ( 
+    # Load our next gadget address from our bytecode stream, advancing it.
+    "ldr x27, [x28], #8",
+
+    # Jump to the next gadget.
+    "br x27"
+)
+
+# The number of general-purpose registers we're affording the TCG. This must match
+# the configuration in the TCTI target.
+TCG_REGISTER_COUNT   = 16
+TCG_REGISTER_NUMBERS = list(range(TCG_REGISTER_COUNT))
+
+# Helper that provides each of the AArch64 condition codes of interest.
+ARCH_CONDITION_CODES = ["eq", "ne", "lt", "ge", "le", "gt", "lo", "hs", "ls", "hi"]
+
+# We'll create a variety of gadgets that assume the MMU's TLB is stored at certain
+# offsets into its structure. These should match the offsets in tcg-target.c.in.
+QEMU_ALLOWED_MMU_OFFSETS = [ 64, 96, 128 ]
+
+# Statistics.
+gadgets      = 0
+instructions = 0
+
+def simple(name, *lines):
+    """ Generates a simple gadget that needs no per-register specialization. """
+
+    global gadgets, instructions
+
+    gadgets += 1
+
+    # Create our C/ASM framing.
+    #print(f"__attribute__((naked)) static void gadget_{name}(void)")
+    print(f"__attribute__((naked)) void gadget_{name}(void);")
+    print(f"__attribute__((naked)) void gadget_{name}(void)")
+    print("{")
+
+    # Add the core gadget
+    print("\tasm(")
+    for line in lines + EPILOGUE:
+        print(f"\t\t\"{line} \\n\"")
+        instructions += 1
+    print("\t);")
+
+    # End our framing.
+    print("}\n")
+
+
+def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
+    """ Generates a collection of gadgtes with register substitutions. """
+
+    def substitutions_for_letter(letter, number, line):
+        """ Helper that transforms Wd => w1, implementing gadget substitutions. """
+
+        # Register substitutions...
+        line = line.replace(f"X{letter}", f"x{number}")
+        line = line.replace(f"W{letter}", f"w{number}")
+
+        # ... immediate substitutions.
+        line = line.replace(f"I{letter}", f"{number}")
+        return line
+
+        
+    # Build a list of all the various stages we'll iterate over...
+    immediate_parameters = list(immediate_range)
+    parameters   = ([TCG_REGISTER_NUMBERS] * len(substitutions))
+
+    # ... adding immediates, if need be.
+    if immediate_parameters:
+        parameters.append(immediate_parameters)
+        substitutions = substitutions + ['i']
+
+    # Generate a list of register-combinations we'll support.
+    permutations = itertools.product(*parameters)
+
+    #  For each permutation...
+    for permutation in permutations:
+        new_lines = lines
+
+        # Replace each placeholder element with its proper value...
+        for index, element in enumerate(permutation):
+            letter = substitutions[index]
+            number = element
+
+            # Create new gadgets for the releavnt line...
+            new_lines = [substitutions_for_letter(letter, number, line) for line in new_lines]
+
+        # ... and emit the gadget.
+        permutation_id = "_arg".join(str(number) for number in permutation)
+        simple(f"{name}_arg{permutation_id}", *new_lines)
+
+
+def with_dnm(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
+    with_register_substitutions(name, ("d", "n", "m"), *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    # D array
+    for d in TCG_REGISTER_NUMBERS:
+        print("\t{")
+
+        # N array
+        for n in TCG_REGISTER_NUMBERS:
+            print("\t\t{", end="")
+
+            # M array
+            for m in TCG_REGISTER_NUMBERS:
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{m}", end=", ")
+
+            print("},")
+        print("\t},")
+    print("};")
+
+
+def with_dn_immediate(name, *lines, immediate_range):
+    """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
+    with_register_substitutions(name, ["d", "n"], *lines, immediate_range=immediate_range)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print("{")
+
+    # D array
+    for d in TCG_REGISTER_NUMBERS:
+        print("\t{")
+
+        # N array
+        for n in TCG_REGISTER_NUMBERS:
+            print("\t\t{", end="")
+
+            # M array
+            for i in immediate_range:
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{i}", end=", ")
+
+            print("},")
+        print("\t},")
+    print("};")
+
+
+def with_pair(name, substitutions, *lines):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, substitutions, *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    # N array
+    for a in TCG_REGISTER_NUMBERS:
+        print("\t\t{", end="")
+
+        # M array
+        for b in TCG_REGISTER_NUMBERS:
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+
+        print("},")
+    print("};")
+
+
+def math_dnm(name, mnemonic):
+    """ Equivalent to `with_dnm`, but creates a _i32 and _i64 variant. For simple math. """
+    with_dnm(f'{name}_i32', f"{mnemonic} Wd, Wn, Wm")
+    with_dnm(f'{name}_i64', f"{mnemonic} Xd, Xn, Xm")
+
+def math_dn(name, mnemonic):
+    """ Equivalent to `with_dn`, but creates a _i32 and _i64 variant. For simple math. """
+    with_dn(f'{name}_i32', f"{mnemonic} Wd, Wn")
+    with_dn(f'{name}_i64', f"{mnemonic} Xd, Xn")
+
+
+def with_nm(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xn, and Xm, and equivalents. """
+    with_pair(name, ('n', 'm',), *lines)
+
+
+def with_dn(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, and Xn, and equivalents. """
+    with_pair(name, ('d', 'n',), *lines)
+
+
+def ldst_dn(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, and Xn, and equivalents. 
+    
+    This variant is optimized for loads and stores, and optimizes common offset cases.
+    """
+
+    #
+    # Simple case: create our gadgets.
+    #
+    with_dn(name, "ldr x27, [x28], #8", *lines)
+
+    #
+    # Optimization case: create variants of our gadgets with our offsets replaced with common immediates.
+    #
+    immediate_lines_pos = [line.replace("x27", "#Ii") for line in lines]
+    with_dn_immediate(f"{name}_imm", *immediate_lines_pos, immediate_range=range(64))
+
+    immediate_lines_aligned = [line.replace("x27", "#(Ii << 3)") for line in lines]
+    with_dn_immediate(f"{name}_sh8_imm", *immediate_lines_aligned, immediate_range=range(64))
+
+    immediate_lines_neg = [line.replace("x27", "#-Ii") for line in lines]
+    with_dn_immediate(f"{name}_neg_imm", *immediate_lines_neg, immediate_range=range(64))
+
+
+def with_single(name, substitution, *lines):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, (substitution,), *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    for n in TCG_REGISTER_NUMBERS:
+        print(f"gadget_{name}_arg{n}", end=", ")
+
+    print("};")
+
+
+def with_d_immediate(name, *lines, immediate_range=range(0)):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, ['d'], *lines, immediate_range=immediate_range)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print("{")
+
+    # D array
+    for a in TCG_REGISTER_NUMBERS:
+        print("\t\t{", end="")
+
+        # I array
+        for b in immediate_range:
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+
+        print("},")
+    print("};")
+
+
+
+def with_d(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd. """
+    with_single(name, 'd', *lines)
+
+
+# Assembly code for saving our machine state before entering the C runtime.
+C_CALL_PROLOGUE = [
+    # Store our machine state.
+    "str x25,      [sp, #-16]!",
+    "stp x14, x15, [sp, #-16]!",
+    "stp x12, x13, [sp, #-16]!",
+    "stp x10, x11, [sp, #-16]!",
+    "stp x8,  x9,  [sp, #-16]!",
+    "stp x6,  x7,  [sp, #-16]!",
+    "stp x4,  x5,  [sp, #-16]!",
+    "stp x2,  x3,  [sp, #-16]!",
+    "stp x0,  x1,  [sp, #-16]!",
+    "stp x28, lr,  [sp, #-16]!",
+]
+
+# Assembly code for restoring our machine state after leaving the C runtime.
+C_CALL_EPILOGUE = [
+    "ldp x28, lr, [sp], #16",
+    "ldp x0,  x1, [sp], #16",
+    "ldp x2,  x3, [sp], #16",
+    "ldp x4,  x5, [sp], #16",
+    "ldp x6,  x7, [sp], #16",
+    "ldp x8,  x9, [sp], #16",
+    "ldp x10, x11, [sp], #16",
+    "ldp x12, x13, [sp], #16",
+    "ldp x14, x15, [sp], #16",
+    "ldr x25,      [sp], #16",
+]
+
+
+def create_tlb_fastpath(is_aligned, is_write, offset, miss_label="0"):
+    """ Creates a set of instructions that perform a soft-MMU TLB lookup.
+
+    This is used for `qemu_ld`/qemu_st` instructions; to emit a prologue that
+    hopefully helps us skip a slow call into the C runtime when a Guest Virtual 
+    -> Host Virtual mapping is in the softmmu's TLB.
+
+    This "fast-path" prelude behaves as follows:
+        - If a TLB entry is found for the address stored in Xn, then x27
+          is stored to an "addend" that can be added to the guest virtual addres
+          to get the host virtual address (the address in our local memory space).
+        - If a TLB entry isn't found, it branches to the "miss_label" (by default, 0:),
+          so address lookup can be handled by the fastpath.
+
+    Clobbers x24, and x26; provides output in x27.
+    """
+
+    fast_path = [
+        # Load env_tlb(env)->f[mmu_idx].{mask,table} into {x26,x27}.
+        f"ldp x26, x27, [x14, #-{offset}]",
+
+        # Extract the TLB index from the address into X26. 
+        "and x26, x26, Xn, lsr #7", # Xn = addr regsiter 
+
+        # Add the tlb_table pointer, creating the CPUTLBEntry address into X27. 
+        "add x27, x27, x26",
+
+        # Load the tlb comparator into X26, and the fast path addend into X27. 
+        "ldr x26, [x27, #8]" if is_write else "ldr x26, [x27]",
+        "ldr x27, [x27, #0x18]",
+
+    ]
+
+    if is_aligned:
+        fast_path.extend([
+            # Store the page mask part of the address into X24.
+            "and x24, Xn, #0xfffffffffffff000",
+
+            # Compare the masked address with the TLB value.
+            "cmp x26, x24",
+
+            # If we're not equal, this isn't a TLB hit. Jump to our miss handler.
+            f"b.ne {miss_label}f",
+        ])
+    else:
+        fast_path.extend([
+            # If we're not aligned, add in our alignment value to ensure we don't
+            # don't straddle the end of a page.
+            "add x24, Xn, #7",
+
+            # Store the page mask part of the address into X24.
+            "and x24, x24, #0xfffffffffffff000",
+
+            # Compare the masked address with the TLB value.
+            "cmp x26, x24",
+
+            # If we're not equal, this isn't a TLB hit. Jump to our miss handler.
+            f"b.ne {miss_label}f",
+        ])
+
+    return fast_path
+
+
+
+def ld_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None, is_aligned=False, force_slowpath=False):
+    """ Creates a thunk into our C runtime for a QEMU ST operation. """
+
+    # Use only offset 0 (no real offset) if we're forcing slowpath; 
+    # otherwise, use all of our allowed MMU offsets.
+    offsets = [0] if force_slowpath else QEMU_ALLOWED_MMU_OFFSETS
+    for offset in offsets:
+        for is_32b in (True, False):
+            fastpath = fastpath_32b if is_32b else fastpath_64b
+
+            gadget_name = f"{name}_off{offset}_i32" if is_32b else f"{name}_off{offset}_i64"
+            postscript = () if immediate else ("add x28, x28, #8",)
+
+            # If we have a pure-assembly fast path, start our gadget with it.
+            if fastpath and not force_slowpath:
+                fastpath_ops = [
+                    # Create a fastpath that jumps to miss_lable on a TLB miss,
+                    # or sets x27 to the TLB addend on a TLB hit.
+                    *create_tlb_fastpath(is_aligned=is_aligned, is_write=False, offset=offset),
+
+                    # On a hit, we can just perform an appropriate load...
+                    *fastpath,
+
+                    # Run our patch-up post-script, if we have one.
+                    *postscript,
+
+                    # ... and then we're done!
+                    *EPILOGUE,
+                ]
+            # Otherwise, we'll save arguments for our slow path.
+            else:
+                fastpath_ops = []
+
+            #
+            # If we're not taking our fast path, we'll call into our C runtime to take the slow path.
+            # 
+            with_dn(gadget_name, 
+                    *fastpath_ops,
+
+                "0:",
+                    "mov x27, Xn",
+
+                    # Save our registers in preparation for entering a C call.
+                    *C_CALL_PROLOGUE,
+
+                    # Per our calling convention:
+                    # - Move our architectural environment into x0, from x14.
+                    # - Move our target address into x1. [Placed in x27 below.]
+                    # - Move our operation info into x2, from an immediate32.
+                    # - Move the next bytecode pointer into x3, from x28.
+                    "mov   x0, x14",
+                    "mov   x1, x27",
+                    f"mov   x2, #{immediate}" if (immediate is not None) else "ldr   x2, [x28], #8", 
+                    "mov   x3, x28",
+
+                    # Perform our actual core code.
+                    f"bl _{slowpath_helper}",
+
+                    # Temporarily store our result in a register that won't get trashed.
+                    "mov x27, x0",
+
+                    # Restore our registers after our C call.
+                    *C_CALL_EPILOGUE,
+
+                    # Finally, call our postscript...
+                    *postscript,
+
+                    # ... and place our results in the target register.
+                    "mov Wd, w27" if is_32b else "mov Xd, x27"
+            )
+
+
+def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None, is_aligned=False, force_slowpath=False):
+    """ Creates a thunk into our C runtime for a QEMU ST operation. """
+
+    # Use only offset 0 (no real offset) if we're forcing slowpath; 
+    # otherwise, use all of our allowed MMU offsets.
+    offsets = [0] if force_slowpath else QEMU_ALLOWED_MMU_OFFSETS
+    for offset in offsets:
+
+        for is_32b in (True, False):
+            fastpath = fastpath_32b if is_32b else fastpath_64b
+
+            gadget_name = f"{name}_off{offset}_i32" if is_32b else f"{name}_off{offset}_i64"
+            postscript = () if immediate else ("add x28, x28, #8",)
+
+            # If we have a pure-assembly fast path, start our gadget with it.
+            if fastpath and not force_slowpath:
+                fastpath_ops = [
+
+                    # Create a fastpath that jumps to miss_lable on a TLB miss,
+                    # or sets x27 to the TLB addend on a TLB hit.
+                    *create_tlb_fastpath(is_aligned=is_aligned, is_write=True, offset=offset),
+
+                    # On a hit, we can just perform an appropriate load...
+                    *fastpath,
+
+                    # Run our patch-up post-script, if we have one.
+                    *postscript,
+
+                    # ... and then we're done!
+                    *EPILOGUE,
+                ]
+            else:
+                fastpath_ops = []
+
+
+            #
+            # If we're not taking our fast path, we'll call into our C runtime to take the slow path.
+            # 
+            with_dn(gadget_name, 
+                    *fastpath_ops,
+
+                "0:",
+                    # Move our arguments into registers that we're not actively using.
+                    # This ensures that they won't be trounced by our calling convention
+                    # if this is reading values from x0-x4.
+                    "mov w27, Wd" if is_32b else "mov x27, Xd",
+                    "mov x26, Xn",
+
+                    # Save our registers in preparation for entering a C call.
+                    *C_CALL_PROLOGUE,
+
+                    # Per our calling convention:
+                    # - Move our architectural environment into x0, from x14.
+                    # - Move our target address into x1. [Moved into x26 above].
+                    # - Move our target value into x2. [Moved into x27 above].
+                    # - Move our operation info into x3, from an immediate32.
+                    # - Move the next bytecode pointer into x4, from x28.
+                    "mov   x0, x14",
+                    "mov   x1, x26",
+                    "mov   x2, x27",
+                    f"mov  x3, #{immediate}" if (immediate is not None) else "ldr   x3, [x28], #8", 
+                    "mov   x4, x28",
+
+                    # Perform our actual core code.
+                    f"bl _{slowpath_helper}",
+
+                    # Restore our registers after our C call.
+                    *C_CALL_EPILOGUE,
+
+                    # Finally, call our postscript.
+                    *postscript
+            )
+
+
+#
+# Gadget definitions.
+#
+
+print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n")
+
+# Call a C language helper function by address.
+simple("call",
+    # Get our C runtime function's location as a pointer-sized immediate...
+    "ldr x27, [x28], #8",
+
+    # Store our TB return address for our helper.
+    "str x28, [x25]",
+
+    # Prepare ourselves to call into our C runtime...
+    *C_CALL_PROLOGUE,
+
+    # ... perform the call itself ...
+    "blr x27",
+
+    # Save the result of our call for later.
+    "mov x27, x0",
+
+    # ... and restore our environment.
+    *C_CALL_EPILOGUE,
+
+    # Restore our return value.
+    "mov x0, x27"
+)
+
+# Branch to a given immediate address.
+simple("br",
+    # Use our immediate argument as our new bytecode-pointer location.
+    "ldr x28, [x28]"
+)
+
+# Exit from a translation buffer execution.
+simple("exit_tb",
+
+    # We have a single immediate argument, which contains our return code.
+    # Place it into x0, as one would a return code.
+    "ldr x0, [x28], #8",
+
+    # And finally, return back to the code that invoked our gadget stream.
+    "ret"
+)
+
+
+for condition in ARCH_CONDITION_CODES:
+
+    # Performs a comparison between two operands.
+    with_dnm(f"setcond_i32_{condition}",
+        "subs Wd, Wn, Wm",
+        f"cset Wd, {condition}"
+    )
+    with_dnm(f"setcond_i64_{condition}",
+        "subs Xd, Xn, Xm",
+        f"cset Xd, {condition}"
+    )
+
+    #
+    # NOTE: we use _dnm for the conditional branches, even though we don't
+    # actually do anything different based on the d argument. This gemerates
+    # effectively 16 identical `brcond` gadgets for each condition; which we
+    # use in the backend to spread out the actual branch sources we use.
+    #
+    # This is a slight mercy for the branch predictor, as not every conditional
+    # branch is funneled throught the same address.
+    #
+
+    # Branches iff a given comparison is true.
+    with_dnm(f'brcond_i32_{condition}',
+
+        # Grab our immediate argument.
+        "ldr x27, [x28], #8",
+
+        # Perform our comparison and conditional branch.
+        "subs Wzr, Wn, Wm",
+        f"b{condition} 1f",
+
+        "0:", # not taken
+           # Perform our end-of-instruction epilogue.
+            *EPILOGUE,
+
+        "1:" # taken
+            # Update our bytecode pointer to take the label.
+            "mov x28, x27"
+    )
+
+    # Branches iff a given comparison is true.
+    with_dnm(f'brcond_i64_{condition}',
+
+        # Grab our immediate argument.
+        "ldr x27, [x28], #8",
+
+        # Perform our comparison and conditional branch.
+        "subs Xzr, Xn, Xm",
+        f"b{condition} 1f",
+
+        "0:", # not taken
+            # Perform our end-of-instruction epilogue.
+            *EPILOGUE,
+
+        "1:" # taken
+            # Update our bytecode pointer to take the label.
+            "mov x28, x27"
+    )
+
+
+# MOV variants.
+with_dn("mov_i32",     "mov Wd, Wn")
+with_dn("mov_i64",     "mov Xd, Xn")
+with_d("movi_i32", "ldr Wd, [x28], #8")
+with_d("movi_i64", "ldr Xd, [x28], #8")
+
+# Create MOV variants that have common constants built in to the gadget.
+# This optimization helps costly reads from memories for simple operations.
+with_d_immediate("movi_imm_i32", "mov Wd, #Ii", immediate_range=range(64))
+with_d_immediate("movi_imm_i64", "mov Xd, #Ii", immediate_range=range(64))
+
+# LOAD variants.
+# TODO: should the signed variants have X variants for _i64?
+ldst_dn("ld8u",      "ldrb  Wd, [Xn, x27]")
+ldst_dn("ld8s_i32",  "ldrsb Wd, [Xn, x27]")
+ldst_dn("ld8s_i64",  "ldrsb Xd, [Xn, x27]")
+ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
+ldst_dn("ld16s_i32", "ldrsh Wd, [Xn, x27]")
+ldst_dn("ld16s_i64", "ldrsh Xd, [Xn, x27]")
+ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
+ldst_dn("ld32s_i64", "ldrsw Xd, [Xn, x27]")
+ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
+
+# STORE variants.
+ldst_dn("st8",         "strb  Wd, [Xn, x27]")
+ldst_dn("st16",        "strh  Wd, [Xn, x27]")
+ldst_dn("st_i32",      "str   Wd, [Xn, x27]")
+ldst_dn("st_i64",      "str   Xd, [Xn, x27]")
+
+# QEMU LD/ST are handled in our C runtime rather than with simple gadgets,
+# as they're nontrivial.
+
+# Trivial arithmetic.
+math_dnm("add" , "add" )
+math_dnm("sub" , "sub" )
+math_dnm("mul" , "mul" )
+math_dnm("div" , "sdiv")
+math_dnm("divu", "udiv")
+
+# Division remainder
+with_dnm("rem_i32",  "sdiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
+with_dnm("rem_i64",  "sdiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
+with_dnm("remu_i32", "udiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
+with_dnm("remu_i64", "udiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
+
+# Trivial logical.
+math_dn( "not",  "mvn")
+math_dn( "neg",  "neg")
+math_dnm("and",  "and")
+math_dnm("andc", "bic")
+math_dnm("or",   "orr")
+math_dnm("orc",  "orn")
+math_dnm("xor",  "eor")
+math_dnm("eqv",  "eon")
+math_dnm("shl",  "lsl")
+math_dnm("shr",  "lsr")
+math_dnm("sar",  "asr")
+
+# AArch64 lacks a Rotate Left; so we instead rotate right by a negative.
+# TODO: validate this?
+#math_dnm("rotr", "ror")
+#with_dnm("rotl_i32", "neg w27, Wm", "ror Wd, Wn, w27")
+#with_dnm("rotl_i64", "neg x27, Xm", "ror Xd, Xn, x27")
+
+# Numeric extension.
+math_dn("ext8s",      "sxtb")
+with_dn("ext8u",      "and Xd, Xn, #0xff")
+math_dn("ext16s",     "sxth")
+with_dn("ext16u",     "and Wd, Wn, #0xffff")
+with_dn("ext32s_i64", "sxtw Xd, Wn")
+with_dn("ext32u_i64", "and Xd, Xn, #0xffffffff")
+
+# Byte swapping.
+with_dn("bswap16",    "rev w27, Wn", "lsr Wd, w27, #16")
+with_dn("bswap32",    "rev Wd, Wn")
+with_dn("bswap64",    "rev Xd, Xn")
+
+# Memory barriers.
+simple("mb_all", "dmb ish")
+simple("mb_st",  "dmb ishst")
+simple("mb_ld",  "dmb ishld")
+
+# Handlers for QEMU_LD, which handles guest <- host loads.
+for subtype in ('aligned', 'unaligned', 'slowpath'):
+    is_aligned  = (subtype == 'aligned')
+    is_slowpath = (subtype == 'slowpath')
+
+    ld_thunk(f"qemu_ld_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu",
+        fastpath_32b=["ldrb Wd, [Xn, x27]"], fastpath_64b=["ldrb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_sb_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu_signed",
+        fastpath_32b=["ldrsb Wd, [Xn, x27]"], fastpath_64b=["ldrsb Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu",
+        fastpath_32b=["ldrh Wd, [Xn, x27]"], fastpath_64b=["ldrh Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu_signed",
+        fastpath_32b=["ldrsh Wd, [Xn, x27]"], fastpath_64b=["ldrsh Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu",
+        fastpath_32b=["ldr Wd, [Xn, x27]"], fastpath_64b=["ldr Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesl_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu_signed",
+        fastpath_32b=["ldrsw Xd, [Xn, x27]"], fastpath_64b=["ldrsw Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+
+    # Special variant for the most common mode, as a speedup optimization.
+    ld_thunk(f"qemu_ld_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x3a
+    )
+
+    # For now, leave the rare/big-endian stuff slow-path only.
+    ld_thunk(f"qemu_ld_beuw_{subtype}", None, None, "helper_be_lduw_mmu",         
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_besw_{subtype}", None, None, "helper_be_lduw_mmu_signed",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_beul_{subtype}", None, None, "helper_be_ldul_mmu",         
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_besl_{subtype}", None, None, "helper_be_ldul_mmu_signed",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_beq_{subtype}",  None, None, "helper_be_ldq_mmu",          
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+
+
+# Handlers for QEMU_ST, which handles guest -> host stores.
+for subtype in ('aligned', 'unaligned', 'slowpath'):
+    is_aligned  = (subtype == 'aligned')
+    is_slowpath = (subtype == 'slowpath')
+
+    st_thunk(f"qemu_st_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_stb_mmu",
+        fastpath_32b=["strb Wd, [Xn, x27]"], fastpath_64b=["strb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stw_mmu",
+        fastpath_32b=["strh Wd, [Xn, x27]"], fastpath_64b=["strh Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stl_mmu",
+        fastpath_32b=["str Wd, [Xn, x27]"], fastpath_64b=["str Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    
+    # Special optimization for the most common modes.
+    st_thunk(f"qemu_st_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x3a
+    )
+
+    # For now, leave the rare/big-endian stuff slow-path only.
+    st_thunk(f"qemu_st_beuw_{subtype}", None, None, "helper_be_stw_mmu",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    st_thunk(f"qemu_st_beul_{subtype}", None, None, "helper_be_stl_mmu",
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    st_thunk(f"qemu_st_beq_{subtype}",  None, None, "helper_be_stq_mmu",
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+
+
+# Statistics.
+sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions ({instructions * 4} B).\n\n")
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 457a40837feb..0eb06e0ed059 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -162,7 +162,7 @@ TCGv_env cpu_env = 0;
 const void *tcg_code_gen_epilogue;
 uintptr_t tcg_splitwx_diff;
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 tcg_prologue_fn *tcg_qemu_tb_exec;
 #endif
 
@@ -1200,7 +1200,7 @@ void tcg_prologue_init(TCGContext *s)
     region.start = buf0;
     region.end = buf0 + total_size;
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     tcg_qemu_tb_exec = (tcg_prologue_fn *)tcg_splitwx_to_rx(buf0);
 #endif
 
@@ -1226,7 +1226,7 @@ void tcg_prologue_init(TCGContext *s)
 #endif
 
     buf1 = s->code_ptr;
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     flush_idcache_range((uintptr_t)tcg_splitwx_to_rx(buf0), (uintptr_t)buf0,
                         tcg_ptr_byte_diff(buf1, buf0));
 #endif
@@ -1955,7 +1955,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
 #endif
 
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* We have 64-bit values in one register, but need to pass as two
        separate parameters.  Split them.  */
     int orig_sizemask = sizemask;
@@ -2005,7 +2005,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
     pi = 0;
     if (ret != NULL) {
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
         if (orig_sizemask & 1) {
             /* The 32-bit ABI is going to return the 64-bit value in
                the %o0/%o1 register pair.  Prepare for this by using
@@ -2083,7 +2083,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
     tcg_debug_assert(pi <= ARRAY_SIZE(op->args));
 
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* Free all of the parts we allocated above.  */
     for (i = real_args = 0; i < orig_nargs; ++i) {
         int is_64bit = orig_sizemask & (1 << (i+1)*2);
@@ -4763,7 +4763,7 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
         return -2;
     }
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* flush instruction cache */
     flush_idcache_range((uintptr_t)tcg_splitwx_to_rx(s->code_buf),
                         (uintptr_t)s->code_buf,

From 4f59dc2db05b7a1b2654adaee1f03be1d08fb048 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sat, 10 Oct 2020 19:52:38 -0700
Subject: [PATCH 014/180] block: feature detection for host block support

On Darwin (iOS), there are no system level APIs for directly accessing
host block devices. We detect this at configure time.
---
 block/file-posix.c   | 33 ++++++++++++++++++++++-----------
 meson.build          |  6 +++++-
 qapi/block-core.json | 10 +++++++---
 3 files changed, 34 insertions(+), 15 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index 20e14f8e96ba..08d7a1891ffd 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -42,6 +42,8 @@
 #include "scsi/constants.h"
 
 #if defined(__APPLE__) && (__MACH__)
+#include <sys/ioctl.h>
+#if defined(HAVE_HOST_BLOCK_DEVICE)
 #include <paths.h>
 #include <sys/param.h>
 #include <IOKit/IOKitLib.h>
@@ -52,6 +54,7 @@
 //#include <IOKit/storage/IOCDTypes.h>
 #include <IOKit/storage/IODVDMedia.h>
 #include <CoreFoundation/CoreFoundation.h>
+#endif /* defined(HAVE_HOST_BLOCK_DEVICE) */
 #endif
 
 #ifdef __sun__
@@ -181,7 +184,17 @@ typedef struct BDRVRawReopenState {
     bool check_cache_dropped;
 } BDRVRawReopenState;
 
-static int fd_open(BlockDriverState *bs);
+static int fd_open(BlockDriverState *bs)
+{
+    BDRVRawState *s = bs->opaque;
+
+    /* this is just to ensure s->fd is sane (its called by io ops) */
+    if (s->fd >= 0) {
+        return 0;
+    }
+    return -EIO;
+}
+
 static int64_t raw_getlength(BlockDriverState *bs);
 
 typedef struct RawPosixAIOData {
@@ -3027,6 +3040,7 @@ static BlockStatsSpecific *raw_get_specific_stats(BlockDriverState *bs)
     return stats;
 }
 
+#if defined(HAVE_HOST_BLOCK_DEVICE)
 static BlockStatsSpecific *hdev_get_specific_stats(BlockDriverState *bs)
 {
     BlockStatsSpecific *stats = g_new(BlockStatsSpecific, 1);
@@ -3036,6 +3050,7 @@ static BlockStatsSpecific *hdev_get_specific_stats(BlockDriverState *bs)
 
     return stats;
 }
+#endif /* HAVE_HOST_BLOCK_DEVICE */
 
 static QemuOptsList raw_create_opts = {
     .name = "raw-create-opts",
@@ -3260,6 +3275,8 @@ BlockDriver bdrv_file = {
 /***********************************************/
 /* host device */
 
+#if defined(HAVE_HOST_BLOCK_DEVICE)
+
 #if defined(__APPLE__) && defined(__MACH__)
 static kern_return_t GetBSDPath(io_iterator_t mediaIterator, char *bsdPath,
                                 CFIndex maxPathSize, int flags);
@@ -3552,16 +3569,6 @@ hdev_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
 }
 #endif /* linux */
 
-static int fd_open(BlockDriverState *bs)
-{
-    BDRVRawState *s = bs->opaque;
-
-    /* this is just to ensure s->fd is sane (its called by io ops) */
-    if (s->fd >= 0)
-        return 0;
-    return -EIO;
-}
-
 static coroutine_fn int
 hdev_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)
 {
@@ -3885,6 +3892,8 @@ static BlockDriver bdrv_host_cdrom = {
 };
 #endif /* __FreeBSD__ */
 
+#endif /* HAVE_HOST_BLOCK_DEVICE */
+
 static void bdrv_file_init(void)
 {
     /*
@@ -3892,6 +3901,7 @@ static void bdrv_file_init(void)
      * registered last will get probed first.
      */
     bdrv_register(&bdrv_file);
+#if defined(HAVE_HOST_BLOCK_DEVICE)
     bdrv_register(&bdrv_host_device);
 #ifdef __linux__
     bdrv_register(&bdrv_host_cdrom);
@@ -3899,6 +3909,7 @@ static void bdrv_file_init(void)
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
     bdrv_register(&bdrv_host_cdrom);
 #endif
+#endif /* HAVE_HOST_BLOCK_DEVICE */
 }
 
 block_init(bdrv_file_init);
diff --git a/meson.build b/meson.build
index c6f4b0cf5e8a..78aa4670fd92 100644
--- a/meson.build
+++ b/meson.build
@@ -181,7 +181,7 @@ if targetos == 'windows'
                                       include_directories: include_directories('.'))
 elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
-  iokit = dependency('appleframeworks', modules: 'IOKit')
+  iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
             cc.find_library('nsl'),
@@ -1056,6 +1056,9 @@ if get_option('cfi')
   add_global_link_arguments(cfi_flags, native: false, language: ['c', 'cpp', 'objc'])
 endif
 
+have_host_block_device = (targetos != 'darwin' or
+    cc.has_header('IOKit/storage/IOMedia.h'))
+
 #################
 # config-host.h #
 #################
@@ -1149,6 +1152,7 @@ config_host_data.set('HAVE_PTY_H', cc.has_header('pty.h'))
 config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
 config_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))
+config_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)
 
 config_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))
 
diff --git a/qapi/block-core.json b/qapi/block-core.json
index 6d227924d06c..ea0d2725d261 100644
--- a/qapi/block-core.json
+++ b/qapi/block-core.json
@@ -897,7 +897,8 @@
   'discriminator': 'driver',
   'data': {
       'file': 'BlockStatsSpecificFile',
-      'host_device': 'BlockStatsSpecificFile',
+      'host_device': { 'type': 'BlockStatsSpecificFile',
+                       'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
       'nvme': 'BlockStatsSpecificNvme' } }
 
 ##
@@ -2814,7 +2815,9 @@
 { 'enum': 'BlockdevDriver',
   'data': [ 'blkdebug', 'blklogwrites', 'blkreplay', 'blkverify', 'bochs',
             'cloop', 'compress', 'copy-on-read', 'dmg', 'file', 'ftp', 'ftps',
-            'gluster', 'host_cdrom', 'host_device', 'http', 'https', 'iscsi',
+            'gluster', 'host_cdrom',
+            {'name': 'host_device', 'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
+            'http', 'https', 'iscsi',
             'luks', 'nbd', 'nfs', 'null-aio', 'null-co', 'nvme', 'parallels',
             'preallocate', 'qcow', 'qcow2', 'qed', 'quorum', 'raw', 'rbd',
             { 'name': 'replication', 'if': 'defined(CONFIG_REPLICATION)' },
@@ -4017,7 +4020,8 @@
       'ftps':       'BlockdevOptionsCurlFtps',
       'gluster':    'BlockdevOptionsGluster',
       'host_cdrom': 'BlockdevOptionsFile',
-      'host_device':'BlockdevOptionsFile',
+      'host_device': { 'type': 'BlockdevOptionsFile',
+                       'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
       'http':       'BlockdevOptionsCurlHttp',
       'https':      'BlockdevOptionsCurlHttps',
       'iscsi':      'BlockdevOptionsIscsi',

From 1913d4d2a7a16e3e3ea8725bd42564c4da22b617 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Thu, 21 Jan 2021 16:12:00 -0800
Subject: [PATCH 015/180] block: check for sys/disk.h

Some BSD platforms do not have this header.
---
 block.c     | 2 +-
 meson.build | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/block.c b/block.c
index c5b887cec196..7f33709c94da 100644
--- a/block.c
+++ b/block.c
@@ -54,7 +54,7 @@
 #ifdef CONFIG_BSD
 #include <sys/ioctl.h>
 #include <sys/queue.h>
-#ifndef __DragonFly__
+#if defined(HAVE_SYS_DISK_H)
 #include <sys/disk.h>
 #endif
 #endif
diff --git a/meson.build b/meson.build
index 78aa4670fd92..202b1e0f1940 100644
--- a/meson.build
+++ b/meson.build
@@ -1153,6 +1153,7 @@ config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
 config_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))
 config_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)
+config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h'))
 
 config_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))
 

From 36c2febd7f65c98cc3661d788e10b02e3d9d8c7e Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sun, 7 Mar 2021 16:52:56 -0800
Subject: [PATCH 016/180] block: detect DKIOCGETBLOCKCOUNT/SIZE before use

iOS hosts do not have these defined so we fallback to the
default behaviour.

Co-authored-by: Warner Losh <imp@bsdimp.com>
---
 block/file-posix.c | 18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index 08d7a1891ffd..dcd2a2375bfe 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -2321,8 +2321,10 @@ static int64_t raw_getlength(BlockDriverState *bs)
 again:
 #endif
     if (!fstat(fd, &sb) && (S_IFCHR & sb.st_mode)) {
+        size = 0;
 #ifdef DIOCGMEDIASIZE
         if (ioctl(fd, DIOCGMEDIASIZE, (off_t *)&size))
+            size = 0;
 #elif defined(DIOCGPART)
         {
                 struct partinfo pi;
@@ -2331,9 +2333,7 @@ static int64_t raw_getlength(BlockDriverState *bs)
                 else
                         size = 0;
         }
-        if (size == 0)
-#endif
-#if defined(__APPLE__) && defined(__MACH__)
+#elif defined(DKIOCGETBLOCKCOUNT) && defined(DKIOCGETBLOCKSIZE)
         {
             uint64_t sectors = 0;
             uint32_t sector_size = 0;
@@ -2341,19 +2341,15 @@ static int64_t raw_getlength(BlockDriverState *bs)
             if (ioctl(fd, DKIOCGETBLOCKCOUNT, &sectors) == 0
                && ioctl(fd, DKIOCGETBLOCKSIZE, &sector_size) == 0) {
                 size = sectors * sector_size;
-            } else {
-                size = lseek(fd, 0LL, SEEK_END);
-                if (size < 0) {
-                    return -errno;
-                }
             }
         }
-#else
-        size = lseek(fd, 0LL, SEEK_END);
+#endif
+        if (size == 0) {
+            size = lseek(fd, 0LL, SEEK_END);
+        }
         if (size < 0) {
             return -errno;
         }
-#endif
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
         switch(s->type) {
         case FTYPE_CD:

From d4e9108ef1b5f98bf1beeb14529aa4684736e57a Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Thu, 21 Jan 2021 16:31:09 -0800
Subject: [PATCH 017/180] slirp: feature detection for smbd

Replace Windows specific macro with a more generic feature detection
macro. Allows slirp smb feature to be disabled manually as well.
---
 configure   | 25 ++++++++++++++++++++++---
 meson.build |  2 +-
 net/slirp.c | 16 ++++++++--------
 3 files changed, 31 insertions(+), 12 deletions(-)

diff --git a/configure b/configure
index 535e6a9269be..7fec65c90c51 100755
--- a/configure
+++ b/configure
@@ -466,6 +466,7 @@ multiprocess="auto"
 
 malloc_trim="auto"
 gio="$default_feature"
+slirp_smbd="auto"
 
 # parse CC options second
 for opt do
@@ -835,8 +836,6 @@ do
     fi
 done
 
-: ${smbd=${SMBD-/usr/sbin/smbd}}
-
 # Default objcc to clang if available, otherwise use CC
 if has clang; then
   objcc=clang
@@ -1564,6 +1563,9 @@ for opt do
   --enable-gio) gio=yes
   ;;
   --disable-gio) gio=no
+  --enable-slirp-smbd) slirp_smbd=yes
+  ;;
+  --disable-slirp-smbd) slirp_smbd=no
   ;;
   *)
       echo "ERROR: unknown option $opt"
@@ -1919,6 +1921,7 @@ disabled with --disable-FEATURE, default is enabled if available
   fuse-lseek      SEEK_HOLE/SEEK_DATA support for FUSE exports
   multiprocess    Out of process device emulation support
   gio             libgio support
+  slirp-smbd      use smbd (at path --smbd=*) in slirp networking
 
 NOTE: The object files are built at the place where configure is launched
 EOF
@@ -5255,6 +5258,19 @@ case "$slirp" in
     ;;
 esac
 
+# Check for slirp smbd dupport
+: ${smbd=${SMBD-/usr/sbin/smbd}}
+if test "$slirp_smbd" != "no" ; then
+  if test "$mingw32" = "yes" ; then
+    if test "$slirp_smbd" = "yes" ; then
+      error_exit "Host smbd not supported on this platform."
+    fi
+    slirp_smbd=no
+  else
+    slirp_smbd=yes
+  fi
+fi
+
 ##########################################
 # check for usable __NR_keyctl syscall
 
@@ -5530,7 +5546,10 @@ fi
 if test "$guest_agent" = "yes" ; then
   echo "CONFIG_GUEST_AGENT=y" >> $config_host_mak
 fi
-echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
+if test "$slirp_smbd" = "yes" ; then
+  echo "CONFIG_SLIRP_SMBD=y" >> $config_host_mak
+  echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
+fi
 if test "$vde" = "yes" ; then
   echo "CONFIG_VDE=y" >> $config_host_mak
   echo "VDE_LIBS=$vde_libs" >> $config_host_mak
diff --git a/meson.build b/meson.build
index 202b1e0f1940..3c8905517637 100644
--- a/meson.build
+++ b/meson.build
@@ -2456,7 +2456,7 @@ summary_info += {'genisoimage':       config_host['GENISOIMAGE']}
 if targetos == 'windows' and config_host.has_key('CONFIG_GUEST_AGENT')
   summary_info += {'wixl':            wixl.found() ? wixl.full_path() : false}
 endif
-if slirp_opt != 'disabled'
+if slirp_opt != 'disabled' and 'CONFIG_SLIRP_SMBD' in config_host
   summary_info += {'smbd':            config_host['CONFIG_SMBD_COMMAND']}
 endif
 summary(summary_info, bool_yn: true, section: 'Host binaries')
diff --git a/net/slirp.c b/net/slirp.c
index a9fdc7a08f24..ae0e6c625eaf 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -27,7 +27,7 @@
 #include "net/slirp.h"
 
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 #include <pwd.h>
 #include <sys/wait.h>
 #endif
@@ -91,7 +91,7 @@ typedef struct SlirpState {
     Slirp *slirp;
     Notifier poll_notifier;
     Notifier exit_notifier;
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     gchar *smb_dir;
 #endif
     GSList *fwd;
@@ -104,7 +104,7 @@ static QTAILQ_HEAD(, SlirpState) slirp_stacks =
 static int slirp_hostfwd(SlirpState *s, const char *redir_str, Error **errp);
 static int slirp_guestfwd(SlirpState *s, const char *config_str, Error **errp);
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 static int slirp_smb(SlirpState *s, const char *exported_dir,
                      struct in_addr vserver_addr, Error **errp);
 static void slirp_smb_cleanup(SlirpState *s);
@@ -377,7 +377,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
     struct in6_addr ip6_prefix;
     struct in6_addr ip6_host;
     struct in6_addr ip6_dns;
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     struct in_addr smbsrv = { .s_addr = 0 };
 #endif
     NetClientState *nc;
@@ -490,7 +490,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
         return -1;
     }
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     if (vsmbserver && !inet_aton(vsmbserver, &smbsrv)) {
         error_setg(errp, "Failed to parse SMB address");
         return -1;
@@ -720,7 +720,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
             QAPI_LIST_APPEND(stored_guestfwd, element);
         }
     }
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     if (smb_export) {
         if (slirp_smb(s, smb_export, smbsrv, errp) < 0) {
             goto error;
@@ -912,7 +912,7 @@ void hmp_hostfwd_add(Monitor *mon, const QDict *qdict)
 
 }
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 
 /* automatic user mode samba server configuration */
 static void slirp_smb_cleanup(SlirpState *s)
@@ -1027,7 +1027,7 @@ static int slirp_smb(SlirpState* s, const char *exported_dir,
     return 0;
 }
 
-#endif /* !defined(_WIN32) */
+#endif /* defined(CONFIG_SLIRP_SMBD) */
 
 static int guestfwd_can_read(void *opaque)
 {

From e034ab0b4dd9ba3a5a70d9910ad5b863ef256616 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 7 Mar 2021 17:24:50 -0800
Subject: [PATCH 018/180] meson: option to build as shared library

On iOS, we cannot fork() new processes, so the best way to load QEMU into an
app is through a shared library. We add a new configure option
`--enable-shared-lib` that will build the bulk of QEMU into a shared lib.
The usual executables will then link to the library.
---
 configure         | 14 ++++++++++++--
 meson.build       | 40 ++++++++++++++++++++++++++++++++++------
 meson_options.txt |  2 ++
 3 files changed, 48 insertions(+), 8 deletions(-)

diff --git a/configure b/configure
index 7fec65c90c51..4440743e8475 100755
--- a/configure
+++ b/configure
@@ -463,6 +463,7 @@ gettext="auto"
 fuse="auto"
 fuse_lseek="auto"
 multiprocess="auto"
+shared_lib="false"
 
 malloc_trim="auto"
 gio="$default_feature"
@@ -1567,6 +1568,10 @@ for opt do
   ;;
   --disable-slirp-smbd) slirp_smbd=no
   ;;
+  --enable-shared-lib) shared_lib=true
+  ;;
+  --disable-shared-lib) shared_lib=false
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -1794,6 +1799,7 @@ Advanced options (experts only):
                            enable plugins via shared library loading
   --disable-containers     don't use containers for cross-building
   --gdb=GDB-path           gdb to use for gdbstub tests [$gdb_bin]
+  --enable-shared-lib      build QEMU as a shared library
 
 Optional features, enabled with --enable-FEATURE and
 disabled with --disable-FEATURE, default is enabled if available
@@ -6362,7 +6368,11 @@ echo "ranlib = [$(meson_quote $ranlib)]" >> $cross
 if has $sdl2_config; then
   echo "sdl2-config = [$(meson_quote $sdl2_config)]" >> $cross
 fi
-echo "strip = [$(meson_quote $strip)]" >> $cross
+if test "$shared_lib" = "true"; then
+  echo "strip = [$(meson_quote $strip), '-x']" >> $cross
+else
+  echo "strip = [$(meson_quote $strip)]" >> $cross
+fi
 echo "windres = [$(meson_quote $windres)]" >> $cross
 if test "$cross_compile" = "yes"; then
     cross_arg="--cross-file config-meson.cross"
@@ -6444,7 +6454,7 @@ NINJA=$ninja $meson setup \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
         $(if test "$default_features" = no; then echo "-Dauto_features=disabled"; fi) \
-	-Dtcg_interpreter=$tcg_interpreter \
+	-Dtcg_interpreter=$tcg_interpreter -Dshared_lib=$shared_lib \
         $cross_arg \
         "$PWD" "$source_path"
 
diff --git a/meson.build b/meson.build
index 3c8905517637..80e9305d5a64 100644
--- a/meson.build
+++ b/meson.build
@@ -2217,14 +2217,31 @@ foreach target : target_dirs
   arch_srcs += target_specific.sources()
   arch_deps += target_specific.dependencies()
 
-  lib = static_library('qemu-' + target,
+  if get_option('shared_lib')
+    build_lib_args = {
+      'target_type': 'shared_library',
+      'install': true,
+      'dependencies': arch_deps + deps,
+      'link_language': link_language,
+      'link_depends': [block_syms, qemu_syms],
+      'link_args': link_args + cc.get_supported_link_arguments(['-Wl,-U,_qemu_main'])
+    }
+  else
+    build_lib_args = {
+      'target_type': 'static_library',
+      'install': false,
+      'dependencies': arch_deps,
+      'name_suffix': 'fa'
+    }
+  endif
+
+  lib = build_target('qemu-' + target,
                  sources: arch_srcs + genh,
-                 dependencies: arch_deps,
                  objects: objects,
                  include_directories: target_inc,
                  c_args: c_args,
                  build_by_default: false,
-                 name_suffix: 'fa')
+                 kwargs: build_lib_args)
 
   if target.endswith('-softmmu')
     execs = [{
@@ -2258,6 +2275,17 @@ foreach target : target_dirs
       'dependencies': []
     }]
   endif
+  if get_option('shared_lib')
+    build_exe_args = {
+      'link_with': lib,
+      'link_args': link_args + cc.get_supported_link_arguments(['-Wl,--exclude-libs,ALL'])
+    }
+  else
+    build_exe_args = {
+      'objects': lib.extract_all_objects(recursive: true),
+      'link_args': link_args
+    }
+  endif
   foreach exe: execs
     exe_name = exe['name']
     exe_sign = 'CONFIG_HVF' in config_target
@@ -2269,11 +2297,10 @@ foreach target : target_dirs
                install: true,
                c_args: c_args,
                dependencies: arch_deps + deps + exe['dependencies'],
-               objects: lib.extract_all_objects(recursive: true),
                link_language: link_language,
                link_depends: [block_syms, qemu_syms] + exe.get('link_depends', []),
-               link_args: link_args,
-               gui_app: exe['gui'])
+               gui_app: exe['gui'],
+               kwargs: build_exe_args)
 
     if exe_sign
       emulators += {exe['name'] : custom_target(exe['name'],
@@ -2440,6 +2467,7 @@ endif
 summary_info += {'Doc directory':     get_option('docdir')}
 summary_info += {'Build directory':   meson.current_build_dir()}
 summary_info += {'Source path':       meson.current_source_dir()}
+summary_info += {'build shared lib':  get_option('shared_lib')}
 summary_info += {'GIT submodules':    config_host['GIT_SUBMODULES']}
 summary(summary_info, bool_yn: true, section: 'Directories')
 
diff --git a/meson_options.txt b/meson_options.txt
index 9734019995a0..4594d42769d6 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -6,6 +6,8 @@ option('qemu_firmwarepath', type : 'string', value : '',
        description: 'search PATH for firmware files')
 option('sphinx_build', type : 'string', value : '',
        description: 'Use specified sphinx-build [$sphinx_build] for building document (default to be empty)')
+option('shared_lib', type : 'boolean', value : false,
+       description: 'build QEMU as a shared library')
 
 option('default_devices', type : 'boolean', value : true,
        description: 'Include a default selection of devices in emulators')

From 17ebce776d24f2d9346ba647dd8bbea1d8aa2c55 Mon Sep 17 00:00:00 2001
From: Gerd Hoffmann <kraxel@redhat.com>
Date: Fri, 8 Jun 2018 13:19:58 +0200
Subject: [PATCH 019/180] hw/display: add virtio-ramfb device

Like virtio-vga, but using ramfb instead of legacy vga.
Useful for booting from OVMF into Windows ARM which expects a linear FB.
---
 hw/display/meson.build    |   1 +
 hw/display/virtio-ramfb.c | 188 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 189 insertions(+)
 create mode 100644 hw/display/virtio-ramfb.c

diff --git a/hw/display/meson.build b/hw/display/meson.build
index 9d79e3951d9e..14f5fa39f4c1 100644
--- a/hw/display/meson.build
+++ b/hw/display/meson.build
@@ -60,6 +60,7 @@ if config_all_devices.has_key('CONFIG_VIRTIO_GPU')
   virtio_gpu_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRGL'],
                     if_true: [files('virtio-gpu-3d.c'), pixman, virgl])
   virtio_gpu_ss.add(when: 'CONFIG_VHOST_USER_GPU', if_true: files('vhost-user-gpu.c'))
+  virtio_gpu_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('virtio-ramfb.c'))
   hw_display_modules += {'virtio-gpu': virtio_gpu_ss}
 endif
 
diff --git a/hw/display/virtio-ramfb.c b/hw/display/virtio-ramfb.c
new file mode 100644
index 000000000000..d08bb90a14d4
--- /dev/null
+++ b/hw/display/virtio-ramfb.c
@@ -0,0 +1,188 @@
+#include "qemu/osdep.h"
+#include "hw/pci/pci.h"
+#include "ui/console.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-gpu-pci.h"
+#include "qapi/error.h"
+#include "hw/display/ramfb.h"
+#include "qom/object.h"
+
+/*
+ * virtio-ramfb-base: This extends VirtioPCIProxy.
+ */
+#define TYPE_VIRTIO_RAMFB_BASE "virtio-ramfb-base"
+OBJECT_DECLARE_TYPE(VirtIORAMFBBase, VirtIORAMFBBaseClass,
+                    VIRTIO_RAMFB_BASE)
+
+struct VirtIORAMFBBase {
+    VirtIOPCIProxy parent_obj;
+
+    VirtIOGPUBase *vgpu;
+    RAMFBState    *ramfb;
+};
+
+struct VirtIORAMFBBaseClass {
+    VirtioPCIClass parent_class;
+
+    DeviceReset parent_reset;
+};
+
+static void virtio_ramfb_invalidate_display(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->enable) {
+        g->hw_ops->invalidate(g);
+    }
+}
+
+static void virtio_ramfb_update_display(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->enable) {
+        g->hw_ops->gfx_update(g);
+    } else {
+        ramfb_display_update(g->scanout[0].con, vramfb->ramfb);
+    }
+}
+
+static int virtio_ramfb_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->ui_info) {
+        return g->hw_ops->ui_info(g, idx, info);
+    }
+    return -1;
+}
+
+static void virtio_ramfb_gl_block(void *opaque, bool block)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->gl_block) {
+        g->hw_ops->gl_block(g, block);
+    }
+}
+
+static const GraphicHwOps virtio_ramfb_ops = {
+    .invalidate = virtio_ramfb_invalidate_display,
+    .gfx_update = virtio_ramfb_update_display,
+    .ui_info = virtio_ramfb_ui_info,
+    .gl_block = virtio_ramfb_gl_block,
+};
+
+static const VMStateDescription vmstate_virtio_ramfb = {
+    .name = "virtio-ramfb",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    .fields = (VMStateField[]) {
+        /* no pci stuff here, saving the virtio device will handle that */
+        /* FIXME */
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+/* RAMFB device wrapper around PCI device around virtio GPU */
+static void virtio_ramfb_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
+{
+    VirtIORAMFBBase *vramfb = VIRTIO_RAMFB_BASE(vpci_dev);
+    VirtIOGPUBase *g = vramfb->vgpu;
+    int i;
+
+    /* init virtio bits */
+    virtio_pci_force_virtio_1(vpci_dev);
+    if (!qdev_realize(DEVICE(g), BUS(&vpci_dev->bus), errp)) {
+        return;
+    }
+
+    /* init ramfb */
+    vramfb->ramfb = ramfb_setup(errp);
+    graphic_console_set_hwops(g->scanout[0].con, &virtio_ramfb_ops, vramfb);
+
+    for (i = 0; i < g->conf.max_outputs; i++) {
+        object_property_set_link(OBJECT(g->scanout[i].con), "device",
+                                 OBJECT(vpci_dev), &error_abort);
+    }
+}
+
+static void virtio_ramfb_reset(DeviceState *dev)
+{
+    VirtIORAMFBBaseClass *klass = VIRTIO_RAMFB_BASE_GET_CLASS(dev);
+
+    /* reset virtio-gpu */
+    klass->parent_reset(dev);
+}
+
+static Property virtio_ramfb_base_properties[] = {
+    DEFINE_VIRTIO_GPU_PCI_PROPERTIES(VirtIOPCIProxy),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_ramfb_base_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioPCIClass *k = VIRTIO_PCI_CLASS(klass);
+    VirtIORAMFBBaseClass *v = VIRTIO_RAMFB_BASE_CLASS(klass);
+    PCIDeviceClass *pcidev_k = PCI_DEVICE_CLASS(klass);
+
+    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
+    device_class_set_props(dc, virtio_ramfb_base_properties);
+    dc->vmsd = &vmstate_virtio_ramfb;
+    dc->hotpluggable = false;
+    device_class_set_parent_reset(dc, virtio_ramfb_reset,
+                                  &v->parent_reset);
+
+    k->realize = virtio_ramfb_realize;
+    pcidev_k->class_id = PCI_CLASS_DISPLAY_OTHER;
+}
+
+static TypeInfo virtio_ramfb_base_info = {
+    .name          = TYPE_VIRTIO_RAMFB_BASE,
+    .parent        = TYPE_VIRTIO_PCI,
+    .instance_size = sizeof(VirtIORAMFBBase),
+    .class_size    = sizeof(VirtIORAMFBBaseClass),
+    .class_init    = virtio_ramfb_base_class_init,
+    .abstract      = true,
+};
+
+#define TYPE_VIRTIO_RAMFB "virtio-ramfb"
+
+typedef struct VirtIORAMFB VirtIORAMFB;
+DECLARE_INSTANCE_CHECKER(VirtIORAMFB, VIRTIO_RAMFB,
+                         TYPE_VIRTIO_RAMFB)
+
+struct VirtIORAMFB {
+    VirtIORAMFBBase parent_obj;
+
+    VirtIOGPU     vdev;
+};
+
+static void virtio_ramfb_inst_initfn(Object *obj)
+{
+    VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
+
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+}
+
+static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {
+    .generic_name  = TYPE_VIRTIO_RAMFB,
+    .parent        = TYPE_VIRTIO_RAMFB_BASE,
+    .instance_size = sizeof(VirtIORAMFB),
+    .instance_init = virtio_ramfb_inst_initfn,
+};
+
+static void virtio_ramfb_register_types(void)
+{
+    type_register_static(&virtio_ramfb_base_info);
+    virtio_pci_types_register(&virtio_ramfb_info);
+}
+
+type_init(virtio_ramfb_register_types)

From 138287176bcd6f91506bafce274dd8741716617b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>
Date: Mon, 25 Jan 2021 11:34:26 +0400
Subject: [PATCH 020/180] slirp: update to git master
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

git cherry-diff:

Commits on bacb71f1c3ed5f40e393afd8be81bedfba13a401 branch that is not on 8f43a99191afb47ca3f3c6972f6306209f367ece branch
+ 1021b0dc38d39f1dc95a296fe3e05a24a087cdc6 disable_dns option
+ 0f94ceec752592e4ac632a24e3c64a97dd09bf4c limit vnameserver_addr to port 53
+ b57bafa852ef16b133907a13678ec69e9531f177 libslirp.h: fix SlirpConfig v3 documentation
+ 1abf18b2b5edb462797629ed47ad4515a195686e Update CHANGELOG
+ ff4ecf9b6c6542b24b4ac6ea178be9d44e159f79 Release v4.3.0
+ 21f1d933050a40d62612c6274c32de60b811d9ea changelog: post-release
+ 376187c4b14c795763d472214812826eebe7e9c2 Release v4.3.1
+ 73336e08902a7e826f7d960453df037380266186 changelog: post-release
+ 5c1c9d43be61571608e9b14615045b67b830daf5 udp, udp6, icmp: handle TTL value
+ 73ed49ab71998d4288e71e954ef6214b70f23d79 icmp, icmp6: Add icmp_forward_error and icmp6_forward_error
+ 7a4840a57ec7dbc37cca1ab96f058a9610b26950 udp, udp6, icmp, icmp6: Enable forwarding errors on Linux
+ e9b2bc19ae652a2907f247e621b2e4773bdd2aab TCPIPHDR_DELTA: Fix potential negative value
+ 39f9a363eec082f04513413046321abd04163148 .gitlab-ci: add a Coverity stage
+ 1b0093b973cfa0dc041522e5d4e6f576b2df642e sosendoob: better document what urgc is used for
+ 5b9ad89ebbb8afa50162c9156fabd5fc56291088 Add G_GNUC_PRINTF to local function slirp_vsnprintf
+ 8a808aa493980e212b4d5f5465330905c8294e59 meson: remove meson-dist script
+ 0b669b5fbe4d3c25a682a67f1059d8633c963b3d meson: support compiling as subproject
+ 9f82a47b81f2864422b82c1e40e51a2ed9c6ac32 Add DNS resolving for iOS
+ c0eac03e8ce1b9a743231f2fe21e7cb579fc9339 Remove the QEMU-special make build-system
+ 1bfd4d9368f9fa2e4f0731e1266bec05bbc83a80 socket: consume empty packets
+ 92413be68914f8cae2f5bad4bf3ab8491dcbc5d7 Release v4.4.0
+ 07e8cfac69766081871ab620d9f16a630543d302 changelog: post-release
+ 4c4e035813313d02b63fdeb920d56fb2fdc0a5b1 Remove some needless (void)casts
+ eee9db9d115d91aa82f33685c4e76d656db92976 fork_exec_child_setup: improve signal handling
+ 216f434a018b3af182a4f31bbe5a00daee170343 Fix unused variables

Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
Message-Id: <20210125073427.3970606-2-marcandre.lureau@redhat.com>
---
 slirp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/slirp b/slirp
index 8f43a99191af..5dce846e3ee8 160000
--- a/slirp
+++ b/slirp
@@ -1 +1 @@
-Subproject commit 8f43a99191afb47ca3f3c6972f6306209f367ece
+Subproject commit 5dce846e3ee82d93462bc637bb0db2fd49f0fc5a

From c78951da1b67f293b750a1b6a7c9ff7e0575eccd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>
Date: Mon, 25 Jan 2021 11:34:27 +0400
Subject: [PATCH 021/180] build-sys: make libslirp a meson subproject
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Remove the manual build.

Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
Message-Id: <20210125073427.3970606-3-marcandre.lureau@redhat.com>
---
 .gitmodules          |  6 ++---
 configure            |  2 +-
 meson.build          | 63 +++-----------------------------------------
 slirp                |  1 -
 subprojects/libslirp |  1 +
 5 files changed, 9 insertions(+), 64 deletions(-)
 delete mode 160000 slirp
 create mode 160000 subprojects/libslirp

diff --git a/.gitmodules b/.gitmodules
index 08b1b48a09f4..c28831c50ab4 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -49,9 +49,9 @@
 [submodule "roms/edk2"]
 	path = roms/edk2
 	url = https://gitlab.com/qemu-project/edk2.git
-[submodule "slirp"]
-	path = slirp
-	url = https://gitlab.com/qemu-project/libslirp.git
+[submodule "subprojects/libslirp"]
+	path = subprojects/libslirp
+	url = https://git.qemu.org/git/libslirp.git
 [submodule "roms/opensbi"]
 	path = roms/opensbi
 	url = 	https://gitlab.com/qemu-project/opensbi.git
diff --git a/configure b/configure
index 4440743e8475..12de8035e42d 100755
--- a/configure
+++ b/configure
@@ -5259,7 +5259,7 @@ case "$slirp" in
   auto | enabled | internal)
     # Simpler to always update submodule, even if not needed.
     if test "$git_submodules_action" != "ignore"; then
-      git_submodules="${git_submodules} slirp"
+      git_submodules="${git_submodules} subprojects/libslirp"
     fi
     ;;
 esac
diff --git a/meson.build b/meson.build
index 80e9305d5a64..8b1e240a3ec3 100644
--- a/meson.build
+++ b/meson.build
@@ -1504,7 +1504,7 @@ slirp_opt = 'disabled'
 if have_system
   slirp_opt = get_option('slirp')
   if slirp_opt in ['enabled', 'auto', 'system']
-    have_internal = fs.exists(meson.current_source_dir() / 'slirp/meson.build')
+    have_internal = fs.exists(meson.current_source_dir() / 'subprojects/libslirp/meson.build')
     slirp = dependency('slirp', kwargs: static_kwargs,
                        method: 'pkg-config',
                        required: slirp_opt == 'system' or
@@ -1518,64 +1518,9 @@ if have_system
     endif
   endif
   if slirp_opt == 'internal'
-    slirp_deps = []
-    if targetos == 'windows'
-      slirp_deps = cc.find_library('iphlpapi')
-    endif
-    slirp_conf = configuration_data()
-    slirp_conf.set('SLIRP_MAJOR_VERSION', meson.project_version().split('.')[0])
-    slirp_conf.set('SLIRP_MINOR_VERSION', meson.project_version().split('.')[1])
-    slirp_conf.set('SLIRP_MICRO_VERSION', meson.project_version().split('.')[2])
-    slirp_conf.set_quoted('SLIRP_VERSION_STRING', meson.project_version())
-    slirp_cargs = ['-DG_LOG_DOMAIN="Slirp"']
-    slirp_files = [
-      'slirp/src/arp_table.c',
-      'slirp/src/bootp.c',
-      'slirp/src/cksum.c',
-      'slirp/src/dhcpv6.c',
-      'slirp/src/dnssearch.c',
-      'slirp/src/if.c',
-      'slirp/src/ip6_icmp.c',
-      'slirp/src/ip6_input.c',
-      'slirp/src/ip6_output.c',
-      'slirp/src/ip_icmp.c',
-      'slirp/src/ip_input.c',
-      'slirp/src/ip_output.c',
-      'slirp/src/mbuf.c',
-      'slirp/src/misc.c',
-      'slirp/src/ncsi.c',
-      'slirp/src/ndp_table.c',
-      'slirp/src/sbuf.c',
-      'slirp/src/slirp.c',
-      'slirp/src/socket.c',
-      'slirp/src/state.c',
-      'slirp/src/stream.c',
-      'slirp/src/tcp_input.c',
-      'slirp/src/tcp_output.c',
-      'slirp/src/tcp_subr.c',
-      'slirp/src/tcp_timer.c',
-      'slirp/src/tftp.c',
-      'slirp/src/udp.c',
-      'slirp/src/udp6.c',
-      'slirp/src/util.c',
-      'slirp/src/version.c',
-      'slirp/src/vmstate.c',
-    ]
-
-    configure_file(
-      input : 'slirp/src/libslirp-version.h.in',
-      output : 'libslirp-version.h',
-      configuration: slirp_conf)
-
-    slirp_inc = include_directories('slirp', 'slirp/src')
-    libslirp = static_library('slirp',
-                              build_by_default: false,
-                              sources: slirp_files,
-                              c_args: slirp_cargs,
-                              include_directories: slirp_inc)
-    slirp = declare_dependency(link_with: libslirp,
-                               dependencies: slirp_deps,
-                               include_directories: slirp_inc)
+    libslirp = subproject('libslirp',
+                          default_options: ['default_library=static'])
+    slirp = libslirp.get_variable('libslirp_dep')
   endif
 endif
 
diff --git a/slirp b/slirp
deleted file mode 160000
index 5dce846e3ee8..000000000000
--- a/slirp
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 5dce846e3ee82d93462bc637bb0db2fd49f0fc5a
diff --git a/subprojects/libslirp b/subprojects/libslirp
new file mode 160000
index 000000000000..bacb71f1c3ed
--- /dev/null
+++ b/subprojects/libslirp
@@ -0,0 +1 @@
+Subproject commit bacb71f1c3ed5f40e393afd8be81bedfba13a401

From 5db66c67b993632f5d0b158cf52eeb56845c0dbc Mon Sep 17 00:00:00 2001
From: Roman Bolshakov <r.bolshakov@yadro.com>
Date: Wed, 10 Feb 2021 13:55:27 +0300
Subject: [PATCH 022/180] util/osdep: Avoid mprotect() RWX->NONE on Big Sur
 11.2

There's a change in mprotect() behaviour [1] in the latest macOS on M1
and it's not yet clear if it's going to be fixed by Apple. For now we
can avoid unsupported mprotect() calls. QEMU and qtests work fine
without it.

1. https://gist.github.com/hikalium/75ae822466ee4da13cbbe486498a191f

Buglink: https://bugs.launchpad.net/qemu/+bug/1914849
Apple-Feedback: FB8994773
Signed-off-by: Roman Bolshakov <r.bolshakov@yadro.com>
Message-Id: <20210210105527.74943-1-r.bolshakov@yadro.com>
---
 util/osdep.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/util/osdep.c b/util/osdep.c
index 66d01b9160fb..1edd7b1caf9c 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -111,6 +111,12 @@ int qemu_mprotect_none(void *addr, size_t size)
 #ifdef _WIN32
     return qemu_mprotect__osdep(addr, size, PAGE_NOACCESS);
 #else
+# if defined(__APPLE__) && defined(__arm64__)
+    if (__builtin_available(macOS 11.2, *)) {
+        /* mprotect() in macOS 11.2 can't switch RWX to NONE */
+        return 0;
+    }
+# endif
     return qemu_mprotect__osdep(addr, size, PROT_NONE);
 #endif
 }

From a6b59f6dee48f0d9d858f5daa2e38e91aba7d949 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 4 Jan 2021 14:04:27 -0800
Subject: [PATCH 023/180] tcg: custom APRR implementation

---
 accel/tcg/cpu-exec.c        |   1 +
 accel/tcg/translate-all.c   |   1 +
 include/qemu/osdep.h        |  28 ----------
 include/tcg/tcg-apple-jit.h | 100 ++++++++++++++++++++++++++++++++++++
 tcg/tcg.c                   |   1 +
 util/osdep.c                |   4 ++
 6 files changed, 107 insertions(+), 28 deletions(-)
 create mode 100644 include/tcg/tcg-apple-jit.h

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index f62f12e717ca..07f8e3604a67 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -26,6 +26,7 @@
 #include "disas/disas.h"
 #include "exec/exec-all.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #include "qemu/atomic.h"
 #include "qemu/compiler.h"
 #include "qemu/timer.h"
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index f32df8b24042..0ca0a8c5c23c 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -27,6 +27,7 @@
 #include "disas/disas.h"
 #include "exec/exec-all.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #if defined(CONFIG_USER_ONLY)
 #include "qemu.h"
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index ba15be9c569c..5bd1a6776915 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -119,10 +119,6 @@ extern int daemon(int, int);
 #include "sysemu/os-posix.h"
 #endif
 
-#ifdef __APPLE__
-#include <AvailabilityMacros.h>
-#endif
-
 #include "glib-compat.h"
 #include "qemu/typedefs.h"
 
@@ -686,30 +682,6 @@ char *qemu_get_host_name(Error **errp);
  */
 size_t qemu_get_host_physmem(void);
 
-/*
- * Toggle write/execute on the pages marked MAP_JIT
- * for the current thread.
- */
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_11_0
-static inline void qemu_thread_jit_execute(void)
-{
-    if (__builtin_available(macOS 11.0, *)) {
-        pthread_jit_write_protect_np(true);
-    }
-}
-
-static inline void qemu_thread_jit_write(void)
-{
-    if (__builtin_available(macOS 11.0, *)) {
-        pthread_jit_write_protect_np(false);
-    }
-}
-#else
-static inline void qemu_thread_jit_write(void) {}
-static inline void qemu_thread_jit_execute(void) {}
-#endif
-
 /**
  * Platforms which do not support system() return ENOSYS
  */
diff --git a/include/tcg/tcg-apple-jit.h b/include/tcg/tcg-apple-jit.h
new file mode 100644
index 000000000000..7f25dab809a3
--- /dev/null
+++ b/include/tcg/tcg-apple-jit.h
@@ -0,0 +1,100 @@
+/*
+ * Apple Silicon functions for JIT handling
+ *
+ * Copyright (c) 2020 osy
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TCG_APPLE_JIT_H
+#define TCG_APPLE_JIT_H
+
+/*
+ * APRR handling
+ * Credits to: https://siguza.github.io/APRR/
+ * Reversed from /usr/lib/system/libsystem_pthread.dylib
+ */
+
+#if defined(__aarch64__) && defined(CONFIG_DARWIN)
+
+#define _COMM_PAGE_START_ADDRESS        (0x0000000FFFFFC000ULL) /* In TTBR0 */
+#define _COMM_PAGE_APRR_SUPPORT         (_COMM_PAGE_START_ADDRESS + 0x10C)
+#define _COMM_PAGE_APPR_WRITE_ENABLE    (_COMM_PAGE_START_ADDRESS + 0x110)
+#define _COMM_PAGE_APRR_WRITE_DISABLE   (_COMM_PAGE_START_ADDRESS + 0x118)
+
+static __attribute__((__always_inline__)) bool jit_write_protect_supported(void)
+{
+    /* Access shared kernel page at fixed memory location. */
+    uint8_t aprr_support = *(volatile uint8_t *)_COMM_PAGE_APRR_SUPPORT;
+    return aprr_support > 0;
+}
+
+/* write protect enable = write disable */
+static __attribute__((__always_inline__)) void jit_write_protect(int enabled)
+{
+    /* Access shared kernel page at fixed memory location. */
+    uint8_t aprr_support = *(volatile uint8_t *)_COMM_PAGE_APRR_SUPPORT;
+    if (aprr_support == 0 || aprr_support > 3) {
+        return;
+    } else if (aprr_support == 1) {
+        __asm__ __volatile__ (
+            "mov x0, %0\n"
+            "ldr x0, [x0]\n"
+            "msr S3_4_c15_c2_7, x0\n"
+            "isb sy\n"
+            :: "r" (enabled ? _COMM_PAGE_APRR_WRITE_DISABLE
+                            : _COMM_PAGE_APPR_WRITE_ENABLE)
+            : "memory", "x0"
+        );
+    } else {
+        __asm__ __volatile__ (
+            "mov x0, %0\n"
+            "ldr x0, [x0]\n"
+            "msr S3_6_c15_c1_5, x0\n"
+            "isb sy\n"
+            :: "r" (enabled ? _COMM_PAGE_APRR_WRITE_DISABLE
+                            : _COMM_PAGE_APPR_WRITE_ENABLE)
+            : "memory", "x0"
+        );
+    }
+}
+
+#else /* defined(__aarch64__) && defined(CONFIG_DARWIN) */
+
+static __attribute__((__always_inline__)) bool jit_write_protect_supported(void)
+{
+    return false;
+}
+
+static __attribute__((__always_inline__)) void jit_write_protect(int enabled)
+{
+}
+
+#endif
+
+static inline void qemu_thread_jit_execute(void)
+{
+    if (jit_write_protect_supported()) {
+        jit_write_protect(true);
+    }
+}
+
+static inline void qemu_thread_jit_write(void)
+{
+    if (jit_write_protect_supported()) {
+        jit_write_protect(false);
+    }
+}
+
+#endif /* define TCG_APPLE_JIT_H */
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 1fbe0b686d57..5b0750685102 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -49,6 +49,7 @@
 #include "hw/boards.h"
 #endif
 
+#include "tcg/tcg-apple-jit.h"
 #include "tcg/tcg-op.h"
 
 #if UINTPTR_MAX == UINT32_MAX
diff --git a/util/osdep.c b/util/osdep.c
index 1edd7b1caf9c..cb20608292ef 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -39,6 +39,10 @@ extern int madvise(char *, size_t, int);
 #include "qemu/error-report.h"
 #include "monitor/monitor.h"
 
+#ifdef CONFIG_DARWIN
+#include "tcg/tcg-apple-jit.h"
+#endif
+
 static bool fips_enabled = false;
 
 static const char *hw_version = QEMU_HW_VERSION;

From ad73633ab31a025128b70e847fb3a2a77e295247 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sun, 3 Jan 2021 08:58:11 -0800
Subject: [PATCH 024/180] coroutine: add libucontext as external library

iOS does not support ucontext natively for aarch64 and the sigaltstack is
also unsupported (even worse, it fails silently, see:
https://openradar.appspot.com/13002712 )

As a workaround we include a library implementation of ucontext and add it
as a build option.
---
 .gitmodules               |  3 +++
 configure                 | 23 ++++++++++++++++++++---
 meson.build               | 12 +++++++++++-
 meson_options.txt         |  2 ++
 subprojects/libucontext   |  1 +
 util/coroutine-ucontext.c |  9 +++++++++
 6 files changed, 46 insertions(+), 4 deletions(-)
 create mode 160000 subprojects/libucontext

diff --git a/.gitmodules b/.gitmodules
index c28831c50ab4..33f90687266b 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -64,3 +64,6 @@
 [submodule "roms/vbootrom"]
 	path = roms/vbootrom
 	url = https://gitlab.com/qemu-project/vbootrom.git
+[submodule "libucontext"]
+	path = subprojects/libucontext
+	url = https://github.com/utmapp/libucontext.git
diff --git a/configure b/configure
index 12de8035e42d..1c5c9fc0f06a 100755
--- a/configure
+++ b/configure
@@ -1785,7 +1785,7 @@ Advanced options (experts only):
   --oss-lib                path to OSS library
   --cpu=CPU                Build for host CPU [$cpu]
   --with-coroutine=BACKEND coroutine backend. Supported options:
-                           ucontext, sigaltstack, windows
+                           ucontext, libucontext, sigaltstack, windows
   --enable-gcov            enable test coverage analysis with gcov
   --disable-blobs          disable installing provided firmware blobs
   --with-vss-sdk=SDK-path  enable Windows VSS support in QEMU Guest Agent
@@ -4521,6 +4521,8 @@ if test "$coroutine" = ""; then
     coroutine=win32
   elif test "$ucontext_works" = "yes"; then
     coroutine=ucontext
+  elif test "$ios" = "yes"; then
+    coroutine=libucontext
   else
     coroutine=sigaltstack
   fi
@@ -4544,12 +4546,27 @@ else
       error_exit "only the 'windows' coroutine backend is valid for Windows"
     fi
     ;;
+  libucontext)
+  ;;
   *)
     error_exit "unknown coroutine backend $coroutine"
     ;;
   esac
 fi
 
+case $coroutine in
+libucontext)
+  git_submodules="${git_submodules} subprojects/libucontext"
+  mkdir -p libucontext
+  coroutine_impl=ucontext
+  libucontext="enabled"
+  ;;
+*)
+  coroutine_impl=$coroutine
+  libucontext="disabled"
+  ;;
+esac
+
 if test "$coroutine_pool" = ""; then
   coroutine_pool=yes
 fi
@@ -5886,7 +5903,7 @@ if test "$qom_cast_debug" = "yes" ; then
   echo "CONFIG_QOM_CAST_DEBUG=y" >> $config_host_mak
 fi
 
-echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
+echo "CONFIG_COROUTINE_BACKEND=$coroutine_impl" >> $config_host_mak
 if test "$coroutine_pool" = "yes" ; then
   echo "CONFIG_COROUTINE_POOL=1" >> $config_host_mak
 else
@@ -6449,7 +6466,7 @@ NINJA=$ninja $meson setup \
         -Dlibnfs=$libnfs -Diconv=$iconv -Dcurses=$curses -Dlibudev=$libudev\
         -Drbd=$rbd -Dlzo=$lzo -Dsnappy=$snappy -Dlzfse=$lzfse \
         -Dzstd=$zstd -Dseccomp=$seccomp -Dvirtfs=$virtfs -Dcap_ng=$cap_ng \
-        -Dattr=$attr -Ddefault_devices=$default_devices \
+        -Dattr=$attr -Ddefault_devices=$default_devices -Ducontext=$libucontext \
         -Ddocs=$docs -Dsphinx_build=$sphinx_build -Dinstall_blobs=$blobs \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
diff --git a/meson.build b/meson.build
index 8b1e240a3ec3..7968c40f630f 100644
--- a/meson.build
+++ b/meson.build
@@ -1583,9 +1583,18 @@ if not fdt.found() and fdt_required.length() > 0
   error('fdt not available but required by targets ' + ', '.join(fdt_required))
 endif
 
+ucontext = dependency('libucontext', kwargs: static_kwargs, required : false)
+if not ucontext.found() and get_option('ucontext').enabled()
+  libucontext_proj = subproject('libucontext',
+                                default_options: ['default_library=static',
+                                                  'freestanding=true'])
+  ucontext = libucontext_proj.get_variable('libucontext_dep')
+endif
+
 config_host_data.set('CONFIG_CAPSTONE', capstone.found())
 config_host_data.set('CONFIG_FDT', fdt.found())
 config_host_data.set('CONFIG_SLIRP', slirp.found())
+config_host_data.set('CONFIG_LIBUCONTEXT', ucontext.found())
 
 #####################
 # Generated sources #
@@ -1833,7 +1842,7 @@ util_ss.add_all(trace_ss)
 util_ss = util_ss.apply(config_all, strict: false)
 libqemuutil = static_library('qemuutil',
                              sources: util_ss.sources() + stub_ss.sources() + genh,
-                             dependencies: [util_ss.dependencies(), m, glib, socket, malloc])
+                             dependencies: [util_ss.dependencies(), m, glib, socket, malloc, ucontext])
 qemuutil = declare_dependency(link_with: libqemuutil,
                               sources: genh + version_res)
 
@@ -2577,6 +2586,7 @@ summary(summary_info, bool_yn: true, section: 'Targets and accelerators')
 
 # Block layer
 summary_info = {}
+summary_info += {'libucontext support': ucontext.found()}
 summary_info += {'coroutine backend': config_host['CONFIG_COROUTINE_BACKEND']}
 summary_info += {'coroutine pool':    config_host['CONFIG_COROUTINE_POOL'] == '1'}
 if have_block
diff --git a/meson_options.txt b/meson_options.txt
index 4594d42769d6..6c29ea93300a 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -110,6 +110,8 @@ option('fuse', type: 'feature', value: 'auto',
        description: 'FUSE block device export')
 option('fuse_lseek', type : 'feature', value : 'auto',
        description: 'SEEK_HOLE/SEEK_DATA support for FUSE exports')
+option('ucontext', type : 'feature', value : 'disabled',
+       description: 'libucontext support')
 
 option('vhost_user_blk_server', type: 'feature', value: 'auto',
        description: 'build vhost-user-blk server')
diff --git a/subprojects/libucontext b/subprojects/libucontext
new file mode 160000
index 000000000000..9b1d8f01a6e9
--- /dev/null
+++ b/subprojects/libucontext
@@ -0,0 +1 @@
+Subproject commit 9b1d8f01a6e99166f9808c79966abe10786de8b6
diff --git a/util/coroutine-ucontext.c b/util/coroutine-ucontext.c
index 904b375192ca..220c57a743af 100644
--- a/util/coroutine-ucontext.c
+++ b/util/coroutine-ucontext.c
@@ -23,7 +23,16 @@
 #undef _FORTIFY_SOURCE
 #endif
 #include "qemu/osdep.h"
+#if defined(CONFIG_LIBUCONTEXT)
+#include <libucontext/libucontext.h>
+#define ucontext_t libucontext_ucontext_t
+#define getcontext libucontext_getcontext
+#define setcontext libucontext_setcontext
+#define swapcontext libucontext_swapcontext
+#define makecontext libucontext_makecontext
+#else
 #include <ucontext.h>
+#endif
 #include "qemu/coroutine_int.h"
 
 #ifdef CONFIG_VALGRIND_H

From 6c39f9e99bd7c284d2328026ff6ab0b509a43fbd Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Sat, 27 Mar 2021 15:46:31 -0600
Subject: [PATCH 025/180] get building for an iOS target, as well

---
 block/file-posix.c      | 21 +++++++++++++++++++++
 configure               | 41 ++++++++++++++++++++++++++++++++++++++++-
 include/qemu/osdep.h    |  2 +-
 meson.build             |  7 +++----
 tests/qtest/meson.build |  4 ++--
 5 files changed, 67 insertions(+), 8 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index dcd2a2375bfe..913b82210ba3 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -279,6 +279,13 @@ static int raw_normalize_devicepath(const char **filename, Error **errp)
 }
 #endif
 
+#if defined(CONFIG_IOS)
+static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
+{
+    return -ENOTSUP; /* not supported on iOS */
+}
+#else /* CONFIG_IOS */
+
 /*
  * Get logical block size via ioctl. On success store it in @sector_size_p.
  */
@@ -312,6 +319,8 @@ static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
     return success ? 0 : -errno;
 }
 
+#endif
+
 /**
  * Get physical block size of @fd.
  * On success, store it in @blk_size and return 0.
@@ -1403,12 +1412,24 @@ static bool preadv_present = true;
 static ssize_t
 qemu_preadv(int fd, const struct iovec *iov, int nr_iov, off_t offset)
 {
+#ifdef CONFIG_DARWIN /* preadv introduced in macOS 11 */
+    if (!__builtin_available(macOS 11, iOS 14, watchOS 7, tvOS 14, *)) {
+        preadv_present = false;
+        return -ENOSYS;
+    } else
+#endif
     return preadv(fd, iov, nr_iov, offset);
 }
 
 static ssize_t
 qemu_pwritev(int fd, const struct iovec *iov, int nr_iov, off_t offset)
 {
+#ifdef CONFIG_DARWIN /* pwritev introduced in macOS 11 */
+    if (!__builtin_available(macOS 11, iOS 14, watchOS 7, tvOS 14, *)) {
+        preadv_present = false;
+        return -ENOSYS;
+    } else
+#endif
     return pwritev(fd, iov, nr_iov, offset);
 }
 
diff --git a/configure b/configure
index 1c5c9fc0f06a..edb2a5257f9c 100755
--- a/configure
+++ b/configure
@@ -572,6 +572,21 @@ EOF
   compile_object
 }
 
+check_ios() {
+  cat > $TMPC <<EOF
+#ifdef __APPLE__
+#import "TargetConditionals.h"
+#if !TARGET_OS_IPHONE
+#error TARGET_OS_IPHONE not true
+#endif
+#endif
+int main(void) { return 0; }
+EOF
+  compile_object
+}
+
+
+
 check_include() {
 cat > $TMPC <<EOF
 #include <$1>
@@ -614,7 +629,11 @@ elif check_define __DragonFly__ ; then
 elif check_define __NetBSD__; then
   targetos='NetBSD'
 elif check_define __APPLE__; then
-  targetos='Darwin'
+  if check_ios ; then
+    targetos='iOS'
+  else
+    targetos='Darwin'
+  fi
 else
   # This is a fatal error, but don't report it yet, because we
   # might be going to just print the --help text, or it might
@@ -630,6 +649,22 @@ case $targetos in
 Darwin)
   HOST_DSOSUF=".dylib"
   ;;
+iOS)
+  bsd="yes"
+  darwin="yes"
+  ios="yes"
+  if [ "$cpu" = "x86_64" ] ; then
+    QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
+    QEMU_LDFLAGS="-arch x86_64 $QEMU_LDFLAGS"
+  fi
+  host_block_device_support="no"
+  audio_drv_list=""
+  audio_possible_drivers=""
+  QEMU_LDFLAGS="-framework CoreFoundation $QEMU_LDFLAGS"
+  # Disable attempts to use ObjectiveC features in os/object.h since they
+  # won't work when we're compiling with gcc as a C compiler.
+  QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
+;;
 SunOS)
   # $(uname -m) returns i86pc even on an x86_64 box, so default based on isainfo
   if test -z "$cpu" && test "$(isainfo -k)" = "amd64"; then
@@ -5551,6 +5586,10 @@ if test "$darwin" = "yes" ; then
   echo "CONFIG_DARWIN=y" >> $config_host_mak
 fi
 
+if test "$ios" = "yes" ; then
+  echo "CONFIG_IOS=y" >> $config_host_mak
+fi
+
 if test "$solaris" = "yes" ; then
   echo "CONFIG_SOLARIS=y" >> $config_host_mak
 fi
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index 5bd1a6776915..76cfa8f83562 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -685,7 +685,7 @@ size_t qemu_get_host_physmem(void);
 /**
  * Platforms which do not support system() return ENOSYS
  */
-#ifndef HAVE_SYSTEM_FUNCTION
+#if !defined(HAVE_SYSTEM_FUNCTION) || defined(CONFIG_IOS)
 #define system platform_does_not_support_system
 static inline int platform_does_not_support_system(const char *command)
 {
diff --git a/meson.build b/meson.build
index 7968c40f630f..6c758cb0c8ad 100644
--- a/meson.build
+++ b/meson.build
@@ -181,7 +181,7 @@ if targetos == 'windows'
                                       include_directories: include_directories('.'))
 elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
-  iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
+  iokit = dependency('appleframeworks', modules: 'IOKit', required: 'CONFIG_IOS' not in config_host)
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
             cc.find_library('nsl'),
@@ -1056,8 +1056,7 @@ if get_option('cfi')
   add_global_link_arguments(cfi_flags, native: false, language: ['c', 'cpp', 'objc'])
 endif
 
-have_host_block_device = (targetos != 'darwin' or
-    cc.has_header('IOKit/storage/IOMedia.h'))
+have_host_block_device = (targetos != 'darwin' or (cc.has_header('IOKit/storage/IOMedia.h') and ('CONFIG_IOS' not in config_host)))
 
 #################
 # config-host.h #
@@ -1153,7 +1152,7 @@ config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
 config_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))
 config_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)
-config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h'))
+config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h') and ('CONFIG_IOS' not in config_host))
 
 config_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))
 
diff --git a/tests/qtest/meson.build b/tests/qtest/meson.build
index 902cfef7cb2f..5d2b43c7c6ce 100644
--- a/tests/qtest/meson.build
+++ b/tests/qtest/meson.build
@@ -68,12 +68,11 @@ qtests_i386 = \
   (config_all_devices.has_key('CONFIG_TPM_TIS_ISA') ? ['tpm-tis-swtpm-test'] : []) +        \
   (config_all_devices.has_key('CONFIG_RTL8139_PCI') ? ['rtl8139-test'] : []) +              \
   (config_all_devices.has_key('CONFIG_E1000E_PCI_EXPRESS') ? ['fuzz-e1000e-test'] : []) +   \
+  (not config_host.has_key('CONFIG_IOS') ? ['bios-tables-test', 'hd-geo-test'] : []) +      \
   qtests_pci +                                                                              \
   ['fdc-test',
    'ide-test',
-   'hd-geo-test',
    'boot-order-test',
-   'bios-tables-test',
    'rtc-test',
    'i440fx-test',
    'fw_cfg-test',
@@ -182,6 +181,7 @@ qtests_aarch64 = \
   (cpu != 'arm' ? ['bios-tables-test'] : []) +                                                  \
   (config_all_devices.has_key('CONFIG_TPM_TIS_SYSBUS') ? ['tpm-tis-device-test'] : []) +        \
   (config_all_devices.has_key('CONFIG_TPM_TIS_SYSBUS') ? ['tpm-tis-device-swtpm-test'] : []) +  \
+  (cpu != 'arm' and not config_host.has_key('CONFIG_IOS') ? ['bios-tables-test'] : []) + \
   ['arm-cpu-features',
    'numa-test',
    'boot-serial-test',

From 1e4d72b004c26724cd049798b3370492016cd3b0 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Mon, 29 Mar 2021 13:26:08 -0600
Subject: [PATCH 026/180] TCTI: add TCTI TCG backend for acceleration on
 non-JIT AArch64

---
 accel/tcg/translate-all.c             |    6 +-
 configure                             |   10 +-
 disas.c                               |    2 +
 include/disas/dis-asm.h               |    1 +
 include/exec/exec-all.h               |    4 +
 include/tcg/tcg.h                     |    2 +-
 meson.build                           |   24 +
 meson_options.txt                     |    2 +
 scripts/mtest2make.py                 |   24 +-
 tcg/aarch64-tcti/README.md            | 1026 +++++++++++++++++++
 tcg/aarch64-tcti/tcg-target-con-set.h |   21 +
 tcg/aarch64-tcti/tcg-target-con-str.h |   11 +
 tcg/aarch64-tcti/tcg-target.c.inc     | 1347 +++++++++++++++++++++++++
 tcg/aarch64-tcti/tcg-target.h         |  220 ++++
 tcg/aarch64-tcti/tcti-gadget-gen.py   |  788 +++++++++++++++
 tcg/tcg.c                             |   14 +-
 16 files changed, 3476 insertions(+), 26 deletions(-)
 create mode 100644 tcg/aarch64-tcti/README.md
 create mode 100644 tcg/aarch64-tcti/tcg-target-con-set.h
 create mode 100644 tcg/aarch64-tcti/tcg-target-con-str.h
 create mode 100644 tcg/aarch64-tcti/tcg-target.c.inc
 create mode 100644 tcg/aarch64-tcti/tcg-target.h
 create mode 100755 tcg/aarch64-tcti/tcti-gadget-gen.py

diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index 0ca0a8c5c23c..b25b17e44c84 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -1129,7 +1129,7 @@ static bool alloc_code_gen_buffer_anon(size_t size, int prot,
     return true;
 }
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 #ifdef CONFIG_POSIX
 #include "qemu/memfd.h"
 
@@ -1256,7 +1256,7 @@ static bool alloc_code_gen_buffer_splitwx_vmremap(size_t size, Error **errp)
 
 static bool alloc_code_gen_buffer_splitwx(size_t size, Error **errp)
 {
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 # ifdef CONFIG_DARWIN
     return alloc_code_gen_buffer_splitwx_vmremap(size, errp);
 # endif
@@ -1289,7 +1289,7 @@ static bool alloc_code_gen_buffer(size_t size, int splitwx, Error **errp)
 
     prot = PROT_READ | PROT_WRITE | PROT_EXEC;
     flags = MAP_PRIVATE | MAP_ANONYMOUS;
-#ifdef CONFIG_TCG_INTERPRETER
+#if defined(CONFIG_TCG_INTERPRETER) || defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* The tcg interpreter does not need execute permission. */
     prot = PROT_READ | PROT_WRITE;
 #elif defined(CONFIG_DARWIN)
diff --git a/configure b/configure
index edb2a5257f9c..d0053845169c 100755
--- a/configure
+++ b/configure
@@ -362,6 +362,7 @@ tsan="no"
 fortify_source="$default_feature"
 strip_opt="yes"
 tcg_interpreter="false"
+tcg_threaded_interpreter="false"
 bigendian="no"
 mingw32="no"
 gcov="no"
@@ -1150,6 +1151,10 @@ for opt do
   ;;
   --enable-tcg-interpreter) tcg_interpreter="true"
   ;;
+  --disable-tcg-tcti) tcg_threaded_interpreter="false"
+  ;;
+  --enable-tcg-tcti) tcg_threaded_interpreter="true"
+  ;;
   --disable-cap-ng)  cap_ng="disabled"
   ;;
   --enable-cap-ng) cap_ng="enabled"
@@ -6510,9 +6515,8 @@ NINJA=$ninja $meson setup \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
         $(if test "$default_features" = no; then echo "-Dauto_features=disabled"; fi) \
-	-Dtcg_interpreter=$tcg_interpreter -Dshared_lib=$shared_lib \
-        $cross_arg \
-        "$PWD" "$source_path"
+	-Dtcg_interpreter=$tcg_interpreter -Dtcg_threaded_interpreter=$tcg_threaded_interpreter\
+	-Dshared_lib=$shared_lib $cross_arg "$PWD" "$source_path"
 
 if test "$?" -ne 0 ; then
     error_exit "meson setup failed"
diff --git a/disas.c b/disas.c
index a61f95b580b8..cea0f9019e49 100644
--- a/disas.c
+++ b/disas.c
@@ -152,6 +152,8 @@ static void initialize_debug_host(CPUDebug *s)
 #endif
 #if defined(CONFIG_TCG_INTERPRETER)
     s->info.print_insn = print_insn_tci;
+#elif defined(CONFIG_TCG_THREADED_INTERPRETER)
+    s->info.print_insn = print_insn_tcti;
 #elif defined(__i386__)
     s->info.mach = bfd_mach_i386_i386;
     s->info.print_insn = print_insn_i386;
diff --git a/include/disas/dis-asm.h b/include/disas/dis-asm.h
index 13fa1edd411e..ded69ba2ffaa 100644
--- a/include/disas/dis-asm.h
+++ b/include/disas/dis-asm.h
@@ -411,6 +411,7 @@ typedef struct disassemble_info {
 typedef int (*disassembler_ftype) (bfd_vma, disassemble_info *);
 
 int print_insn_tci(bfd_vma, disassemble_info*);
+int print_insn_tcti(bfd_vma, disassemble_info*);
 int print_insn_big_mips         (bfd_vma, disassemble_info*);
 int print_insn_little_mips      (bfd_vma, disassemble_info*);
 int print_insn_nanomips         (bfd_vma, disassemble_info*);
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index 6b036cae8f65..a8f2295decd2 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -543,7 +543,11 @@ void tb_set_jmp_target(TranslationBlock *tb, int n, uintptr_t addr);
 #if defined(CONFIG_TCG_INTERPRETER)
 extern __thread uintptr_t tci_tb_ptr;
 # define GETPC() tci_tb_ptr
+#elif defined(CONFIG_TCG_THREADED_INTERPRETER)
+extern __thread uintptr_t tcti_call_return_address;
+# define GETPC() tcti_call_return_address
 #else
+/* Note that this is correct for TCTI also; whose gadget behaves like native code. */
 # define GETPC() \
     ((uintptr_t)__builtin_extract_return_addr(__builtin_return_address(0)))
 #endif
diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 0f0695e90da2..cfcd069bf3f6 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -1296,7 +1296,7 @@ static inline unsigned get_mmuidx(TCGMemOpIdx oi)
 #define TB_EXIT_IDXMAX    1
 #define TB_EXIT_REQUESTED 3
 
-#ifdef CONFIG_TCG_INTERPRETER
+#if defined(CONFIG_TCG_INTERPRETER) || defined(CONFIG_TCG_THREADED_INTERPRETER)
 uintptr_t tcg_qemu_tb_exec(CPUArchState *env, const void *tb_ptr);
 #else
 typedef uintptr_t tcg_prologue_fn(CPUArchState *env, const void *tb_ptr);
diff --git a/meson.build b/meson.build
index 6c758cb0c8ad..2bcd98dd0865 100644
--- a/meson.build
+++ b/meson.build
@@ -58,6 +58,7 @@ python = import('python').find_installation()
 supported_oses = ['windows', 'freebsd', 'netbsd', 'openbsd', 'darwin', 'sunos', 'linux']
 supported_cpus = ['ppc', 'ppc64', 's390x', 'riscv32', 'riscv64', 'x86', 'x86_64',
   'arm', 'aarch64', 'mips', 'mips64', 'sparc', 'sparc64']
+tcti_supported_cpus = ['aarch64']
 
 cpu = host_machine.cpu_family()
 targetos = host_machine.system()
@@ -246,6 +247,25 @@ if not get_option('tcg').disabled()
   endif
   if get_option('tcg_interpreter')
     tcg_arch = 'tci'
+  elif get_option('tcg_threaded_interpreter')
+    if cpu not in tcti_supported_cpus
+      error('Unsupported CPU @0@ for TCTI, try --enable-tcg-interpreter'.format(cpu))
+    else
+      warning('TCTI is extremely experimental and incomplete! Things might break!')
+      tcg_arch = '@0@-tcti'.format(cpu)
+    endif
+
+    # Tell our compiler how to generate our TCTI gadgets.
+    gadget_generator = 'tcg/@0@/tcti-gadget-gen.py'.format(tcg_arch)
+    tcti_gadgets = custom_target('tcti-gadgets.c.inc',
+                                output: 'tcti-gadgets.c.inc',
+                                input: gadget_generator,
+                                command: [find_program(gadget_generator), '@OUTPUT@'],
+                                build_by_default: true,
+                                build_always_stale: false)
+
+    genh += tcti_gadgets
+    
   elif config_host['ARCH'] == 'sparc64'
     tcg_arch = 'sparc'
   elif config_host['ARCH'] == 's390x'
@@ -1280,6 +1300,8 @@ foreach target : target_dirs
       config_all += { sym: 'y' }
       if sym == 'CONFIG_TCG' and tcg_arch == 'tci'
         config_target += { 'CONFIG_TCG_INTERPRETER': 'y' }
+      elif sym == 'CONFIG_TCG' and tcg_arch.endswith('tcti')
+        config_target += { 'CONFIG_TCG_THREADED_INTERPRETER': 'y' }
       elif sym == 'CONFIG_XEN' and have_xen_pci_passthrough
         config_target += { 'CONFIG_XEN_PCI_PASSTHROUGH': 'y' }
       endif
@@ -2571,6 +2593,8 @@ summary_info += {'TCG support':       config_all.has_key('CONFIG_TCG')}
 if config_all.has_key('CONFIG_TCG')
   if get_option('tcg_interpreter')
     summary_info += {'TCG backend':   'TCI (TCG with bytecode interpreter, experimental and slow)'}
+  elif get_option('tcg_threaded_interpreter')
+    summary_info += {'TCG backend':   'TCTI (TCG with threaded-dispatch bytecode interpreter, experimental and slow; but faster than TCI)'}
   else
     summary_info += {'TCG backend':   'native (@0@)'.format(cpu)}
   endif
diff --git a/meson_options.txt b/meson_options.txt
index 6c29ea93300a..5aa68672c2ff 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -43,6 +43,8 @@ option('tcg', type: 'feature', value: 'auto',
        description: 'TCG support')
 option('tcg_interpreter', type: 'boolean', value: false,
        description: 'TCG with bytecode interpreter (experimental and slow)')
+option('tcg_threaded_interpreter', type: 'boolean', value: false,
+       description: 'TCG with threaded-dispatch bytecode interpreter (experimental and slow, but less slow than TCI)')
 option('cfi', type: 'boolean', value: 'false',
        description: 'Control-Flow Integrity (CFI)')
 option('cfi_debug', type: 'boolean', value: 'false',
diff --git a/scripts/mtest2make.py b/scripts/mtest2make.py
index ee072c05025a..b0467ab56545 100644
--- a/scripts/mtest2make.py
+++ b/scripts/mtest2make.py
@@ -75,18 +75,18 @@ def process_tests(test, targets, suites):
     print('run-test-%d: $(.test.deps.%d)' % (i,i))
     print('\t@$(call .test.run,%d,$(.test.output-format))' % (i,))
 
-    test_suites = test['suite'] or ['default']
-    is_slow = any(s.endswith('-slow') for s in test_suites)
-    for s in test_suites:
-        # The suite name in the introspection info is "PROJECT:SUITE"
-        s = s.split(':')[1]
-        if s.endswith('-slow'):
-            s = s[:-5]
-        if is_slow:
-            suites[s].slow_tests.append(i)
-        else:
-            suites[s].tests.append(i)
-        suites[s].executables.add(executable)
+    #test_suites = test['suite'] or ['default']
+    #is_slow = any(s.endswith('-slow') for s in test_suites)
+    #for s in test_suites:
+    #    # The suite name in the introspection info is "PROJECT:SUITE"
+    #    s = s.split(':')[1]
+    #    if s.endswith('-slow'):
+    #        s = s[:-5]
+    #    if is_slow:
+    #        suites[s].slow_tests.append(i)
+    #    else:
+    #        suites[s].tests.append(i)
+    #    suites[s].executables.add(executable)
 
 def emit_prolog(suites, prefix):
     all_tap = ' '.join(('%s-report-%s.tap' % (prefix, k) for k in suites.keys()))
diff --git a/tcg/aarch64-tcti/README.md b/tcg/aarch64-tcti/README.md
new file mode 100644
index 000000000000..eb848e5a9e57
--- /dev/null
+++ b/tcg/aarch64-tcti/README.md
@@ -0,0 +1,1026 @@
+# QEMU Tiny-Code Threaded Interpreter (AArch64)
+
+A TCG backend that chains together JOP/ROP-ish gadgets to massively reduce interpreter overhead vs TCI.
+Platform-dependent; but usable when JIT isn't available; e.g. on platforms that lack WX mappings. The general idea squish the addresses of a gadget sequence into a "queue" and then write each gadget so it ends in a "dequeue-jump".
+
+Execution occurs by jumping into the first gadget, and letting it just play back some linear-overhead native code sequences for a while.
+
+Since TCG-TCI is optimized for sets of 16 GP registers and aarch64 has 30, we could easily keep JIT/QEMU and guest state separate, and since 16\*16 is reasonably small we could actually have a set of reasonable gadgets for each combination of operands.
+
+
+## Register Convention
+
+| Regs    | Use                   |
+| :------ | :-------------------- |
+| x1-x15  | Guest Registers       |
+| x24     | TCTI temporary        |
+| x25     | saved IP during call  |
+| x26     | TCTI temporary        |
+| x27     | TCTI temporary        |
+| x28     | Thread-stream pointer |
+| x30     | Link register         |
+| SP      | Stack Pointer, host   |
+| PC      | Program Counter, host |
+
+In pseudocode:
+
+| Symbol | Meaning                             |
+| :----- | :---------------------------------- |
+| Rd     | stand-in for destination register   |
+| Rn     | stand-in for first source register  |
+| Rm     | stand-in for second source register |
+
+## Gadget Structure
+
+### End of gadget
+
+Each gadget ends by advancing our bytecode pointer, and then executing from thew new location.
+
+```asm
+# Load our next gadget address from our bytecode stream, advancing it, and jump to the next gadget.
+
+ldr x27, [x28], #8\n
+br x27
+```
+
+## Calling into QEMU's C codebase
+
+When calling into C, we lose control over which registers are used. Accordingly, we'll need to save
+registers relevant to TCTI:
+
+```asm
+str x25,      [sp, #-16]!
+stp x14, x15, [sp, #-16]!
+stp x12, x13, [sp, #-16]!
+stp x10, x11, [sp, #-16]!
+stp x8,  x9,  [sp, #-16]!
+stp x6,  x7,  [sp, #-16]!
+stp x4,  x5,  [sp, #-16]!
+stp x2,  x3,  [sp, #-16]!
+stp x0,  x1,  [sp, #-16]!
+stp x28, lr,  [sp, #-16]!
+```
+
+Upon returning to the gadget stream, we'll then restore them.
+
+```asm
+ldp x28, lr, [sp], #16
+ldp x0,  x1, [sp], #16
+ldp x2,  x3, [sp], #16
+ldp x4,  x5, [sp], #16
+ldp x6,  x7, [sp], #16
+ldp x8,  x9, [sp], #16
+ldp x10, x11, [sp], #16
+ldp x12, x13, [sp], #16
+ldp x14, x15, [sp], #16
+ldr x25,      [sp], #16
+```
+
+## TCG Operations
+
+Each operation needs an implementation for every platform; and probably a set of gadgets for each possible set of operands.
+
+At 14 GP registers, that means that
+
+1 operand =\> 16 gadgets
+2 operands =\> 256 gadgets
+3 operands =\> 4096 gadgets
+
+### call
+
+Calls a helper function by address.
+
+**IR Format**: `br <ptr address>`  
+**Gadget type:** single
+
+```asm
+    # Get our C runtime function's location as a pointer-sized immediate...
+    "ldr x27, [x28], #8",
+
+    # Store our TB return address for our helper. This is necessary so the GETPC()
+    # macro works correctly as used in helper functions.
+    "str x28, [x25]",
+
+    # Prepare ourselves to call into our C runtime...
+    *C_CALL_PROLOGUE,
+
+    # ... perform the call itself ...
+    "blr x27",
+
+    # Save the result of our call for later.
+    "mov x27, x0",
+
+    # ... and restore our environment.
+    *C_CALL_EPILOGUE,
+
+    # Restore our return value.
+    "mov x0, x27"
+```
+
+### br
+
+Branches to a given immediate address. Branches are
+
+**IR Format**: `br <ptr address>`  
+**Gadget type:** single
+
+```asm
+# Use our immediate argument as our new bytecode-pointer location.
+ldr x28, [x28]
+```
+
+### setcond_i32
+
+Performs a comparison between two 32-bit operands.
+
+**IR Format**: `setcond32 <cond>, Rd, Rn, Rm`  
+**Gadget type:** treated as 10 operations with variants for every `Rd`/`Rn`/`Rm` (40,960)
+
+```asm
+subs Wd, Wn, Wm
+cset Wd, <cond>
+```
+
+| QEMU Cond | AArch64 Cond |
+| :-------- | :----------- |
+| EQ        | EQ           |
+| NE        | NE           |
+| LT        | LT           |
+| GE        | GE           |
+| LE        | LE           |
+| GT        | GT           |
+| LTU       | LO           |
+| GEU       | HS           |
+| LEU       | LS           |
+| GTU       | HI           |
+
+### setcond_i64
+
+Performs a comparison between two 32-bit operands.
+
+**IR Format**: `setcond64 <cond>, Rd, Rn, Rm`  
+**Gadget type:** treated as 10 operations with variants for every `Rd`/`Rn`/`Rm` (40,960)
+
+```asm
+subs Xd, Xn, Xm
+cset Xd, <cond>
+```
+
+Comparison chart is the same as the `_i32` variant.
+
+### brcond_i32
+
+Compares two 32-bit numbers, and branches if the comparison is true.
+
+**IR Format**: `brcond Rn, Rm, <cond>`  
+**Gadget type:** treated as 10 operations with variants for every `Rn`/`Rm` (2560)
+
+```asm
+# Perform our comparison and conditional branch.
+subs Wrz, Wn, Wm
+br<cond> taken
+
+    # Consume the branch target, without using it.
+    add x28, x28, #8
+
+    # Perform our end-of-instruction epilogue.
+    <epilogue here>
+
+taken:
+
+    # Update our bytecode pointer to take the label.
+    ldr x28, [x28]
+```
+
+Comparison chart is the same as in `setcond_i32` .
+
+### brcond_i64
+
+Compares two 64-bit numbers, and branches if the comparison is true.
+
+**IR Format**: `brcond Rn, Rm, <cond>`  
+**Gadget type:** treated as 10 operations with variants for every `Rn`/`Rm` (2560)
+
+```asm
+# Perform our comparison and conditional branch.
+subs Xrz, Xn, Xm
+br<cond> taken
+
+    # Consume the branch target, without using it.
+    add x28, x28, #8
+
+    # Perform our end-of-instruction epilogue.
+    <epilogue here>
+
+taken:
+
+    # Update our bytecode pointer to take the label.
+    ldr x28, [x28]
+```
+
+Comparison chart is the same as in `setcond_i32` .
+
+### mov_i32
+
+Moves a value from a register to another register.
+
+**IR Format**: `mov Rd, Rn`  
+**Gadget type:** gadget per `Rd` + `Rn` combo (256)
+
+```asm
+mov Rd, Rn
+```
+
+### mov_i64
+
+Moves a value from a register to another register.
+
+**IR Format**: `mov Rd, Rn`  
+**Gadget type:** gadget per `Rd` + `Rn` combo (256)
+
+```asm
+mov Xd, Xn
+```
+
+### tci_movi_i32
+
+Moves an 32b immediate into a register.
+
+**IR Format**: `mov Rd, #imm32`  
+**Gadget type:** gadget per `Rd` (16)
+
+```asm
+ldr w27, [x28], #4
+mov Wd, w27
+```
+
+### tci_movi_i64
+
+Moves an 64b immediate into a register.
+
+**IR Format**: `mov Rd, #imm64`  
+**Gadget type:** gadget per `Rd` (16)
+
+```asm
+ldr x27, [x28], #4
+mov Xd, x27
+```
+
+### ld8u_i32 / ld8u_i64
+
+Load byte from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrb Xd, [Xn, x27]
+```
+
+### ld8s_i32 / ld8s_i64
+
+Load byte from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsb Xd, [Xn, x27]
+```
+
+### ld16u_i32 / ld16u_i64
+
+Load 16b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrh Wd, [Xn, x27]
+```
+
+### ld16s_i32 / ld16s_i64
+
+Load 16b from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsh Xd, [Xn, x27]
+```
+
+### ld32u_i32 / ld32u_i64
+
+Load 32b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldr Wd, [Xn, x27]
+```
+
+### ld32s_i64
+
+Load 32b from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsw Xd, [Xn, x27]
+```
+
+### ld_i64
+
+Load 64b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldr Xd, [Xn, x27]
+```
+
+### st8_i32 / st8_i64
+
+Stores byte from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+strb Wd, [Xn, x27]
+```
+
+### st16_i32 / st16_i64
+
+Stores 16b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+strh Wd, [Xn, x27]
+```
+
+### st_i32 / st32_i64
+
+Stores 32b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+str Wd, [Xn, x27]
+```
+
+### st_i64
+
+Stores 64b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+str Xd, [Xn, x27]
+```
+
+### qemu_ld_i32
+
+Loads 32b from _guest_ memory to register.
+
+**IR Format**: `ld Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+### qemu_ld_i64
+
+Loads 64b from _guest_ memory to register.
+
+**IR Format**: `ld Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+### qemu_st_i32
+
+Stores 32b from a register to _guest_ memory.
+
+**IR Format**: `st Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl
+
+### qemu_st_i64
+
+Stores 64b from a register to _guest_ memory.
+
+**IR Format**: `st Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+#### Note
+
+See note on `qemu_ld_i32`.
+
+### add_i32
+
+Adds two 32-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+add Wd, Wn, Wm
+```
+
+### add_i64
+
+Adds two 64-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+add Xd, Xn, Xm
+```
+
+### sub_i32
+
+Subtracts two 32-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+Sub Wd, Wn, Wm
+```
+
+### sub_i64
+
+Subtracts two 64-bit numbers.
+
+**IR Format**: `sub Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sub Xd, Xn, Xm
+```
+
+### mul_i32
+
+Multiplies two 32-bit numbers.
+
+**IR Format**: `mul Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+mul Wd, Wn, Wm
+```
+
+### mul_i64
+
+Multiplies two 64-bit numbers.
+
+**IR Format**: `mul Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+mul Xd, Xn, Xm
+```
+
+### div_i32
+
+Divides two 32-bit numbers; considering them signed.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv Wd, Wn, Wm
+```
+
+### div_i64
+
+Divides two 64-bit numbers; considering them signed.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv Xd, Xn, Xm
+```
+
+### divu_i32
+
+Divides two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv Wd, Wn, Wm
+```
+
+### divu_i64
+
+Divides two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv Xd, Xn, Xm
+```
+
+### rem_i32
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them signed.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv    w27, Wn, Wm
+msub    Wd, w27, Wm, Wn
+```
+
+### rem_i64
+
+Computes the division remainder (modulus) of two 64-bit numbers; considering them signed.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv    x27, Xn, Xm
+msub    Xd, x27, Xm, Xn
+```
+
+### remu_i32
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv    w27, Wn, Wm
+msub    Wd, w27, Wm, Wn
+```
+
+### remu_i64
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv    x27, Xn, Xm
+msub    Xd, x27, Xm, Xn
+```
+
+### not_i32
+
+Logically inverts a 32-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+mvn Wd, Wn
+```
+
+### not_i64
+
+Logically inverts a 64-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+mvn Xd, Xn
+```
+
+### neg_i32
+
+Arithmetically inverts (two's compliment) a 32-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+neg Wd, Wn
+```
+
+### neg_i64
+
+Arithmetically inverts (two's compliment) a 64-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+neg Xd, Xn
+```
+
+### and_i32
+
+Logically ANDs two 32-bit numbers.
+
+**IR Format**: `and Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+and Wd, Wn, Wm
+```
+
+### and_i64
+
+Logically ANDs two 64-bit numbers.
+
+**IR Format**: `and Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+and Xd, Xn, Xm
+```
+
+### or_i32
+
+Logically ORs two 32-bit numbers.
+
+**IR Format**: `or Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+or Wd, Wn, Wm
+```
+
+### or_i64
+
+Logically ORs two 64-bit numbers.
+
+**IR Format**: `or Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+or Xd, Xn, Xm
+```
+
+### xor_i32
+
+Logically XORs two 32-bit numbers.
+
+**IR Format**: `xor Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+eor Wd, Wn, Wm
+```
+
+### xor_i64
+
+Logically XORs two 64-bit numbers.
+
+**IR Format**: `xor Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+eor Xd, Xn, Xm
+```
+
+### shl_i32
+
+Logically shifts a 32-bit number left.
+
+**IR Format**: `shl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsl Wd, Wn, Wm
+```
+
+### shl_i64
+
+Logically shifts a 64-bit number left.
+
+**IR Format**: `shl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsl Xd, Xn, Xm
+```
+
+### shr_i32
+
+Logically shifts a 32-bit number right.
+
+**IR Format**: `shr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsr Wd, Wn, Wm
+```
+
+### shr_i64
+
+Logically shifts a 64-bit number right.
+
+**IR Format**: `shr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsr Xd, Xn, Xm
+```
+
+### sar_i32
+
+Arithmetically shifts a 32-bit number right.
+
+**IR Format**: `sar Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+asr Wd, Wn, Wm
+```
+
+### sar_i64
+
+Arithmetically shifts a 64-bit number right.
+
+**IR Format**: `sar Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+asr Xd, Xn, Xm
+```
+
+### rotl_i32
+
+Rotates a 32-bit number left.
+
+**IR Format**: `rotl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+rol Wd, Wn, Wm
+```
+
+### rotl_i64
+
+Rotates a 64-bit number left.
+
+**IR Format**: `rotl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+rol Xd, Xn, Xm
+```
+
+### rotr_i32
+
+Rotates a 32-bit number right.
+
+**IR Format**: `rotr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+ror Wd, Wn, Wm
+```
+
+### rotr_i64
+
+Rotates a 64-bit number right.
+
+**IR Format**: `rotr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+ror Xd, Xn, Xm
+```
+
+### deposit_i32
+
+Optional; not currently implementing.
+
+### deposit_i64
+
+Optional; not currently implementing.
+
+### ext8s_i32
+
+Sign extends the lower 8b of a register into a 32b destination.
+
+**IR Format**: `ext8s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtb Wd, Wn
+```
+
+### ext8s_i64
+
+Sign extends the lower 8b of a register into a 64b destination.
+
+**IR Format**: `ext8s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtb Xd, Wn
+```
+
+### ext8u_i32
+
+Zero extends the lower 8b of a register into a 32b destination.
+
+**IR Format**: `ext8u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xff
+```
+
+### ext8u_i64
+
+Zero extends the lower 8b of a register into a 64b destination.
+
+**IR Format**: `ext8u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xff
+```
+
+### ext16s_i32
+
+Sign extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxth Xd, Wn
+```
+
+### ext16s_i64
+
+Sign extends the lower 16b of a register into a 64b destination.
+
+**IR Format**: `ext16s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxth Xd, Wn
+```
+
+### ext16u_i32
+
+Zero extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Wd, Wn, #0xffff
+```
+
+### ext16u_i64
+
+Zero extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Wd, Wn, #0xffff
+```
+
+### ext32s_i64
+
+Sign extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### ext32u_i64
+
+Zero extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### ext_i32_i64
+
+Sign extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### extu_i32_i64
+
+Zero extends the lower 32b of a register into a 32b destination.
+
+**IR Format**: `ext32u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xffffffff
+```
+
+### bswap16_i32
+
+Byte-swaps a 16b quantity.
+
+**IR Format**: `bswap16 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     w27, Wn
+lsr     Wd, w27, #16
+```
+
+### bswap16_i64
+
+Byte-swaps a 16b quantity.
+
+**IR Format**: `bswap16 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     w27, Wn
+lsr     Wd, w27, #16
+```
+
+### bswap32_i32
+
+Byte-swaps a 32b quantity.
+
+**IR Format**: `bswap32 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Wd, Wn
+```
+
+### bswap32_i64
+
+Byte-swaps a 32b quantity.
+
+**IR Format**: `bswap32 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Wd, Wn
+```
+
+### bswap64_i64
+
+Byte-swaps a 64b quantity.
+
+**IR Format**: `bswap64 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Xd, Xn
+```
+
+### exit_tb
+
+Exits the translation block. Has no gadget; but instead inserts the address of the translation block epilogue.
+
+
+### mb
+
+Memory barrier.
+
+**IR Format**: `mb <type>`  
+**Gadget type:** gadget per type
+
+```asm
+# !!! TODO
+```
+
+#### Note
+
+We still need to look up out how to map QEMU MB types map to AArch64 ones. This might take nuance.
diff --git a/tcg/aarch64-tcti/tcg-target-con-set.h b/tcg/aarch64-tcti/tcg-target-con-set.h
new file mode 100644
index 000000000000..f51b7bcb13e7
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target-con-set.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * TCI target-specific constraint sets.
+ * Copyright (c) 2021 Linaro
+ */
+
+/*
+ * C_On_Im(...) defines a constraint set with <n> outputs and <m> inputs.
+ * Each operand should be a sequence of constraint letters as defined by
+ * tcg-target-con-str.h; the constraint combination is inclusive or.
+ */
+C_O0_I2(r, r)
+C_O0_I3(r, r, r)
+C_O0_I4(r, r, r, r)
+C_O1_I1(r, r)
+C_O1_I2(r, 0, r)
+C_O1_I2(r, r, r)
+C_O1_I4(r, r, r, r, r)
+C_O2_I1(r, r, r)
+C_O2_I2(r, r, r, r)
+C_O2_I4(r, r, r, r, r, r)
diff --git a/tcg/aarch64-tcti/tcg-target-con-str.h b/tcg/aarch64-tcti/tcg-target-con-str.h
new file mode 100644
index 000000000000..87c0f19e9c2e
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target-con-str.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Define TCI target-specific operand constraints.
+ * Copyright (c) 2021 Linaro
+ */
+
+/*
+ * Define constraint letters for register sets:
+ * REGS(letter, register_mask)
+ */
+REGS('r', MAKE_64BIT_MASK(0, TCG_TARGET_NB_REGS))
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
new file mode 100644
index 000000000000..d7bb67a92140
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -0,0 +1,1347 @@
+/*
+ * Tiny Code Threaded Intepreter for QEMU
+ *
+ * Copyright (c) 2021 Kate Temkin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define TCTI_GADGET_IMMEDIATE_ARRAY_LEN 64
+
+// Grab our gadget definitions.
+// FIXME: use the system path instead of hardcoding this?
+#include "tcti-gadgets.c.inc"
+
+/* Marker for missing code. */
+#define TODO() \
+    do { \
+        fprintf(stderr, "TODO %s:%u: %s()\n", \
+                __FILE__, __LINE__, __func__); \
+        tcg_abort(); \
+    } while (0)
+
+
+/* Enable TCTI assertions only when debugging TCG (and without NDEBUG defined).
+ * Without assertions, the interpreter runs much faster. */
+#if defined(CONFIG_DEBUG_TCG)
+# define tcti_assert(cond) assert(cond)
+#else
+# define tcti_assert(cond) ((void)0)
+#endif
+
+/* Bitfield n...m (in 32 bit value). */
+#define BITS(n, m) (((0xffffffffU << (31 - n)) >> (31 - n + m)) << m)
+
+/**
+ * Macro that defines a look-up tree for named QEMU_LD gadgets.
+ */ 
+#define LD_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_ld_ub_   ## suffix; break; \
+        case MO_SB:   variable = gadget_qemu_ld_sb_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_ld_leuw_ ## suffix; break; \
+        case MO_LESW: variable = gadget_qemu_ld_lesw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_ld_leul_ ## suffix; break; \
+        case MO_LESL: variable = gadget_qemu_ld_lesl_ ## suffix; break; \
+        case MO_LEQ:  variable = gadget_qemu_ld_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_ld_beuw_ ## suffix; break; \
+        case MO_BESW: variable = gadget_qemu_ld_besw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_ld_beul_ ## suffix; break; \
+        case MO_BESL: variable = gadget_qemu_ld_besl_ ## suffix; break; \
+        case MO_BEQ:  variable = gadget_qemu_ld_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define LD_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            LD_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            LD_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+
+/**
+ * Macro that defines a look-up tree for named QEMU_ST gadgets.
+ */ 
+#define ST_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_st_ub_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_st_leuw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_st_leul_ ## suffix; break; \
+        case MO_LEQ:  variable = gadget_qemu_st_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_st_beuw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_st_beul_ ## suffix; break; \
+        case MO_BEQ:  variable = gadget_qemu_st_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define ST_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            ST_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            ST_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
+{
+    switch (op) {
+    case INDEX_op_ld8u_i32:
+    case INDEX_op_ld8s_i32:
+    case INDEX_op_ld16u_i32:
+    case INDEX_op_ld16s_i32:
+    case INDEX_op_ld_i32:
+    case INDEX_op_ld8u_i64:
+    case INDEX_op_ld8s_i64:
+    case INDEX_op_ld16u_i64:
+    case INDEX_op_ld16s_i64:
+    case INDEX_op_ld32u_i64:
+    case INDEX_op_ld32s_i64:
+    case INDEX_op_ld_i64:
+    case INDEX_op_not_i32:
+    case INDEX_op_not_i64:
+    case INDEX_op_neg_i32:
+    case INDEX_op_neg_i64:
+    case INDEX_op_ext8s_i32:
+    case INDEX_op_ext8s_i64:
+    case INDEX_op_ext16s_i32:
+    case INDEX_op_ext16s_i64:
+    case INDEX_op_ext8u_i32:
+    case INDEX_op_ext8u_i64:
+    case INDEX_op_ext16u_i32:
+    case INDEX_op_ext16u_i64:
+    case INDEX_op_ext32s_i64:
+    case INDEX_op_ext32u_i64:
+    case INDEX_op_ext_i32_i64:
+    case INDEX_op_extu_i32_i64:
+    case INDEX_op_bswap16_i32:
+    case INDEX_op_bswap16_i64:
+    case INDEX_op_bswap32_i32:
+    case INDEX_op_bswap32_i64:
+    case INDEX_op_bswap64_i64:
+        return C_O1_I1(r, r);
+
+    case INDEX_op_st8_i32:
+    case INDEX_op_st16_i32:
+    case INDEX_op_st_i32:
+    case INDEX_op_st8_i64:
+    case INDEX_op_st16_i64:
+    case INDEX_op_st32_i64:
+    case INDEX_op_st_i64:
+        return C_O0_I2(r, r);
+
+    case INDEX_op_div_i32:
+    case INDEX_op_div_i64:
+    case INDEX_op_divu_i32:
+    case INDEX_op_divu_i64:
+    case INDEX_op_rem_i32:
+    case INDEX_op_rem_i64:
+    case INDEX_op_remu_i32:
+    case INDEX_op_remu_i64:
+    case INDEX_op_add_i32:
+    case INDEX_op_add_i64:
+    case INDEX_op_sub_i32:
+    case INDEX_op_sub_i64:
+    case INDEX_op_mul_i32:
+    case INDEX_op_mul_i64:
+    case INDEX_op_and_i32:
+    case INDEX_op_and_i64:
+    case INDEX_op_andc_i32:
+    case INDEX_op_andc_i64:
+    case INDEX_op_eqv_i32:
+    case INDEX_op_eqv_i64:
+    case INDEX_op_nand_i32:
+    case INDEX_op_nand_i64:
+    case INDEX_op_nor_i32:
+    case INDEX_op_nor_i64:
+    case INDEX_op_or_i32:
+    case INDEX_op_or_i64:
+    case INDEX_op_orc_i32:
+    case INDEX_op_orc_i64:
+    case INDEX_op_xor_i32:
+    case INDEX_op_xor_i64:
+    case INDEX_op_shl_i32:
+    case INDEX_op_shl_i64:
+    case INDEX_op_shr_i32:
+    case INDEX_op_shr_i64:
+    case INDEX_op_sar_i32:
+    case INDEX_op_sar_i64:
+    case INDEX_op_rotl_i32:
+    case INDEX_op_rotl_i64:
+    case INDEX_op_rotr_i32:
+    case INDEX_op_rotr_i64:
+    case INDEX_op_setcond_i32:
+    case INDEX_op_setcond_i64:
+        return C_O1_I2(r, r, r);
+
+    case INDEX_op_brcond_i32:
+    case INDEX_op_brcond_i64:
+        return C_O0_I2(r, r);
+
+    case INDEX_op_qemu_ld_i32:
+    case INDEX_op_qemu_ld_i64:
+        return C_O1_I2(r, r, r);
+    case INDEX_op_qemu_st_i32:
+    case INDEX_op_qemu_st_i64:
+        return C_O0_I3(r, r, r);
+
+    default:
+        g_assert_not_reached();
+    }
+}
+
+static const int tcg_target_reg_alloc_order[] = {
+    TCG_REG_R0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+    TCG_REG_R6,
+    TCG_REG_R7,
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
+    /*
+    TCG_REG_R14,  // AREG0
+    TCG_REG_R15,  // SP
+    */
+};
+
+#if MAX_OPC_PARAM_IARGS != 6
+# error Fix needed, number of supported input arguments changed!
+#endif
+
+static const int tcg_target_call_iarg_regs[] = {
+    TCG_REG_R0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+};
+
+static const int tcg_target_call_oarg_regs[] = {
+    TCG_REG_R0,
+};
+
+#ifdef CONFIG_DEBUG_TCG
+static const char *const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {
+    "r00",
+    "r01",
+    "r02",
+    "r03",
+    "r04",
+    "r05",
+    "r06",
+    "r07",
+    "r08",
+    "r09",
+    "r10",
+    "r11",
+    "r12",
+    "r13",
+    "r14",
+    "r15",
+};
+#endif
+
+static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+                        intptr_t value, intptr_t addend)
+{
+    /* tcg_out_reloc always uses the same type, addend. */
+    tcg_debug_assert(type == sizeof(tcg_target_long));
+    tcg_debug_assert(addend == 0);
+    tcg_debug_assert(value != 0);
+    if (TCG_TARGET_REG_BITS == 32) {
+        tcg_patch32(code_ptr, value);
+    } else {
+        tcg_patch64(code_ptr, value);
+    }
+    return true;
+}
+
+#if defined(CONFIG_DEBUG_TCG_INTERPRETER)
+/* Show current bytecode. Used by tcg interpreter. */
+void tci_disas(uint8_t opc)
+{
+    const TCGOpDef *def = &tcg_op_defs[opc];
+    fprintf(stderr, "TCG %s %u, %u, %u\n",
+            def->name, def->nb_oargs, def->nb_iargs, def->nb_cargs);
+}
+#endif
+
+/* Write value (native size). */
+static void tcg_out_immediate(TCGContext *s, tcg_target_ulong v)
+{
+    if (TCG_TARGET_REG_BITS == 32) {
+        //tcg_out32(s, v);
+        tcg_out64(s, v);
+    } else {
+        tcg_out64(s, v);
+    }
+}
+
+void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_rx, uintptr_t jmp_rw, uintptr_t addr)
+{
+    /* Get a pointer to our immediate, which exists after a single pointer. */
+    uintptr_t immediate_addr = jmp_rw;
+
+    /* Patch it to be match our target address. */
+    qatomic_set((uint64_t *)immediate_addr, addr);
+}
+
+
+/**
+ * TCTI Thunk Helpers
+ */
+
+#ifdef CONFIG_SOFTMMU
+
+// TODO: relocate these prototypes?
+tcg_target_ulong helper_ret_ldub_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+
+tcg_target_ulong helper_ret_ldub_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int8_t)helper_ret_ldub_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_le_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int16_t)helper_le_lduw_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_le_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int32_t)helper_le_ldul_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_be_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int16_t)helper_be_lduw_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int32_t)helper_be_ldul_mmu(env, addr, oi, retaddr);
+}
+
+#else
+#error TCTI currently only supports use of the soft MMU.
+#endif
+
+
+/**
+ * TCTI Emmiter Helpers
+ */
+
+
+/* Write gadget pointer. */
+static void tcg_out_nullary_gadget(TCGContext *s, void *gadget)
+{
+    tcg_out_immediate(s, (tcg_target_ulong)gadget);
+}
+
+/* Write gadget pointer, plus 64b immediate. */
+static void tcg_out_imm64_gadget(TCGContext *s, void *gadget, tcg_target_ulong immediate)
+{
+    tcg_out_nullary_gadget(s, gadget);
+    tcg_out64(s, immediate);
+}
+
+
+/* Write gadget pointer (one register). */
+static void tcg_out_unary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS], unsigned reg0)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0]);
+}
+
+
+/* Write gadget pointer (two registers). */
+static void tcg_out_binary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1]);
+}
+
+
+/* Write gadget pointer (three registers). */
+static void tcg_out_ternary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1, unsigned reg2)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1][reg2]);
+}
+
+
+/**
+ * Version of our LDST generator that defers to more optimized gadgets selectively.
+ */
+static void tcg_out_ldst_gadget_inner(TCGContext *s, 
+    void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], 
+    void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    unsigned reg0, unsigned reg1, uint32_t offset)
+{
+    int64_t extended_offset = (int32_t)offset;
+    bool is_negative = (extended_offset < 0);
+
+    // Optimal case: we have a gadget that handles our specific offset, so we don't need to encode
+    // an immediate. This saves us a bunch of speed. :)
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        uint64_t shifted_offset = (extended_offset >> 3);
+        bool aligned_to_8B = ((extended_offset & 0b111) == 0);
+
+        bool have_optimized_gadget = (extended_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN);
+        bool have_shifted_gadget   = (shifted_offset  < TCTI_GADGET_IMMEDIATE_ARRAY_LEN);
+
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (have_optimized_gadget) {
+            tcg_out_nullary_gadget(s, gadget_pos_imm[reg0][reg1][extended_offset]);
+            return;
+        } 
+
+        // Special case: it's frequent to have low-numbered positive offsets that are aligned
+        // to 16B boundaries
+        else if(aligned_to_8B && have_shifted_gadget) {
+            tcg_out_nullary_gadget(s, gadget_shifted_imm[reg0][reg1][shifted_offset]);
+            return;
+        }
+    } 
+    else {
+        uint64_t negated_offset = -(extended_offset);
+
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (negated_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN) {
+            tcg_out_nullary_gadget(s, gadget_neg_imm[reg0][reg1][negated_offset]);
+            return;
+        }
+    }
+
+    // Less optimal case: we don't have a gadget specifically for this. Emit the general case immediate.
+    tcg_out_binary_gadget(s, gadget_base, reg0, reg1);
+    tcg_out64(s, extended_offset); //tcg_out32(s, offset);
+}
+
+/* Shorthand for the above, that prevents us from having to specify the name three times. */
+#define tcg_out_ldst_gadget(s, name, a, b, c) \
+    tcg_out_ldst_gadget_inner(s, name, \
+        name ## _imm,  \
+        name ## _sh8_imm,  \
+        name ## _neg_imm, \
+    a, b, c)
+
+
+
+/* Write label. */
+static void tcti_out_label(TCGContext *s, TCGLabel *label)
+{
+    if (label->has_value) {
+        tcg_out64(s, label->u.value);
+        tcg_debug_assert(label->u.value);
+    } else {
+        tcg_out_reloc(s, s->code_ptr, sizeof(tcg_target_ulong), label, 0);
+        s->code_ptr += sizeof(tcg_target_ulong);
+    }
+}
+
+/**
+ * Generate a register-to-register MOV.
+ */
+static bool tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
+{
+    tcg_debug_assert(ret != arg);
+
+    if (type == TCG_TYPE_I32) {
+        tcg_out_binary_gadget(s, gadget_mov_i32, ret, arg);
+    } else {
+        tcg_out_binary_gadget(s, gadget_mov_i64, ret, arg);
+    }
+
+
+    return true;
+}
+
+
+static void tcg_out_movi_i32(TCGContext *s, TCGReg t0, tcg_target_long arg)
+{
+    bool is_negative = (arg < 0);
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (arg < ARRAY_SIZE(gadget_movi_imm_i32[t0])) {
+            tcg_out_nullary_gadget(s, gadget_movi_imm_i32[t0][arg]);
+            return;
+        }
+    } 
+    else {
+
+    }
+
+    // Emit the mov and its immediate.
+    tcg_out_unary_gadget(s, gadget_movi_i32, t0);
+    tcg_out64(s, arg); // TODO: make 32b?
+}
+
+
+static void tcg_out_movi_i64(TCGContext *s, TCGReg t0, tcg_target_long arg)
+{
+    uint8_t is_negative = arg < 0;
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (arg < ARRAY_SIZE(gadget_movi_imm_i64[t0])) {
+            tcg_out_nullary_gadget(s, gadget_movi_imm_i64[t0][arg]);
+            return;
+        }
+    } 
+    else {
+
+    }
+
+    // TODO: optimize the negative case, too?
+
+    // Less optimal case: emit the mov and its immediate.
+    tcg_out_unary_gadget(s, gadget_movi_i64, t0);
+    tcg_out64(s, arg);
+}
+
+
+/**
+ * Generate an immediate-to-register MOV.
+ */
+static void tcg_out_movi(TCGContext *s, TCGType type, TCGReg t0, tcg_target_long arg)
+{
+    if (type == TCG_TYPE_I32) {
+        tcg_out_movi_i32(s, t0, arg);
+    } else {
+        tcg_out_movi_i64(s, t0, arg);
+    }
+}
+
+/**
+ * Generate a CALL.
+ */
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
+{
+    tcg_out_nullary_gadget(s, gadget_call);
+    tcg_out64(s, (uintptr_t)arg);
+}
+
+/**
+ * Generates LD instructions.
+ */
+static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,
+                       intptr_t arg2)
+{
+
+    if (type == TCG_TYPE_I32) {
+        tcg_out_ldst_gadget(s, gadget_ld32u, ret, arg1, arg2); 
+    } else {
+        tcg_out_ldst_gadget(s, gadget_ld_i64, ret, arg1, arg2); 
+    }
+}
+
+
+/**
+ * Generate every other operation.
+ */
+//static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args)
+void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args)
+{
+    switch (opc) {
+
+    // Exit translation, and return back to QEMU.
+    case INDEX_op_exit_tb:
+        // Emit a simple gadget with a known return code.
+        tcg_out_imm64_gadget(s, gadget_exit_tb, args[0]);
+        break;
+
+    // Jump to a translation block.
+    case INDEX_op_goto_tb:
+
+        // If we're using a direct jump, we'll emit a "relocation" that can be usd
+        // to patch our gadget stream with the target address, later.
+        if (s->tb_jmp_insn_offset) {
+            // Emit our gadget.
+            tcg_out_nullary_gadget(s, gadget_br);
+
+            // Place our current instruction into our "relocation table", so it can
+            // be patched once we know where the branch will target...
+            s->tb_jmp_insn_offset[args[0]] = tcg_current_code_size(s);
+
+            // ... and emit our relocation.
+            tcg_out64(s, args[0]);
+
+
+        } else {
+            /* Indirect jump method. */
+            TODO();
+        }
+        set_jmp_reset_offset(s, args[0]);
+        break;
+
+    // Simple branch.
+    case INDEX_op_br:
+        tcg_out_nullary_gadget(s, gadget_br);
+        tcti_out_label(s, arg_label(args[0]));
+        break;
+
+
+    // Set condition flag.
+    // a0 = Rd, a1 = Rn, a2 = Rm
+    case INDEX_op_setcond_i32:
+    {
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[3]) {
+            case TCG_COND_EQ:  gadget = gadget_setcond_i32_eq; break;
+            case TCG_COND_NE:  gadget = gadget_setcond_i32_ne; break;
+            case TCG_COND_LT:  gadget = gadget_setcond_i32_lt; break;
+            case TCG_COND_GE:  gadget = gadget_setcond_i32_ge; break;
+            case TCG_COND_LE:  gadget = gadget_setcond_i32_le; break;
+            case TCG_COND_GT:  gadget = gadget_setcond_i32_gt; break;
+            case TCG_COND_LTU: gadget = gadget_setcond_i32_lo; break;
+            case TCG_COND_GEU: gadget = gadget_setcond_i32_hs; break;
+            case TCG_COND_LEU: gadget = gadget_setcond_i32_ls; break;
+            case TCG_COND_GTU: gadget = gadget_setcond_i32_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        tcg_out_ternary_gadget(s, gadget, args[0], args[1], args[2]);
+        break;
+    }
+
+    case INDEX_op_setcond_i64:
+    {
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[3]) {
+            case TCG_COND_EQ:  gadget = gadget_setcond_i64_eq; break;
+            case TCG_COND_NE:  gadget = gadget_setcond_i64_ne; break;
+            case TCG_COND_LT:  gadget = gadget_setcond_i64_lt; break;
+            case TCG_COND_GE:  gadget = gadget_setcond_i64_ge; break;
+            case TCG_COND_LE:  gadget = gadget_setcond_i64_le; break;
+            case TCG_COND_GT:  gadget = gadget_setcond_i64_gt; break;
+            case TCG_COND_LTU: gadget = gadget_setcond_i64_lo; break;
+            case TCG_COND_GEU: gadget = gadget_setcond_i64_hs; break;
+            case TCG_COND_LEU: gadget = gadget_setcond_i64_ls; break;
+            case TCG_COND_GTU: gadget = gadget_setcond_i64_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        tcg_out_ternary_gadget(s, gadget, args[0], args[1], args[2]);
+        break;
+    }
+
+    /**
+     * Load instructions.
+     */
+
+    case INDEX_op_ld8u_i32:
+    case INDEX_op_ld8u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld8u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld8s_i32:
+        tcg_out_ldst_gadget(s, gadget_ld8s_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld8s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld8s_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16u_i32:
+    case INDEX_op_ld16u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld16u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16s_i32:
+        tcg_out_ldst_gadget(s, gadget_ld16s_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld16s_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld_i32:
+    case INDEX_op_ld32u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld32u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld_i64:
+        tcg_out_ldst_gadget(s, gadget_ld_i64, args[0], args[1], args[2]); 
+        break;
+    
+    case INDEX_op_ld32s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld32s_i64, args[0], args[1], args[2]); 
+        break;
+
+
+    /**
+     * Store instructions.
+     */
+    case INDEX_op_st8_i32:
+    case INDEX_op_st8_i64:
+        tcg_out_ldst_gadget(s, gadget_st8, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st16_i32:
+    case INDEX_op_st16_i64:
+        tcg_out_ldst_gadget(s, gadget_st16, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st_i32:
+    case INDEX_op_st32_i64:
+        tcg_out_ldst_gadget(s, gadget_st_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st_i64:
+        tcg_out_ldst_gadget(s, gadget_st_i64, args[0], args[1], args[2]); 
+        break;
+
+    /**
+     * Arithmetic instructions.
+     */
+
+    case INDEX_op_add_i32: 
+        tcg_out_ternary_gadget(s, gadget_add_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sub_i32:
+        tcg_out_ternary_gadget(s, gadget_sub_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_mul_i32:
+        tcg_out_ternary_gadget(s, gadget_mul_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_and_i32:
+        tcg_out_ternary_gadget(s, gadget_and_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_andc_i32:     /* Optional (TCG_TARGET_HAS_andc_i32). */
+        tcg_out_ternary_gadget(s, gadget_andc_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_orc_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_orc_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_eqv_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_eqv_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_or_i32:
+        tcg_out_ternary_gadget(s, gadget_or_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_xor_i32:
+        tcg_out_ternary_gadget(s, gadget_xor_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shl_i32:
+        tcg_out_ternary_gadget(s, gadget_shl_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shr_i32:
+        tcg_out_ternary_gadget(s, gadget_shr_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sar_i32:
+        tcg_out_ternary_gadget(s, gadget_sar_i32, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_rotr_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+    //    tcg_out_ternary_gadget(s, gadget_rotr_i32, args[0], args[1], args[2]); 
+    //    break;
+
+    //case INDEX_op_rotl_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+    //    tcg_out_ternary_gadget(s, gadget_rotl_i32, args[0], args[1], args[2]); 
+
+    case INDEX_op_add_i64:
+        tcg_out_ternary_gadget(s, gadget_add_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sub_i64:
+        tcg_out_ternary_gadget(s, gadget_sub_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_mul_i64:
+        tcg_out_ternary_gadget(s, gadget_mul_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_and_i64:
+        tcg_out_ternary_gadget(s, gadget_and_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_andc_i64:     /* Optional (TCG_TARGET_HAS_andc_i64). */
+        tcg_out_ternary_gadget(s, gadget_andc_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_orc_i64:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_orc_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_eqv_i64:      /* Optional (TCG_TARGET_HAS_eqv_i64). */
+        tcg_out_ternary_gadget(s, gadget_eqv_i64, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_nand_i64:     /* Optional (TCG_TARGET_HAS_nand_i64). */
+    //case INDEX_op_nor_i64:      /* Optional (TCG_TARGET_HAS_nor_i64). */
+
+    case INDEX_op_or_i64:
+        tcg_out_ternary_gadget(s, gadget_or_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_xor_i64:
+        tcg_out_ternary_gadget(s, gadget_xor_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shl_i64:
+        tcg_out_ternary_gadget(s, gadget_shl_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shr_i64:
+        tcg_out_ternary_gadget(s, gadget_shr_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sar_i64:
+        tcg_out_ternary_gadget(s, gadget_sar_i64, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_rotl_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+    //    tcg_out_ternary_gadget(s, gadget_rotl_i64, args[0], args[1], args[2]); 
+    //    break;
+
+    //case INDEX_op_rotr_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+    //    tcg_out_ternary_gadget(s, gadget_rotr_i64, args[0], args[1], args[2]); 
+    //    break;
+
+    case INDEX_op_div_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_div_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_divu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_divu_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_rem_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_rem_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_remu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_remu_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_brcond_i64:
+    {
+        static uint8_t last_brcond_i64 = 0;
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[2]) {
+            case TCG_COND_EQ:  gadget = gadget_brcond_i64_eq; break;
+            case TCG_COND_NE:  gadget = gadget_brcond_i64_ne; break;
+            case TCG_COND_LT:  gadget = gadget_brcond_i64_lt; break;
+            case TCG_COND_GE:  gadget = gadget_brcond_i64_ge; break;
+            case TCG_COND_LE:  gadget = gadget_brcond_i64_le; break;
+            case TCG_COND_GT:  gadget = gadget_brcond_i64_gt; break;
+            case TCG_COND_LTU: gadget = gadget_brcond_i64_lo; break;
+            case TCG_COND_GEU: gadget = gadget_brcond_i64_hs; break;
+            case TCG_COND_LEU: gadget = gadget_brcond_i64_ls; break;
+            case TCG_COND_GTU: gadget = gadget_brcond_i64_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        // We'll select the which branch to used based on a cycling counter.
+        // This means we'll pick one of 16 identical brconds. Spreading this out
+        // helps the processor's branch prediction be less "squished", as not every
+        // branch is going throuh the same instruction.
+        tcg_out_ternary_gadget(s, gadget, last_brcond_i64, args[0], args[1]);
+        last_brcond_i64 = (last_brcond_i64 + 1) % TCG_TARGET_NB_REGS;
+
+        // Branch target immediate.
+        tcti_out_label(s, arg_label(args[3]));
+        break;
+    }
+
+
+    case INDEX_op_bswap16_i32:  /* Optional (TCG_TARGET_HAS_bswap16_i32). */
+    case INDEX_op_bswap16_i64:  /* Optional (TCG_TARGET_HAS_bswap16_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap16, args[0], args[1]);
+        break;
+
+    case INDEX_op_bswap32_i32:  /* Optional (TCG_TARGET_HAS_bswap32_i32). */
+    case INDEX_op_bswap32_i64:  /* Optional (TCG_TARGET_HAS_bswap32_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap32, args[0], args[1]);
+        break;
+
+    case INDEX_op_bswap64_i64:  /* Optional (TCG_TARGET_HAS_bswap64_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap64, args[0], args[1]);
+        break;
+
+    case INDEX_op_not_i64:      /* Optional (TCG_TARGET_HAS_not_i64). */
+        tcg_out_binary_gadget(s, gadget_not_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_neg_i64:      /* Optional (TCG_TARGET_HAS_neg_i64). */
+        tcg_out_binary_gadget(s, gadget_neg_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8s_i64:    /* Optional (TCG_TARGET_HAS_ext8s_i64). */
+        tcg_out_binary_gadget(s, gadget_ext8s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8u_i32:    /* Optional (TCG_TARGET_HAS_ext8u_i32). */
+    case INDEX_op_ext8u_i64:    /* Optional (TCG_TARGET_HAS_ext8u_i64). */
+        tcg_out_binary_gadget(s, gadget_ext8u, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16s_i64:   /* Optional (TCG_TARGET_HAS_ext16s_i64). */
+        tcg_out_binary_gadget(s, gadget_ext16s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16u_i32:   /* Optional (TCG_TARGET_HAS_ext16u_i32). */
+    case INDEX_op_ext16u_i64:   /* Optional (TCG_TARGET_HAS_ext16u_i64). */
+        tcg_out_binary_gadget(s, gadget_ext16u, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext32s_i64:   /* Optional (TCG_TARGET_HAS_ext32s_i64). */
+    case INDEX_op_ext_i32_i64:
+        tcg_out_binary_gadget(s, gadget_ext32s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext32u_i64:   /* Optional (TCG_TARGET_HAS_ext32u_i64). */
+    case INDEX_op_extu_i32_i64:
+        tcg_out_binary_gadget(s, gadget_ext32u_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_neg_i32:      /* Optional (TCG_TARGET_HAS_neg_i32). */
+        tcg_out_binary_gadget(s, gadget_neg_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_not_i32:      /* Optional (TCG_TARGET_HAS_not_i32). */
+        tcg_out_binary_gadget(s, gadget_not_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8s_i32:    /* Optional (TCG_TARGET_HAS_ext8s_i32). */
+        tcg_out_binary_gadget(s, gadget_ext8s_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16s_i32:   /* Optional (TCG_TARGET_HAS_ext16s_i32). */
+        tcg_out_binary_gadget(s, gadget_ext16s_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_div_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_div_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_divu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_divu_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_rem_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_rem_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_remu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_remu_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_brcond_i32:
+    {
+        static uint8_t last_brcond_i32 = 0;
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[2]) {
+            case TCG_COND_EQ:  gadget = gadget_brcond_i32_eq; break;
+            case TCG_COND_NE:  gadget = gadget_brcond_i32_ne; break;
+            case TCG_COND_LT:  gadget = gadget_brcond_i32_lt; break;
+            case TCG_COND_GE:  gadget = gadget_brcond_i32_ge; break;
+            case TCG_COND_LE:  gadget = gadget_brcond_i32_le; break;
+            case TCG_COND_GT:  gadget = gadget_brcond_i32_gt; break;
+            case TCG_COND_LTU: gadget = gadget_brcond_i32_lo; break;
+            case TCG_COND_GEU: gadget = gadget_brcond_i32_hs; break;
+            case TCG_COND_LEU: gadget = gadget_brcond_i32_ls; break;
+            case TCG_COND_GTU: gadget = gadget_brcond_i32_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        // We'll select the which branch to used based on a cycling counter.
+        // This means we'll pick one of 16 identical brconds. Spreading this out
+        // helps the processor's branch prediction be less "squished", as not every
+        // branch is going throuh the same instruction.
+        tcg_out_ternary_gadget(s, gadget, last_brcond_i32, args[0], args[1]);
+        last_brcond_i32 = (last_brcond_i32 + 1) % TCG_TARGET_NB_REGS;
+
+        // Branch target immediate.
+        tcti_out_label(s, arg_label(args[3]));
+
+        break;
+    }
+
+    case INDEX_op_qemu_ld_i32:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
+            case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
+            case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
+            default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+        }
+
+        // Args:
+        // - an immediate32 encodes our operation index 
+        tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
+        break;
+    }
+
+    case INDEX_op_qemu_ld_i64:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        // Special optimization case: if we have an operation/target of 0x3A, 
+        // this is a common case. Delegate to our special-case handler.
+        if (args[2] == 0x3a) {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+
+                case -64: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off64_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off64_i64;
+                    break;
+                case -96: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off96_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off96_i64;
+                    break;
+                case -128: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off128_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off128_i64;
+                    break;
+
+                default: 
+                    gadget = gadget_qemu_ld_leq_slowpath_mode3a_off0_i64;
+                    break;
+            }
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } 
+        // Otherwise, handle the generic case.
+        else {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
+                case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
+                case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
+                default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+            }
+            // Args:
+            // - an immediate32 encodes our operation index 
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+            tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
+        }
+
+        break;
+    }
+
+    case INDEX_op_qemu_st_i32:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
+            case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
+            case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
+            default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+        }
+
+        // Args:
+        // - our gadget encodes the target and address registers
+        // - an immediate32 encodes our operation index 
+        tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        tcg_out64(s, args[2]); // FIXME: double encoded
+        break;
+    }
+
+    case INDEX_op_qemu_st_i64:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        // Special optimization case: if we have an operation/target of 0x3A, 
+        // this is a common case. Delegate to our special-case handler.
+        if (args[2] == 0x3a) {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+
+                case -64: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off64_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off64_i64;
+                    break;
+                case -96: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off96_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off96_i64;
+                    break;
+                case -128: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off128_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off128_i64;
+                    break;
+
+                default: 
+                    gadget = gadget_qemu_st_leq_slowpath_mode3a_off0_i64;
+                    break;
+            }
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } 
+        // Otherwise, handle the generic case.
+        else {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
+                case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
+                case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
+                default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+            }
+
+            // Args:
+            // - our gadget encodes the target and address registers
+            // - an immediate32 encodes our operation index 
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+            tcg_out64(s, args[2]); // FIXME: double encoded
+        }
+
+        break;
+    }
+
+    // Memory barriers.
+    case INDEX_op_mb:
+    {
+        static void* sync[] = {
+            [0 ... TCG_MO_ALL]            = gadget_mb_all,
+            [TCG_MO_ST_ST]                = gadget_mb_st,
+            [TCG_MO_LD_LD]                = gadget_mb_ld,
+            [TCG_MO_LD_ST]                = gadget_mb_ld,
+            [TCG_MO_LD_ST | TCG_MO_LD_LD] = gadget_mb_ld,
+        };
+        tcg_out_nullary_gadget(s, sync[args[0] & TCG_MO_ALL]);
+
+        break;
+    }
+
+    case INDEX_op_mov_i32:  /* Always emitted via tcg_out_mov.  */
+    case INDEX_op_mov_i64:
+    case INDEX_op_call:     /* Always emitted via tcg_out_call.  */
+    default:
+        tcg_abort();
+    }
+}
+
+/**
+ * Generate immediate stores.
+ */
+static void tcg_out_st(TCGContext *s, TCGType type, TCGReg arg, TCGReg arg1,
+                       intptr_t arg2)
+{
+    if (type == TCG_TYPE_I32) {
+        tcg_out_ldst_gadget(s, gadget_st_i32, arg, arg1, arg2); 
+    } else {
+        tcg_out_ldst_gadget(s, gadget_st_i64, arg, arg1, arg2); 
+    }
+}
+
+static inline bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
+                               TCGReg base, intptr_t ofs)
+{
+    return false;
+}
+
+/* Test if a constant matches the constraint. */
+static int tcg_target_const_match(tcg_target_long val, TCGType type,
+                                  const TCGArgConstraint *arg_ct)
+{
+    /* No need to return 0 or 1, 0 or != 0 is good enough. */
+    return arg_ct->ct & TCG_CT_CONST;
+}
+
+static void tcg_target_init(TCGContext *s)
+{
+    /* The current code uses uint8_t for tcg operations. */
+    tcg_debug_assert(tcg_op_defs_max <= UINT8_MAX);
+
+    /* Registers available for 32 bit operations. */
+    tcg_target_available_regs[TCG_TYPE_I32] = BIT(TCG_TARGET_NB_REGS) - 1;
+    /* Registers available for 64 bit operations. */
+    tcg_target_available_regs[TCG_TYPE_I64] = BIT(TCG_TARGET_NB_REGS) - 1;
+
+    /* TODO: Which registers should be set here? */
+    tcg_target_call_clobber_regs = BIT(TCG_TARGET_NB_REGS) - 1;
+
+    s->reserved_regs = 0;
+    tcg_regset_set_reg(s->reserved_regs, TCG_REG_CALL_STACK);
+
+    /* We use negative offsets from "sp" so that we can distinguish
+       stores that might pretend to be call arguments.  */
+    tcg_set_frame(s, TCG_REG_CALL_STACK, -CPU_TEMP_BUF_NLONGS * sizeof(long), CPU_TEMP_BUF_NLONGS * sizeof(long));
+}
+
+/* Generate global QEMU prologue and epilogue code. */
+static inline void tcg_target_qemu_prologue(TCGContext *s)
+{
+    // No prologue; as we're interpreted.
+}
+
+
+/**
+ * TCTI 'interpreter' bootstrap.
+ */
+
+// Store the current return address during helper calls.
+__thread uintptr_t tcti_call_return_address;
+
+/* Dispatch the bytecode stream contained in our translation buffer. */
+uintptr_t QEMU_DISABLE_CFI tcg_qemu_tb_exec(CPUArchState *env, const void *v_tb_ptr)
+{
+    // Create our per-CPU temporary storage.
+    long tcg_temps[CPU_TEMP_BUF_NLONGS];
+
+    uint64_t return_value = 0;
+    uintptr_t sp_value    = (uintptr_t)(tcg_temps + CPU_TEMP_BUF_NLONGS);
+    uintptr_t pc_mirror   = (uintptr_t)&tcti_call_return_address;
+
+    // Ensure our target configuration hasn't changed.
+    tcti_assert(TCG_AREG0 == TCG_REG_R14);
+    tcti_assert(TCG_REG_CALL_STACK == TCG_REG_R15);
+
+    asm(
+        // Our threaded-dispatch prologue needs to set up things for our machine to run.
+        // This means:
+        //   - Set up TCG_AREG0 (R14) to point to our architectural state.
+        //   - Set up TCG_REG_CALL_STACK (R15) to point to our temporary buffer.
+        //   - Point x28 (our bytecode "instruction pointer") to the relevant stream address.
+        "ldr x14, %[areg0]\n"
+        "ldr x15, %[sp_value]\n"
+        "ldr x25, %[pc_mirror]\n"
+        "ldr x28, %[start_tb_ptr]\n"
+
+        // To start our code, we'll -call- the gadget at the first bytecode pointer.
+        // Note that we call/branch-with-link, here; so our TB_EXIT gadget can RET in order
+        // to return to this point when things are complete.
+        "ldr x27, [x28], #8\n"
+        "blr x27\n"
+
+        // Finally, we'll copy out our final return value.
+        "str x0, %[return_value]\n"
+
+        : [return_value] "=m" (return_value)
+
+        : [areg0]        "m"  (env), 
+          [sp_value]     "m"  (sp_value), 
+          [start_tb_ptr] "m"  (v_tb_ptr),
+          [pc_mirror]    "m"  (pc_mirror)
+
+        // We touch _every_ one of the lower registers, as we use these to execute directly.
+        : "x0", "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7",
+          "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
+
+        // We also use x26/x27 for temporary values, and x28 as our bytecode poitner.
+        "x25", "x26", "x27", "x28", "cc", "memory"
+    );
+
+    return return_value;
+}
+
+
+/**
+ *  Disassembly output support.
+ */
+#include <dlfcn.h>
+
+
+/* Disassemble TCI bytecode. */
+int print_insn_tcti(bfd_vma addr, disassemble_info *info)
+{
+    Dl_info symbol_info = {};
+    char symbol_name[48] ;
+
+    int status;
+    uint64_t block;
+
+    // Read the relevant pointer.
+    status = info->read_memory_func(addr, (void *)&block, sizeof(block), info);
+    if (status != 0) {
+        info->memory_error_func(status, addr, info);
+        return -1;
+    }
+
+    // Most of our disassembly stream will be gadgets. Try to get their names, for nice output.
+    dladdr((void *)block, &symbol_info);
+
+    if(symbol_info.dli_sname != 0) {
+        strlcpy(symbol_name, symbol_info.dli_sname, 47);
+        info->fprintf_func(info->stream, "%s", symbol_name);
+    } else {
+        info->fprintf_func(info->stream, "%016llx", block);
+    }
+
+    return sizeof(block);
+}
+
+
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
new file mode 100644
index 000000000000..fa2ae5c40a3e
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -0,0 +1,220 @@
+/*
+ * Tiny Code Generator for QEMU
+ *
+ * Copyright (c) 2009, 2011 Stefan Weil
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/*
+ * This code implements a TCG which does not generate machine code for some
+ * real target machine but which generates virtual machine code for an
+ * interpreter. Interpreted pseudo code is slow, but it works on any host.
+ *
+ * Some remarks might help in understanding the code:
+ *
+ * "target" or "TCG target" is the machine which runs the generated code.
+ * This is different to the usual meaning in QEMU where "target" is the
+ * emulated machine. So normally QEMU host is identical to TCG target.
+ * Here the TCG target is a virtual machine, but this virtual machine must
+ * use the same word size like the real machine.
+ * Therefore, we need both 32 and 64 bit virtual machines (interpreter).
+ */
+
+#ifndef TCG_TARGET_H
+#define TCG_TARGET_H
+
+#if UINTPTR_MAX == UINT32_MAX
+# error We only support AArch64 running in 64B mode.
+#elif UINTPTR_MAX == UINT64_MAX
+# define TCG_TARGET_REG_BITS 64
+#else
+# error Unknown pointer size for tcti target
+#endif
+
+#define TCG_TARGET_INSN_UNIT_SIZE        1
+#define TCG_TARGET_TLB_DISPLACEMENT_BITS 32
+
+// We're an interpreted target; even if we're JIT-compiling to our interpreter's
+// weird psuedo-native bytecode. We'll indicate that we're intepreted.
+#define TCG_TARGET_INTERPRETER 1
+
+//
+// Supported optional instructions.
+//
+
+// Divs.
+#define TCG_TARGET_HAS_div_i32          1
+#define TCG_TARGET_HAS_rem_i32          1
+#define TCG_TARGET_HAS_div_i64          1
+#define TCG_TARGET_HAS_rem_i64          1
+
+// Extends.
+#define TCG_TARGET_HAS_ext8s_i32        1
+#define TCG_TARGET_HAS_ext16s_i32       1
+#define TCG_TARGET_HAS_ext8u_i32        1
+#define TCG_TARGET_HAS_ext16u_i32       1
+#define TCG_TARGET_HAS_ext8s_i64        1
+#define TCG_TARGET_HAS_ext16s_i64       1
+#define TCG_TARGET_HAS_ext32s_i64       1
+#define TCG_TARGET_HAS_ext8u_i64        1
+#define TCG_TARGET_HAS_ext16u_i64       1
+#define TCG_TARGET_HAS_ext32u_i64       1
+
+// Logicals.
+#define TCG_TARGET_HAS_neg_i32          1
+#define TCG_TARGET_HAS_not_i32          1
+#define TCG_TARGET_HAS_neg_i64          1
+#define TCG_TARGET_HAS_not_i64          1
+
+#define TCG_TARGET_HAS_andc_i32         1
+#define TCG_TARGET_HAS_orc_i32          1
+#define TCG_TARGET_HAS_eqv_i32          1
+#define TCG_TARGET_HAS_andc_i64         1
+#define TCG_TARGET_HAS_eqv_i64          1
+#define TCG_TARGET_HAS_orc_i64          1
+
+// We don't curretly support rotates, since AArch64 lacks ROL.
+// We'll fix this later.
+#define TCG_TARGET_HAS_rot_i32          0
+#define TCG_TARGET_HAS_rot_i64          0
+
+// Swaps.
+#define TCG_TARGET_HAS_bswap16_i32      1
+#define TCG_TARGET_HAS_bswap32_i32      1
+#define TCG_TARGET_HAS_bswap16_i64      1
+#define TCG_TARGET_HAS_bswap32_i64      1
+#define TCG_TARGET_HAS_bswap64_i64      1
+#define TCG_TARGET_HAS_MEMORY_BSWAP     1
+
+// Specify we'll handle direct jumps.
+#define TCG_TARGET_HAS_direct_jump      1
+
+//
+// Potential TODOs.
+//
+
+// TODO: implement DEPOSIT as BFI.
+#define TCG_TARGET_HAS_deposit_i32      0
+#define TCG_TARGET_HAS_deposit_i64      0
+
+// TODO: implement EXTRACT as BFX.
+#define TCG_TARGET_HAS_extract_i32      0
+#define TCG_TARGET_HAS_sextract_i32     0
+#define TCG_TARGET_HAS_extract_i64      0
+#define TCG_TARGET_HAS_sextract_i64     0
+
+// TODO: it might be worth writing a gadget for this
+#define TCG_TARGET_HAS_movcond_i32      0
+#define TCG_TARGET_HAS_movcond_i64      0
+
+//
+// Unsupported instructions.
+//
+
+// ARMv8 doesn't have instructions for NAND/NOR.
+#define TCG_TARGET_HAS_nand_i32         0
+#define TCG_TARGET_HAS_nor_i32          0
+#define TCG_TARGET_HAS_nor_i64          0
+#define TCG_TARGET_HAS_nand_i64         0
+
+// aarch64's CLZ is implemented without a condition, so it
+#define TCG_TARGET_HAS_clz_i32          0
+#define TCG_TARGET_HAS_ctz_i32          0
+#define TCG_TARGET_HAS_ctpop_i32        0
+#define TCG_TARGET_HAS_clz_i64          0
+#define TCG_TARGET_HAS_ctz_i64          0
+#define TCG_TARGET_HAS_ctpop_i64        0
+
+
+// GOTO_PTR is too complex to emit a simple gadget for.
+// We'll let C handle it, since the overhead is similar.
+#define TCG_TARGET_HAS_goto_ptr         0
+
+// We don't have a simple gadget for this, since we're always assuming softmmu.
+#define TCG_TARGET_HAS_qemu_st8_i32     0
+
+// No AArch64 equivalent.a
+#define TCG_TARGET_HAS_extrl_i64_i32    0
+#define TCG_TARGET_HAS_extrh_i64_i32    0
+
+#define TCG_TARGET_HAS_extract2_i64     0
+
+// These should always be zero on our 64B platform.
+#define TCG_TARGET_HAS_muls2_i64        0
+#define TCG_TARGET_HAS_add2_i32         0
+#define TCG_TARGET_HAS_sub2_i32         0
+#define TCG_TARGET_HAS_mulu2_i32        0
+#define TCG_TARGET_HAS_add2_i64         0
+#define TCG_TARGET_HAS_sub2_i64         0
+#define TCG_TARGET_HAS_mulu2_i64        0
+#define TCG_TARGET_HAS_muluh_i64        0
+#define TCG_TARGET_HAS_mulsh_i64        0
+#define TCG_TARGET_HAS_extract2_i32     0
+#define TCG_TARGET_HAS_muls2_i32        0
+#define TCG_TARGET_HAS_muluh_i32        0
+#define TCG_TARGET_HAS_mulsh_i32        0
+
+//
+// Platform metadata.
+//
+
+// Number of registers available.
+// It might make sense to up these, since we can also use x16 -> x25?
+#define TCG_TARGET_NB_REGS 16
+
+/* List of registers which are used by TCG. */
+typedef enum {
+    TCG_REG_R0 = 0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+    TCG_REG_R6,
+    TCG_REG_R7,
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
+    TCG_REG_R14,
+    TCG_REG_R15,
+
+    TCG_AREG0          = TCG_REG_R14,
+    TCG_REG_CALL_STACK = TCG_REG_R15,
+} TCGReg;
+
+// Specify the shape of the stack our runtime will use.
+#define TCG_TARGET_CALL_STACK_OFFSET    0
+#define TCG_TARGET_STACK_ALIGN          16
+
+// We're interpreted, so we'll use our own code to run TB_EXEC.
+#define HAVE_TCG_QEMU_TB_EXEC
+
+// We'll need to enforce memory ordering with barriers.
+#define TCG_TARGET_DEFAULT_MO  (0)
+
+void tci_disas(uint8_t opc);
+
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+
+
+#endif /* TCG_TARGET_H */
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
new file mode 100755
index 000000000000..1296f6d0c2d7
--- /dev/null
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -0,0 +1,788 @@
+#!/usr/bin/env python3
+""" Gadget-code generator for QEMU TCTI on AArch64. 
+
+Generates a C-code include file containing 'gadgets' for use by TCTI.
+"""
+
+import sys
+import itertools
+
+# Get a handle on the file we'll be working with, and redirect print to it.
+if len(sys.argv) > 1:
+    out_file = open(sys.argv[1], "w")
+
+    # Hook our print function, so it always outputs to the relevant file.
+    core_print = print
+    print = lambda *a, **k : core_print(*a, **k, file=out_file)
+
+# Epilogue code follows at the end of each gadget, and handles continuing execution.
+EPILOGUE = ( 
+    # Load our next gadget address from our bytecode stream, advancing it.
+    "ldr x27, [x28], #8",
+
+    # Jump to the next gadget.
+    "br x27"
+)
+
+# The number of general-purpose registers we're affording the TCG. This must match
+# the configuration in the TCTI target.
+TCG_REGISTER_COUNT   = 16
+TCG_REGISTER_NUMBERS = list(range(TCG_REGISTER_COUNT))
+
+# Helper that provides each of the AArch64 condition codes of interest.
+ARCH_CONDITION_CODES = ["eq", "ne", "lt", "ge", "le", "gt", "lo", "hs", "ls", "hi"]
+
+# We'll create a variety of gadgets that assume the MMU's TLB is stored at certain
+# offsets into its structure. These should match the offsets in tcg-target.c.in.
+QEMU_ALLOWED_MMU_OFFSETS = [ 64, 96, 128 ]
+
+# Statistics.
+gadgets      = 0
+instructions = 0
+
+def simple(name, *lines):
+    """ Generates a simple gadget that needs no per-register specialization. """
+
+    global gadgets, instructions
+
+    gadgets += 1
+
+    # Create our C/ASM framing.
+    #print(f"__attribute__((naked)) static void gadget_{name}(void)")
+    print(f"__attribute__((naked)) void gadget_{name}(void);")
+    print(f"__attribute__((naked)) void gadget_{name}(void)")
+    print("{")
+
+    # Add the core gadget
+    print("\tasm(")
+    for line in lines + EPILOGUE:
+        print(f"\t\t\"{line} \\n\"")
+        instructions += 1
+    print("\t);")
+
+    # End our framing.
+    print("}\n")
+
+
+def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
+    """ Generates a collection of gadgtes with register substitutions. """
+
+    def substitutions_for_letter(letter, number, line):
+        """ Helper that transforms Wd => w1, implementing gadget substitutions. """
+
+        # Register substitutions...
+        line = line.replace(f"X{letter}", f"x{number}")
+        line = line.replace(f"W{letter}", f"w{number}")
+
+        # ... immediate substitutions.
+        line = line.replace(f"I{letter}", f"{number}")
+        return line
+
+        
+    # Build a list of all the various stages we'll iterate over...
+    immediate_parameters = list(immediate_range)
+    parameters   = ([TCG_REGISTER_NUMBERS] * len(substitutions))
+
+    # ... adding immediates, if need be.
+    if immediate_parameters:
+        parameters.append(immediate_parameters)
+        substitutions = substitutions + ['i']
+
+    # Generate a list of register-combinations we'll support.
+    permutations = itertools.product(*parameters)
+
+    #  For each permutation...
+    for permutation in permutations:
+        new_lines = lines
+
+        # Replace each placeholder element with its proper value...
+        for index, element in enumerate(permutation):
+            letter = substitutions[index]
+            number = element
+
+            # Create new gadgets for the releavnt line...
+            new_lines = [substitutions_for_letter(letter, number, line) for line in new_lines]
+
+        # ... and emit the gadget.
+        permutation_id = "_arg".join(str(number) for number in permutation)
+        simple(f"{name}_arg{permutation_id}", *new_lines)
+
+
+def with_dnm(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
+    with_register_substitutions(name, ("d", "n", "m"), *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    # D array
+    for d in TCG_REGISTER_NUMBERS:
+        print("\t{")
+
+        # N array
+        for n in TCG_REGISTER_NUMBERS:
+            print("\t\t{", end="")
+
+            # M array
+            for m in TCG_REGISTER_NUMBERS:
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{m}", end=", ")
+
+            print("},")
+        print("\t},")
+    print("};")
+
+
+def with_dn_immediate(name, *lines, immediate_range):
+    """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
+    with_register_substitutions(name, ["d", "n"], *lines, immediate_range=immediate_range)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print("{")
+
+    # D array
+    for d in TCG_REGISTER_NUMBERS:
+        print("\t{")
+
+        # N array
+        for n in TCG_REGISTER_NUMBERS:
+            print("\t\t{", end="")
+
+            # M array
+            for i in immediate_range:
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{i}", end=", ")
+
+            print("},")
+        print("\t},")
+    print("};")
+
+
+def with_pair(name, substitutions, *lines):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, substitutions, *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    # N array
+    for a in TCG_REGISTER_NUMBERS:
+        print("\t\t{", end="")
+
+        # M array
+        for b in TCG_REGISTER_NUMBERS:
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+
+        print("},")
+    print("};")
+
+
+def math_dnm(name, mnemonic):
+    """ Equivalent to `with_dnm`, but creates a _i32 and _i64 variant. For simple math. """
+    with_dnm(f'{name}_i32', f"{mnemonic} Wd, Wn, Wm")
+    with_dnm(f'{name}_i64', f"{mnemonic} Xd, Xn, Xm")
+
+def math_dn(name, mnemonic):
+    """ Equivalent to `with_dn`, but creates a _i32 and _i64 variant. For simple math. """
+    with_dn(f'{name}_i32', f"{mnemonic} Wd, Wn")
+    with_dn(f'{name}_i64', f"{mnemonic} Xd, Xn")
+
+
+def with_nm(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xn, and Xm, and equivalents. """
+    with_pair(name, ('n', 'm',), *lines)
+
+
+def with_dn(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, and Xn, and equivalents. """
+    with_pair(name, ('d', 'n',), *lines)
+
+
+def ldst_dn(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, and Xn, and equivalents. 
+    
+    This variant is optimized for loads and stores, and optimizes common offset cases.
+    """
+
+    #
+    # Simple case: create our gadgets.
+    #
+    with_dn(name, "ldr x27, [x28], #8", *lines)
+
+    #
+    # Optimization case: create variants of our gadgets with our offsets replaced with common immediates.
+    #
+    immediate_lines_pos = [line.replace("x27", "#Ii") for line in lines]
+    with_dn_immediate(f"{name}_imm", *immediate_lines_pos, immediate_range=range(64))
+
+    immediate_lines_aligned = [line.replace("x27", "#(Ii << 3)") for line in lines]
+    with_dn_immediate(f"{name}_sh8_imm", *immediate_lines_aligned, immediate_range=range(64))
+
+    immediate_lines_neg = [line.replace("x27", "#-Ii") for line in lines]
+    with_dn_immediate(f"{name}_neg_imm", *immediate_lines_neg, immediate_range=range(64))
+
+
+def with_single(name, substitution, *lines):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, (substitution,), *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    for n in TCG_REGISTER_NUMBERS:
+        print(f"gadget_{name}_arg{n}", end=", ")
+
+    print("};")
+
+
+def with_d_immediate(name, *lines, immediate_range=range(0)):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, ['d'], *lines, immediate_range=immediate_range)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print("{")
+
+    # D array
+    for a in TCG_REGISTER_NUMBERS:
+        print("\t\t{", end="")
+
+        # I array
+        for b in immediate_range:
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+
+        print("},")
+    print("};")
+
+
+
+def with_d(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd. """
+    with_single(name, 'd', *lines)
+
+
+# Assembly code for saving our machine state before entering the C runtime.
+C_CALL_PROLOGUE = [
+    # Store our machine state.
+    "str x25,      [sp, #-16]!",
+    "stp x14, x15, [sp, #-16]!",
+    "stp x12, x13, [sp, #-16]!",
+    "stp x10, x11, [sp, #-16]!",
+    "stp x8,  x9,  [sp, #-16]!",
+    "stp x6,  x7,  [sp, #-16]!",
+    "stp x4,  x5,  [sp, #-16]!",
+    "stp x2,  x3,  [sp, #-16]!",
+    "stp x0,  x1,  [sp, #-16]!",
+    "stp x28, lr,  [sp, #-16]!",
+]
+
+# Assembly code for restoring our machine state after leaving the C runtime.
+C_CALL_EPILOGUE = [
+    "ldp x28, lr, [sp], #16",
+    "ldp x0,  x1, [sp], #16",
+    "ldp x2,  x3, [sp], #16",
+    "ldp x4,  x5, [sp], #16",
+    "ldp x6,  x7, [sp], #16",
+    "ldp x8,  x9, [sp], #16",
+    "ldp x10, x11, [sp], #16",
+    "ldp x12, x13, [sp], #16",
+    "ldp x14, x15, [sp], #16",
+    "ldr x25,      [sp], #16",
+]
+
+
+def create_tlb_fastpath(is_aligned, is_write, offset, miss_label="0"):
+    """ Creates a set of instructions that perform a soft-MMU TLB lookup.
+
+    This is used for `qemu_ld`/qemu_st` instructions; to emit a prologue that
+    hopefully helps us skip a slow call into the C runtime when a Guest Virtual 
+    -> Host Virtual mapping is in the softmmu's TLB.
+
+    This "fast-path" prelude behaves as follows:
+        - If a TLB entry is found for the address stored in Xn, then x27
+          is stored to an "addend" that can be added to the guest virtual addres
+          to get the host virtual address (the address in our local memory space).
+        - If a TLB entry isn't found, it branches to the "miss_label" (by default, 0:),
+          so address lookup can be handled by the fastpath.
+
+    Clobbers x24, and x26; provides output in x27.
+    """
+
+    fast_path = [
+        # Load env_tlb(env)->f[mmu_idx].{mask,table} into {x26,x27}.
+        f"ldp x26, x27, [x14, #-{offset}]",
+
+        # Extract the TLB index from the address into X26. 
+        "and x26, x26, Xn, lsr #7", # Xn = addr regsiter 
+
+        # Add the tlb_table pointer, creating the CPUTLBEntry address into X27. 
+        "add x27, x27, x26",
+
+        # Load the tlb comparator into X26, and the fast path addend into X27. 
+        "ldr x26, [x27, #8]" if is_write else "ldr x26, [x27]",
+        "ldr x27, [x27, #0x18]",
+
+    ]
+
+    if is_aligned:
+        fast_path.extend([
+            # Store the page mask part of the address into X24.
+            "and x24, Xn, #0xfffffffffffff000",
+
+            # Compare the masked address with the TLB value.
+            "cmp x26, x24",
+
+            # If we're not equal, this isn't a TLB hit. Jump to our miss handler.
+            f"b.ne {miss_label}f",
+        ])
+    else:
+        fast_path.extend([
+            # If we're not aligned, add in our alignment value to ensure we don't
+            # don't straddle the end of a page.
+            "add x24, Xn, #7",
+
+            # Store the page mask part of the address into X24.
+            "and x24, x24, #0xfffffffffffff000",
+
+            # Compare the masked address with the TLB value.
+            "cmp x26, x24",
+
+            # If we're not equal, this isn't a TLB hit. Jump to our miss handler.
+            f"b.ne {miss_label}f",
+        ])
+
+    return fast_path
+
+
+
+def ld_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None, is_aligned=False, force_slowpath=False):
+    """ Creates a thunk into our C runtime for a QEMU ST operation. """
+
+    # Use only offset 0 (no real offset) if we're forcing slowpath; 
+    # otherwise, use all of our allowed MMU offsets.
+    offsets = [0] if force_slowpath else QEMU_ALLOWED_MMU_OFFSETS
+    for offset in offsets:
+        for is_32b in (True, False):
+            fastpath = fastpath_32b if is_32b else fastpath_64b
+
+            gadget_name = f"{name}_off{offset}_i32" if is_32b else f"{name}_off{offset}_i64"
+            postscript = () if immediate else ("add x28, x28, #8",)
+
+            # If we have a pure-assembly fast path, start our gadget with it.
+            if fastpath and not force_slowpath:
+                fastpath_ops = [
+                    # Create a fastpath that jumps to miss_lable on a TLB miss,
+                    # or sets x27 to the TLB addend on a TLB hit.
+                    *create_tlb_fastpath(is_aligned=is_aligned, is_write=False, offset=offset),
+
+                    # On a hit, we can just perform an appropriate load...
+                    *fastpath,
+
+                    # Run our patch-up post-script, if we have one.
+                    *postscript,
+
+                    # ... and then we're done!
+                    *EPILOGUE,
+                ]
+            # Otherwise, we'll save arguments for our slow path.
+            else:
+                fastpath_ops = []
+
+            #
+            # If we're not taking our fast path, we'll call into our C runtime to take the slow path.
+            # 
+            with_dn(gadget_name, 
+                    *fastpath_ops,
+
+                "0:",
+                    "mov x27, Xn",
+
+                    # Save our registers in preparation for entering a C call.
+                    *C_CALL_PROLOGUE,
+
+                    # Per our calling convention:
+                    # - Move our architectural environment into x0, from x14.
+                    # - Move our target address into x1. [Placed in x27 below.]
+                    # - Move our operation info into x2, from an immediate32.
+                    # - Move the next bytecode pointer into x3, from x28.
+                    "mov   x0, x14",
+                    "mov   x1, x27",
+                    f"mov   x2, #{immediate}" if (immediate is not None) else "ldr   x2, [x28], #8", 
+                    "mov   x3, x28",
+
+                    # Perform our actual core code.
+                    f"bl _{slowpath_helper}",
+
+                    # Temporarily store our result in a register that won't get trashed.
+                    "mov x27, x0",
+
+                    # Restore our registers after our C call.
+                    *C_CALL_EPILOGUE,
+
+                    # Finally, call our postscript...
+                    *postscript,
+
+                    # ... and place our results in the target register.
+                    "mov Wd, w27" if is_32b else "mov Xd, x27"
+            )
+
+
+def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None, is_aligned=False, force_slowpath=False):
+    """ Creates a thunk into our C runtime for a QEMU ST operation. """
+
+    # Use only offset 0 (no real offset) if we're forcing slowpath; 
+    # otherwise, use all of our allowed MMU offsets.
+    offsets = [0] if force_slowpath else QEMU_ALLOWED_MMU_OFFSETS
+    for offset in offsets:
+
+        for is_32b in (True, False):
+            fastpath = fastpath_32b if is_32b else fastpath_64b
+
+            gadget_name = f"{name}_off{offset}_i32" if is_32b else f"{name}_off{offset}_i64"
+            postscript = () if immediate else ("add x28, x28, #8",)
+
+            # If we have a pure-assembly fast path, start our gadget with it.
+            if fastpath and not force_slowpath:
+                fastpath_ops = [
+
+                    # Create a fastpath that jumps to miss_lable on a TLB miss,
+                    # or sets x27 to the TLB addend on a TLB hit.
+                    *create_tlb_fastpath(is_aligned=is_aligned, is_write=True, offset=offset),
+
+                    # On a hit, we can just perform an appropriate load...
+                    *fastpath,
+
+                    # Run our patch-up post-script, if we have one.
+                    *postscript,
+
+                    # ... and then we're done!
+                    *EPILOGUE,
+                ]
+            else:
+                fastpath_ops = []
+
+
+            #
+            # If we're not taking our fast path, we'll call into our C runtime to take the slow path.
+            # 
+            with_dn(gadget_name, 
+                    *fastpath_ops,
+
+                "0:",
+                    # Move our arguments into registers that we're not actively using.
+                    # This ensures that they won't be trounced by our calling convention
+                    # if this is reading values from x0-x4.
+                    "mov w27, Wd" if is_32b else "mov x27, Xd",
+                    "mov x26, Xn",
+
+                    # Save our registers in preparation for entering a C call.
+                    *C_CALL_PROLOGUE,
+
+                    # Per our calling convention:
+                    # - Move our architectural environment into x0, from x14.
+                    # - Move our target address into x1. [Moved into x26 above].
+                    # - Move our target value into x2. [Moved into x27 above].
+                    # - Move our operation info into x3, from an immediate32.
+                    # - Move the next bytecode pointer into x4, from x28.
+                    "mov   x0, x14",
+                    "mov   x1, x26",
+                    "mov   x2, x27",
+                    f"mov  x3, #{immediate}" if (immediate is not None) else "ldr   x3, [x28], #8", 
+                    "mov   x4, x28",
+
+                    # Perform our actual core code.
+                    f"bl _{slowpath_helper}",
+
+                    # Restore our registers after our C call.
+                    *C_CALL_EPILOGUE,
+
+                    # Finally, call our postscript.
+                    *postscript
+            )
+
+
+#
+# Gadget definitions.
+#
+
+print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n")
+
+# Call a C language helper function by address.
+simple("call",
+    # Get our C runtime function's location as a pointer-sized immediate...
+    "ldr x27, [x28], #8",
+
+    # Store our TB return address for our helper.
+    "str x28, [x25]",
+
+    # Prepare ourselves to call into our C runtime...
+    *C_CALL_PROLOGUE,
+
+    # ... perform the call itself ...
+    "blr x27",
+
+    # Save the result of our call for later.
+    "mov x27, x0",
+
+    # ... and restore our environment.
+    *C_CALL_EPILOGUE,
+
+    # Restore our return value.
+    "mov x0, x27"
+)
+
+# Branch to a given immediate address.
+simple("br",
+    # Use our immediate argument as our new bytecode-pointer location.
+    "ldr x28, [x28]"
+)
+
+# Exit from a translation buffer execution.
+simple("exit_tb",
+
+    # We have a single immediate argument, which contains our return code.
+    # Place it into x0, as one would a return code.
+    "ldr x0, [x28], #8",
+
+    # And finally, return back to the code that invoked our gadget stream.
+    "ret"
+)
+
+
+for condition in ARCH_CONDITION_CODES:
+
+    # Performs a comparison between two operands.
+    with_dnm(f"setcond_i32_{condition}",
+        "subs Wd, Wn, Wm",
+        f"cset Wd, {condition}"
+    )
+    with_dnm(f"setcond_i64_{condition}",
+        "subs Xd, Xn, Xm",
+        f"cset Xd, {condition}"
+    )
+
+    #
+    # NOTE: we use _dnm for the conditional branches, even though we don't
+    # actually do anything different based on the d argument. This gemerates
+    # effectively 16 identical `brcond` gadgets for each condition; which we
+    # use in the backend to spread out the actual branch sources we use.
+    #
+    # This is a slight mercy for the branch predictor, as not every conditional
+    # branch is funneled throught the same address.
+    #
+
+    # Branches iff a given comparison is true.
+    with_dnm(f'brcond_i32_{condition}',
+
+        # Grab our immediate argument.
+        "ldr x27, [x28], #8",
+
+        # Perform our comparison and conditional branch.
+        "subs Wzr, Wn, Wm",
+        f"b{condition} 1f",
+
+        "0:", # not taken
+           # Perform our end-of-instruction epilogue.
+            *EPILOGUE,
+
+        "1:" # taken
+            # Update our bytecode pointer to take the label.
+            "mov x28, x27"
+    )
+
+    # Branches iff a given comparison is true.
+    with_dnm(f'brcond_i64_{condition}',
+
+        # Grab our immediate argument.
+        "ldr x27, [x28], #8",
+
+        # Perform our comparison and conditional branch.
+        "subs Xzr, Xn, Xm",
+        f"b{condition} 1f",
+
+        "0:", # not taken
+            # Perform our end-of-instruction epilogue.
+            *EPILOGUE,
+
+        "1:" # taken
+            # Update our bytecode pointer to take the label.
+            "mov x28, x27"
+    )
+
+
+# MOV variants.
+with_dn("mov_i32",     "mov Wd, Wn")
+with_dn("mov_i64",     "mov Xd, Xn")
+with_d("movi_i32", "ldr Wd, [x28], #8")
+with_d("movi_i64", "ldr Xd, [x28], #8")
+
+# Create MOV variants that have common constants built in to the gadget.
+# This optimization helps costly reads from memories for simple operations.
+with_d_immediate("movi_imm_i32", "mov Wd, #Ii", immediate_range=range(64))
+with_d_immediate("movi_imm_i64", "mov Xd, #Ii", immediate_range=range(64))
+
+# LOAD variants.
+# TODO: should the signed variants have X variants for _i64?
+ldst_dn("ld8u",      "ldrb  Wd, [Xn, x27]")
+ldst_dn("ld8s_i32",  "ldrsb Wd, [Xn, x27]")
+ldst_dn("ld8s_i64",  "ldrsb Xd, [Xn, x27]")
+ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
+ldst_dn("ld16s_i32", "ldrsh Wd, [Xn, x27]")
+ldst_dn("ld16s_i64", "ldrsh Xd, [Xn, x27]")
+ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
+ldst_dn("ld32s_i64", "ldrsw Xd, [Xn, x27]")
+ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
+
+# STORE variants.
+ldst_dn("st8",         "strb  Wd, [Xn, x27]")
+ldst_dn("st16",        "strh  Wd, [Xn, x27]")
+ldst_dn("st_i32",      "str   Wd, [Xn, x27]")
+ldst_dn("st_i64",      "str   Xd, [Xn, x27]")
+
+# QEMU LD/ST are handled in our C runtime rather than with simple gadgets,
+# as they're nontrivial.
+
+# Trivial arithmetic.
+math_dnm("add" , "add" )
+math_dnm("sub" , "sub" )
+math_dnm("mul" , "mul" )
+math_dnm("div" , "sdiv")
+math_dnm("divu", "udiv")
+
+# Division remainder
+with_dnm("rem_i32",  "sdiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
+with_dnm("rem_i64",  "sdiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
+with_dnm("remu_i32", "udiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
+with_dnm("remu_i64", "udiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
+
+# Trivial logical.
+math_dn( "not",  "mvn")
+math_dn( "neg",  "neg")
+math_dnm("and",  "and")
+math_dnm("andc", "bic")
+math_dnm("or",   "orr")
+math_dnm("orc",  "orn")
+math_dnm("xor",  "eor")
+math_dnm("eqv",  "eon")
+math_dnm("shl",  "lsl")
+math_dnm("shr",  "lsr")
+math_dnm("sar",  "asr")
+
+# AArch64 lacks a Rotate Left; so we instead rotate right by a negative.
+# TODO: validate this?
+#math_dnm("rotr", "ror")
+#with_dnm("rotl_i32", "neg w27, Wm", "ror Wd, Wn, w27")
+#with_dnm("rotl_i64", "neg x27, Xm", "ror Xd, Xn, x27")
+
+# Numeric extension.
+math_dn("ext8s",      "sxtb")
+with_dn("ext8u",      "and Xd, Xn, #0xff")
+math_dn("ext16s",     "sxth")
+with_dn("ext16u",     "and Wd, Wn, #0xffff")
+with_dn("ext32s_i64", "sxtw Xd, Wn")
+with_dn("ext32u_i64", "and Xd, Xn, #0xffffffff")
+
+# Byte swapping.
+with_dn("bswap16",    "rev w27, Wn", "lsr Wd, w27, #16")
+with_dn("bswap32",    "rev Wd, Wn")
+with_dn("bswap64",    "rev Xd, Xn")
+
+# Memory barriers.
+simple("mb_all", "dmb ish")
+simple("mb_st",  "dmb ishst")
+simple("mb_ld",  "dmb ishld")
+
+# Handlers for QEMU_LD, which handles guest <- host loads.
+for subtype in ('aligned', 'unaligned', 'slowpath'):
+    is_aligned  = (subtype == 'aligned')
+    is_slowpath = (subtype == 'slowpath')
+
+    ld_thunk(f"qemu_ld_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu",
+        fastpath_32b=["ldrb Wd, [Xn, x27]"], fastpath_64b=["ldrb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_sb_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu_signed",
+        fastpath_32b=["ldrsb Wd, [Xn, x27]"], fastpath_64b=["ldrsb Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu",
+        fastpath_32b=["ldrh Wd, [Xn, x27]"], fastpath_64b=["ldrh Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu_signed",
+        fastpath_32b=["ldrsh Wd, [Xn, x27]"], fastpath_64b=["ldrsh Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu",
+        fastpath_32b=["ldr Wd, [Xn, x27]"], fastpath_64b=["ldr Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesl_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu_signed",
+        fastpath_32b=["ldrsw Xd, [Xn, x27]"], fastpath_64b=["ldrsw Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+
+    # Special variant for the most common mode, as a speedup optimization.
+    ld_thunk(f"qemu_ld_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x3a
+    )
+
+    # For now, leave the rare/big-endian stuff slow-path only.
+    ld_thunk(f"qemu_ld_beuw_{subtype}", None, None, "helper_be_lduw_mmu",         
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_besw_{subtype}", None, None, "helper_be_lduw_mmu_signed",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_beul_{subtype}", None, None, "helper_be_ldul_mmu",         
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_besl_{subtype}", None, None, "helper_be_ldul_mmu_signed",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_beq_{subtype}",  None, None, "helper_be_ldq_mmu",          
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+
+
+# Handlers for QEMU_ST, which handles guest -> host stores.
+for subtype in ('aligned', 'unaligned', 'slowpath'):
+    is_aligned  = (subtype == 'aligned')
+    is_slowpath = (subtype == 'slowpath')
+
+    st_thunk(f"qemu_st_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_stb_mmu",
+        fastpath_32b=["strb Wd, [Xn, x27]"], fastpath_64b=["strb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stw_mmu",
+        fastpath_32b=["strh Wd, [Xn, x27]"], fastpath_64b=["strh Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stl_mmu",
+        fastpath_32b=["str Wd, [Xn, x27]"], fastpath_64b=["str Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    
+    # Special optimization for the most common modes.
+    st_thunk(f"qemu_st_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x3a
+    )
+
+    # For now, leave the rare/big-endian stuff slow-path only.
+    st_thunk(f"qemu_st_beuw_{subtype}", None, None, "helper_be_stw_mmu",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    st_thunk(f"qemu_st_beul_{subtype}", None, None, "helper_be_stl_mmu",
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    st_thunk(f"qemu_st_beq_{subtype}",  None, None, "helper_be_stq_mmu",
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+
+
+# Statistics.
+sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions ({instructions * 4} B).\n\n")
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 5b0750685102..ec832d92d0e6 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -165,7 +165,7 @@ TCGv_env cpu_env = 0;
 const void *tcg_code_gen_epilogue;
 uintptr_t tcg_splitwx_diff;
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 tcg_prologue_fn *tcg_qemu_tb_exec;
 #endif
 
@@ -1227,7 +1227,7 @@ void tcg_prologue_init(TCGContext *s)
     region.start = buf0;
     region.end = buf0 + total_size;
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     tcg_qemu_tb_exec = (tcg_prologue_fn *)tcg_splitwx_to_rx(buf0);
 #endif
 
@@ -1253,7 +1253,7 @@ void tcg_prologue_init(TCGContext *s)
 #endif
 
     buf1 = s->code_ptr;
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     flush_idcache_range((uintptr_t)tcg_splitwx_to_rx(buf0), (uintptr_t)buf0,
                         tcg_ptr_byte_diff(buf1, buf0));
 #endif
@@ -1981,7 +1981,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
 #endif
 
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* We have 64-bit values in one register, but need to pass as two
        separate parameters.  Split them.  */
     int orig_sizemask = sizemask;
@@ -2031,7 +2031,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
     pi = 0;
     if (ret != NULL) {
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
         if (orig_sizemask & 1) {
             /* The 32-bit ABI is going to return the 64-bit value in
                the %o0/%o1 register pair.  Prepare for this by using
@@ -2109,7 +2109,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
     tcg_debug_assert(pi <= ARRAY_SIZE(op->args));
 
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* Free all of the parts we allocated above.  */
     for (i = real_args = 0; i < orig_nargs; ++i) {
         int is_64bit = orig_sizemask & (1 << (i+1)*2);
@@ -4789,7 +4789,7 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
         return -2;
     }
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* flush instruction cache */
     flush_idcache_range((uintptr_t)tcg_splitwx_to_rx(s->code_buf),
                         (uintptr_t)s->code_buf,

From c77bed1d5cf3a935ded239b21665512f5bfb618c Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Tue, 27 Apr 2021 17:23:16 +0000
Subject: [PATCH 027/180] split gadgets into multiple files

---
 meson.build                         |  42 ++++--
 tcg/aarch64-tcti/tcg-target.c.inc   |  33 +++--
 tcg/aarch64-tcti/tcti-gadget-gen.py | 212 ++++++++++++++++++++--------
 3 files changed, 213 insertions(+), 74 deletions(-)

diff --git a/meson.build b/meson.build
index 2bcd98dd0865..52f40e6b77e8 100644
--- a/meson.build
+++ b/meson.build
@@ -257,14 +257,38 @@ if not get_option('tcg').disabled()
 
     # Tell our compiler how to generate our TCTI gadgets.
     gadget_generator = 'tcg/@0@/tcti-gadget-gen.py'.format(tcg_arch)
-    tcti_gadgets = custom_target('tcti-gadgets.c.inc',
-                                output: 'tcti-gadgets.c.inc',
-                                input: gadget_generator,
-                                command: [find_program(gadget_generator), '@OUTPUT@'],
-                                build_by_default: true,
-                                build_always_stale: false)
-
-    genh += tcti_gadgets
+    gadgets = [
+      'tcti_misc_gadgets.c', 
+      'tcti_conditionals_gadgets.c', 
+      'tcti_mov_gadgets.c', 
+      'tcti_load_gadgets.c', 
+      'tcti_store_gadgets.c', 
+      'tcti_arithmetic_gadgets.c', 
+      'tcti_logical_gadgets.c', 
+      'tcti_extension_gadgets.c', 
+      'tcti_byteswap_gadgets.c', 
+      'tcti_qemu_ld_gadgets.c', 
+      'tcti_qemu_st_gadgets.c', 
+      'tcti_misc_gadgets.h', 
+      'tcti_conditionals_gadgets.h', 
+      'tcti_mov_gadgets.h', 
+      'tcti_load_gadgets.h', 
+      'tcti_store_gadgets.h', 
+      'tcti_arithmetic_gadgets.h', 
+      'tcti_logical_gadgets.h', 
+      'tcti_extension_gadgets.h', 
+      'tcti_byteswap_gadgets.h', 
+      'tcti_qemu_ld_gadgets.h', 
+      'tcti_qemu_st_gadgets.h', 
+      'tcti_gadgets.h']
+
+    tcti_gadgets = custom_target('tcti-gadgets.h',
+                              output: gadgets,
+                              input: gadget_generator,
+                              command: [find_program(gadget_generator)],
+                              build_by_default: true,
+                              build_always_stale: false)
+
     
   elif config_host['ARCH'] == 'sparc64'
     tcg_arch = 'sparc'
@@ -1943,6 +1967,8 @@ if get_option('b_lto')
 endif
 common_ss.add(pagevary)
 specific_ss.add(files('page-vary.c'))
+specific_ss.add(when: 'CONFIG_TCG_INTERPRETER', if_true: files('disas/tci.c', 'tcg/tci.c'))
+specific_ss.add(when: 'CONFIG_TCG_THREADED_INTERPRETER', if_true: tcti_gadgets)
 
 subdir('backends')
 subdir('disas')
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index d7bb67a92140..315033502ef7 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -22,11 +22,13 @@
  * THE SOFTWARE.
  */
 
+//#define TCTI_GADGET_RICH_DISASSEMBLY
+
 #define TCTI_GADGET_IMMEDIATE_ARRAY_LEN 64
 
-// Grab our gadget definitions.
-// FIXME: use the system path instead of hardcoding this?
-#include "tcti-gadgets.c.inc"
+
+// Grab our gadget headers.
+#include "tcti_gadgets.h"
 
 /* Marker for missing code. */
 #define TODO() \
@@ -575,6 +577,12 @@ static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,
 }
 
 
+static void warn_slow_memop(const TCGArg arg)
+{
+    fprintf(stderr, "--- NOTE: emitting non-optimized memop at offset %i\n", TLB_MASK_TABLE_OFS(get_mmuidx(arg)));
+}
+
+
 /**
  * Generate every other operation.
  */
@@ -1032,7 +1040,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
             case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
             case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
             case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
-            default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+            default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); warn_slow_memop(args[2]); break;
         }
 
         // Args:
@@ -1083,7 +1091,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
                 case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
                 case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
                 case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
-                default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+                default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); warn_slow_memop(args[2]); break;
             }
             // Args:
             // - an immediate32 encodes our operation index 
@@ -1106,7 +1114,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
             case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
             case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
             case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
-            default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+            default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); warn_slow_memop(args[2]); break;
         }
 
         // Args:
@@ -1158,7 +1166,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
                 case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
                 case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
                 case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
-                default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+                default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); warn_slow_memop(args[2]); break;
             }
 
             // Args:
@@ -1318,8 +1326,11 @@ uintptr_t QEMU_DISABLE_CFI tcg_qemu_tb_exec(CPUArchState *env, const void *v_tb_
 /* Disassemble TCI bytecode. */
 int print_insn_tcti(bfd_vma addr, disassemble_info *info)
 {
+
+#ifdef TCTI_GADGET_RICH_DISASSEMBLY
     Dl_info symbol_info = {};
     char symbol_name[48] ;
+#endif
 
     int status;
     uint64_t block;
@@ -1331,16 +1342,22 @@ int print_insn_tcti(bfd_vma addr, disassemble_info *info)
         return -1;
     }
 
+#ifdef TCTI_GADGET_RICH_DISASSEMBLY
     // Most of our disassembly stream will be gadgets. Try to get their names, for nice output.
     dladdr((void *)block, &symbol_info);
 
     if(symbol_info.dli_sname != 0) {
-        strlcpy(symbol_name, symbol_info.dli_sname, 47);
+        strncpy(symbol_name, symbol_info.dli_sname, sizeof(symbol_name));
+        symbol_name[sizeof(symbol_name) - 1] = 0;
         info->fprintf_func(info->stream, "%s", symbol_name);
     } else {
         info->fprintf_func(info->stream, "%016llx", block);
     }
 
+#else
+    info->fprintf_func(info->stream, "%016llx", block);
+#endif
+
     return sizeof(block);
 }
 
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 1296f6d0c2d7..51471719a48b 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -7,14 +7,6 @@
 import sys
 import itertools
 
-# Get a handle on the file we'll be working with, and redirect print to it.
-if len(sys.argv) > 1:
-    out_file = open(sys.argv[1], "w")
-
-    # Hook our print function, so it always outputs to the relevant file.
-    core_print = print
-    print = lambda *a, **k : core_print(*a, **k, file=out_file)
-
 # Epilogue code follows at the end of each gadget, and handles continuing execution.
 EPILOGUE = ( 
     # Load our next gadget address from our bytecode stream, advancing it.
@@ -40,6 +32,48 @@
 gadgets      = 0
 instructions = 0
 
+# Files to write to.
+current_collection = "basic"
+output_files = {}
+
+# Create a top-level header.
+top_header = open("tcti_gadgets.h", "w")
+print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=top_header)
+
+def _get_output_files():
+    """ Gathers the output C and H files for a given gadget-cluster name. """
+
+    # If we don't have an output file for this already, create it.
+    return output_files[current_collection]
+
+
+def START_COLLECTION(name):
+    """ Sets the name of the current collection. """
+
+    global current_collection
+
+    # Create the relevant output files
+    new_c_file = open(f"tcti_{name}_gadgets.c", "w")
+    new_h_file = open(f"tcti_{name}_gadgets.h", "w")
+    output_files[name] = (new_c_file, new_h_file)
+
+    # Add the file to our gadget collection.
+    print(f'#include "tcti_{name}_gadgets.h"', file=top_header)
+
+    # Add generated messages to the relevant collection.
+    print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=new_c_file)
+    print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=new_h_file)
+
+    # Start our C file with inclusion of the relevant header.
+    print(f'\n#include "tcti_{name}_gadgets.h"\n', file=new_c_file)
+
+    # Start our H file with a simple pragma-guard, for speed.
+    print('\n#pragma once\n', file=new_h_file)
+
+    # Finally, set the global active collection.
+    current_collection = name
+    
+
 def simple(name, *lines):
     """ Generates a simple gadget that needs no per-register specialization. """
 
@@ -47,21 +81,23 @@ def simple(name, *lines):
 
     gadgets += 1
 
+    # Fetch the files we'll be using for output.
+    c_file, h_file = _get_output_files()
+
     # Create our C/ASM framing.
-    #print(f"__attribute__((naked)) static void gadget_{name}(void)")
-    print(f"__attribute__((naked)) void gadget_{name}(void);")
-    print(f"__attribute__((naked)) void gadget_{name}(void)")
-    print("{")
+    print(f"__attribute__((naked)) void gadget_{name}(void);", file=h_file)
+    print(f"__attribute__((naked)) void gadget_{name}(void)", file=c_file)
+    print("{", file=c_file)
 
     # Add the core gadget
-    print("\tasm(")
+    print("\tasm(", file=c_file)
     for line in lines + EPILOGUE:
-        print(f"\t\t\"{line} \\n\"")
+        print(f"\t\t\"{line} \\n\"", file=c_file)
         instructions += 1
-    print("\t);")
+    print("\t);", file=c_file)
 
     # End our framing.
-    print("}\n")
+    print("}\n", file=c_file)
 
 
 def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
@@ -112,70 +148,87 @@ def with_dnm(name, *lines):
     """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
     with_register_substitutions(name, ("d", "n", "m"), *lines)
 
+    # Fetch the files we'll be using for output.
+    c_file, h_file = _get_output_files()
+
+    # Print out an extern.
+    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
+
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
-    print("{")
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
+    print("{", file=c_file)
 
     # D array
     for d in TCG_REGISTER_NUMBERS:
-        print("\t{")
+        print("\t{", file=c_file)
 
         # N array
         for n in TCG_REGISTER_NUMBERS:
-            print("\t\t{", end="")
+            print("\t\t{", end="", file=c_file)
 
             # M array
             for m in TCG_REGISTER_NUMBERS:
-                print(f"gadget_{name}_arg{d}_arg{n}_arg{m}", end=", ")
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{m}", end=", ", file=c_file)
 
-            print("},")
-        print("\t},")
-    print("};")
+            print("},", file=c_file)
+        print("\t},", file=c_file)
+    print("};", file=c_file)
 
 
 def with_dn_immediate(name, *lines, immediate_range):
     """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
     with_register_substitutions(name, ["d", "n"], *lines, immediate_range=immediate_range)
 
+    # Fetch the files we'll be using for output.
+    c_file, h_file = _get_output_files()
+
+    # Print out an extern.
+    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}];", file=h_file)
+
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
-    print("{")
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="", file=c_file)
+    print("{", file=c_file)
 
     # D array
     for d in TCG_REGISTER_NUMBERS:
-        print("\t{")
+        print("\t{", file=c_file)
 
         # N array
         for n in TCG_REGISTER_NUMBERS:
-            print("\t\t{", end="")
+            print("\t\t{", end="", file=c_file)
 
             # M array
             for i in immediate_range:
-                print(f"gadget_{name}_arg{d}_arg{n}_arg{i}", end=", ")
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{i}", end=", ", file=c_file)
 
-            print("},")
-        print("\t},")
-    print("};")
+            print("},", file=c_file)
+        print("\t},", file=c_file)
+    print("};", file=c_file)
 
 
 def with_pair(name, substitutions, *lines):
     """ Generates a collection of gadgets with two subtstitutions."""
     with_register_substitutions(name, substitutions, *lines)
 
+    # Fetch the files we'll be using for output.
+    c_file, h_file = _get_output_files()
+
+    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
+
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
-    print("{")
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
+    print("{", file=c_file)
 
     # N array
     for a in TCG_REGISTER_NUMBERS:
-        print("\t\t{", end="")
+        print("\t\t{", end="", file=c_file)
 
         # M array
         for b in TCG_REGISTER_NUMBERS:
-            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ", file=c_file)
 
-        print("},")
-    print("};")
+        print("},", file=c_file)
+    print("};", file=c_file)
 
 
 def math_dnm(name, mnemonic):
@@ -227,34 +280,44 @@ def with_single(name, substitution, *lines):
     """ Generates a collection of gadgets with two subtstitutions."""
     with_register_substitutions(name, (substitution,), *lines)
 
+    # Fetch the files we'll be using for output.
+    c_file, h_file = _get_output_files()
+
+    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}];", file=h_file)
+
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="")
-    print("{")
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
+    print("{", file=c_file)
 
     for n in TCG_REGISTER_NUMBERS:
-        print(f"gadget_{name}_arg{n}", end=", ")
+        print(f"gadget_{name}_arg{n}", end=", ", file=c_file)
 
-    print("};")
+    print("};", file=c_file)
 
 
 def with_d_immediate(name, *lines, immediate_range=range(0)):
     """ Generates a collection of gadgets with two subtstitutions."""
     with_register_substitutions(name, ['d'], *lines, immediate_range=immediate_range)
 
+    # Fetch the files we'll be using for output.
+    c_file, h_file = _get_output_files()
+
+    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}];", file=h_file)
+
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
-    print("{")
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="", file=c_file)
+    print("{", file=c_file)
 
     # D array
     for a in TCG_REGISTER_NUMBERS:
-        print("\t\t{", end="")
+        print("\t\t{", end="", file=c_file)
 
         # I array
         for b in immediate_range:
-            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ", file=c_file)
 
-        print("},")
-    print("};")
+        print("},", file=c_file)
+    print("};", file=c_file)
 
 
 
@@ -413,7 +476,7 @@ def ld_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
                     "mov   x3, x28",
 
                     # Perform our actual core code.
-                    f"bl _{slowpath_helper}",
+                    f"bl {slowpath_helper}",
 
                     # Temporarily store our result in a register that won't get trashed.
                     "mov x27, x0",
@@ -493,7 +556,7 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
                     "mov   x4, x28",
 
                     # Perform our actual core code.
-                    f"bl _{slowpath_helper}",
+                    f"bl {slowpath_helper}",
 
                     # Restore our registers after our C call.
                     *C_CALL_EPILOGUE,
@@ -507,7 +570,7 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 # Gadget definitions.
 #
 
-print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n")
+START_COLLECTION("misc")
 
 # Call a C language helper function by address.
 simple("call",
@@ -550,6 +613,14 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
     "ret"
 )
 
+# Memory barriers.
+simple("mb_all", "dmb ish")
+simple("mb_st",  "dmb ishst")
+simple("mb_ld",  "dmb ishld")
+
+
+START_COLLECTION("conditionals")
+
 
 for condition in ARCH_CONDITION_CODES:
 
@@ -612,6 +683,9 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
     )
 
 
+START_COLLECTION("mov")
+
+
 # MOV variants.
 with_dn("mov_i32",     "mov Wd, Wn")
 with_dn("mov_i64",     "mov Xd, Xn")
@@ -623,17 +697,24 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 with_d_immediate("movi_imm_i32", "mov Wd, #Ii", immediate_range=range(64))
 with_d_immediate("movi_imm_i64", "mov Xd, #Ii", immediate_range=range(64))
 
+START_COLLECTION("load_unsigned")
+
 # LOAD variants.
 # TODO: should the signed variants have X variants for _i64?
 ldst_dn("ld8u",      "ldrb  Wd, [Xn, x27]")
+ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
+ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
+ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
+
+START_COLLECTION("load_signed")
+
 ldst_dn("ld8s_i32",  "ldrsb Wd, [Xn, x27]")
 ldst_dn("ld8s_i64",  "ldrsb Xd, [Xn, x27]")
-ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
 ldst_dn("ld16s_i32", "ldrsh Wd, [Xn, x27]")
 ldst_dn("ld16s_i64", "ldrsh Xd, [Xn, x27]")
-ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
 ldst_dn("ld32s_i64", "ldrsw Xd, [Xn, x27]")
-ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
+
+START_COLLECTION("store")
 
 # STORE variants.
 ldst_dn("st8",         "strb  Wd, [Xn, x27]")
@@ -644,6 +725,8 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 # QEMU LD/ST are handled in our C runtime rather than with simple gadgets,
 # as they're nontrivial.
 
+START_COLLECTION("arithmetic")
+
 # Trivial arithmetic.
 math_dnm("add" , "add" )
 math_dnm("sub" , "sub" )
@@ -657,6 +740,8 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 with_dnm("remu_i32", "udiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
 with_dnm("remu_i64", "udiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
 
+START_COLLECTION("logical")
+
 # Trivial logical.
 math_dn( "not",  "mvn")
 math_dn( "neg",  "neg")
@@ -676,6 +761,8 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 #with_dnm("rotl_i32", "neg w27, Wm", "ror Wd, Wn, w27")
 #with_dnm("rotl_i64", "neg x27, Xm", "ror Xd, Xn, x27")
 
+START_COLLECTION("extension")
+
 # Numeric extension.
 math_dn("ext8s",      "sxtb")
 with_dn("ext8u",      "and Xd, Xn, #0xff")
@@ -684,15 +771,14 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 with_dn("ext32s_i64", "sxtw Xd, Wn")
 with_dn("ext32u_i64", "and Xd, Xn, #0xffffffff")
 
+START_COLLECTION("byteswap")
+
 # Byte swapping.
 with_dn("bswap16",    "rev w27, Wn", "lsr Wd, w27, #16")
 with_dn("bswap32",    "rev Wd, Wn")
 with_dn("bswap64",    "rev Xd, Xn")
 
-# Memory barriers.
-simple("mb_all", "dmb ish")
-simple("mb_st",  "dmb ishst")
-simple("mb_ld",  "dmb ishld")
+START_COLLECTION("qemu_ld")
 
 # Handlers for QEMU_LD, which handles guest <- host loads.
 for subtype in ('aligned', 'unaligned', 'slowpath'):
@@ -747,6 +833,9 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
             is_aligned=is_aligned, force_slowpath=is_slowpath)
 
 
+START_COLLECTION("qemu_st")
+
+
 # Handlers for QEMU_ST, which handles guest -> host stores.
 for subtype in ('aligned', 'unaligned', 'slowpath'):
     is_aligned  = (subtype == 'aligned')
@@ -784,5 +873,12 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
             is_aligned=is_aligned, force_slowpath=is_slowpath)
 
 
+# Print a list of output files generated.
+output_c_filenames = ", ".join(f"'tcti_{name}_gadgets.c'" for name in output_files.keys())
+output_h_filenames = ", ".join(f"'tcti_{name}_gadgets.h'" for name in output_files.keys())
+
+print("Sources generated:", file=sys.stderr)
+print(f"output: [{output_c_filenames}, {output_h_filenames}, 'tcti_gadgets.h']", file=sys.stderr)
+
 # Statistics.
 sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions ({instructions * 4} B).\n\n")

From 744075b9ee623e3090340c576743a1b7024c2358 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Tue, 27 Apr 2021 14:02:53 -0600
Subject: [PATCH 028/180] TCTI: dramatically speed up build & reduce footprint

---
 configure                           |  1 +
 meson.build                         | 66 +++++++++++++++-----------
 tcg/aarch64-tcti/tcg-target.c.inc   | 24 ++++++++--
 tcg/aarch64-tcti/tcti-gadget-gen.py | 72 ++++++++++++++++-------------
 4 files changed, 99 insertions(+), 64 deletions(-)

diff --git a/configure b/configure
index d0053845169c..c3637f198428 100755
--- a/configure
+++ b/configure
@@ -1604,6 +1604,7 @@ for opt do
   --enable-gio) gio=yes
   ;;
   --disable-gio) gio=no
+  ;;
   --enable-slirp-smbd) slirp_smbd=yes
   ;;
   --disable-slirp-smbd) slirp_smbd=no
diff --git a/meson.build b/meson.build
index 52f40e6b77e8..02a6354802c7 100644
--- a/meson.build
+++ b/meson.build
@@ -121,6 +121,9 @@ add_global_arguments(config_host['QEMU_CXXFLAGS'].split(),
 add_global_link_arguments(config_host['QEMU_LDFLAGS'].split(),
                           native: false, language: ['c', 'cpp', 'objc'])
 
+add_global_arguments('-Wno-unused-command-line-argument', native: false, language: ['c', 'objc'])
+add_global_link_arguments('-ldl', native: false, language: ['c', 'cpp', 'objc'])
+
 if targetos == 'linux'
   add_project_arguments('-isystem', meson.current_source_dir() / 'linux-headers',
                         '-isystem', 'linux-headers',
@@ -258,30 +261,41 @@ if not get_option('tcg').disabled()
     # Tell our compiler how to generate our TCTI gadgets.
     gadget_generator = 'tcg/@0@/tcti-gadget-gen.py'.format(tcg_arch)
     gadgets = [
-      'tcti_misc_gadgets.c', 
-      'tcti_conditionals_gadgets.c', 
-      'tcti_mov_gadgets.c', 
-      'tcti_load_gadgets.c', 
-      'tcti_store_gadgets.c', 
-      'tcti_arithmetic_gadgets.c', 
-      'tcti_logical_gadgets.c', 
-      'tcti_extension_gadgets.c', 
-      'tcti_byteswap_gadgets.c', 
-      'tcti_qemu_ld_gadgets.c', 
-      'tcti_qemu_st_gadgets.c', 
-      'tcti_misc_gadgets.h', 
-      'tcti_conditionals_gadgets.h', 
-      'tcti_mov_gadgets.h', 
-      'tcti_load_gadgets.h', 
-      'tcti_store_gadgets.h', 
-      'tcti_arithmetic_gadgets.h', 
-      'tcti_logical_gadgets.h', 
-      'tcti_extension_gadgets.h', 
-      'tcti_byteswap_gadgets.h', 
-      'tcti_qemu_ld_gadgets.h', 
-      'tcti_qemu_st_gadgets.h', 
-      'tcti_gadgets.h']
-
+        'tcti_gadgets.h',
+        'tcti_misc_gadgets.c',
+        'tcti_misc_gadgets.s',
+        'tcti_misc_gadgets.h',
+        'tcti_conditionals_gadgets.c',
+        'tcti_conditionals_gadgets.s',
+        'tcti_conditionals_gadgets.h',
+        'tcti_mov_gadgets.c',
+        'tcti_mov_gadgets.s',
+        'tcti_mov_gadgets.h',
+        'tcti_load_gadgets.c',
+        'tcti_load_gadgets.s',
+        'tcti_load_gadgets.h',
+        'tcti_store_gadgets.c',
+        'tcti_store_gadgets.s',
+        'tcti_store_gadgets.h',
+        'tcti_arithmetic_gadgets.c',
+        'tcti_arithmetic_gadgets.s',
+        'tcti_arithmetic_gadgets.h',
+        'tcti_logical_gadgets.c',
+        'tcti_logical_gadgets.s',
+        'tcti_logical_gadgets.h',
+        'tcti_extension_gadgets.c',
+        'tcti_extension_gadgets.s',
+        'tcti_extension_gadgets.h',
+        'tcti_byteswap_gadgets.c',
+        'tcti_byteswap_gadgets.s',
+        'tcti_byteswap_gadgets.h',
+        'tcti_qemu_ld_gadgets.c',
+        'tcti_qemu_ld_gadgets.s',
+        'tcti_qemu_ld_gadgets.h',
+        'tcti_qemu_st_gadgets.c',
+        'tcti_qemu_st_gadgets.s',
+        'tcti_qemu_st_gadgets.h',
+    ]
     tcti_gadgets = custom_target('tcti-gadgets.h',
                               output: gadgets,
                               input: gadget_generator,
@@ -498,7 +512,7 @@ endif
 rt = cc.find_library('rt', required: false)
 libdl = not_found
 if 'CONFIG_PLUGIN' in config_host
-  libdl = cc.find_library('dl', required: true)
+  libdl = dependency('dl', required: true)
 endif
 libiscsi = not_found
 if not get_option('libiscsi').auto() or have_block
@@ -1967,7 +1981,7 @@ if get_option('b_lto')
 endif
 common_ss.add(pagevary)
 specific_ss.add(files('page-vary.c'))
-specific_ss.add(when: 'CONFIG_TCG_INTERPRETER', if_true: files('disas/tci.c', 'tcg/tci.c'))
+specific_ss.add(when: 'CONFIG_TCG_INTERPRETER', if_true: files('tcg/tci.c'))
 specific_ss.add(when: 'CONFIG_TCG_THREADED_INTERPRETER', if_true: tcti_gadgets)
 
 subdir('backends')
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index 315033502ef7..7cf6acdc3dfa 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -22,7 +22,9 @@
  * THE SOFTWARE.
  */
 
-//#define TCTI_GADGET_RICH_DISASSEMBLY
+
+// Rich disassembly is nice in theory, but it's -slow-.
+#define TCTI_GADGET_RICH_DISASSEMBLY
 
 #define TCTI_GADGET_IMMEDIATE_ARRAY_LEN 64
 
@@ -1037,6 +1039,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         void *gadget;
 
         switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -32:  LD_MEMOP_HANDLER(gadget, args[2],  off32_i32, a_bits, s_bits); break;
             case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
             case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
             case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
@@ -1062,7 +1065,11 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         // this is a common case. Delegate to our special-case handler.
         if (args[2] == 0x3a) {
             switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
-
+                case -32: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off32_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off32_i64;
+                    break;
                 case -64: 
                     gadget = (a_bits >= s_bits) ? 
                         gadget_qemu_ld_leq_aligned_mode3a_off64_i64 :
@@ -1088,6 +1095,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         // Otherwise, handle the generic case.
         else {
             switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -32:  LD_MEMOP_HANDLER(gadget, args[2],  off32_i64, a_bits, s_bits); break;
                 case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
                 case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
                 case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
@@ -1111,6 +1119,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         void *gadget;
 
         switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -32:  ST_MEMOP_HANDLER(gadget, args[2],  off32_i32, a_bits, s_bits); break;
             case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
             case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
             case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
@@ -1137,7 +1146,11 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         // this is a common case. Delegate to our special-case handler.
         if (args[2] == 0x3a) {
             switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
-
+                case -32: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off32_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off32_i64;
+                    break;
                 case -64: 
                     gadget = (a_bits >= s_bits) ? 
                         gadget_qemu_st_leq_aligned_mode3a_off64_i64 :
@@ -1163,6 +1176,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         // Otherwise, handle the generic case.
         else {
             switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -32:  ST_MEMOP_HANDLER(gadget, args[2],  off32_i32, a_bits, s_bits); break;
                 case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
                 case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
                 case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
@@ -1351,11 +1365,11 @@ int print_insn_tcti(bfd_vma addr, disassemble_info *info)
         symbol_name[sizeof(symbol_name) - 1] = 0;
         info->fprintf_func(info->stream, "%s", symbol_name);
     } else {
-        info->fprintf_func(info->stream, "%016llx", block);
+        info->fprintf_func(info->stream, "%016lx", block);
     }
 
 #else
-    info->fprintf_func(info->stream, "%016llx", block);
+    info->fprintf_func(info->stream, "%016lx", block);
 #endif
 
     return sizeof(block);
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 51471719a48b..800702fad3db 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -4,6 +4,7 @@
 Generates a C-code include file containing 'gadgets' for use by TCTI.
 """
 
+import os
 import sys
 import itertools
 
@@ -26,7 +27,7 @@
 
 # We'll create a variety of gadgets that assume the MMU's TLB is stored at certain
 # offsets into its structure. These should match the offsets in tcg-target.c.in.
-QEMU_ALLOWED_MMU_OFFSETS = [ 64, 96, 128 ]
+QEMU_ALLOWED_MMU_OFFSETS = [ 32, 64, 96, 128 ]
 
 # Statistics.
 gadgets      = 0
@@ -54,14 +55,16 @@ def START_COLLECTION(name):
 
     # Create the relevant output files
     new_c_file = open(f"tcti_{name}_gadgets.c", "w")
+    new_s_file = open(f"tcti_{name}_gadgets.s", "w")
     new_h_file = open(f"tcti_{name}_gadgets.h", "w")
-    output_files[name] = (new_c_file, new_h_file)
+    output_files[name] = (new_c_file, new_s_file, new_h_file)
 
     # Add the file to our gadget collection.
     print(f'#include "tcti_{name}_gadgets.h"', file=top_header)
 
     # Add generated messages to the relevant collection.
     print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=new_c_file)
+    print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=new_s_file)
     print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=new_h_file)
 
     # Start our C file with inclusion of the relevant header.
@@ -82,22 +85,19 @@ def simple(name, *lines):
     gadgets += 1
 
     # Fetch the files we'll be using for output.
-    c_file, h_file = _get_output_files()
+    c_file, s_file, h_file = _get_output_files()
 
     # Create our C/ASM framing.
-    print(f"__attribute__((naked)) void gadget_{name}(void);", file=h_file)
-    print(f"__attribute__((naked)) void gadget_{name}(void)", file=c_file)
-    print("{", file=c_file)
+    print(f"void gadget_{name}(void);", file=h_file)
+    print(f".global gadget_{name}", file=s_file)
+    print(f"gadget_{name}:", file=s_file)
 
     # Add the core gadget
-    print("\tasm(", file=c_file)
     for line in lines + EPILOGUE:
-        print(f"\t\t\"{line} \\n\"", file=c_file)
+        print(f"\t{line}", file=s_file)
         instructions += 1
-    print("\t);", file=c_file)
 
-    # End our framing.
-    print("}\n", file=c_file)
+    print(f"", file=s_file)
 
 
 def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
@@ -149,7 +149,7 @@ def with_dnm(name, *lines):
     with_register_substitutions(name, ("d", "n", "m"), *lines)
 
     # Fetch the files we'll be using for output.
-    c_file, h_file = _get_output_files()
+    c_file, s_file, h_file = _get_output_files()
 
     # Print out an extern.
     print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
@@ -180,7 +180,7 @@ def with_dn_immediate(name, *lines, immediate_range):
     with_register_substitutions(name, ["d", "n"], *lines, immediate_range=immediate_range)
 
     # Fetch the files we'll be using for output.
-    c_file, h_file = _get_output_files()
+    c_file, s_file, h_file = _get_output_files()
 
     # Print out an extern.
     print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}];", file=h_file)
@@ -211,7 +211,7 @@ def with_pair(name, substitutions, *lines):
     with_register_substitutions(name, substitutions, *lines)
 
     # Fetch the files we'll be using for output.
-    c_file, h_file = _get_output_files()
+    c_file, s_file, h_file = _get_output_files()
 
     print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
 
@@ -236,10 +236,10 @@ def math_dnm(name, mnemonic):
     with_dnm(f'{name}_i32', f"{mnemonic} Wd, Wn, Wm")
     with_dnm(f'{name}_i64', f"{mnemonic} Xd, Xn, Xm")
 
-def math_dn(name, mnemonic):
+def math_dn(name, mnemonic, source_is_wn=False):
     """ Equivalent to `with_dn`, but creates a _i32 and _i64 variant. For simple math. """
     with_dn(f'{name}_i32', f"{mnemonic} Wd, Wn")
-    with_dn(f'{name}_i64', f"{mnemonic} Xd, Xn")
+    with_dn(f'{name}_i64', f"{mnemonic} Xd, Wn" if source_is_wn else f"{mnemonic} Xd, Xn")
 
 
 def with_nm(name, *lines):
@@ -281,7 +281,7 @@ def with_single(name, substitution, *lines):
     with_register_substitutions(name, (substitution,), *lines)
 
     # Fetch the files we'll be using for output.
-    c_file, h_file = _get_output_files()
+    c_file, s_file, h_file = _get_output_files()
 
     print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}];", file=h_file)
 
@@ -300,7 +300,7 @@ def with_d_immediate(name, *lines, immediate_range=range(0)):
     with_register_substitutions(name, ['d'], *lines, immediate_range=immediate_range)
 
     # Fetch the files we'll be using for output.
-    c_file, h_file = _get_output_files()
+    c_file, s_file, h_file = _get_output_files()
 
     print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}];", file=h_file)
 
@@ -651,7 +651,7 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
         "ldr x27, [x28], #8",
 
         # Perform our comparison and conditional branch.
-        "subs Wzr, Wn, Wm",
+        "subs wzr, Wn, Wm",
         f"b{condition} 1f",
 
         "0:", # not taken
@@ -670,7 +670,7 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
         "ldr x27, [x28], #8",
 
         # Perform our comparison and conditional branch.
-        "subs Xzr, Xn, Xm",
+        "subs xzr, Xn, Xm",
         f"b{condition} 1f",
 
         "0:", # not taken
@@ -697,22 +697,19 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 with_d_immediate("movi_imm_i32", "mov Wd, #Ii", immediate_range=range(64))
 with_d_immediate("movi_imm_i64", "mov Xd, #Ii", immediate_range=range(64))
 
-START_COLLECTION("load_unsigned")
+START_COLLECTION("load")
 
 # LOAD variants.
 # TODO: should the signed variants have X variants for _i64?
 ldst_dn("ld8u",      "ldrb  Wd, [Xn, x27]")
-ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
-ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
-ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
-
-START_COLLECTION("load_signed")
-
 ldst_dn("ld8s_i32",  "ldrsb Wd, [Xn, x27]")
 ldst_dn("ld8s_i64",  "ldrsb Xd, [Xn, x27]")
+ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
 ldst_dn("ld16s_i32", "ldrsh Wd, [Xn, x27]")
 ldst_dn("ld16s_i64", "ldrsh Xd, [Xn, x27]")
+ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
 ldst_dn("ld32s_i64", "ldrsw Xd, [Xn, x27]")
+ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
 
 START_COLLECTION("store")
 
@@ -764,9 +761,9 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 START_COLLECTION("extension")
 
 # Numeric extension.
-math_dn("ext8s",      "sxtb")
+math_dn("ext8s",      "sxtb", source_is_wn=True)
 with_dn("ext8u",      "and Xd, Xn, #0xff")
-math_dn("ext16s",     "sxth")
+math_dn("ext16s",     "sxth", source_is_wn=True)
 with_dn("ext16u",     "and Wd, Wn, #0xffff")
 with_dn("ext32s_i64", "sxtw Xd, Wn")
 with_dn("ext32u_i64", "and Xd, Xn, #0xffffffff")
@@ -874,11 +871,20 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 
 
 # Print a list of output files generated.
-output_c_filenames = ", ".join(f"'tcti_{name}_gadgets.c'" for name in output_files.keys())
-output_h_filenames = ", ".join(f"'tcti_{name}_gadgets.h'" for name in output_files.keys())
+output_c_filenames = (f"'tcti_{name}_gadgets.c'" for name in output_files.keys())
+output_s_filenames = (f"'tcti_{name}_gadgets.s'" for name in output_files.keys())
+output_h_filenames = (f"'tcti_{name}_gadgets.h'" for name in output_files.keys())
+
+print("Sources generated:",    file=sys.stderr)
+print(f"gadgets = [",          file=sys.stderr)
+print("      tcti_gadgets.h,", file=sys.stderr)
+
+for name in output_files.keys():
+    print(f"      tcti_{name}_gadgets.c,", file=sys.stderr)
+    print(f"      tcti_{name}_gadgets.s,", file=sys.stderr)
+    print(f"      tcti_{name}_gadgets.h,", file=sys.stderr)
 
-print("Sources generated:", file=sys.stderr)
-print(f"output: [{output_c_filenames}, {output_h_filenames}, 'tcti_gadgets.h']", file=sys.stderr)
+print(f"]", file=sys.stderr)
 
 # Statistics.
 sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions ({instructions * 4} B).\n\n")

From 6764fe306fe541ee7768b545b4d853b5fa74b275 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Wed, 28 Apr 2021 05:37:42 -0600
Subject: [PATCH 029/180] TCTI: more modular hacks

---
 meson.build                         | 69 ++++++++++++++++++++++-----
 tcg/aarch64-tcti/tcg-target.c.inc   | 18 +++----
 tcg/aarch64-tcti/tcti-gadget-gen.py | 73 ++++++++++++++++++-----------
 3 files changed, 112 insertions(+), 48 deletions(-)

diff --git a/meson.build b/meson.build
index 02a6354802c7..dfd1606bfa30 100644
--- a/meson.build
+++ b/meson.build
@@ -265,15 +265,21 @@ if not get_option('tcg').disabled()
         'tcti_misc_gadgets.c',
         'tcti_misc_gadgets.s',
         'tcti_misc_gadgets.h',
-        'tcti_conditionals_gadgets.c',
-        'tcti_conditionals_gadgets.s',
-        'tcti_conditionals_gadgets.h',
+        'tcti_setcond_gadgets.c',
+        'tcti_setcond_gadgets.s',
+        'tcti_setcond_gadgets.h',
+        'tcti_brcond_gadgets.c',
+        'tcti_brcond_gadgets.s',
+        'tcti_brcond_gadgets.h',
         'tcti_mov_gadgets.c',
         'tcti_mov_gadgets.s',
         'tcti_mov_gadgets.h',
-        'tcti_load_gadgets.c',
-        'tcti_load_gadgets.s',
-        'tcti_load_gadgets.h',
+        'tcti_load_signed_gadgets.c',
+        'tcti_load_signed_gadgets.s',
+        'tcti_load_signed_gadgets.h',
+        'tcti_load_unsigned_gadgets.c',
+        'tcti_load_unsigned_gadgets.s',
+        'tcti_load_unsigned_gadgets.h',
         'tcti_store_gadgets.c',
         'tcti_store_gadgets.s',
         'tcti_store_gadgets.h',
@@ -289,12 +295,51 @@ if not get_option('tcg').disabled()
         'tcti_byteswap_gadgets.c',
         'tcti_byteswap_gadgets.s',
         'tcti_byteswap_gadgets.h',
-        'tcti_qemu_ld_gadgets.c',
-        'tcti_qemu_ld_gadgets.s',
-        'tcti_qemu_ld_gadgets.h',
-        'tcti_qemu_st_gadgets.c',
-        'tcti_qemu_st_gadgets.s',
-        'tcti_qemu_st_gadgets.h',
+        'tcti_qemu_ld_aligned_signed_le_gadgets.c',
+        'tcti_qemu_ld_aligned_signed_le_gadgets.s',
+        'tcti_qemu_ld_aligned_signed_le_gadgets.h',
+        'tcti_qemu_ld_unaligned_signed_le_gadgets.c',
+        'tcti_qemu_ld_unaligned_signed_le_gadgets.s',
+        'tcti_qemu_ld_unaligned_signed_le_gadgets.h',
+        'tcti_qemu_ld_slowpath_signed_le_gadgets.c',
+        'tcti_qemu_ld_slowpath_signed_le_gadgets.s',
+        'tcti_qemu_ld_slowpath_signed_le_gadgets.h',
+        'tcti_qemu_ld_aligned_unsigned_le_gadgets.c',
+        'tcti_qemu_ld_aligned_unsigned_le_gadgets.s',
+        'tcti_qemu_ld_aligned_unsigned_le_gadgets.h',
+        'tcti_qemu_ld_unaligned_unsigned_le_gadgets.c',
+        'tcti_qemu_ld_unaligned_unsigned_le_gadgets.s',
+        'tcti_qemu_ld_unaligned_unsigned_le_gadgets.h',
+        'tcti_qemu_ld_slowpath_unsigned_le_gadgets.c',
+        'tcti_qemu_ld_slowpath_unsigned_le_gadgets.s',
+        'tcti_qemu_ld_slowpath_unsigned_le_gadgets.h',
+        'tcti_qemu_ld_aligned_be_gadgets.c',
+        'tcti_qemu_ld_aligned_be_gadgets.s',
+        'tcti_qemu_ld_aligned_be_gadgets.h',
+        'tcti_qemu_ld_unaligned_be_gadgets.c',
+        'tcti_qemu_ld_unaligned_be_gadgets.s',
+        'tcti_qemu_ld_unaligned_be_gadgets.h',
+        'tcti_qemu_ld_slowpath_be_gadgets.c',
+        'tcti_qemu_ld_slowpath_be_gadgets.s',
+        'tcti_qemu_ld_slowpath_be_gadgets.h',
+        'tcti_qemu_st_aligned_le_gadgets.c',
+        'tcti_qemu_st_aligned_le_gadgets.s',
+        'tcti_qemu_st_aligned_le_gadgets.h',
+        'tcti_qemu_st_unaligned_le_gadgets.c',
+        'tcti_qemu_st_unaligned_le_gadgets.s',
+        'tcti_qemu_st_unaligned_le_gadgets.h',
+        'tcti_qemu_st_slowpath_le_gadgets.c',
+        'tcti_qemu_st_slowpath_le_gadgets.s',
+        'tcti_qemu_st_slowpath_le_gadgets.h',
+        'tcti_qemu_st_aligned_be_gadgets.c',
+        'tcti_qemu_st_aligned_be_gadgets.s',
+        'tcti_qemu_st_aligned_be_gadgets.h',
+        'tcti_qemu_st_unaligned_be_gadgets.c',
+        'tcti_qemu_st_unaligned_be_gadgets.s',
+        'tcti_qemu_st_unaligned_be_gadgets.h',
+        'tcti_qemu_st_slowpath_be_gadgets.c',
+        'tcti_qemu_st_slowpath_be_gadgets.s',
+        'tcti_qemu_st_slowpath_be_gadgets.h',
     ]
     tcti_gadgets = custom_target('tcti-gadgets.h',
                               output: gadgets,
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index 7cf6acdc3dfa..b5da8e228162 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -365,13 +365,13 @@ tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr,
 
 
 /* Write gadget pointer. */
-static void tcg_out_nullary_gadget(TCGContext *s, void *gadget)
+static void tcg_out_nullary_gadget(TCGContext *s, const void *gadget)
 {
     tcg_out_immediate(s, (tcg_target_ulong)gadget);
 }
 
 /* Write gadget pointer, plus 64b immediate. */
-static void tcg_out_imm64_gadget(TCGContext *s, void *gadget, tcg_target_ulong immediate)
+static void tcg_out_imm64_gadget(TCGContext *s, const void *gadget, tcg_target_ulong immediate)
 {
     tcg_out_nullary_gadget(s, gadget);
     tcg_out64(s, immediate);
@@ -379,21 +379,21 @@ static void tcg_out_imm64_gadget(TCGContext *s, void *gadget, tcg_target_ulong i
 
 
 /* Write gadget pointer (one register). */
-static void tcg_out_unary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS], unsigned reg0)
+static void tcg_out_unary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_NB_REGS], unsigned reg0)
 {
     tcg_out_nullary_gadget(s, gadget_base[reg0]);
 }
 
 
 /* Write gadget pointer (two registers). */
-static void tcg_out_binary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1)
+static void tcg_out_binary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1)
 {
     tcg_out_nullary_gadget(s, gadget_base[reg0][reg1]);
 }
 
 
 /* Write gadget pointer (three registers). */
-static void tcg_out_ternary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1, unsigned reg2)
+static void tcg_out_ternary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1, unsigned reg2)
 {
     tcg_out_nullary_gadget(s, gadget_base[reg0][reg1][reg2]);
 }
@@ -403,10 +403,10 @@ static void tcg_out_ternary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_N
  * Version of our LDST generator that defers to more optimized gadgets selectively.
  */
 static void tcg_out_ldst_gadget_inner(TCGContext *s, 
-    void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], 
-    void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
-    void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
-    void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    const void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], 
+    const void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    const void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    const void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
     unsigned reg0, unsigned reg1, uint32_t offset)
 {
     int64_t extended_offset = (int32_t)offset;
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 800702fad3db..3501988acc80 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -53,6 +53,10 @@ def START_COLLECTION(name):
 
     global current_collection
 
+    # If we already have a collection for this, skip it.
+    if name in output_files:
+        return
+
     # Create the relevant output files
     new_c_file = open(f"tcti_{name}_gadgets.c", "w")
     new_s_file = open(f"tcti_{name}_gadgets.s", "w")
@@ -152,10 +156,10 @@ def with_dnm(name, *lines):
     c_file, s_file, h_file = _get_output_files()
 
     # Print out an extern.
-    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
+    print(f"extern const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
+    print(f"const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
     print("{", file=c_file)
 
     # D array
@@ -183,10 +187,10 @@ def with_dn_immediate(name, *lines, immediate_range):
     c_file, s_file, h_file = _get_output_files()
 
     # Print out an extern.
-    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}];", file=h_file)
+    print(f"extern const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}];", file=h_file)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="", file=c_file)
+    print(f"const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="", file=c_file)
     print("{", file=c_file)
 
     # D array
@@ -213,10 +217,10 @@ def with_pair(name, substitutions, *lines):
     # Fetch the files we'll be using for output.
     c_file, s_file, h_file = _get_output_files()
 
-    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
+    print(f"extern const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
+    print(f"const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
     print("{", file=c_file)
 
     # N array
@@ -283,10 +287,10 @@ def with_single(name, substitution, *lines):
     # Fetch the files we'll be using for output.
     c_file, s_file, h_file = _get_output_files()
 
-    print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}];", file=h_file)
+    print(f"extern const void* gadget_{name}[{TCG_REGISTER_COUNT}];", file=h_file)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
+    print(f"const void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="", file=c_file)
     print("{", file=c_file)
 
     for n in TCG_REGISTER_NUMBERS:
@@ -619,11 +623,12 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 simple("mb_ld",  "dmb ishld")
 
 
-START_COLLECTION("conditionals")
 
 
 for condition in ARCH_CONDITION_CODES:
 
+    START_COLLECTION("setcond")
+
     # Performs a comparison between two operands.
     with_dnm(f"setcond_i32_{condition}",
         "subs Wd, Wn, Wm",
@@ -644,6 +649,8 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
     # branch is funneled throught the same address.
     #
 
+    START_COLLECTION("brcond")
+
     # Branches iff a given comparison is true.
     with_dnm(f'brcond_i32_{condition}',
 
@@ -697,19 +704,22 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 with_d_immediate("movi_imm_i32", "mov Wd, #Ii", immediate_range=range(64))
 with_d_immediate("movi_imm_i64", "mov Xd, #Ii", immediate_range=range(64))
 
-START_COLLECTION("load")
+START_COLLECTION("load_unsigned")
 
 # LOAD variants.
 # TODO: should the signed variants have X variants for _i64?
 ldst_dn("ld8u",      "ldrb  Wd, [Xn, x27]")
+ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
+ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
+ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
+
+START_COLLECTION("load_signed")
+
 ldst_dn("ld8s_i32",  "ldrsb Wd, [Xn, x27]")
 ldst_dn("ld8s_i64",  "ldrsb Xd, [Xn, x27]")
-ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
 ldst_dn("ld16s_i32", "ldrsh Wd, [Xn, x27]")
 ldst_dn("ld16s_i64", "ldrsh Xd, [Xn, x27]")
-ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
 ldst_dn("ld32s_i64", "ldrsw Xd, [Xn, x27]")
-ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
 
 START_COLLECTION("store")
 
@@ -775,48 +785,54 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 with_dn("bswap32",    "rev Wd, Wn")
 with_dn("bswap64",    "rev Xd, Xn")
 
-START_COLLECTION("qemu_ld")
 
 # Handlers for QEMU_LD, which handles guest <- host loads.
 for subtype in ('aligned', 'unaligned', 'slowpath'):
     is_aligned  = (subtype == 'aligned')
     is_slowpath = (subtype == 'slowpath')
 
+    START_COLLECTION(f"qemu_ld_{subtype}_unsigned_le")
+
     ld_thunk(f"qemu_ld_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu",
         fastpath_32b=["ldrb Wd, [Xn, x27]"], fastpath_64b=["ldrb Wd, [Xn, x27]"],
         force_slowpath=is_slowpath,
     )
-    ld_thunk(f"qemu_ld_sb_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu_signed",
-        fastpath_32b=["ldrsb Wd, [Xn, x27]"], fastpath_64b=["ldrsb Xd, [Xn, x27]"],
-        force_slowpath=is_slowpath,
-    )
     ld_thunk(f"qemu_ld_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu",
         fastpath_32b=["ldrh Wd, [Xn, x27]"], fastpath_64b=["ldrh Wd, [Xn, x27]"],
         force_slowpath=is_slowpath,
     )
-    ld_thunk(f"qemu_ld_lesw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu_signed",
-        fastpath_32b=["ldrsh Wd, [Xn, x27]"], fastpath_64b=["ldrsh Xd, [Xn, x27]"],
-        force_slowpath=is_slowpath,
-    )
     ld_thunk(f"qemu_ld_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu",
         fastpath_32b=["ldr Wd, [Xn, x27]"], fastpath_64b=["ldr Wd, [Xn, x27]"],
         force_slowpath=is_slowpath,
     )
-    ld_thunk(f"qemu_ld_lesl_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu_signed",
-        fastpath_32b=["ldrsw Xd, [Xn, x27]"], fastpath_64b=["ldrsw Xd, [Xn, x27]"],
-        force_slowpath=is_slowpath,
-    )
     ld_thunk(f"qemu_ld_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
         fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
         force_slowpath=is_slowpath,
     )
 
+    START_COLLECTION(f"qemu_ld_{subtype}_signed_le")
+
+    ld_thunk(f"qemu_ld_sb_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu_signed",
+        fastpath_32b=["ldrsb Wd, [Xn, x27]"], fastpath_64b=["ldrsb Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu_signed",
+        fastpath_32b=["ldrsh Wd, [Xn, x27]"], fastpath_64b=["ldrsh Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesl_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu_signed",
+        fastpath_32b=["ldrsw Xd, [Xn, x27]"], fastpath_64b=["ldrsw Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+
     # Special variant for the most common mode, as a speedup optimization.
     ld_thunk(f"qemu_ld_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
         fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
         force_slowpath=is_slowpath, immediate=0x3a
     )
 
+    START_COLLECTION(f"qemu_ld_{subtype}_be")
+
     # For now, leave the rare/big-endian stuff slow-path only.
     ld_thunk(f"qemu_ld_beuw_{subtype}", None, None, "helper_be_lduw_mmu",         
             is_aligned=is_aligned, force_slowpath=is_slowpath)
@@ -830,7 +846,6 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
             is_aligned=is_aligned, force_slowpath=is_slowpath)
 
 
-START_COLLECTION("qemu_st")
 
 
 # Handlers for QEMU_ST, which handles guest -> host stores.
@@ -838,6 +853,8 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
     is_aligned  = (subtype == 'aligned')
     is_slowpath = (subtype == 'slowpath')
 
+    START_COLLECTION(f"qemu_st_{subtype}_le")
+
     st_thunk(f"qemu_st_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_stb_mmu",
         fastpath_32b=["strb Wd, [Xn, x27]"], fastpath_64b=["strb Wd, [Xn, x27]"],
         force_slowpath=is_slowpath,
@@ -861,6 +878,8 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
         force_slowpath=is_slowpath, immediate=0x3a
     )
 
+    START_COLLECTION(f"qemu_st_{subtype}_be")
+
     # For now, leave the rare/big-endian stuff slow-path only.
     st_thunk(f"qemu_st_beuw_{subtype}", None, None, "helper_be_stw_mmu",  
             is_aligned=is_aligned, force_slowpath=is_slowpath)

From 69c9fe3f2edc904e93f3dded97d50e02db27dbed Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Thu, 29 Apr 2021 04:23:23 -0600
Subject: [PATCH 030/180] TCTI: modularize things more for fast clang

---
 configure                           | 14 ++++++++
 meson.build                         | 50 +++++++++++------------------
 tcg/aarch64-tcti/tcti-gadget-gen.py | 43 +++++++++++++------------
 3 files changed, 55 insertions(+), 52 deletions(-)

diff --git a/configure b/configure
index c3637f198428..9858e71f538a 100755
--- a/configure
+++ b/configure
@@ -479,6 +479,8 @@ for opt do
   ;;
   --cc=*) CC="$optarg"
   ;;
+  --ld=*) LD="$optarg"
+  ;;
   --cxx=*) CXX="$optarg"
   ;;
   --cpu=*) cpu="$optarg"
@@ -908,6 +910,8 @@ for opt do
   ;;
   --cc=*)
   ;;
+  --ld=*) ld="$optarg"
+  ;;
   --host-cc=*) host_cc="$optarg"
   ;;
   --cxx=*)
@@ -1696,6 +1700,13 @@ case "$cpu" in
     # No special flags required for other host CPUs
 esac
 
+# XXX
+QEMU_LDFLAGS="$QEMU_LDFLAGS -Wl,-no_deduplicate"
+QEMU_LDFLAGS="$QEMU_LDFLAGS -Wl,-random_uuid"
+#QEMU_LDFLAGS="$QEMU_LDFLAGS -Wl,-force_load"
+QEMU_LDFLAGS="$QEMU_LDFLAGS -Wl,-no_compact_unwind"
+
+
 eval "cross_cc_${cpu}=\$host_cc"
 cross_cc_vars="$cross_cc_vars cross_cc_${cpu}"
 QEMU_CFLAGS="$CPU_CFLAGS $QEMU_CFLAGS"
@@ -6473,6 +6484,9 @@ else
 fi
 mv $cross config-meson.cross
 
+export CC_LD="$ld"
+export CXX_LD="$ld"
+
 rm -rf meson-private meson-info meson-logs
 unset staticpic
 if ! version_ge "$($meson --version)" 0.56.0; then
diff --git a/meson.build b/meson.build
index dfd1606bfa30..7927a1d163ab 100644
--- a/meson.build
+++ b/meson.build
@@ -142,6 +142,7 @@ if link_language == 'cpp'
 endif
 if host_machine.system() == 'darwin'
   add_languages('objc', required: false, native: false)
+  add_project_link_arguments(['-fvisibility-inlines-hidden', '-Xlinker', '-no_deduplicate'], native: false, language: ['c', 'cpp', 'objc'])
 endif
 
 sparse = find_program('cgcc', required: get_option('sparse'))
@@ -260,95 +261,68 @@ if not get_option('tcg').disabled()
 
     # Tell our compiler how to generate our TCTI gadgets.
     gadget_generator = 'tcg/@0@/tcti-gadget-gen.py'.format(tcg_arch)
-    gadgets = [
+    tcti_sources = [
         'tcti_gadgets.h',
-        'tcti_misc_gadgets.c',
         'tcti_misc_gadgets.s',
         'tcti_misc_gadgets.h',
-        'tcti_setcond_gadgets.c',
         'tcti_setcond_gadgets.s',
         'tcti_setcond_gadgets.h',
-        'tcti_brcond_gadgets.c',
         'tcti_brcond_gadgets.s',
         'tcti_brcond_gadgets.h',
-        'tcti_mov_gadgets.c',
         'tcti_mov_gadgets.s',
         'tcti_mov_gadgets.h',
-        'tcti_load_signed_gadgets.c',
         'tcti_load_signed_gadgets.s',
         'tcti_load_signed_gadgets.h',
-        'tcti_load_unsigned_gadgets.c',
         'tcti_load_unsigned_gadgets.s',
         'tcti_load_unsigned_gadgets.h',
-        'tcti_store_gadgets.c',
         'tcti_store_gadgets.s',
         'tcti_store_gadgets.h',
-        'tcti_arithmetic_gadgets.c',
         'tcti_arithmetic_gadgets.s',
         'tcti_arithmetic_gadgets.h',
-        'tcti_logical_gadgets.c',
         'tcti_logical_gadgets.s',
         'tcti_logical_gadgets.h',
-        'tcti_extension_gadgets.c',
         'tcti_extension_gadgets.s',
         'tcti_extension_gadgets.h',
-        'tcti_byteswap_gadgets.c',
         'tcti_byteswap_gadgets.s',
         'tcti_byteswap_gadgets.h',
-        'tcti_qemu_ld_aligned_signed_le_gadgets.c',
         'tcti_qemu_ld_aligned_signed_le_gadgets.s',
         'tcti_qemu_ld_aligned_signed_le_gadgets.h',
-        'tcti_qemu_ld_unaligned_signed_le_gadgets.c',
         'tcti_qemu_ld_unaligned_signed_le_gadgets.s',
         'tcti_qemu_ld_unaligned_signed_le_gadgets.h',
-        'tcti_qemu_ld_slowpath_signed_le_gadgets.c',
         'tcti_qemu_ld_slowpath_signed_le_gadgets.s',
         'tcti_qemu_ld_slowpath_signed_le_gadgets.h',
-        'tcti_qemu_ld_aligned_unsigned_le_gadgets.c',
         'tcti_qemu_ld_aligned_unsigned_le_gadgets.s',
         'tcti_qemu_ld_aligned_unsigned_le_gadgets.h',
-        'tcti_qemu_ld_unaligned_unsigned_le_gadgets.c',
         'tcti_qemu_ld_unaligned_unsigned_le_gadgets.s',
         'tcti_qemu_ld_unaligned_unsigned_le_gadgets.h',
-        'tcti_qemu_ld_slowpath_unsigned_le_gadgets.c',
         'tcti_qemu_ld_slowpath_unsigned_le_gadgets.s',
         'tcti_qemu_ld_slowpath_unsigned_le_gadgets.h',
-        'tcti_qemu_ld_aligned_be_gadgets.c',
         'tcti_qemu_ld_aligned_be_gadgets.s',
         'tcti_qemu_ld_aligned_be_gadgets.h',
-        'tcti_qemu_ld_unaligned_be_gadgets.c',
         'tcti_qemu_ld_unaligned_be_gadgets.s',
         'tcti_qemu_ld_unaligned_be_gadgets.h',
-        'tcti_qemu_ld_slowpath_be_gadgets.c',
         'tcti_qemu_ld_slowpath_be_gadgets.s',
         'tcti_qemu_ld_slowpath_be_gadgets.h',
-        'tcti_qemu_st_aligned_le_gadgets.c',
         'tcti_qemu_st_aligned_le_gadgets.s',
         'tcti_qemu_st_aligned_le_gadgets.h',
-        'tcti_qemu_st_unaligned_le_gadgets.c',
         'tcti_qemu_st_unaligned_le_gadgets.s',
         'tcti_qemu_st_unaligned_le_gadgets.h',
-        'tcti_qemu_st_slowpath_le_gadgets.c',
         'tcti_qemu_st_slowpath_le_gadgets.s',
         'tcti_qemu_st_slowpath_le_gadgets.h',
-        'tcti_qemu_st_aligned_be_gadgets.c',
         'tcti_qemu_st_aligned_be_gadgets.s',
         'tcti_qemu_st_aligned_be_gadgets.h',
-        'tcti_qemu_st_unaligned_be_gadgets.c',
         'tcti_qemu_st_unaligned_be_gadgets.s',
         'tcti_qemu_st_unaligned_be_gadgets.h',
-        'tcti_qemu_st_slowpath_be_gadgets.c',
         'tcti_qemu_st_slowpath_be_gadgets.s',
         'tcti_qemu_st_slowpath_be_gadgets.h',
     ]
     tcti_gadgets = custom_target('tcti-gadgets.h',
-                              output: gadgets,
+                              output: tcti_sources,
                               input: gadget_generator,
                               command: [find_program(gadget_generator)],
                               build_by_default: true,
                               build_always_stale: false)
 
-    
   elif config_host['ARCH'] == 'sparc64'
     tcg_arch = 'sparc'
   elif config_host['ARCH'] == 's390x'
@@ -1806,6 +1780,7 @@ qom_ss = ss.source_set()
 softmmu_ss = ss.source_set()
 specific_fuzz_ss = ss.source_set()
 specific_ss = ss.source_set()
+tcti_ss = ss.source_set()
 stub_ss = ss.source_set()
 trace_ss = ss.source_set()
 user_ss = ss.source_set()
@@ -2027,7 +2002,10 @@ endif
 common_ss.add(pagevary)
 specific_ss.add(files('page-vary.c'))
 specific_ss.add(when: 'CONFIG_TCG_INTERPRETER', if_true: files('tcg/tci.c'))
-specific_ss.add(when: 'CONFIG_TCG_THREADED_INTERPRETER', if_true: tcti_gadgets)
+
+# FIXME: This is being used for now for development quickness, but these realy should be
+# added to a gadget-specific shared library.
+tcti_ss.add(when: 'CONFIG_TCG_THREADED_INTERPRETER', if_true: tcti_gadgets)
 
 subdir('backends')
 subdir('disas')
@@ -2197,6 +2175,12 @@ common_all = static_library('common',
                             dependencies: common_all.dependencies(),
                             name_suffix: 'fa')
 
+tcti_all = common_ss.apply(config_all, strict: false)
+tcti_all = shared_library('tcti',
+                            build_by_default: false,
+                            sources: tcti_gadgets,
+                            name_suffix: 'fa')
+
 feature_to_c = find_program('scripts/feature_to_c.sh')
 
 emulators = {}
@@ -2270,7 +2254,7 @@ foreach target : target_dirs
   arch_deps += t.dependencies()
 
   target_common = common_ss.apply(config_target, strict: false)
-  objects = common_all.extract_objects(target_common.sources())
+  objects = [common_all.extract_objects(target_common.sources()), tcti_all.extract_all_objects()]
   deps = target_common.dependencies()
 
   target_specific = specific_ss.apply(config_target, strict: false)
@@ -2301,7 +2285,9 @@ foreach target : target_dirs
                  include_directories: target_inc,
                  c_args: c_args,
                  build_by_default: false,
-                 kwargs: build_lib_args)
+                 kwargs: build_lib_args,
+                 link_with: tcti_all
+                 )
 
   if target.endswith('-softmmu')
     execs = [{
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 3501988acc80..60dba2ffc907 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -59,16 +59,14 @@ def START_COLLECTION(name):
 
     # Create the relevant output files
     new_c_file = open(f"tcti_{name}_gadgets.c", "w")
-    new_s_file = open(f"tcti_{name}_gadgets.s", "w")
     new_h_file = open(f"tcti_{name}_gadgets.h", "w")
-    output_files[name] = (new_c_file, new_s_file, new_h_file)
+    output_files[name] = (new_c_file, new_h_file)
 
     # Add the file to our gadget collection.
     print(f'#include "tcti_{name}_gadgets.h"', file=top_header)
 
     # Add generated messages to the relevant collection.
     print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=new_c_file)
-    print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=new_s_file)
     print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n", file=new_h_file)
 
     # Start our C file with inclusion of the relevant header.
@@ -81,7 +79,7 @@ def START_COLLECTION(name):
     current_collection = name
     
 
-def simple(name, *lines):
+def simple(name, *lines, export=True):
     """ Generates a simple gadget that needs no per-register specialization. """
 
     global gadgets, instructions
@@ -89,19 +87,26 @@ def simple(name, *lines):
     gadgets += 1
 
     # Fetch the files we'll be using for output.
-    c_file, s_file, h_file = _get_output_files()
+    c_file, h_file = _get_output_files()
 
     # Create our C/ASM framing.
-    print(f"void gadget_{name}(void);", file=h_file)
-    print(f".global gadget_{name}", file=s_file)
-    print(f"gadget_{name}:", file=s_file)
+    if export:
+        print(f"__attribute__((naked)) void gadget_{name}(void);", file=h_file)
+        print(f"__attribute__((naked)) void gadget_{name}(void)", file=c_file)
+    else:
+        print(f"static __attribute__((naked)) void gadget_{name}(void)", file=c_file)
+
+    print("{", file=c_file)
 
     # Add the core gadget
+    print("\tasm(", file=c_file)
     for line in lines + EPILOGUE:
-        print(f"\t{line}", file=s_file)
+        print(f"\t\t\"{line} \\n\"", file=c_file)
         instructions += 1
+    print("\t);", file=c_file)
 
-    print(f"", file=s_file)
+    # End our framing.
+    print("}\n", file=c_file)
 
 
 def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
@@ -145,7 +150,7 @@ def substitutions_for_letter(letter, number, line):
 
         # ... and emit the gadget.
         permutation_id = "_arg".join(str(number) for number in permutation)
-        simple(f"{name}_arg{permutation_id}", *new_lines)
+        simple(f"{name}_arg{permutation_id}", *new_lines, export=False)
 
 
 def with_dnm(name, *lines):
@@ -153,7 +158,7 @@ def with_dnm(name, *lines):
     with_register_substitutions(name, ("d", "n", "m"), *lines)
 
     # Fetch the files we'll be using for output.
-    c_file, s_file, h_file = _get_output_files()
+    c_file, h_file = _get_output_files()
 
     # Print out an extern.
     print(f"extern const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
@@ -184,7 +189,7 @@ def with_dn_immediate(name, *lines, immediate_range):
     with_register_substitutions(name, ["d", "n"], *lines, immediate_range=immediate_range)
 
     # Fetch the files we'll be using for output.
-    c_file, s_file, h_file = _get_output_files()
+    c_file, h_file = _get_output_files()
 
     # Print out an extern.
     print(f"extern const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}];", file=h_file)
@@ -215,7 +220,7 @@ def with_pair(name, substitutions, *lines):
     with_register_substitutions(name, substitutions, *lines)
 
     # Fetch the files we'll be using for output.
-    c_file, s_file, h_file = _get_output_files()
+    c_file, h_file = _get_output_files()
 
     print(f"extern const void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}];", file=h_file)
 
@@ -285,7 +290,7 @@ def with_single(name, substitution, *lines):
     with_register_substitutions(name, (substitution,), *lines)
 
     # Fetch the files we'll be using for output.
-    c_file, s_file, h_file = _get_output_files()
+    c_file, h_file = _get_output_files()
 
     print(f"extern const void* gadget_{name}[{TCG_REGISTER_COUNT}];", file=h_file)
 
@@ -304,7 +309,7 @@ def with_d_immediate(name, *lines, immediate_range=range(0)):
     with_register_substitutions(name, ['d'], *lines, immediate_range=immediate_range)
 
     # Fetch the files we'll be using for output.
-    c_file, s_file, h_file = _get_output_files()
+    c_file, h_file = _get_output_files()
 
     print(f"extern void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}];", file=h_file)
 
@@ -480,7 +485,7 @@ def ld_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
                     "mov   x3, x28",
 
                     # Perform our actual core code.
-                    f"bl {slowpath_helper}",
+                    f"bl _{slowpath_helper}",
 
                     # Temporarily store our result in a register that won't get trashed.
                     "mov x27, x0",
@@ -560,7 +565,7 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
                     "mov   x4, x28",
 
                     # Perform our actual core code.
-                    f"bl {slowpath_helper}",
+                    f"bl _{slowpath_helper}",
 
                     # Restore our registers after our C call.
                     *C_CALL_EPILOGUE,
@@ -891,7 +896,6 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 
 # Print a list of output files generated.
 output_c_filenames = (f"'tcti_{name}_gadgets.c'" for name in output_files.keys())
-output_s_filenames = (f"'tcti_{name}_gadgets.s'" for name in output_files.keys())
 output_h_filenames = (f"'tcti_{name}_gadgets.h'" for name in output_files.keys())
 
 print("Sources generated:",    file=sys.stderr)
@@ -900,7 +904,6 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 
 for name in output_files.keys():
     print(f"      tcti_{name}_gadgets.c,", file=sys.stderr)
-    print(f"      tcti_{name}_gadgets.s,", file=sys.stderr)
     print(f"      tcti_{name}_gadgets.h,", file=sys.stderr)
 
 print(f"]", file=sys.stderr)

From e252078b6e74c729d9d1609704d3f5b0118d43a4 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sat, 10 Oct 2020 19:52:38 -0700
Subject: [PATCH 031/180] block: feature detection for host block support

On Darwin (iOS), there are no system level APIs for directly accessing
host block devices. We detect this at configure time.
---
 block/file-posix.c   | 33 ++++++++++++++++++++++-----------
 meson.build          |  6 +++++-
 qapi/block-core.json | 10 +++++++---
 3 files changed, 34 insertions(+), 15 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index 20e14f8e96ba..08d7a1891ffd 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -42,6 +42,8 @@
 #include "scsi/constants.h"
 
 #if defined(__APPLE__) && (__MACH__)
+#include <sys/ioctl.h>
+#if defined(HAVE_HOST_BLOCK_DEVICE)
 #include <paths.h>
 #include <sys/param.h>
 #include <IOKit/IOKitLib.h>
@@ -52,6 +54,7 @@
 //#include <IOKit/storage/IOCDTypes.h>
 #include <IOKit/storage/IODVDMedia.h>
 #include <CoreFoundation/CoreFoundation.h>
+#endif /* defined(HAVE_HOST_BLOCK_DEVICE) */
 #endif
 
 #ifdef __sun__
@@ -181,7 +184,17 @@ typedef struct BDRVRawReopenState {
     bool check_cache_dropped;
 } BDRVRawReopenState;
 
-static int fd_open(BlockDriverState *bs);
+static int fd_open(BlockDriverState *bs)
+{
+    BDRVRawState *s = bs->opaque;
+
+    /* this is just to ensure s->fd is sane (its called by io ops) */
+    if (s->fd >= 0) {
+        return 0;
+    }
+    return -EIO;
+}
+
 static int64_t raw_getlength(BlockDriverState *bs);
 
 typedef struct RawPosixAIOData {
@@ -3027,6 +3040,7 @@ static BlockStatsSpecific *raw_get_specific_stats(BlockDriverState *bs)
     return stats;
 }
 
+#if defined(HAVE_HOST_BLOCK_DEVICE)
 static BlockStatsSpecific *hdev_get_specific_stats(BlockDriverState *bs)
 {
     BlockStatsSpecific *stats = g_new(BlockStatsSpecific, 1);
@@ -3036,6 +3050,7 @@ static BlockStatsSpecific *hdev_get_specific_stats(BlockDriverState *bs)
 
     return stats;
 }
+#endif /* HAVE_HOST_BLOCK_DEVICE */
 
 static QemuOptsList raw_create_opts = {
     .name = "raw-create-opts",
@@ -3260,6 +3275,8 @@ BlockDriver bdrv_file = {
 /***********************************************/
 /* host device */
 
+#if defined(HAVE_HOST_BLOCK_DEVICE)
+
 #if defined(__APPLE__) && defined(__MACH__)
 static kern_return_t GetBSDPath(io_iterator_t mediaIterator, char *bsdPath,
                                 CFIndex maxPathSize, int flags);
@@ -3552,16 +3569,6 @@ hdev_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
 }
 #endif /* linux */
 
-static int fd_open(BlockDriverState *bs)
-{
-    BDRVRawState *s = bs->opaque;
-
-    /* this is just to ensure s->fd is sane (its called by io ops) */
-    if (s->fd >= 0)
-        return 0;
-    return -EIO;
-}
-
 static coroutine_fn int
 hdev_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)
 {
@@ -3885,6 +3892,8 @@ static BlockDriver bdrv_host_cdrom = {
 };
 #endif /* __FreeBSD__ */
 
+#endif /* HAVE_HOST_BLOCK_DEVICE */
+
 static void bdrv_file_init(void)
 {
     /*
@@ -3892,6 +3901,7 @@ static void bdrv_file_init(void)
      * registered last will get probed first.
      */
     bdrv_register(&bdrv_file);
+#if defined(HAVE_HOST_BLOCK_DEVICE)
     bdrv_register(&bdrv_host_device);
 #ifdef __linux__
     bdrv_register(&bdrv_host_cdrom);
@@ -3899,6 +3909,7 @@ static void bdrv_file_init(void)
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
     bdrv_register(&bdrv_host_cdrom);
 #endif
+#endif /* HAVE_HOST_BLOCK_DEVICE */
 }
 
 block_init(bdrv_file_init);
diff --git a/meson.build b/meson.build
index c6f4b0cf5e8a..78aa4670fd92 100644
--- a/meson.build
+++ b/meson.build
@@ -181,7 +181,7 @@ if targetos == 'windows'
                                       include_directories: include_directories('.'))
 elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
-  iokit = dependency('appleframeworks', modules: 'IOKit')
+  iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
             cc.find_library('nsl'),
@@ -1056,6 +1056,9 @@ if get_option('cfi')
   add_global_link_arguments(cfi_flags, native: false, language: ['c', 'cpp', 'objc'])
 endif
 
+have_host_block_device = (targetos != 'darwin' or
+    cc.has_header('IOKit/storage/IOMedia.h'))
+
 #################
 # config-host.h #
 #################
@@ -1149,6 +1152,7 @@ config_host_data.set('HAVE_PTY_H', cc.has_header('pty.h'))
 config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
 config_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))
+config_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)
 
 config_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))
 
diff --git a/qapi/block-core.json b/qapi/block-core.json
index 6d227924d06c..ea0d2725d261 100644
--- a/qapi/block-core.json
+++ b/qapi/block-core.json
@@ -897,7 +897,8 @@
   'discriminator': 'driver',
   'data': {
       'file': 'BlockStatsSpecificFile',
-      'host_device': 'BlockStatsSpecificFile',
+      'host_device': { 'type': 'BlockStatsSpecificFile',
+                       'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
       'nvme': 'BlockStatsSpecificNvme' } }
 
 ##
@@ -2814,7 +2815,9 @@
 { 'enum': 'BlockdevDriver',
   'data': [ 'blkdebug', 'blklogwrites', 'blkreplay', 'blkverify', 'bochs',
             'cloop', 'compress', 'copy-on-read', 'dmg', 'file', 'ftp', 'ftps',
-            'gluster', 'host_cdrom', 'host_device', 'http', 'https', 'iscsi',
+            'gluster', 'host_cdrom',
+            {'name': 'host_device', 'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
+            'http', 'https', 'iscsi',
             'luks', 'nbd', 'nfs', 'null-aio', 'null-co', 'nvme', 'parallels',
             'preallocate', 'qcow', 'qcow2', 'qed', 'quorum', 'raw', 'rbd',
             { 'name': 'replication', 'if': 'defined(CONFIG_REPLICATION)' },
@@ -4017,7 +4020,8 @@
       'ftps':       'BlockdevOptionsCurlFtps',
       'gluster':    'BlockdevOptionsGluster',
       'host_cdrom': 'BlockdevOptionsFile',
-      'host_device':'BlockdevOptionsFile',
+      'host_device': { 'type': 'BlockdevOptionsFile',
+                       'if': 'defined(HAVE_HOST_BLOCK_DEVICE)' },
       'http':       'BlockdevOptionsCurlHttp',
       'https':      'BlockdevOptionsCurlHttps',
       'iscsi':      'BlockdevOptionsIscsi',

From 324cef19f89b5b891fe8d6b92478f6d5f66c8562 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Thu, 21 Jan 2021 16:12:00 -0800
Subject: [PATCH 032/180] block: check for sys/disk.h

Some BSD platforms do not have this header.
---
 block.c     | 2 +-
 meson.build | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/block.c b/block.c
index c5b887cec196..7f33709c94da 100644
--- a/block.c
+++ b/block.c
@@ -54,7 +54,7 @@
 #ifdef CONFIG_BSD
 #include <sys/ioctl.h>
 #include <sys/queue.h>
-#ifndef __DragonFly__
+#if defined(HAVE_SYS_DISK_H)
 #include <sys/disk.h>
 #endif
 #endif
diff --git a/meson.build b/meson.build
index 78aa4670fd92..202b1e0f1940 100644
--- a/meson.build
+++ b/meson.build
@@ -1153,6 +1153,7 @@ config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
 config_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))
 config_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)
+config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h'))
 
 config_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))
 

From 47cd50d3d26df8706555e31edc0c11ba45cca61d Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sun, 7 Mar 2021 16:52:56 -0800
Subject: [PATCH 033/180] block: detect DKIOCGETBLOCKCOUNT/SIZE before use

iOS hosts do not have these defined so we fallback to the
default behaviour.

Co-authored-by: Warner Losh <imp@bsdimp.com>
---
 block/file-posix.c | 18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index 08d7a1891ffd..dcd2a2375bfe 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -2321,8 +2321,10 @@ static int64_t raw_getlength(BlockDriverState *bs)
 again:
 #endif
     if (!fstat(fd, &sb) && (S_IFCHR & sb.st_mode)) {
+        size = 0;
 #ifdef DIOCGMEDIASIZE
         if (ioctl(fd, DIOCGMEDIASIZE, (off_t *)&size))
+            size = 0;
 #elif defined(DIOCGPART)
         {
                 struct partinfo pi;
@@ -2331,9 +2333,7 @@ static int64_t raw_getlength(BlockDriverState *bs)
                 else
                         size = 0;
         }
-        if (size == 0)
-#endif
-#if defined(__APPLE__) && defined(__MACH__)
+#elif defined(DKIOCGETBLOCKCOUNT) && defined(DKIOCGETBLOCKSIZE)
         {
             uint64_t sectors = 0;
             uint32_t sector_size = 0;
@@ -2341,19 +2341,15 @@ static int64_t raw_getlength(BlockDriverState *bs)
             if (ioctl(fd, DKIOCGETBLOCKCOUNT, &sectors) == 0
                && ioctl(fd, DKIOCGETBLOCKSIZE, &sector_size) == 0) {
                 size = sectors * sector_size;
-            } else {
-                size = lseek(fd, 0LL, SEEK_END);
-                if (size < 0) {
-                    return -errno;
-                }
             }
         }
-#else
-        size = lseek(fd, 0LL, SEEK_END);
+#endif
+        if (size == 0) {
+            size = lseek(fd, 0LL, SEEK_END);
+        }
         if (size < 0) {
             return -errno;
         }
-#endif
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
         switch(s->type) {
         case FTYPE_CD:

From d1bf1e28b60ca5ae90afc08c557c077e57ca9ad5 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Thu, 21 Jan 2021 16:31:09 -0800
Subject: [PATCH 034/180] slirp: feature detection for smbd

Replace Windows specific macro with a more generic feature detection
macro. Allows slirp smb feature to be disabled manually as well.
---
 configure   | 26 +++++++++++++++++++++++---
 meson.build |  2 +-
 net/slirp.c | 16 ++++++++--------
 3 files changed, 32 insertions(+), 12 deletions(-)

diff --git a/configure b/configure
index 4f374b48890e..9470f5158128 100755
--- a/configure
+++ b/configure
@@ -466,6 +466,7 @@ multiprocess="auto"
 
 malloc_trim="auto"
 gio="$default_feature"
+slirp_smbd="auto"
 
 # parse CC options second
 for opt do
@@ -835,8 +836,6 @@ do
     fi
 done
 
-: ${smbd=${SMBD-/usr/sbin/smbd}}
-
 # Default objcc to clang if available, otherwise use CC
 if has clang; then
   objcc=clang
@@ -1565,6 +1564,10 @@ for opt do
   ;;
   --disable-gio) gio=no
   ;;
+  --enable-slirp-smbd) slirp_smbd=yes
+  ;;
+  --disable-slirp-smbd) slirp_smbd=no
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -1919,6 +1922,7 @@ disabled with --disable-FEATURE, default is enabled if available
   fuse-lseek      SEEK_HOLE/SEEK_DATA support for FUSE exports
   multiprocess    Out of process device emulation support
   gio             libgio support
+  slirp-smbd      use smbd (at path --smbd=*) in slirp networking
 
 NOTE: The object files are built at the place where configure is launched
 EOF
@@ -5255,6 +5259,19 @@ case "$slirp" in
     ;;
 esac
 
+# Check for slirp smbd dupport
+: ${smbd=${SMBD-/usr/sbin/smbd}}
+if test "$slirp_smbd" != "no" ; then
+  if test "$mingw32" = "yes" ; then
+    if test "$slirp_smbd" = "yes" ; then
+      error_exit "Host smbd not supported on this platform."
+    fi
+    slirp_smbd=no
+  else
+    slirp_smbd=yes
+  fi
+fi
+
 ##########################################
 # check for usable __NR_keyctl syscall
 
@@ -5530,7 +5547,10 @@ fi
 if test "$guest_agent" = "yes" ; then
   echo "CONFIG_GUEST_AGENT=y" >> $config_host_mak
 fi
-echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
+if test "$slirp_smbd" = "yes" ; then
+  echo "CONFIG_SLIRP_SMBD=y" >> $config_host_mak
+  echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
+fi
 if test "$vde" = "yes" ; then
   echo "CONFIG_VDE=y" >> $config_host_mak
   echo "VDE_LIBS=$vde_libs" >> $config_host_mak
diff --git a/meson.build b/meson.build
index 202b1e0f1940..3c8905517637 100644
--- a/meson.build
+++ b/meson.build
@@ -2456,7 +2456,7 @@ summary_info += {'genisoimage':       config_host['GENISOIMAGE']}
 if targetos == 'windows' and config_host.has_key('CONFIG_GUEST_AGENT')
   summary_info += {'wixl':            wixl.found() ? wixl.full_path() : false}
 endif
-if slirp_opt != 'disabled'
+if slirp_opt != 'disabled' and 'CONFIG_SLIRP_SMBD' in config_host
   summary_info += {'smbd':            config_host['CONFIG_SMBD_COMMAND']}
 endif
 summary(summary_info, bool_yn: true, section: 'Host binaries')
diff --git a/net/slirp.c b/net/slirp.c
index 7a4e96db5c26..ad3a838e0b46 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -27,7 +27,7 @@
 #include "net/slirp.h"
 
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 #include <pwd.h>
 #include <sys/wait.h>
 #endif
@@ -91,7 +91,7 @@ typedef struct SlirpState {
     Slirp *slirp;
     Notifier poll_notifier;
     Notifier exit_notifier;
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     gchar *smb_dir;
 #endif
     GSList *fwd;
@@ -104,7 +104,7 @@ static QTAILQ_HEAD(, SlirpState) slirp_stacks =
 static int slirp_hostfwd(SlirpState *s, const char *redir_str, Error **errp);
 static int slirp_guestfwd(SlirpState *s, const char *config_str, Error **errp);
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 static int slirp_smb(SlirpState *s, const char *exported_dir,
                      struct in_addr vserver_addr, Error **errp);
 static void slirp_smb_cleanup(SlirpState *s);
@@ -377,7 +377,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
     struct in6_addr ip6_prefix;
     struct in6_addr ip6_host;
     struct in6_addr ip6_dns;
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     struct in_addr smbsrv = { .s_addr = 0 };
 #endif
     NetClientState *nc;
@@ -487,7 +487,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
         return -1;
     }
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     if (vsmbserver && !inet_aton(vsmbserver, &smbsrv)) {
         error_setg(errp, "Failed to parse SMB address");
         return -1;
@@ -602,7 +602,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
             }
         }
     }
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
     if (smb_export) {
         if (slirp_smb(s, smb_export, smbsrv, errp) < 0) {
             goto error;
@@ -794,7 +794,7 @@ void hmp_hostfwd_add(Monitor *mon, const QDict *qdict)
 
 }
 
-#ifndef _WIN32
+#if defined(CONFIG_SLIRP_SMBD)
 
 /* automatic user mode samba server configuration */
 static void slirp_smb_cleanup(SlirpState *s)
@@ -909,7 +909,7 @@ static int slirp_smb(SlirpState* s, const char *exported_dir,
     return 0;
 }
 
-#endif /* !defined(_WIN32) */
+#endif /* defined(CONFIG_SLIRP_SMBD) */
 
 static int guestfwd_can_read(void *opaque)
 {

From 8ed0f7cb4d8cf2af6baab8bbf30b4ded97153c1c Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 7 Mar 2021 17:24:50 -0800
Subject: [PATCH 035/180] meson: option to build as shared library

On iOS, we cannot fork() new processes, so the best way to load QEMU into an
app is through a shared library. We add a new configure option
`--enable-shared-lib` that will build the bulk of QEMU into a shared lib.
The usual executables will then link to the library.
---
 configure         | 14 ++++++++++++--
 meson.build       | 40 ++++++++++++++++++++++++++++++++++------
 meson_options.txt |  2 ++
 3 files changed, 48 insertions(+), 8 deletions(-)

diff --git a/configure b/configure
index 9470f5158128..8acf7a949d62 100755
--- a/configure
+++ b/configure
@@ -463,6 +463,7 @@ gettext="auto"
 fuse="auto"
 fuse_lseek="auto"
 multiprocess="auto"
+shared_lib="false"
 
 malloc_trim="auto"
 gio="$default_feature"
@@ -1568,6 +1569,10 @@ for opt do
   ;;
   --disable-slirp-smbd) slirp_smbd=no
   ;;
+  --enable-shared-lib) shared_lib=true
+  ;;
+  --disable-shared-lib) shared_lib=false
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -1795,6 +1800,7 @@ Advanced options (experts only):
                            enable plugins via shared library loading
   --disable-containers     don't use containers for cross-building
   --gdb=GDB-path           gdb to use for gdbstub tests [$gdb_bin]
+  --enable-shared-lib      build QEMU as a shared library
 
 Optional features, enabled with --enable-FEATURE and
 disabled with --disable-FEATURE, default is enabled if available
@@ -6363,7 +6369,11 @@ echo "ranlib = [$(meson_quote $ranlib)]" >> $cross
 if has $sdl2_config; then
   echo "sdl2-config = [$(meson_quote $sdl2_config)]" >> $cross
 fi
-echo "strip = [$(meson_quote $strip)]" >> $cross
+if test "$shared_lib" = "true"; then
+  echo "strip = [$(meson_quote $strip), '-x']" >> $cross
+else
+  echo "strip = [$(meson_quote $strip)]" >> $cross
+fi
 echo "windres = [$(meson_quote $windres)]" >> $cross
 if test "$cross_compile" = "yes"; then
     cross_arg="--cross-file config-meson.cross"
@@ -6445,7 +6455,7 @@ NINJA=$ninja $meson setup \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
         $(if test "$default_features" = no; then echo "-Dauto_features=disabled"; fi) \
-	-Dtcg_interpreter=$tcg_interpreter \
+	-Dtcg_interpreter=$tcg_interpreter -Dshared_lib=$shared_lib \
         $cross_arg \
         "$PWD" "$source_path"
 
diff --git a/meson.build b/meson.build
index 3c8905517637..80e9305d5a64 100644
--- a/meson.build
+++ b/meson.build
@@ -2217,14 +2217,31 @@ foreach target : target_dirs
   arch_srcs += target_specific.sources()
   arch_deps += target_specific.dependencies()
 
-  lib = static_library('qemu-' + target,
+  if get_option('shared_lib')
+    build_lib_args = {
+      'target_type': 'shared_library',
+      'install': true,
+      'dependencies': arch_deps + deps,
+      'link_language': link_language,
+      'link_depends': [block_syms, qemu_syms],
+      'link_args': link_args + cc.get_supported_link_arguments(['-Wl,-U,_qemu_main'])
+    }
+  else
+    build_lib_args = {
+      'target_type': 'static_library',
+      'install': false,
+      'dependencies': arch_deps,
+      'name_suffix': 'fa'
+    }
+  endif
+
+  lib = build_target('qemu-' + target,
                  sources: arch_srcs + genh,
-                 dependencies: arch_deps,
                  objects: objects,
                  include_directories: target_inc,
                  c_args: c_args,
                  build_by_default: false,
-                 name_suffix: 'fa')
+                 kwargs: build_lib_args)
 
   if target.endswith('-softmmu')
     execs = [{
@@ -2258,6 +2275,17 @@ foreach target : target_dirs
       'dependencies': []
     }]
   endif
+  if get_option('shared_lib')
+    build_exe_args = {
+      'link_with': lib,
+      'link_args': link_args + cc.get_supported_link_arguments(['-Wl,--exclude-libs,ALL'])
+    }
+  else
+    build_exe_args = {
+      'objects': lib.extract_all_objects(recursive: true),
+      'link_args': link_args
+    }
+  endif
   foreach exe: execs
     exe_name = exe['name']
     exe_sign = 'CONFIG_HVF' in config_target
@@ -2269,11 +2297,10 @@ foreach target : target_dirs
                install: true,
                c_args: c_args,
                dependencies: arch_deps + deps + exe['dependencies'],
-               objects: lib.extract_all_objects(recursive: true),
                link_language: link_language,
                link_depends: [block_syms, qemu_syms] + exe.get('link_depends', []),
-               link_args: link_args,
-               gui_app: exe['gui'])
+               gui_app: exe['gui'],
+               kwargs: build_exe_args)
 
     if exe_sign
       emulators += {exe['name'] : custom_target(exe['name'],
@@ -2440,6 +2467,7 @@ endif
 summary_info += {'Doc directory':     get_option('docdir')}
 summary_info += {'Build directory':   meson.current_build_dir()}
 summary_info += {'Source path':       meson.current_source_dir()}
+summary_info += {'build shared lib':  get_option('shared_lib')}
 summary_info += {'GIT submodules':    config_host['GIT_SUBMODULES']}
 summary(summary_info, bool_yn: true, section: 'Directories')
 
diff --git a/meson_options.txt b/meson_options.txt
index 9734019995a0..4594d42769d6 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -6,6 +6,8 @@ option('qemu_firmwarepath', type : 'string', value : '',
        description: 'search PATH for firmware files')
 option('sphinx_build', type : 'string', value : '',
        description: 'Use specified sphinx-build [$sphinx_build] for building document (default to be empty)')
+option('shared_lib', type : 'boolean', value : false,
+       description: 'build QEMU as a shared library')
 
 option('default_devices', type : 'boolean', value : true,
        description: 'Include a default selection of devices in emulators')

From 819b2c298415d2b4b2ec0180f81b4bffa1fcb701 Mon Sep 17 00:00:00 2001
From: Gerd Hoffmann <kraxel@redhat.com>
Date: Fri, 8 Jun 2018 13:19:58 +0200
Subject: [PATCH 036/180] hw/display: add virtio-ramfb device

Like virtio-vga, but using ramfb instead of legacy vga.
Useful for booting from OVMF into Windows ARM which expects a linear FB.
---
 hw/display/meson.build    |   1 +
 hw/display/virtio-ramfb.c | 188 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 189 insertions(+)
 create mode 100644 hw/display/virtio-ramfb.c

diff --git a/hw/display/meson.build b/hw/display/meson.build
index 9d79e3951d9e..14f5fa39f4c1 100644
--- a/hw/display/meson.build
+++ b/hw/display/meson.build
@@ -60,6 +60,7 @@ if config_all_devices.has_key('CONFIG_VIRTIO_GPU')
   virtio_gpu_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRGL'],
                     if_true: [files('virtio-gpu-3d.c'), pixman, virgl])
   virtio_gpu_ss.add(when: 'CONFIG_VHOST_USER_GPU', if_true: files('vhost-user-gpu.c'))
+  virtio_gpu_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('virtio-ramfb.c'))
   hw_display_modules += {'virtio-gpu': virtio_gpu_ss}
 endif
 
diff --git a/hw/display/virtio-ramfb.c b/hw/display/virtio-ramfb.c
new file mode 100644
index 000000000000..d08bb90a14d4
--- /dev/null
+++ b/hw/display/virtio-ramfb.c
@@ -0,0 +1,188 @@
+#include "qemu/osdep.h"
+#include "hw/pci/pci.h"
+#include "ui/console.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-gpu-pci.h"
+#include "qapi/error.h"
+#include "hw/display/ramfb.h"
+#include "qom/object.h"
+
+/*
+ * virtio-ramfb-base: This extends VirtioPCIProxy.
+ */
+#define TYPE_VIRTIO_RAMFB_BASE "virtio-ramfb-base"
+OBJECT_DECLARE_TYPE(VirtIORAMFBBase, VirtIORAMFBBaseClass,
+                    VIRTIO_RAMFB_BASE)
+
+struct VirtIORAMFBBase {
+    VirtIOPCIProxy parent_obj;
+
+    VirtIOGPUBase *vgpu;
+    RAMFBState    *ramfb;
+};
+
+struct VirtIORAMFBBaseClass {
+    VirtioPCIClass parent_class;
+
+    DeviceReset parent_reset;
+};
+
+static void virtio_ramfb_invalidate_display(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->enable) {
+        g->hw_ops->invalidate(g);
+    }
+}
+
+static void virtio_ramfb_update_display(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->enable) {
+        g->hw_ops->gfx_update(g);
+    } else {
+        ramfb_display_update(g->scanout[0].con, vramfb->ramfb);
+    }
+}
+
+static int virtio_ramfb_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->ui_info) {
+        return g->hw_ops->ui_info(g, idx, info);
+    }
+    return -1;
+}
+
+static void virtio_ramfb_gl_block(void *opaque, bool block)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->gl_block) {
+        g->hw_ops->gl_block(g, block);
+    }
+}
+
+static const GraphicHwOps virtio_ramfb_ops = {
+    .invalidate = virtio_ramfb_invalidate_display,
+    .gfx_update = virtio_ramfb_update_display,
+    .ui_info = virtio_ramfb_ui_info,
+    .gl_block = virtio_ramfb_gl_block,
+};
+
+static const VMStateDescription vmstate_virtio_ramfb = {
+    .name = "virtio-ramfb",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    .fields = (VMStateField[]) {
+        /* no pci stuff here, saving the virtio device will handle that */
+        /* FIXME */
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+/* RAMFB device wrapper around PCI device around virtio GPU */
+static void virtio_ramfb_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
+{
+    VirtIORAMFBBase *vramfb = VIRTIO_RAMFB_BASE(vpci_dev);
+    VirtIOGPUBase *g = vramfb->vgpu;
+    int i;
+
+    /* init virtio bits */
+    virtio_pci_force_virtio_1(vpci_dev);
+    if (!qdev_realize(DEVICE(g), BUS(&vpci_dev->bus), errp)) {
+        return;
+    }
+
+    /* init ramfb */
+    vramfb->ramfb = ramfb_setup(errp);
+    graphic_console_set_hwops(g->scanout[0].con, &virtio_ramfb_ops, vramfb);
+
+    for (i = 0; i < g->conf.max_outputs; i++) {
+        object_property_set_link(OBJECT(g->scanout[i].con), "device",
+                                 OBJECT(vpci_dev), &error_abort);
+    }
+}
+
+static void virtio_ramfb_reset(DeviceState *dev)
+{
+    VirtIORAMFBBaseClass *klass = VIRTIO_RAMFB_BASE_GET_CLASS(dev);
+
+    /* reset virtio-gpu */
+    klass->parent_reset(dev);
+}
+
+static Property virtio_ramfb_base_properties[] = {
+    DEFINE_VIRTIO_GPU_PCI_PROPERTIES(VirtIOPCIProxy),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_ramfb_base_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioPCIClass *k = VIRTIO_PCI_CLASS(klass);
+    VirtIORAMFBBaseClass *v = VIRTIO_RAMFB_BASE_CLASS(klass);
+    PCIDeviceClass *pcidev_k = PCI_DEVICE_CLASS(klass);
+
+    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
+    device_class_set_props(dc, virtio_ramfb_base_properties);
+    dc->vmsd = &vmstate_virtio_ramfb;
+    dc->hotpluggable = false;
+    device_class_set_parent_reset(dc, virtio_ramfb_reset,
+                                  &v->parent_reset);
+
+    k->realize = virtio_ramfb_realize;
+    pcidev_k->class_id = PCI_CLASS_DISPLAY_OTHER;
+}
+
+static TypeInfo virtio_ramfb_base_info = {
+    .name          = TYPE_VIRTIO_RAMFB_BASE,
+    .parent        = TYPE_VIRTIO_PCI,
+    .instance_size = sizeof(VirtIORAMFBBase),
+    .class_size    = sizeof(VirtIORAMFBBaseClass),
+    .class_init    = virtio_ramfb_base_class_init,
+    .abstract      = true,
+};
+
+#define TYPE_VIRTIO_RAMFB "virtio-ramfb"
+
+typedef struct VirtIORAMFB VirtIORAMFB;
+DECLARE_INSTANCE_CHECKER(VirtIORAMFB, VIRTIO_RAMFB,
+                         TYPE_VIRTIO_RAMFB)
+
+struct VirtIORAMFB {
+    VirtIORAMFBBase parent_obj;
+
+    VirtIOGPU     vdev;
+};
+
+static void virtio_ramfb_inst_initfn(Object *obj)
+{
+    VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
+
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+}
+
+static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {
+    .generic_name  = TYPE_VIRTIO_RAMFB,
+    .parent        = TYPE_VIRTIO_RAMFB_BASE,
+    .instance_size = sizeof(VirtIORAMFB),
+    .instance_init = virtio_ramfb_inst_initfn,
+};
+
+static void virtio_ramfb_register_types(void)
+{
+    type_register_static(&virtio_ramfb_base_info);
+    virtio_pci_types_register(&virtio_ramfb_info);
+}
+
+type_init(virtio_ramfb_register_types)

From ecc067a3ba5afad653b247abedd5192d208c945b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>
Date: Mon, 25 Jan 2021 11:34:26 +0400
Subject: [PATCH 037/180] slirp: update to git master
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

git cherry-diff:

Commits on bacb71f1c3ed5f40e393afd8be81bedfba13a401 branch that is not on 8f43a99191afb47ca3f3c6972f6306209f367ece branch
+ 1021b0dc38d39f1dc95a296fe3e05a24a087cdc6 disable_dns option
+ 0f94ceec752592e4ac632a24e3c64a97dd09bf4c limit vnameserver_addr to port 53
+ b57bafa852ef16b133907a13678ec69e9531f177 libslirp.h: fix SlirpConfig v3 documentation
+ 1abf18b2b5edb462797629ed47ad4515a195686e Update CHANGELOG
+ ff4ecf9b6c6542b24b4ac6ea178be9d44e159f79 Release v4.3.0
+ 21f1d933050a40d62612c6274c32de60b811d9ea changelog: post-release
+ 376187c4b14c795763d472214812826eebe7e9c2 Release v4.3.1
+ 73336e08902a7e826f7d960453df037380266186 changelog: post-release
+ 5c1c9d43be61571608e9b14615045b67b830daf5 udp, udp6, icmp: handle TTL value
+ 73ed49ab71998d4288e71e954ef6214b70f23d79 icmp, icmp6: Add icmp_forward_error and icmp6_forward_error
+ 7a4840a57ec7dbc37cca1ab96f058a9610b26950 udp, udp6, icmp, icmp6: Enable forwarding errors on Linux
+ e9b2bc19ae652a2907f247e621b2e4773bdd2aab TCPIPHDR_DELTA: Fix potential negative value
+ 39f9a363eec082f04513413046321abd04163148 .gitlab-ci: add a Coverity stage
+ 1b0093b973cfa0dc041522e5d4e6f576b2df642e sosendoob: better document what urgc is used for
+ 5b9ad89ebbb8afa50162c9156fabd5fc56291088 Add G_GNUC_PRINTF to local function slirp_vsnprintf
+ 8a808aa493980e212b4d5f5465330905c8294e59 meson: remove meson-dist script
+ 0b669b5fbe4d3c25a682a67f1059d8633c963b3d meson: support compiling as subproject
+ 9f82a47b81f2864422b82c1e40e51a2ed9c6ac32 Add DNS resolving for iOS
+ c0eac03e8ce1b9a743231f2fe21e7cb579fc9339 Remove the QEMU-special make build-system
+ 1bfd4d9368f9fa2e4f0731e1266bec05bbc83a80 socket: consume empty packets
+ 92413be68914f8cae2f5bad4bf3ab8491dcbc5d7 Release v4.4.0
+ 07e8cfac69766081871ab620d9f16a630543d302 changelog: post-release
+ 4c4e035813313d02b63fdeb920d56fb2fdc0a5b1 Remove some needless (void)casts
+ eee9db9d115d91aa82f33685c4e76d656db92976 fork_exec_child_setup: improve signal handling
+ 216f434a018b3af182a4f31bbe5a00daee170343 Fix unused variables

Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
Message-Id: <20210125073427.3970606-2-marcandre.lureau@redhat.com>
---
 slirp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/slirp b/slirp
index 8f43a99191af..5dce846e3ee8 160000
--- a/slirp
+++ b/slirp
@@ -1 +1 @@
-Subproject commit 8f43a99191afb47ca3f3c6972f6306209f367ece
+Subproject commit 5dce846e3ee82d93462bc637bb0db2fd49f0fc5a

From 2541dde9367c6d58c89232109001ca51056e1cca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>
Date: Mon, 25 Jan 2021 11:34:27 +0400
Subject: [PATCH 038/180] build-sys: make libslirp a meson subproject
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Remove the manual build.

Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
Message-Id: <20210125073427.3970606-3-marcandre.lureau@redhat.com>
---
 .gitmodules          |  6 ++---
 configure            |  2 +-
 meson.build          | 63 +++-----------------------------------------
 slirp                |  1 -
 subprojects/libslirp |  1 +
 5 files changed, 9 insertions(+), 64 deletions(-)
 delete mode 160000 slirp
 create mode 160000 subprojects/libslirp

diff --git a/.gitmodules b/.gitmodules
index 08b1b48a09f4..c28831c50ab4 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -49,9 +49,9 @@
 [submodule "roms/edk2"]
 	path = roms/edk2
 	url = https://gitlab.com/qemu-project/edk2.git
-[submodule "slirp"]
-	path = slirp
-	url = https://gitlab.com/qemu-project/libslirp.git
+[submodule "subprojects/libslirp"]
+	path = subprojects/libslirp
+	url = https://git.qemu.org/git/libslirp.git
 [submodule "roms/opensbi"]
 	path = roms/opensbi
 	url = 	https://gitlab.com/qemu-project/opensbi.git
diff --git a/configure b/configure
index 8acf7a949d62..fd8fb0ee20e3 100755
--- a/configure
+++ b/configure
@@ -5260,7 +5260,7 @@ case "$slirp" in
   auto | enabled | internal)
     # Simpler to always update submodule, even if not needed.
     if test "$git_submodules_action" != "ignore"; then
-      git_submodules="${git_submodules} slirp"
+      git_submodules="${git_submodules} subprojects/libslirp"
     fi
     ;;
 esac
diff --git a/meson.build b/meson.build
index 80e9305d5a64..8b1e240a3ec3 100644
--- a/meson.build
+++ b/meson.build
@@ -1504,7 +1504,7 @@ slirp_opt = 'disabled'
 if have_system
   slirp_opt = get_option('slirp')
   if slirp_opt in ['enabled', 'auto', 'system']
-    have_internal = fs.exists(meson.current_source_dir() / 'slirp/meson.build')
+    have_internal = fs.exists(meson.current_source_dir() / 'subprojects/libslirp/meson.build')
     slirp = dependency('slirp', kwargs: static_kwargs,
                        method: 'pkg-config',
                        required: slirp_opt == 'system' or
@@ -1518,64 +1518,9 @@ if have_system
     endif
   endif
   if slirp_opt == 'internal'
-    slirp_deps = []
-    if targetos == 'windows'
-      slirp_deps = cc.find_library('iphlpapi')
-    endif
-    slirp_conf = configuration_data()
-    slirp_conf.set('SLIRP_MAJOR_VERSION', meson.project_version().split('.')[0])
-    slirp_conf.set('SLIRP_MINOR_VERSION', meson.project_version().split('.')[1])
-    slirp_conf.set('SLIRP_MICRO_VERSION', meson.project_version().split('.')[2])
-    slirp_conf.set_quoted('SLIRP_VERSION_STRING', meson.project_version())
-    slirp_cargs = ['-DG_LOG_DOMAIN="Slirp"']
-    slirp_files = [
-      'slirp/src/arp_table.c',
-      'slirp/src/bootp.c',
-      'slirp/src/cksum.c',
-      'slirp/src/dhcpv6.c',
-      'slirp/src/dnssearch.c',
-      'slirp/src/if.c',
-      'slirp/src/ip6_icmp.c',
-      'slirp/src/ip6_input.c',
-      'slirp/src/ip6_output.c',
-      'slirp/src/ip_icmp.c',
-      'slirp/src/ip_input.c',
-      'slirp/src/ip_output.c',
-      'slirp/src/mbuf.c',
-      'slirp/src/misc.c',
-      'slirp/src/ncsi.c',
-      'slirp/src/ndp_table.c',
-      'slirp/src/sbuf.c',
-      'slirp/src/slirp.c',
-      'slirp/src/socket.c',
-      'slirp/src/state.c',
-      'slirp/src/stream.c',
-      'slirp/src/tcp_input.c',
-      'slirp/src/tcp_output.c',
-      'slirp/src/tcp_subr.c',
-      'slirp/src/tcp_timer.c',
-      'slirp/src/tftp.c',
-      'slirp/src/udp.c',
-      'slirp/src/udp6.c',
-      'slirp/src/util.c',
-      'slirp/src/version.c',
-      'slirp/src/vmstate.c',
-    ]
-
-    configure_file(
-      input : 'slirp/src/libslirp-version.h.in',
-      output : 'libslirp-version.h',
-      configuration: slirp_conf)
-
-    slirp_inc = include_directories('slirp', 'slirp/src')
-    libslirp = static_library('slirp',
-                              build_by_default: false,
-                              sources: slirp_files,
-                              c_args: slirp_cargs,
-                              include_directories: slirp_inc)
-    slirp = declare_dependency(link_with: libslirp,
-                               dependencies: slirp_deps,
-                               include_directories: slirp_inc)
+    libslirp = subproject('libslirp',
+                          default_options: ['default_library=static'])
+    slirp = libslirp.get_variable('libslirp_dep')
   endif
 endif
 
diff --git a/slirp b/slirp
deleted file mode 160000
index 5dce846e3ee8..000000000000
--- a/slirp
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 5dce846e3ee82d93462bc637bb0db2fd49f0fc5a
diff --git a/subprojects/libslirp b/subprojects/libslirp
new file mode 160000
index 000000000000..bacb71f1c3ed
--- /dev/null
+++ b/subprojects/libslirp
@@ -0,0 +1 @@
+Subproject commit bacb71f1c3ed5f40e393afd8be81bedfba13a401

From 36195a781c1c7237935b45c30a91686c07a10474 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 4 Jan 2021 14:04:27 -0800
Subject: [PATCH 039/180] tcg: custom APRR implementation

---
 accel/tcg/cpu-exec.c        |   1 +
 accel/tcg/translate-all.c   |   1 +
 include/qemu/osdep.h        |  24 ---------
 include/tcg/tcg-apple-jit.h | 100 ++++++++++++++++++++++++++++++++++++
 tcg/tcg.c                   |   1 +
 util/osdep.c                |   4 ++
 6 files changed, 107 insertions(+), 24 deletions(-)
 create mode 100644 include/tcg/tcg-apple-jit.h

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index f62f12e717ca..07f8e3604a67 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -26,6 +26,7 @@
 #include "disas/disas.h"
 #include "exec/exec-all.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #include "qemu/atomic.h"
 #include "qemu/compiler.h"
 #include "qemu/timer.h"
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index b12d0898d0aa..28d563454e03 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -27,6 +27,7 @@
 #include "disas/disas.h"
 #include "exec/exec-all.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #if defined(CONFIG_USER_ONLY)
 #include "qemu.h"
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index cb2a07e472e8..63b9b4c36ca8 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -702,30 +702,6 @@ char *qemu_get_host_name(Error **errp);
  */
 size_t qemu_get_host_physmem(void);
 
-/*
- * Toggle write/execute on the pages marked MAP_JIT
- * for the current thread.
- */
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_11_0
-static inline void qemu_thread_jit_execute(void)
-{
-    if (__builtin_available(macOS 11.0, *)) {
-        pthread_jit_write_protect_np(true);
-    }
-}
-
-static inline void qemu_thread_jit_write(void)
-{
-    if (__builtin_available(macOS 11.0, *)) {
-        pthread_jit_write_protect_np(false);
-    }
-}
-#else
-static inline void qemu_thread_jit_write(void) {}
-static inline void qemu_thread_jit_execute(void) {}
-#endif
-
 /**
  * Platforms which do not support system() return ENOSYS
  */
diff --git a/include/tcg/tcg-apple-jit.h b/include/tcg/tcg-apple-jit.h
new file mode 100644
index 000000000000..7f25dab809a3
--- /dev/null
+++ b/include/tcg/tcg-apple-jit.h
@@ -0,0 +1,100 @@
+/*
+ * Apple Silicon functions for JIT handling
+ *
+ * Copyright (c) 2020 osy
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TCG_APPLE_JIT_H
+#define TCG_APPLE_JIT_H
+
+/*
+ * APRR handling
+ * Credits to: https://siguza.github.io/APRR/
+ * Reversed from /usr/lib/system/libsystem_pthread.dylib
+ */
+
+#if defined(__aarch64__) && defined(CONFIG_DARWIN)
+
+#define _COMM_PAGE_START_ADDRESS        (0x0000000FFFFFC000ULL) /* In TTBR0 */
+#define _COMM_PAGE_APRR_SUPPORT         (_COMM_PAGE_START_ADDRESS + 0x10C)
+#define _COMM_PAGE_APPR_WRITE_ENABLE    (_COMM_PAGE_START_ADDRESS + 0x110)
+#define _COMM_PAGE_APRR_WRITE_DISABLE   (_COMM_PAGE_START_ADDRESS + 0x118)
+
+static __attribute__((__always_inline__)) bool jit_write_protect_supported(void)
+{
+    /* Access shared kernel page at fixed memory location. */
+    uint8_t aprr_support = *(volatile uint8_t *)_COMM_PAGE_APRR_SUPPORT;
+    return aprr_support > 0;
+}
+
+/* write protect enable = write disable */
+static __attribute__((__always_inline__)) void jit_write_protect(int enabled)
+{
+    /* Access shared kernel page at fixed memory location. */
+    uint8_t aprr_support = *(volatile uint8_t *)_COMM_PAGE_APRR_SUPPORT;
+    if (aprr_support == 0 || aprr_support > 3) {
+        return;
+    } else if (aprr_support == 1) {
+        __asm__ __volatile__ (
+            "mov x0, %0\n"
+            "ldr x0, [x0]\n"
+            "msr S3_4_c15_c2_7, x0\n"
+            "isb sy\n"
+            :: "r" (enabled ? _COMM_PAGE_APRR_WRITE_DISABLE
+                            : _COMM_PAGE_APPR_WRITE_ENABLE)
+            : "memory", "x0"
+        );
+    } else {
+        __asm__ __volatile__ (
+            "mov x0, %0\n"
+            "ldr x0, [x0]\n"
+            "msr S3_6_c15_c1_5, x0\n"
+            "isb sy\n"
+            :: "r" (enabled ? _COMM_PAGE_APRR_WRITE_DISABLE
+                            : _COMM_PAGE_APPR_WRITE_ENABLE)
+            : "memory", "x0"
+        );
+    }
+}
+
+#else /* defined(__aarch64__) && defined(CONFIG_DARWIN) */
+
+static __attribute__((__always_inline__)) bool jit_write_protect_supported(void)
+{
+    return false;
+}
+
+static __attribute__((__always_inline__)) void jit_write_protect(int enabled)
+{
+}
+
+#endif
+
+static inline void qemu_thread_jit_execute(void)
+{
+    if (jit_write_protect_supported()) {
+        jit_write_protect(true);
+    }
+}
+
+static inline void qemu_thread_jit_write(void)
+{
+    if (jit_write_protect_supported()) {
+        jit_write_protect(false);
+    }
+}
+
+#endif /* define TCG_APPLE_JIT_H */
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 1fbe0b686d57..5b0750685102 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -49,6 +49,7 @@
 #include "hw/boards.h"
 #endif
 
+#include "tcg/tcg-apple-jit.h"
 #include "tcg/tcg-op.h"
 
 #if UINTPTR_MAX == UINT32_MAX
diff --git a/util/osdep.c b/util/osdep.c
index 66d01b9160fb..912657361b9e 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -39,6 +39,10 @@ extern int madvise(char *, size_t, int);
 #include "qemu/error-report.h"
 #include "monitor/monitor.h"
 
+#ifdef CONFIG_DARWIN
+#include "tcg/tcg-apple-jit.h"
+#endif
+
 static bool fips_enabled = false;
 
 static const char *hw_version = QEMU_HW_VERSION;

From 4e70afa94de1e042c969bf1deb5b0adadbae9fb8 Mon Sep 17 00:00:00 2001
From: Joelle van Dyne <j@getutm.app>
Date: Sun, 3 Jan 2021 08:58:11 -0800
Subject: [PATCH 040/180] coroutine: add libucontext as external library

iOS does not support ucontext natively for aarch64 and the sigaltstack is
also unsupported (even worse, it fails silently, see:
https://openradar.appspot.com/13002712 )

As a workaround we include a library implementation of ucontext and add it
as a build option.
---
 .gitmodules               |  3 +++
 configure                 | 20 +++++++++++++++++---
 meson.build               | 12 +++++++++++-
 meson_options.txt         |  2 ++
 subprojects/libucontext   |  1 +
 util/coroutine-ucontext.c |  9 +++++++++
 6 files changed, 43 insertions(+), 4 deletions(-)
 create mode 160000 subprojects/libucontext

diff --git a/.gitmodules b/.gitmodules
index c28831c50ab4..33f90687266b 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -64,3 +64,6 @@
 [submodule "roms/vbootrom"]
 	path = roms/vbootrom
 	url = https://gitlab.com/qemu-project/vbootrom.git
+[submodule "libucontext"]
+	path = subprojects/libucontext
+	url = https://github.com/utmapp/libucontext.git
diff --git a/configure b/configure
index fd8fb0ee20e3..0e7dbc56c784 100755
--- a/configure
+++ b/configure
@@ -1786,7 +1786,7 @@ Advanced options (experts only):
   --oss-lib                path to OSS library
   --cpu=CPU                Build for host CPU [$cpu]
   --with-coroutine=BACKEND coroutine backend. Supported options:
-                           ucontext, sigaltstack, windows
+                           ucontext, libucontext, sigaltstack, windows
   --enable-gcov            enable test coverage analysis with gcov
   --disable-blobs          disable installing provided firmware blobs
   --with-vss-sdk=SDK-path  enable Windows VSS support in QEMU Guest Agent
@@ -4545,12 +4545,26 @@ else
       error_exit "only the 'windows' coroutine backend is valid for Windows"
     fi
     ;;
+  libucontext)
+  ;;
   *)
     error_exit "unknown coroutine backend $coroutine"
     ;;
   esac
 fi
 
+case $coroutine in
+libucontext)
+  git_submodules="${git_submodules} subprojects/libucontext"
+  coroutine_impl=ucontext
+  libucontext="enabled"
+  ;;
+*)
+  coroutine_impl=$coroutine
+  libucontext="disabled"
+  ;;
+esac
+
 if test "$coroutine_pool" = ""; then
   coroutine_pool=yes
 fi
@@ -5887,7 +5901,7 @@ if test "$qom_cast_debug" = "yes" ; then
   echo "CONFIG_QOM_CAST_DEBUG=y" >> $config_host_mak
 fi
 
-echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
+echo "CONFIG_COROUTINE_BACKEND=$coroutine_impl" >> $config_host_mak
 if test "$coroutine_pool" = "yes" ; then
   echo "CONFIG_COROUTINE_POOL=1" >> $config_host_mak
 else
@@ -6450,7 +6464,7 @@ NINJA=$ninja $meson setup \
         -Dlibnfs=$libnfs -Diconv=$iconv -Dcurses=$curses -Dlibudev=$libudev\
         -Drbd=$rbd -Dlzo=$lzo -Dsnappy=$snappy -Dlzfse=$lzfse \
         -Dzstd=$zstd -Dseccomp=$seccomp -Dvirtfs=$virtfs -Dcap_ng=$cap_ng \
-        -Dattr=$attr -Ddefault_devices=$default_devices \
+        -Dattr=$attr -Ddefault_devices=$default_devices -Ducontext=$libucontext \
         -Ddocs=$docs -Dsphinx_build=$sphinx_build -Dinstall_blobs=$blobs \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
diff --git a/meson.build b/meson.build
index 8b1e240a3ec3..7968c40f630f 100644
--- a/meson.build
+++ b/meson.build
@@ -1583,9 +1583,18 @@ if not fdt.found() and fdt_required.length() > 0
   error('fdt not available but required by targets ' + ', '.join(fdt_required))
 endif
 
+ucontext = dependency('libucontext', kwargs: static_kwargs, required : false)
+if not ucontext.found() and get_option('ucontext').enabled()
+  libucontext_proj = subproject('libucontext',
+                                default_options: ['default_library=static',
+                                                  'freestanding=true'])
+  ucontext = libucontext_proj.get_variable('libucontext_dep')
+endif
+
 config_host_data.set('CONFIG_CAPSTONE', capstone.found())
 config_host_data.set('CONFIG_FDT', fdt.found())
 config_host_data.set('CONFIG_SLIRP', slirp.found())
+config_host_data.set('CONFIG_LIBUCONTEXT', ucontext.found())
 
 #####################
 # Generated sources #
@@ -1833,7 +1842,7 @@ util_ss.add_all(trace_ss)
 util_ss = util_ss.apply(config_all, strict: false)
 libqemuutil = static_library('qemuutil',
                              sources: util_ss.sources() + stub_ss.sources() + genh,
-                             dependencies: [util_ss.dependencies(), m, glib, socket, malloc])
+                             dependencies: [util_ss.dependencies(), m, glib, socket, malloc, ucontext])
 qemuutil = declare_dependency(link_with: libqemuutil,
                               sources: genh + version_res)
 
@@ -2577,6 +2586,7 @@ summary(summary_info, bool_yn: true, section: 'Targets and accelerators')
 
 # Block layer
 summary_info = {}
+summary_info += {'libucontext support': ucontext.found()}
 summary_info += {'coroutine backend': config_host['CONFIG_COROUTINE_BACKEND']}
 summary_info += {'coroutine pool':    config_host['CONFIG_COROUTINE_POOL'] == '1'}
 if have_block
diff --git a/meson_options.txt b/meson_options.txt
index 4594d42769d6..6c29ea93300a 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -110,6 +110,8 @@ option('fuse', type: 'feature', value: 'auto',
        description: 'FUSE block device export')
 option('fuse_lseek', type : 'feature', value : 'auto',
        description: 'SEEK_HOLE/SEEK_DATA support for FUSE exports')
+option('ucontext', type : 'feature', value : 'disabled',
+       description: 'libucontext support')
 
 option('vhost_user_blk_server', type: 'feature', value: 'auto',
        description: 'build vhost-user-blk server')
diff --git a/subprojects/libucontext b/subprojects/libucontext
new file mode 160000
index 000000000000..9b1d8f01a6e9
--- /dev/null
+++ b/subprojects/libucontext
@@ -0,0 +1 @@
+Subproject commit 9b1d8f01a6e99166f9808c79966abe10786de8b6
diff --git a/util/coroutine-ucontext.c b/util/coroutine-ucontext.c
index 904b375192ca..220c57a743af 100644
--- a/util/coroutine-ucontext.c
+++ b/util/coroutine-ucontext.c
@@ -23,7 +23,16 @@
 #undef _FORTIFY_SOURCE
 #endif
 #include "qemu/osdep.h"
+#if defined(CONFIG_LIBUCONTEXT)
+#include <libucontext/libucontext.h>
+#define ucontext_t libucontext_ucontext_t
+#define getcontext libucontext_getcontext
+#define setcontext libucontext_setcontext
+#define swapcontext libucontext_swapcontext
+#define makecontext libucontext_makecontext
+#else
 #include <ucontext.h>
+#endif
 #include "qemu/coroutine_int.h"
 
 #ifdef CONFIG_VALGRIND_H

From cd4b5da233938fe85dbc7488ed61f3525fc7e1b5 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Fri, 30 Apr 2021 11:40:17 -0600
Subject: [PATCH 041/180] TCTI: optimize I/O operation and helper call speeds

---
 meson.build                         |  72 ++++++++--------
 tcg/aarch64-tcti/tcg-target.c.inc   | 122 ++++++++++++++--------------
 tcg/aarch64-tcti/tcti-gadget-gen.py |  41 +++++-----
 3 files changed, 117 insertions(+), 118 deletions(-)

diff --git a/meson.build b/meson.build
index 7927a1d163ab..6d9d804bf1aa 100644
--- a/meson.build
+++ b/meson.build
@@ -263,57 +263,57 @@ if not get_option('tcg').disabled()
     gadget_generator = 'tcg/@0@/tcti-gadget-gen.py'.format(tcg_arch)
     tcti_sources = [
         'tcti_gadgets.h',
-        'tcti_misc_gadgets.s',
+        'tcti_misc_gadgets.c',
         'tcti_misc_gadgets.h',
-        'tcti_setcond_gadgets.s',
+        'tcti_setcond_gadgets.c',
         'tcti_setcond_gadgets.h',
-        'tcti_brcond_gadgets.s',
+        'tcti_brcond_gadgets.c',
         'tcti_brcond_gadgets.h',
-        'tcti_mov_gadgets.s',
+        'tcti_mov_gadgets.c',
         'tcti_mov_gadgets.h',
-        'tcti_load_signed_gadgets.s',
+        'tcti_load_signed_gadgets.c',
         'tcti_load_signed_gadgets.h',
-        'tcti_load_unsigned_gadgets.s',
+        'tcti_load_unsigned_gadgets.c',
         'tcti_load_unsigned_gadgets.h',
-        'tcti_store_gadgets.s',
+        'tcti_store_gadgets.c',
         'tcti_store_gadgets.h',
-        'tcti_arithmetic_gadgets.s',
+        'tcti_arithmetic_gadgets.c',
         'tcti_arithmetic_gadgets.h',
-        'tcti_logical_gadgets.s',
+        'tcti_logical_gadgets.c',
         'tcti_logical_gadgets.h',
-        'tcti_extension_gadgets.s',
+        'tcti_extension_gadgets.c',
         'tcti_extension_gadgets.h',
-        'tcti_byteswap_gadgets.s',
+        'tcti_byteswap_gadgets.c',
         'tcti_byteswap_gadgets.h',
-        'tcti_qemu_ld_aligned_signed_le_gadgets.s',
+        'tcti_qemu_ld_aligned_signed_le_gadgets.c',
         'tcti_qemu_ld_aligned_signed_le_gadgets.h',
-        'tcti_qemu_ld_unaligned_signed_le_gadgets.s',
+        'tcti_qemu_ld_unaligned_signed_le_gadgets.c',
         'tcti_qemu_ld_unaligned_signed_le_gadgets.h',
-        'tcti_qemu_ld_slowpath_signed_le_gadgets.s',
+        'tcti_qemu_ld_slowpath_signed_le_gadgets.c',
         'tcti_qemu_ld_slowpath_signed_le_gadgets.h',
-        'tcti_qemu_ld_aligned_unsigned_le_gadgets.s',
+        'tcti_qemu_ld_aligned_unsigned_le_gadgets.c',
         'tcti_qemu_ld_aligned_unsigned_le_gadgets.h',
-        'tcti_qemu_ld_unaligned_unsigned_le_gadgets.s',
+        'tcti_qemu_ld_unaligned_unsigned_le_gadgets.c',
         'tcti_qemu_ld_unaligned_unsigned_le_gadgets.h',
-        'tcti_qemu_ld_slowpath_unsigned_le_gadgets.s',
+        'tcti_qemu_ld_slowpath_unsigned_le_gadgets.c',
         'tcti_qemu_ld_slowpath_unsigned_le_gadgets.h',
-        'tcti_qemu_ld_aligned_be_gadgets.s',
+        'tcti_qemu_ld_aligned_be_gadgets.c',
         'tcti_qemu_ld_aligned_be_gadgets.h',
-        'tcti_qemu_ld_unaligned_be_gadgets.s',
+        'tcti_qemu_ld_unaligned_be_gadgets.c',
         'tcti_qemu_ld_unaligned_be_gadgets.h',
-        'tcti_qemu_ld_slowpath_be_gadgets.s',
+        'tcti_qemu_ld_slowpath_be_gadgets.c',
         'tcti_qemu_ld_slowpath_be_gadgets.h',
-        'tcti_qemu_st_aligned_le_gadgets.s',
+        'tcti_qemu_st_aligned_le_gadgets.c',
         'tcti_qemu_st_aligned_le_gadgets.h',
-        'tcti_qemu_st_unaligned_le_gadgets.s',
+        'tcti_qemu_st_unaligned_le_gadgets.c',
         'tcti_qemu_st_unaligned_le_gadgets.h',
-        'tcti_qemu_st_slowpath_le_gadgets.s',
+        'tcti_qemu_st_slowpath_le_gadgets.c',
         'tcti_qemu_st_slowpath_le_gadgets.h',
-        'tcti_qemu_st_aligned_be_gadgets.s',
+        'tcti_qemu_st_aligned_be_gadgets.c',
         'tcti_qemu_st_aligned_be_gadgets.h',
-        'tcti_qemu_st_unaligned_be_gadgets.s',
+        'tcti_qemu_st_unaligned_be_gadgets.c',
         'tcti_qemu_st_unaligned_be_gadgets.h',
-        'tcti_qemu_st_slowpath_be_gadgets.s',
+        'tcti_qemu_st_slowpath_be_gadgets.c',
         'tcti_qemu_st_slowpath_be_gadgets.h',
     ]
     tcti_gadgets = custom_target('tcti-gadgets.h',
@@ -1780,7 +1780,7 @@ qom_ss = ss.source_set()
 softmmu_ss = ss.source_set()
 specific_fuzz_ss = ss.source_set()
 specific_ss = ss.source_set()
-tcti_ss = ss.source_set()
+#tcti_ss = ss.source_set()
 stub_ss = ss.source_set()
 trace_ss = ss.source_set()
 user_ss = ss.source_set()
@@ -2004,8 +2004,8 @@ specific_ss.add(files('page-vary.c'))
 specific_ss.add(when: 'CONFIG_TCG_INTERPRETER', if_true: files('tcg/tci.c'))
 
 # FIXME: This is being used for now for development quickness, but these realy should be
-# added to a gadget-specific shared library.
-tcti_ss.add(when: 'CONFIG_TCG_THREADED_INTERPRETER', if_true: tcti_gadgets)
+# added to a gadget-specific shared library (tcti_ss).
+specific_ss.add(when: 'CONFIG_TCG_THREADED_INTERPRETER', if_true: tcti_gadgets)
 
 subdir('backends')
 subdir('disas')
@@ -2175,11 +2175,11 @@ common_all = static_library('common',
                             dependencies: common_all.dependencies(),
                             name_suffix: 'fa')
 
-tcti_all = common_ss.apply(config_all, strict: false)
-tcti_all = shared_library('tcti',
-                            build_by_default: false,
-                            sources: tcti_gadgets,
-                            name_suffix: 'fa')
+#tcti_all = common_ss.apply(config_all, strict: false)
+#tcti_all = shared_library('tcti',
+#                            build_by_default: false,
+#                            sources: tcti_gadgets,
+#                            name_suffix: 'fa')
 
 feature_to_c = find_program('scripts/feature_to_c.sh')
 
@@ -2254,7 +2254,7 @@ foreach target : target_dirs
   arch_deps += t.dependencies()
 
   target_common = common_ss.apply(config_target, strict: false)
-  objects = [common_all.extract_objects(target_common.sources()), tcti_all.extract_all_objects()]
+  objects = [common_all.extract_objects(target_common.sources())] #, tcti_all.extract_all_objects()]
   deps = target_common.dependencies()
 
   target_specific = specific_ss.apply(config_target, strict: false)
@@ -2286,7 +2286,7 @@ foreach target : target_dirs
                  c_args: c_args,
                  build_by_default: false,
                  kwargs: build_lib_args,
-                 link_with: tcti_all
+                 #link_with: tcti_all
                  )
 
   if target.endswith('-softmmu')
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index b5da8e228162..4233acf10976 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -104,6 +104,39 @@
         }
 
 
+#define LOOKUP_SPECIAL_CASE_LDST_GADGET(arg, name, mode) \
+    switch(TLB_MASK_TABLE_OFS(get_mmuidx(arg))) { \
+        case -32:  \
+            gadget = (a_bits >= s_bits) ?  \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off32_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off32_i64; \
+            break; \
+        case -48:  \
+            gadget = (a_bits >= s_bits) ?  \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off48_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off48_i64; \
+            break; \
+        case -64: \
+            gadget = (a_bits >= s_bits) ? \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off64_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off64_i64; \
+            break; \
+        case -96: \
+            gadget = (a_bits >= s_bits) ? \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off96_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off96_i64; \
+            break; \
+        case -128: \
+            gadget = (a_bits >= s_bits) ? \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off128_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off128_i64; \
+            break;\
+        default: \
+            gadget = gadget_qemu_ ## name ## _slowpath_ ## mode ## _off0_i64; \
+            break; \
+        }
+
+
 static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
 {
     switch (op) {
@@ -1040,6 +1073,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
         switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
             case -32:  LD_MEMOP_HANDLER(gadget, args[2],  off32_i32, a_bits, s_bits); break;
+            case -48:  LD_MEMOP_HANDLER(gadget, args[2],  off48_i32, a_bits, s_bits); break;
             case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
             case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
             case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
@@ -1061,46 +1095,29 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
         void *gadget;
 
-        // Special optimization case: if we have an operation/target of 0x3A, 
-        // this is a common case. Delegate to our special-case handler.
-        if (args[2] == 0x3a) {
-            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
-                case -32: 
-                    gadget = (a_bits >= s_bits) ? 
-                        gadget_qemu_ld_leq_aligned_mode3a_off32_i64 :
-                        gadget_qemu_ld_leq_unaligned_mode3a_off32_i64;
-                    break;
-                case -64: 
-                    gadget = (a_bits >= s_bits) ? 
-                        gadget_qemu_ld_leq_aligned_mode3a_off64_i64 :
-                        gadget_qemu_ld_leq_unaligned_mode3a_off64_i64;
-                    break;
-                case -96: 
-                    gadget = (a_bits >= s_bits) ? 
-                        gadget_qemu_ld_leq_aligned_mode3a_off96_i64 :
-                        gadget_qemu_ld_leq_unaligned_mode3a_off96_i64;
-                    break;
-                case -128: 
-                    gadget = (a_bits >= s_bits) ? 
-                        gadget_qemu_ld_leq_aligned_mode3a_off128_i64 :
-                        gadget_qemu_ld_leq_unaligned_mode3a_off128_i64;
-                    break;
-
-                default: 
-                    gadget = gadget_qemu_ld_leq_slowpath_mode3a_off0_i64;
-                    break;
-            }
+        // Special optimization case: if we have an common case. 
+        // Delegate to our special-case handler.
+        if (args[2] == 0x02) {
+            LOOKUP_SPECIAL_CASE_LDST_GADGET(args[2], ld_ub, mode02)
             tcg_out_binary_gadget(s, gadget, args[0], args[1]);
-        } 
+        } else if (args[2] == 0x32) {
+            LOOKUP_SPECIAL_CASE_LDST_GADGET(args[2], ld_leq, mode32)
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } else if(args[2] == 0x3a) {
+            LOOKUP_SPECIAL_CASE_LDST_GADGET(args[2], ld_leq, mode3a)
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        }
         // Otherwise, handle the generic case.
         else {
             switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
                 case -32:  LD_MEMOP_HANDLER(gadget, args[2],  off32_i64, a_bits, s_bits); break;
+                case -48:  LD_MEMOP_HANDLER(gadget, args[2],  off48_i64, a_bits, s_bits); break;
                 case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
                 case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
                 case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
                 default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); warn_slow_memop(args[2]); break;
             }
+
             // Args:
             // - an immediate32 encodes our operation index 
             tcg_out_binary_gadget(s, gadget, args[0], args[1]);
@@ -1120,6 +1137,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
         switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
             case -32:  ST_MEMOP_HANDLER(gadget, args[2],  off32_i32, a_bits, s_bits); break;
+            case -48:  ST_MEMOP_HANDLER(gadget, args[2],  off48_i32, a_bits, s_bits); break;
             case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
             case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
             case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
@@ -1142,41 +1160,23 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
         void *gadget;
 
-        // Special optimization case: if we have an operation/target of 0x3A, 
-        // this is a common case. Delegate to our special-case handler.
-        if (args[2] == 0x3a) {
-            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
-                case -32: 
-                    gadget = (a_bits >= s_bits) ? 
-                        gadget_qemu_st_leq_aligned_mode3a_off32_i64 :
-                        gadget_qemu_st_leq_unaligned_mode3a_off32_i64;
-                    break;
-                case -64: 
-                    gadget = (a_bits >= s_bits) ? 
-                        gadget_qemu_st_leq_aligned_mode3a_off64_i64 :
-                        gadget_qemu_st_leq_unaligned_mode3a_off64_i64;
-                    break;
-                case -96: 
-                    gadget = (a_bits >= s_bits) ? 
-                        gadget_qemu_st_leq_aligned_mode3a_off96_i64 :
-                        gadget_qemu_st_leq_unaligned_mode3a_off96_i64;
-                    break;
-                case -128: 
-                    gadget = (a_bits >= s_bits) ? 
-                        gadget_qemu_st_leq_aligned_mode3a_off128_i64 :
-                        gadget_qemu_st_leq_unaligned_mode3a_off128_i64;
-                    break;
-
-                default: 
-                    gadget = gadget_qemu_st_leq_slowpath_mode3a_off0_i64;
-                    break;
-            }
+        // Special optimization case: if we have an common case. 
+        // Delegate to our special-case handler.
+        if (args[2] == 0x02) {
+            LOOKUP_SPECIAL_CASE_LDST_GADGET(args[2], st_ub, mode02)
             tcg_out_binary_gadget(s, gadget, args[0], args[1]);
-        } 
+        } else if (args[2] == 0x32) {
+            LOOKUP_SPECIAL_CASE_LDST_GADGET(args[2], st_leq, mode32)
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } else if(args[2] == 0x3a) {
+            LOOKUP_SPECIAL_CASE_LDST_GADGET(args[2], st_leq, mode3a)
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        }
         // Otherwise, handle the generic case.
         else {
             switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
-                case -32:  ST_MEMOP_HANDLER(gadget, args[2],  off32_i32, a_bits, s_bits); break;
+                case -32:  ST_MEMOP_HANDLER(gadget, args[2],  off32_i64, a_bits, s_bits); break;
+                case -48:  ST_MEMOP_HANDLER(gadget, args[2],  off48_i64, a_bits, s_bits); break;
                 case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
                 case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
                 case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 60dba2ffc907..62b52a01cd26 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -27,7 +27,7 @@
 
 # We'll create a variety of gadgets that assume the MMU's TLB is stored at certain
 # offsets into its structure. These should match the offsets in tcg-target.c.in.
-QEMU_ALLOWED_MMU_OFFSETS = [ 32, 64, 96, 128 ]
+QEMU_ALLOWED_MMU_OFFSETS = [ 32, 48, 64, 96, 128 ]
 
 # Statistics.
 gadgets      = 0
@@ -337,31 +337,14 @@ def with_d(name, *lines):
 
 # Assembly code for saving our machine state before entering the C runtime.
 C_CALL_PROLOGUE = [
-    # Store our machine state.
-    "str x25,      [sp, #-16]!",
     "stp x14, x15, [sp, #-16]!",
-    "stp x12, x13, [sp, #-16]!",
-    "stp x10, x11, [sp, #-16]!",
-    "stp x8,  x9,  [sp, #-16]!",
-    "stp x6,  x7,  [sp, #-16]!",
-    "stp x4,  x5,  [sp, #-16]!",
-    "stp x2,  x3,  [sp, #-16]!",
-    "stp x0,  x1,  [sp, #-16]!",
     "stp x28, lr,  [sp, #-16]!",
 ]
 
 # Assembly code for restoring our machine state after leaving the C runtime.
 C_CALL_EPILOGUE = [
-    "ldp x28, lr, [sp], #16",
-    "ldp x0,  x1, [sp], #16",
-    "ldp x2,  x3, [sp], #16",
-    "ldp x4,  x5, [sp], #16",
-    "ldp x6,  x7, [sp], #16",
-    "ldp x8,  x9, [sp], #16",
-    "ldp x10, x11, [sp], #16",
-    "ldp x12, x13, [sp], #16",
+    "ldp x28, lr,  [sp], #16",
     "ldp x14, x15, [sp], #16",
-    "ldr x25,      [sp], #16",
 ]
 
 
@@ -781,7 +764,7 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 math_dn("ext16s",     "sxth", source_is_wn=True)
 with_dn("ext16u",     "and Wd, Wn, #0xffff")
 with_dn("ext32s_i64", "sxtw Xd, Wn")
-with_dn("ext32u_i64", "and Xd, Xn, #0xffffffff")
+with_dn("ext32u_i64", "mov Wd, Wn")
 
 START_COLLECTION("byteswap")
 
@@ -830,7 +813,15 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
         force_slowpath=is_slowpath,
     )
 
-    # Special variant for the most common mode, as a speedup optimization.
+    # Special variant for the most common modes, as a speedup optimization.
+    ld_thunk(f"qemu_ld_ub_{subtype}_mode02", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu",
+        fastpath_32b=["ldrb Wd, [Xn, x27]"], fastpath_64b=["ldrb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x02
+    )
+    ld_thunk(f"qemu_ld_leq_{subtype}_mode32", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x32
+    )
     ld_thunk(f"qemu_ld_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
         fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
         force_slowpath=is_slowpath, immediate=0x3a
@@ -878,6 +869,14 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
     )
     
     # Special optimization for the most common modes.
+    st_thunk(f"qemu_st_ub_{subtype}_mode02", is_aligned=is_aligned, slowpath_helper="helper_ret_stb_mmu",
+        fastpath_32b=["strb Wd, [Xn, x27]"], fastpath_64b=["strb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x02
+    )
+    st_thunk(f"qemu_st_leq_{subtype}_mode32", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x32
+    )
     st_thunk(f"qemu_st_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
         fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
         force_slowpath=is_slowpath, immediate=0x3a

From 026956a4743e392ca1314bbecfcd020b13b6fe51 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Tue, 4 May 2021 06:19:41 -0600
Subject: [PATCH 042/180] TCTI: minor gadget optimizations

---
 tcg/aarch64-tcti/tcg-target.c.inc   | 186 +++++++++++++++-------------
 tcg/aarch64-tcti/tcg-target.h       |  57 +++++----
 tcg/aarch64-tcti/tcti-gadget-gen.py |  40 +++---
 3 files changed, 151 insertions(+), 132 deletions(-)

diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index 4233acf10976..3b844086bbb2 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -54,7 +54,7 @@
 
 /**
  * Macro that defines a look-up tree for named QEMU_LD gadgets.
- */ 
+ */
 #define LD_MEMOP_LOOKUP(variable, arg, suffix) \
     switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
         case MO_UB:   variable = gadget_qemu_ld_ub_   ## suffix; break; \
@@ -83,7 +83,7 @@
 
 /**
  * Macro that defines a look-up tree for named QEMU_ST gadgets.
- */ 
+ */
 #define ST_MEMOP_LOOKUP(variable, arg, suffix) \
     switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
         case MO_UB:   variable = gadget_qemu_st_ub_   ## suffix; break; \
@@ -435,11 +435,11 @@ static void tcg_out_ternary_gadget(TCGContext *s, const void *gadget_base[TCG_TA
 /**
  * Version of our LDST generator that defers to more optimized gadgets selectively.
  */
-static void tcg_out_ldst_gadget_inner(TCGContext *s, 
-    const void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], 
-    const void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
-    const void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
-    const void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+static void tcg_out_ldst_gadget_inner(TCGContext *s,
+    const void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS],
+    const void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
+    const void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
+    const void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
     unsigned reg0, unsigned reg1, uint32_t offset)
 {
     int64_t extended_offset = (int32_t)offset;
@@ -450,7 +450,7 @@ static void tcg_out_ldst_gadget_inner(TCGContext *s,
 
     // We handle positive and negative gadgets separately, in order to allow for asymmetrical
     // collections of pre-made gadgets.
-    if (!is_negative) 
+    if (!is_negative)
     {
         uint64_t shifted_offset = (extended_offset >> 3);
         bool aligned_to_8B = ((extended_offset & 0b111) == 0);
@@ -462,7 +462,7 @@ static void tcg_out_ldst_gadget_inner(TCGContext *s,
         if (have_optimized_gadget) {
             tcg_out_nullary_gadget(s, gadget_pos_imm[reg0][reg1][extended_offset]);
             return;
-        } 
+        }
 
         // Special case: it's frequent to have low-numbered positive offsets that are aligned
         // to 16B boundaries
@@ -470,7 +470,7 @@ static void tcg_out_ldst_gadget_inner(TCGContext *s,
             tcg_out_nullary_gadget(s, gadget_shifted_imm[reg0][reg1][shifted_offset]);
             return;
         }
-    } 
+    }
     else {
         uint64_t negated_offset = -(extended_offset);
 
@@ -532,14 +532,14 @@ static void tcg_out_movi_i32(TCGContext *s, TCGReg t0, tcg_target_long arg)
 
     // We handle positive and negative gadgets separately, in order to allow for asymmetrical
     // collections of pre-made gadgets.
-    if (!is_negative) 
+    if (!is_negative)
     {
         // More optimal case: we have a gadget that directly encodes the argument.
         if (arg < ARRAY_SIZE(gadget_movi_imm_i32[t0])) {
             tcg_out_nullary_gadget(s, gadget_movi_imm_i32[t0][arg]);
             return;
         }
-    } 
+    }
     else {
 
     }
@@ -556,14 +556,14 @@ static void tcg_out_movi_i64(TCGContext *s, TCGReg t0, tcg_target_long arg)
 
     // We handle positive and negative gadgets separately, in order to allow for asymmetrical
     // collections of pre-made gadgets.
-    if (!is_negative) 
+    if (!is_negative)
     {
         // More optimal case: we have a gadget that directly encodes the argument.
         if (arg < ARRAY_SIZE(gadget_movi_imm_i64[t0])) {
             tcg_out_nullary_gadget(s, gadget_movi_imm_i64[t0][arg]);
             return;
         }
-    } 
+    }
     else {
 
     }
@@ -605,9 +605,9 @@ static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,
 {
 
     if (type == TCG_TYPE_I32) {
-        tcg_out_ldst_gadget(s, gadget_ld32u, ret, arg1, arg2); 
+        tcg_out_ldst_gadget(s, gadget_ld32u, ret, arg1, arg2);
     } else {
-        tcg_out_ldst_gadget(s, gadget_ld_i64, ret, arg1, arg2); 
+        tcg_out_ldst_gadget(s, gadget_ld_i64, ret, arg1, arg2);
     }
 }
 
@@ -719,41 +719,41 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
     case INDEX_op_ld8u_i32:
     case INDEX_op_ld8u_i64:
-        tcg_out_ldst_gadget(s, gadget_ld8u, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld8u, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_ld8s_i32:
-        tcg_out_ldst_gadget(s, gadget_ld8s_i32, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld8s_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_ld8s_i64:
-        tcg_out_ldst_gadget(s, gadget_ld8s_i64, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld8s_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_ld16u_i32:
     case INDEX_op_ld16u_i64:
-        tcg_out_ldst_gadget(s, gadget_ld16u, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld16u, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_ld16s_i32:
-        tcg_out_ldst_gadget(s, gadget_ld16s_i32, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld16s_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_ld16s_i64:
-        tcg_out_ldst_gadget(s, gadget_ld16s_i64, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld16s_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_ld_i32:
     case INDEX_op_ld32u_i64:
-        tcg_out_ldst_gadget(s, gadget_ld32u, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld32u, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_ld_i64:
-        tcg_out_ldst_gadget(s, gadget_ld_i64, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld_i64, args[0], args[1], args[2]);
         break;
-    
+   
     case INDEX_op_ld32s_i64:
-        tcg_out_ldst_gadget(s, gadget_ld32s_i64, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_ld32s_i64, args[0], args[1], args[2]);
         break;
 
 
@@ -762,155 +762,169 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
      */
     case INDEX_op_st8_i32:
     case INDEX_op_st8_i64:
-        tcg_out_ldst_gadget(s, gadget_st8, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_st8, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_st16_i32:
     case INDEX_op_st16_i64:
-        tcg_out_ldst_gadget(s, gadget_st16, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_st16, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_st_i32:
     case INDEX_op_st32_i64:
-        tcg_out_ldst_gadget(s, gadget_st_i32, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_st_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_st_i64:
-        tcg_out_ldst_gadget(s, gadget_st_i64, args[0], args[1], args[2]); 
+        tcg_out_ldst_gadget(s, gadget_st_i64, args[0], args[1], args[2]);
         break;
 
     /**
      * Arithmetic instructions.
      */
 
-    case INDEX_op_add_i32: 
-        tcg_out_ternary_gadget(s, gadget_add_i32, args[0], args[1], args[2]); 
+    case INDEX_op_add_i32:
+        tcg_out_ternary_gadget(s, gadget_add_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_sub_i32:
-        tcg_out_ternary_gadget(s, gadget_sub_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_sub_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_mul_i32:
-        tcg_out_ternary_gadget(s, gadget_mul_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_mul_i32, args[0], args[1], args[2]);
+        break;
+
+    case INDEX_op_nand_i32:     /* Optional (TCG_TARGET_HAS_nand_i32). */
+        tcg_out_ternary_gadget(s, gadget_nand_i32, args[0], args[1], args[2]);
+        break;
+
+    case INDEX_op_nor_i32:     /* Optional (TCG_TARGET_HAS_nor_i32). */
+        tcg_out_ternary_gadget(s, gadget_nor_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_and_i32:
-        tcg_out_ternary_gadget(s, gadget_and_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_and_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_andc_i32:     /* Optional (TCG_TARGET_HAS_andc_i32). */
-        tcg_out_ternary_gadget(s, gadget_andc_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_andc_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_orc_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
-        tcg_out_ternary_gadget(s, gadget_orc_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_orc_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_eqv_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
-        tcg_out_ternary_gadget(s, gadget_eqv_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_eqv_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_or_i32:
-        tcg_out_ternary_gadget(s, gadget_or_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_or_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_xor_i32:
-        tcg_out_ternary_gadget(s, gadget_xor_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_xor_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_shl_i32:
-        tcg_out_ternary_gadget(s, gadget_shl_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_shl_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_shr_i32:
-        tcg_out_ternary_gadget(s, gadget_shr_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_shr_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_sar_i32:
-        tcg_out_ternary_gadget(s, gadget_sar_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_sar_i32, args[0], args[1], args[2]);
         break;
 
-    //case INDEX_op_rotr_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
-    //    tcg_out_ternary_gadget(s, gadget_rotr_i32, args[0], args[1], args[2]); 
-    //    break;
+    case INDEX_op_rotr_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+        tcg_out_ternary_gadget(s, gadget_rotr_i32, args[0], args[1], args[2]);
+        break;
 
-    //case INDEX_op_rotl_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
-    //    tcg_out_ternary_gadget(s, gadget_rotl_i32, args[0], args[1], args[2]); 
+    case INDEX_op_rotl_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+        tcg_out_ternary_gadget(s, gadget_rotl_i32, args[0], args[1], args[2]);
+        break;
 
     case INDEX_op_add_i64:
-        tcg_out_ternary_gadget(s, gadget_add_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_add_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_sub_i64:
-        tcg_out_ternary_gadget(s, gadget_sub_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_sub_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_mul_i64:
-        tcg_out_ternary_gadget(s, gadget_mul_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_mul_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_and_i64:
-        tcg_out_ternary_gadget(s, gadget_and_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_and_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_andc_i64:     /* Optional (TCG_TARGET_HAS_andc_i64). */
-        tcg_out_ternary_gadget(s, gadget_andc_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_andc_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_orc_i64:      /* Optional (TCG_TARGET_HAS_orc_i64). */
-        tcg_out_ternary_gadget(s, gadget_orc_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_orc_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_eqv_i64:      /* Optional (TCG_TARGET_HAS_eqv_i64). */
-        tcg_out_ternary_gadget(s, gadget_eqv_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_eqv_i64, args[0], args[1], args[2]);
         break;
 
-    //case INDEX_op_nand_i64:     /* Optional (TCG_TARGET_HAS_nand_i64). */
-    //case INDEX_op_nor_i64:      /* Optional (TCG_TARGET_HAS_nor_i64). */
+    case INDEX_op_nand_i64:     /* Optional (TCG_TARGET_HAS_nand_i64). */
+        tcg_out_ternary_gadget(s, gadget_nand_i64, args[0], args[1], args[2]);
+        break;
+
+    case INDEX_op_nor_i64:      /* Optional (TCG_TARGET_HAS_nor_i64). */
+        tcg_out_ternary_gadget(s, gadget_nor_i64, args[0], args[1], args[2]);
+        break;
 
     case INDEX_op_or_i64:
-        tcg_out_ternary_gadget(s, gadget_or_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_or_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_xor_i64:
-        tcg_out_ternary_gadget(s, gadget_xor_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_xor_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_shl_i64:
-        tcg_out_ternary_gadget(s, gadget_shl_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_shl_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_shr_i64:
-        tcg_out_ternary_gadget(s, gadget_shr_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_shr_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_sar_i64:
-        tcg_out_ternary_gadget(s, gadget_sar_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_sar_i64, args[0], args[1], args[2]);
         break;
 
-    //case INDEX_op_rotl_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
-    //    tcg_out_ternary_gadget(s, gadget_rotl_i64, args[0], args[1], args[2]); 
-    //    break;
+    case INDEX_op_rotl_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+        tcg_out_ternary_gadget(s, gadget_rotl_i64, args[0], args[1], args[2]);
+        break;
 
-    //case INDEX_op_rotr_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
-    //    tcg_out_ternary_gadget(s, gadget_rotr_i64, args[0], args[1], args[2]); 
-    //    break;
+    case INDEX_op_rotr_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+        tcg_out_ternary_gadget(s, gadget_rotr_i64, args[0], args[1], args[2]);
+        break;
 
     case INDEX_op_div_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
-        tcg_out_ternary_gadget(s, gadget_div_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_div_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_divu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
-        tcg_out_ternary_gadget(s, gadget_divu_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_divu_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_rem_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
-        tcg_out_ternary_gadget(s, gadget_rem_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_rem_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_remu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
-        tcg_out_ternary_gadget(s, gadget_remu_i64, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_remu_i64, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_brcond_i64:
@@ -1014,19 +1028,19 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         break;
 
     case INDEX_op_div_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
-        tcg_out_ternary_gadget(s, gadget_div_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_div_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_divu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
-        tcg_out_ternary_gadget(s, gadget_divu_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_divu_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_rem_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
-        tcg_out_ternary_gadget(s, gadget_rem_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_rem_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_remu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
-        tcg_out_ternary_gadget(s, gadget_remu_i32, args[0], args[1], args[2]); 
+        tcg_out_ternary_gadget(s, gadget_remu_i32, args[0], args[1], args[2]);
         break;
 
     case INDEX_op_brcond_i32:
@@ -1081,7 +1095,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         }
 
         // Args:
-        // - an immediate32 encodes our operation index 
+        // - an immediate32 encodes our operation index
         tcg_out_binary_gadget(s, gadget, args[0], args[1]);
         tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
         break;
@@ -1095,7 +1109,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
         void *gadget;
 
-        // Special optimization case: if we have an common case. 
+        // Special optimization case: if we have an common case.
         // Delegate to our special-case handler.
         if (args[2] == 0x02) {
             LOOKUP_SPECIAL_CASE_LDST_GADGET(args[2], ld_ub, mode02)
@@ -1119,7 +1133,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
             }
 
             // Args:
-            // - an immediate32 encodes our operation index 
+            // - an immediate32 encodes our operation index
             tcg_out_binary_gadget(s, gadget, args[0], args[1]);
             tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
         }
@@ -1146,7 +1160,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
         // Args:
         // - our gadget encodes the target and address registers
-        // - an immediate32 encodes our operation index 
+        // - an immediate32 encodes our operation index
         tcg_out_binary_gadget(s, gadget, args[0], args[1]);
         tcg_out64(s, args[2]); // FIXME: double encoded
         break;
@@ -1160,7 +1174,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
         void *gadget;
 
-        // Special optimization case: if we have an common case. 
+        // Special optimization case: if we have an common case.
         // Delegate to our special-case handler.
         if (args[2] == 0x02) {
             LOOKUP_SPECIAL_CASE_LDST_GADGET(args[2], st_ub, mode02)
@@ -1185,7 +1199,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
             // Args:
             // - our gadget encodes the target and address registers
-            // - an immediate32 encodes our operation index 
+            // - an immediate32 encodes our operation index
             tcg_out_binary_gadget(s, gadget, args[0], args[1]);
             tcg_out64(s, args[2]); // FIXME: double encoded
         }
@@ -1223,9 +1237,9 @@ static void tcg_out_st(TCGContext *s, TCGType type, TCGReg arg, TCGReg arg1,
                        intptr_t arg2)
 {
     if (type == TCG_TYPE_I32) {
-        tcg_out_ldst_gadget(s, gadget_st_i32, arg, arg1, arg2); 
+        tcg_out_ldst_gadget(s, gadget_st_i32, arg, arg1, arg2);
     } else {
-        tcg_out_ldst_gadget(s, gadget_st_i64, arg, arg1, arg2); 
+        tcg_out_ldst_gadget(s, gadget_st_i64, arg, arg1, arg2);
     }
 }
 
@@ -1314,8 +1328,8 @@ uintptr_t QEMU_DISABLE_CFI tcg_qemu_tb_exec(CPUArchState *env, const void *v_tb_
 
         : [return_value] "=m" (return_value)
 
-        : [areg0]        "m"  (env), 
-          [sp_value]     "m"  (sp_value), 
+        : [areg0]        "m"  (env),
+          [sp_value]     "m"  (sp_value),
           [start_tb_ptr] "m"  (v_tb_ptr),
           [pc_mirror]    "m"  (pc_mirror)
 
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
index fa2ae5c40a3e..12d06f8cc671 100644
--- a/tcg/aarch64-tcti/tcg-target.h
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -55,8 +55,11 @@
 // weird psuedo-native bytecode. We'll indicate that we're intepreted.
 #define TCG_TARGET_INTERPRETER 1
 
+// Specify we'll handle direct jumps.
+#define TCG_TARGET_HAS_direct_jump      1
+
 //
-// Supported optional instructions.
+// Supported optional scalar instructions.
 //
 
 // Divs.
@@ -77,23 +80,27 @@
 #define TCG_TARGET_HAS_ext16u_i64       1
 #define TCG_TARGET_HAS_ext32u_i64       1
 
-// Logicals.
+// Negations.
 #define TCG_TARGET_HAS_neg_i32          1
 #define TCG_TARGET_HAS_not_i32          1
 #define TCG_TARGET_HAS_neg_i64          1
 #define TCG_TARGET_HAS_not_i64          1
 
+// Logicals.
 #define TCG_TARGET_HAS_andc_i32         1
 #define TCG_TARGET_HAS_orc_i32          1
 #define TCG_TARGET_HAS_eqv_i32          1
+#define TCG_TARGET_HAS_rot_i32          1
+#define TCG_TARGET_HAS_nand_i32         1
+#define TCG_TARGET_HAS_nor_i32          1
 #define TCG_TARGET_HAS_andc_i64         1
 #define TCG_TARGET_HAS_eqv_i64          1
 #define TCG_TARGET_HAS_orc_i64          1
+#define TCG_TARGET_HAS_rot_i64          1
+#define TCG_TARGET_HAS_nor_i64          1
+#define TCG_TARGET_HAS_nand_i64         1
+
 
-// We don't curretly support rotates, since AArch64 lacks ROL.
-// We'll fix this later.
-#define TCG_TARGET_HAS_rot_i32          0
-#define TCG_TARGET_HAS_rot_i64          0
 
 // Swaps.
 #define TCG_TARGET_HAS_bswap16_i32      1
@@ -103,9 +110,6 @@
 #define TCG_TARGET_HAS_bswap64_i64      1
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
 
-// Specify we'll handle direct jumps.
-#define TCG_TARGET_HAS_direct_jump      1
-
 //
 // Potential TODOs.
 //
@@ -120,19 +124,16 @@
 #define TCG_TARGET_HAS_extract_i64      0
 #define TCG_TARGET_HAS_sextract_i64     0
 
-// TODO: it might be worth writing a gadget for this
-#define TCG_TARGET_HAS_movcond_i32      0
-#define TCG_TARGET_HAS_movcond_i64      0
 
 //
-// Unsupported instructions.
+// Supported optional vector instructions.
 //
 
-// ARMv8 doesn't have instructions for NAND/NOR.
-#define TCG_TARGET_HAS_nand_i32         0
-#define TCG_TARGET_HAS_nor_i32          0
-#define TCG_TARGET_HAS_nor_i64          0
-#define TCG_TARGET_HAS_nand_i64         0
+// TODO!
+
+//
+// Unsupported instructions.
+//
 
 // aarch64's CLZ is implemented without a condition, so it
 #define TCG_TARGET_HAS_clz_i32          0
@@ -142,19 +143,24 @@
 #define TCG_TARGET_HAS_ctz_i64          0
 #define TCG_TARGET_HAS_ctpop_i64        0
 
+// We don't currently support gadgets with more than three arguments,
+// so we can't yet create movcond gadgets.
+#define TCG_TARGET_HAS_movcond_i32      0
+#define TCG_TARGET_HAS_movcond_i64      0
 
-// GOTO_PTR is too complex to emit a simple gadget for.
-// We'll let C handle it, since the overhead is similar.
+// GOTO_PTR is too complex to emit a simple gadget for, since it can
+// target either interpreted code or our non-existent epilogue.
 #define TCG_TARGET_HAS_goto_ptr         0
 
-// We don't have a simple gadget for this, since we're always assuming softmmu.
-#define TCG_TARGET_HAS_qemu_st8_i32     0
-
-// No AArch64 equivalent.a
+// No AArch64 equivalent.
 #define TCG_TARGET_HAS_extrl_i64_i32    0
 #define TCG_TARGET_HAS_extrh_i64_i32    0
 
-#define TCG_TARGET_HAS_extract2_i64     0
+// This operation exists specifically to allow us to provide differing register
+// constraints for 8-bit loads and stores. We don't need to do so, so we'll leave
+// this unimplemented, as we gain nothing by it.
+#define TCG_TARGET_HAS_qemu_st8_i32     0
+
 
 // These should always be zero on our 64B platform.
 #define TCG_TARGET_HAS_muls2_i64        0
@@ -170,6 +176,7 @@
 #define TCG_TARGET_HAS_muls2_i32        0
 #define TCG_TARGET_HAS_muluh_i32        0
 #define TCG_TARGET_HAS_mulsh_i32        0
+#define TCG_TARGET_HAS_extract2_i64     0
 
 //
 // Platform metadata.
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 62b52a01cd26..138b8c45860d 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -594,6 +594,7 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
     "ldr x28, [x28]"
 )
 
+
 # Exit from a translation buffer execution.
 simple("exit_tb",
 
@@ -645,17 +646,12 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
         # Grab our immediate argument.
         "ldr x27, [x28], #8",
 
-        # Perform our comparison and conditional branch.
+        # Perform our comparison...
         "subs wzr, Wn, Wm",
-        f"b{condition} 1f",
-
-        "0:", # not taken
-           # Perform our end-of-instruction epilogue.
-            *EPILOGUE,
 
-        "1:" # taken
-            # Update our bytecode pointer to take the label.
-            "mov x28, x27"
+        # ... and our conditional branch, which selectively sets w28 (our "gadget pointer")
+        # to the new location, if required.
+        f"csel x28, x27, x28, {condition}"
     )
 
     # Branches iff a given comparison is true.
@@ -666,15 +662,10 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 
         # Perform our comparison and conditional branch.
         "subs xzr, Xn, Xm",
-        f"b{condition} 1f",
 
-        "0:", # not taken
-            # Perform our end-of-instruction epilogue.
-            *EPILOGUE,
-
-        "1:" # taken
-            # Update our bytecode pointer to take the label.
-            "mov x28, x27"
+        # ... and our conditional branch, which selectively sets w28 (our "gadget pointer")
+        # to the new location, if required.
+        f"csel x28, x27, x28, {condition}"
     )
 
 
@@ -749,12 +740,19 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 math_dnm("shl",  "lsl")
 math_dnm("shr",  "lsr")
 math_dnm("sar",  "asr")
+math_dnm("rotr", "ror")
 
 # AArch64 lacks a Rotate Left; so we instead rotate right by a negative.
-# TODO: validate this?
-#math_dnm("rotr", "ror")
-#with_dnm("rotl_i32", "neg w27, Wm", "ror Wd, Wn, w27")
-#with_dnm("rotl_i64", "neg x27, Xm", "ror Xd, Xn, x27")
+with_dnm("rotl_i32", "neg w27, Wm", "ror Wd, Wn, w27")
+with_dnm("rotl_i64", "neg w27, Wm", "ror Xd, Xn, x27")
+
+# We'll synthesize several instructions that don't exist; since it's still faster
+# to run these as gadgets.
+with_dnm("nand_i32", "and Wd, Wn, Wm", "mvn Wd, Wd")
+with_dnm("nand_i64", "and Xd, Xn, Xm", "mvn Xd, Xd")
+with_dnm("nor_i32",  "orr Wd, Wn, Wm", "mvn Wd, Wd")
+with_dnm("nor_i64",  "orr Xd, Xn, Xm", "mvn Xd, Xd")
+
 
 START_COLLECTION("extension")
 

From 671b3cefcccaada60b289cdff408b9d29907b7f2 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Tue, 4 May 2021 08:02:19 -0600
Subject: [PATCH 043/180] TCTI: add remaining scalar ops

---
 meson.build                         |  2 +
 tcg/aarch64-tcti/tcg-target.c.inc   | 30 ++++++++++++++
 tcg/aarch64-tcti/tcg-target.h       | 45 +++++++++------------
 tcg/aarch64-tcti/tcti-gadget-gen.py | 62 +++++++++++++++++++++++++++++
 4 files changed, 112 insertions(+), 27 deletions(-)

diff --git a/meson.build b/meson.build
index 6d9d804bf1aa..df83051ebc2a 100644
--- a/meson.build
+++ b/meson.build
@@ -283,6 +283,8 @@ if not get_option('tcg').disabled()
         'tcti_logical_gadgets.h',
         'tcti_extension_gadgets.c',
         'tcti_extension_gadgets.h',
+        'tcti_bitwise_gadgets.c',
+        'tcti_bitwise_gadgets.h',
         'tcti_byteswap_gadgets.c',
         'tcti_byteswap_gadgets.h',
         'tcti_qemu_ld_aligned_signed_le_gadgets.c',
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index 3b844086bbb2..e6020ce59671 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -173,6 +173,8 @@ static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
     case INDEX_op_bswap32_i32:
     case INDEX_op_bswap32_i64:
     case INDEX_op_bswap64_i64:
+    case INDEX_op_extrl_i64_i32:
+    case INDEX_op_extrh_i64_i32:
         return C_O1_I1(r, r);
 
     case INDEX_op_st8_i32:
@@ -226,6 +228,10 @@ static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
     case INDEX_op_rotr_i64:
     case INDEX_op_setcond_i32:
     case INDEX_op_setcond_i64:
+    case INDEX_op_clz_i32:
+    case INDEX_op_clz_i64:
+    case INDEX_op_ctz_i32:
+    case INDEX_op_ctz_i64:
         return C_O1_I2(r, r, r);
 
     case INDEX_op_brcond_i32:
@@ -983,6 +989,14 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         tcg_out_binary_gadget(s, gadget_neg_i64, args[0], args[1]);
         break;
 
+    case INDEX_op_clz_i64:      /* Optional (TCG_TARGET_HAS_clz_i64). */
+        tcg_out_ternary_gadget(s, gadget_clz_i64, args[0], args[1], args[2]);
+        break;
+
+    case INDEX_op_ctz_i64:      /* Optional (TCG_TARGET_HAS_ctz_i64). */
+        tcg_out_ternary_gadget(s, gadget_ctz_i64, args[0], args[1], args[2]);
+        break;
+
     case INDEX_op_ext8s_i64:    /* Optional (TCG_TARGET_HAS_ext8s_i64). */
         tcg_out_binary_gadget(s, gadget_ext8s_i64, args[0], args[1]);
         break;
@@ -1011,10 +1025,26 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         tcg_out_binary_gadget(s, gadget_ext32u_i64, args[0], args[1]);
         break;
 
+    case INDEX_op_extrl_i64_i32:
+        tcg_out_binary_gadget(s, gadget_extrl, args[0], args[1]);
+        break;
+
+    case INDEX_op_extrh_i64_i32:
+        tcg_out_binary_gadget(s, gadget_extrh, args[0], args[1]);
+        break;
+
     case INDEX_op_neg_i32:      /* Optional (TCG_TARGET_HAS_neg_i32). */
         tcg_out_binary_gadget(s, gadget_neg_i32, args[0], args[1]);
         break;
 
+    case INDEX_op_clz_i32:      /* Optional (TCG_TARGET_HAS_clz_i32). */
+        tcg_out_ternary_gadget(s, gadget_clz_i32, args[0], args[1], args[2]);
+        break;
+
+    case INDEX_op_ctz_i32:      /* Optional (TCG_TARGET_HAS_ctz_i32). */
+        tcg_out_ternary_gadget(s, gadget_ctz_i32, args[0], args[1], args[2]);
+        break;
+
     case INDEX_op_not_i32:      /* Optional (TCG_TARGET_HAS_not_i32). */
         tcg_out_binary_gadget(s, gadget_not_i32, args[0], args[1]);
         break;
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
index 12d06f8cc671..7087321de68a 100644
--- a/tcg/aarch64-tcti/tcg-target.h
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -80,6 +80,10 @@
 #define TCG_TARGET_HAS_ext16u_i64       1
 #define TCG_TARGET_HAS_ext32u_i64       1
 
+// Register extractions.
+#define TCG_TARGET_HAS_extrl_i64_i32    1
+#define TCG_TARGET_HAS_extrh_i64_i32    1
+
 // Negations.
 #define TCG_TARGET_HAS_neg_i32          1
 #define TCG_TARGET_HAS_not_i32          1
@@ -100,7 +104,11 @@
 #define TCG_TARGET_HAS_nor_i64          1
 #define TCG_TARGET_HAS_nand_i64         1
 
-
+// Bitwise operations.
+#define TCG_TARGET_HAS_clz_i32          1
+#define TCG_TARGET_HAS_ctz_i32          1
+#define TCG_TARGET_HAS_clz_i64          1
+#define TCG_TARGET_HAS_ctz_i64          1
 
 // Swaps.
 #define TCG_TARGET_HAS_bswap16_i32      1
@@ -110,21 +118,6 @@
 #define TCG_TARGET_HAS_bswap64_i64      1
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
 
-//
-// Potential TODOs.
-//
-
-// TODO: implement DEPOSIT as BFI.
-#define TCG_TARGET_HAS_deposit_i32      0
-#define TCG_TARGET_HAS_deposit_i64      0
-
-// TODO: implement EXTRACT as BFX.
-#define TCG_TARGET_HAS_extract_i32      0
-#define TCG_TARGET_HAS_sextract_i32     0
-#define TCG_TARGET_HAS_extract_i64      0
-#define TCG_TARGET_HAS_sextract_i64     0
-
-
 //
 // Supported optional vector instructions.
 //
@@ -135,33 +128,31 @@
 // Unsupported instructions.
 //
 
-// aarch64's CLZ is implemented without a condition, so it
-#define TCG_TARGET_HAS_clz_i32          0
-#define TCG_TARGET_HAS_ctz_i32          0
+// There's no direct instruction with which to count the number of ones,
+// so we'll leave this implemented as other instructions.
 #define TCG_TARGET_HAS_ctpop_i32        0
-#define TCG_TARGET_HAS_clz_i64          0
-#define TCG_TARGET_HAS_ctz_i64          0
 #define TCG_TARGET_HAS_ctpop_i64        0
 
 // We don't currently support gadgets with more than three arguments,
-// so we can't yet create movcond gadgets.
+// so we can't yet create movcond, deposit, or extract gadgets.
 #define TCG_TARGET_HAS_movcond_i32      0
 #define TCG_TARGET_HAS_movcond_i64      0
+#define TCG_TARGET_HAS_deposit_i32      0
+#define TCG_TARGET_HAS_deposit_i64      0
+#define TCG_TARGET_HAS_extract_i32      0
+#define TCG_TARGET_HAS_sextract_i32     0
+#define TCG_TARGET_HAS_extract_i64      0
+#define TCG_TARGET_HAS_sextract_i64     0
 
 // GOTO_PTR is too complex to emit a simple gadget for, since it can
 // target either interpreted code or our non-existent epilogue.
 #define TCG_TARGET_HAS_goto_ptr         0
 
-// No AArch64 equivalent.
-#define TCG_TARGET_HAS_extrl_i64_i32    0
-#define TCG_TARGET_HAS_extrh_i64_i32    0
-
 // This operation exists specifically to allow us to provide differing register
 // constraints for 8-bit loads and stores. We don't need to do so, so we'll leave
 // this unimplemented, as we gain nothing by it.
 #define TCG_TARGET_HAS_qemu_st8_i32     0
 
-
 // These should always be zero on our 64B platform.
 #define TCG_TARGET_HAS_muls2_i64        0
 #define TCG_TARGET_HAS_add2_i32         0
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 138b8c45860d..0c0e575c4d24 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -753,6 +753,64 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 with_dnm("nor_i32",  "orr Wd, Wn, Wm", "mvn Wd, Wd")
 with_dnm("nor_i64",  "orr Xd, Xn, Xm", "mvn Xd, Xd")
 
+START_COLLECTION("bitwise")
+
+# Count leading zeroes, with a twist: QEMU requires us to provide
+# a default value for when the argument is 0.
+with_dnm("clz_i32",
+
+    # Perform the core CLZ into w26.
+    "clz w26, Wn",
+
+    # Check Wn to see if it was zero
+    "tst Wn, Wn",
+
+    # If it was zero, accept the argument provided in Wm.
+    # Otherwise, accept our result from w26.
+    "csel Wd, Wm, w26, eq"
+)
+with_dnm("clz_i64",
+
+    # Perform the core CLZ into w26.
+    "clz x26, Xn",
+
+    # Check Wn to see if it was zero
+    "tst Xn, Xn",
+
+    # If it was zero, accept the argument provided in Wm.
+    # Otherwise, accept our result from w26.
+    "csel Xd, Xm, x26, eq"
+)
+
+
+# Count trailing zeroes, with a twist: QEMU requires us to provide
+# a default value for when the argument is 0.
+with_dnm("ctz_i32",
+    # Reverse our bits before performing our actual clz.
+    "rbit w26, Wn",
+    "clz w26, w26",
+
+    # Check Wn to see if it was zero
+    "tst Wn, Wn",
+
+    # If it was zero, accept the argument provided in Wm.
+    # Otherwise, accept our result from w26.
+    "csel Wd, Wm, w26, eq"
+)
+with_dnm("ctz_i64",
+
+    # Perform the core CLZ into w26.
+    "rbit x26, Xn",
+    "clz x26, x26",
+
+    # Check Wn to see if it was zero
+    "tst Xn, Xn",
+
+    # If it was zero, accept the argument provided in Wm.
+    # Otherwise, accept our result from w26.
+    "csel Xd, Xm, x26, eq"
+)
+
 
 START_COLLECTION("extension")
 
@@ -764,6 +822,10 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 with_dn("ext32s_i64", "sxtw Xd, Wn")
 with_dn("ext32u_i64", "mov Wd, Wn")
 
+# Numeric extraction.
+with_dn("extrl",      "mov Wd, Wn")
+with_dn("extrh",      "lsr Xd, Xn, #32")
+
 START_COLLECTION("byteswap")
 
 # Byte swapping.

From 21ad741c1c05b8b1723355857069af979659c8b8 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Wed, 5 May 2021 16:49:30 -0600
Subject: [PATCH 044/180] TCTI: add initial vector instruction support

---
 meson.build                           |   6 +
 tcg/aarch64-tcti/tcg-target-con-set.h |  23 +-
 tcg/aarch64-tcti/tcg-target-con-str.h |  11 +-
 tcg/aarch64-tcti/tcg-target.c.inc     | 948 ++++++++++++++++++++++----
 tcg/aarch64-tcti/tcg-target.h         |  81 ++-
 tcg/aarch64-tcti/tcg-target.opc.h     |  15 +
 tcg/aarch64-tcti/tcti-gadget-gen.py   | 177 ++++-
 7 files changed, 1090 insertions(+), 171 deletions(-)
 create mode 100644 tcg/aarch64-tcti/tcg-target.opc.h

diff --git a/meson.build b/meson.build
index df83051ebc2a..cdbe0933ac9d 100644
--- a/meson.build
+++ b/meson.build
@@ -317,6 +317,12 @@ if not get_option('tcg').disabled()
         'tcti_qemu_st_unaligned_be_gadgets.h',
         'tcti_qemu_st_slowpath_be_gadgets.c',
         'tcti_qemu_st_slowpath_be_gadgets.h',
+        'tcti_simd_base_gadgets.c',
+        'tcti_simd_base_gadgets.h',
+        'tcti_simd_arithmetic_gadgets.c',
+        'tcti_simd_arithmetic_gadgets.h',
+        'tcti_simd_logical_gadgets.c',
+        'tcti_simd_logical_gadgets.h',
     ]
     tcti_gadgets = custom_target('tcti-gadgets.h',
                               output: tcti_sources,
diff --git a/tcg/aarch64-tcti/tcg-target-con-set.h b/tcg/aarch64-tcti/tcg-target-con-set.h
index f51b7bcb13e7..a0b91bb320f6 100644
--- a/tcg/aarch64-tcti/tcg-target-con-set.h
+++ b/tcg/aarch64-tcti/tcg-target-con-set.h
@@ -9,13 +9,24 @@
  * Each operand should be a sequence of constraint letters as defined by
  * tcg-target-con-str.h; the constraint combination is inclusive or.
  */
+
+// Simple register functions.
+C_O0_I1(r)
 C_O0_I2(r, r)
 C_O0_I3(r, r, r)
-C_O0_I4(r, r, r, r)
+//C_O0_I4(r, r, r, r)
 C_O1_I1(r, r)
-C_O1_I2(r, 0, r)
 C_O1_I2(r, r, r)
-C_O1_I4(r, r, r, r, r)
-C_O2_I1(r, r, r)
-C_O2_I2(r, r, r, r)
-C_O2_I4(r, r, r, r, r, r)
+//C_O1_I4(r, r, r, r, r)
+//C_O2_I1(r, r, r)
+//C_O2_I2(r, r, r, r)
+//C_O2_I4(r, r, r, r, r, r)
+
+// Vector functions.
+C_O1_I1(w, w)
+C_O1_I1(w, r)
+C_O0_I2(w, r)
+C_O1_I1(w, wr)
+C_O1_I2(w, w, w)
+C_O1_I3(w, w, w, w)
+C_O1_I2(w, 0, w)
\ No newline at end of file
diff --git a/tcg/aarch64-tcti/tcg-target-con-str.h b/tcg/aarch64-tcti/tcg-target-con-str.h
index 87c0f19e9c2e..94d06d3e74a5 100644
--- a/tcg/aarch64-tcti/tcg-target-con-str.h
+++ b/tcg/aarch64-tcti/tcg-target-con-str.h
@@ -8,4 +8,13 @@
  * Define constraint letters for register sets:
  * REGS(letter, register_mask)
  */
-REGS('r', MAKE_64BIT_MASK(0, TCG_TARGET_NB_REGS))
+REGS('r', TCG_MASK_GP_REGISTERS)
+REGS('w', TCG_MASK_VECTOR_REGISTERS)
+
+/*
+ * Define constraint letters for constants:
+ * CONST(letter, TCG_CT_CONST_* bit set)
+ */
+
+// Simple 64-bit immediates.
+CONST('I', 0xFFFFFFFFFFFFFFFF)
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index e6020ce59671..9852650ca6fe 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -24,7 +24,7 @@
 
 
 // Rich disassembly is nice in theory, but it's -slow-.
-#define TCTI_GADGET_RICH_DISASSEMBLY
+//#define TCTI_GADGET_RICH_DISASSEMBLY
 
 #define TCTI_GADGET_IMMEDIATE_ARRAY_LEN 64
 
@@ -49,97 +49,15 @@
 # define tcti_assert(cond) ((void)0)
 #endif
 
-/* Bitfield n...m (in 32 bit value). */
-#define BITS(n, m) (((0xffffffffU << (31 - n)) >> (31 - n + m)) << m)
-
-/**
- * Macro that defines a look-up tree for named QEMU_LD gadgets.
- */
-#define LD_MEMOP_LOOKUP(variable, arg, suffix) \
-    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
-        case MO_UB:   variable = gadget_qemu_ld_ub_   ## suffix; break; \
-        case MO_SB:   variable = gadget_qemu_ld_sb_   ## suffix; break; \
-        case MO_LEUW: variable = gadget_qemu_ld_leuw_ ## suffix; break; \
-        case MO_LESW: variable = gadget_qemu_ld_lesw_ ## suffix; break; \
-        case MO_LEUL: variable = gadget_qemu_ld_leul_ ## suffix; break; \
-        case MO_LESL: variable = gadget_qemu_ld_lesl_ ## suffix; break; \
-        case MO_LEQ:  variable = gadget_qemu_ld_leq_  ## suffix; break; \
-        case MO_BEUW: variable = gadget_qemu_ld_beuw_ ## suffix; break; \
-        case MO_BESW: variable = gadget_qemu_ld_besw_ ## suffix; break; \
-        case MO_BEUL: variable = gadget_qemu_ld_beul_ ## suffix; break; \
-        case MO_BESL: variable = gadget_qemu_ld_besl_ ## suffix; break; \
-        case MO_BEQ:  variable = gadget_qemu_ld_beq_  ## suffix; break; \
-        default: \
-            g_assert_not_reached(); \
-    }
-#define LD_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
-        if (a_bits >= s_bits) { \
-            LD_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
-        } else { \
-            LD_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
-        }
-
-
-
-/**
- * Macro that defines a look-up tree for named QEMU_ST gadgets.
- */
-#define ST_MEMOP_LOOKUP(variable, arg, suffix) \
-    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
-        case MO_UB:   variable = gadget_qemu_st_ub_   ## suffix; break; \
-        case MO_LEUW: variable = gadget_qemu_st_leuw_ ## suffix; break; \
-        case MO_LEUL: variable = gadget_qemu_st_leul_ ## suffix; break; \
-        case MO_LEQ:  variable = gadget_qemu_st_leq_  ## suffix; break; \
-        case MO_BEUW: variable = gadget_qemu_st_beuw_ ## suffix; break; \
-        case MO_BEUL: variable = gadget_qemu_st_beul_ ## suffix; break; \
-        case MO_BEQ:  variable = gadget_qemu_st_beq_  ## suffix; break; \
-        default: \
-            g_assert_not_reached(); \
-    }
-#define ST_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
-        if (a_bits >= s_bits) { \
-            ST_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
-        } else { \
-            ST_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
-        }
-
-
-#define LOOKUP_SPECIAL_CASE_LDST_GADGET(arg, name, mode) \
-    switch(TLB_MASK_TABLE_OFS(get_mmuidx(arg))) { \
-        case -32:  \
-            gadget = (a_bits >= s_bits) ?  \
-                gadget_qemu_ ## name ## _aligned_ ## mode ## _off32_i64 : \
-                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off32_i64; \
-            break; \
-        case -48:  \
-            gadget = (a_bits >= s_bits) ?  \
-                gadget_qemu_ ## name ## _aligned_ ## mode ## _off48_i64 : \
-                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off48_i64; \
-            break; \
-        case -64: \
-            gadget = (a_bits >= s_bits) ? \
-                gadget_qemu_ ## name ## _aligned_ ## mode ## _off64_i64 : \
-                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off64_i64; \
-            break; \
-        case -96: \
-            gadget = (a_bits >= s_bits) ? \
-                gadget_qemu_ ## name ## _aligned_ ## mode ## _off96_i64 : \
-                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off96_i64; \
-            break; \
-        case -128: \
-            gadget = (a_bits >= s_bits) ? \
-                gadget_qemu_ ## name ## _aligned_ ## mode ## _off128_i64 : \
-                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off128_i64; \
-            break;\
-        default: \
-            gadget = gadget_qemu_ ## name ## _slowpath_ ## mode ## _off0_i64; \
-            break; \
-        }
 
+/********************************
+ *  TCG Constraints Definitions *
+ ********************************/
 
 static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
 {
     switch (op) {
+
     case INDEX_op_ld8u_i32:
     case INDEX_op_ld8s_i32:
     case INDEX_op_ld16u_i32:
@@ -245,12 +163,67 @@ static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
     case INDEX_op_qemu_st_i64:
         return C_O0_I3(r, r, r);
 
+    //
+    // Vector ops.
+    //
+    case INDEX_op_add_vec:
+    case INDEX_op_sub_vec:
+    case INDEX_op_mul_vec:
+    case INDEX_op_xor_vec:
+    case INDEX_op_ssadd_vec:
+    case INDEX_op_sssub_vec:
+    case INDEX_op_usadd_vec:
+    case INDEX_op_ussub_vec:
+    case INDEX_op_smax_vec:
+    case INDEX_op_smin_vec:
+    case INDEX_op_umax_vec:
+    case INDEX_op_umin_vec:
+    case INDEX_op_shlv_vec:
+    case INDEX_op_shrv_vec:
+    case INDEX_op_sarv_vec:
+    case INDEX_op_aa64_sshl_vec:
+        return C_O1_I2(w, w, w);
+    case INDEX_op_not_vec:
+    case INDEX_op_neg_vec:
+    case INDEX_op_abs_vec:
+    case INDEX_op_shli_vec:
+    case INDEX_op_shri_vec:
+    case INDEX_op_sari_vec:
+        return C_O1_I1(w, w);
+    case INDEX_op_ld_vec:
+    case INDEX_op_dupm_vec:
+        return C_O1_I1(w, r);
+    case INDEX_op_st_vec:
+        return C_O0_I2(w, r);
+    case INDEX_op_dup_vec:
+        return C_O1_I1(w, wr);
+    case INDEX_op_or_vec:
+    case INDEX_op_andc_vec:
+        return C_O1_I2(w, w, w);
+    case INDEX_op_and_vec:
+    case INDEX_op_orc_vec:
+        return C_O1_I2(w, w, w);
+    case INDEX_op_cmp_vec:
+        return C_O1_I2(w, w, w);
+    case INDEX_op_bitsel_vec:
+        return C_O1_I3(w, w, w, w);
+    case INDEX_op_aa64_sli_vec:
+        return C_O1_I2(w, 0, w);
+
     default:
         g_assert_not_reached();
     }
 }
 
 static const int tcg_target_reg_alloc_order[] = {
+
+    // General purpose registers, in preference-of-allocation order.
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
     TCG_REG_R0,
     TCG_REG_R1,
     TCG_REG_R2,
@@ -259,16 +232,15 @@ static const int tcg_target_reg_alloc_order[] = {
     TCG_REG_R5,
     TCG_REG_R6,
     TCG_REG_R7,
-    TCG_REG_R8,
-    TCG_REG_R9,
-    TCG_REG_R10,
-    TCG_REG_R11,
-    TCG_REG_R12,
-    TCG_REG_R13,
-    /*
-    TCG_REG_R14,  // AREG0
-    TCG_REG_R15,  // SP
-    */
+
+    // Note: we do not allocate R14 or R15, as they're used for our
+    // special-purpose values.
+
+    // We'll use the high 16 vector register; avoiding the call-saved lower ones.
+    TCG_REG_V16, TCG_REG_V17, TCG_REG_V18, TCG_REG_V19,
+    TCG_REG_V20, TCG_REG_V21, TCG_REG_V22, TCG_REG_V23,
+    TCG_REG_V24, TCG_REG_V25, TCG_REG_V26, TCG_REG_V27,
+    TCG_REG_V28, TCG_REG_V29, TCG_REG_V30, TCG_REG_V31,
 };
 
 #if MAX_OPC_PARAM_IARGS != 6
@@ -289,7 +261,7 @@ static const int tcg_target_call_oarg_regs[] = {
 };
 
 #ifdef CONFIG_DEBUG_TCG
-static const char *const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {
+static const char *const tcg_target_reg_names[TCG_TARGET_GP_REGS] = {
     "r00",
     "r01",
     "r02",
@@ -309,6 +281,98 @@ static const char *const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {
 };
 #endif
 
+/*************************
+ *  TCG Emitter Helpers  *
+ *************************/
+
+/* Bitfield n...m (in 32 bit value). */
+#define BITS(n, m) (((0xffffffffU << (31 - n)) >> (31 - n + m)) << m)
+
+/**
+ * Macro that defines a look-up tree for named QEMU_LD gadgets.
+ */
+#define LD_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_ld_ub_   ## suffix; break; \
+        case MO_SB:   variable = gadget_qemu_ld_sb_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_ld_leuw_ ## suffix; break; \
+        case MO_LESW: variable = gadget_qemu_ld_lesw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_ld_leul_ ## suffix; break; \
+        case MO_LESL: variable = gadget_qemu_ld_lesl_ ## suffix; break; \
+        case MO_LEQ:  variable = gadget_qemu_ld_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_ld_beuw_ ## suffix; break; \
+        case MO_BESW: variable = gadget_qemu_ld_besw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_ld_beul_ ## suffix; break; \
+        case MO_BESL: variable = gadget_qemu_ld_besl_ ## suffix; break; \
+        case MO_BEQ:  variable = gadget_qemu_ld_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define LD_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            LD_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            LD_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+
+/**
+ * Macro that defines a look-up tree for named QEMU_ST gadgets.
+ */
+#define ST_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_st_ub_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_st_leuw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_st_leul_ ## suffix; break; \
+        case MO_LEQ:  variable = gadget_qemu_st_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_st_beuw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_st_beul_ ## suffix; break; \
+        case MO_BEQ:  variable = gadget_qemu_st_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define ST_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            ST_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            ST_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+#define LOOKUP_SPECIAL_CASE_LDST_GADGET(arg, name, mode) \
+    switch(TLB_MASK_TABLE_OFS(get_mmuidx(arg))) { \
+        case -32:  \
+            gadget = (a_bits >= s_bits) ?  \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off32_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off32_i64; \
+            break; \
+        case -48:  \
+            gadget = (a_bits >= s_bits) ?  \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off48_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off48_i64; \
+            break; \
+        case -64: \
+            gadget = (a_bits >= s_bits) ? \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off64_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off64_i64; \
+            break; \
+        case -96: \
+            gadget = (a_bits >= s_bits) ? \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off96_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off96_i64; \
+            break; \
+        case -128: \
+            gadget = (a_bits >= s_bits) ? \
+                gadget_qemu_ ## name ## _aligned_ ## mode ## _off128_i64 : \
+                gadget_qemu_ ## name ## _unaligned_ ## mode ## _off128_i64; \
+            break;\
+        default: \
+            gadget = gadget_qemu_ ## name ## _slowpath_ ## mode ## _off0_i64; \
+            break; \
+        }
+
+
 static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
@@ -404,7 +468,7 @@ tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr,
 
 
 /* Write gadget pointer. */
-static void tcg_out_nullary_gadget(TCGContext *s, const void *gadget)
+static void tcg_out_gadget(TCGContext *s, const void *gadget)
 {
     tcg_out_immediate(s, (tcg_target_ulong)gadget);
 }
@@ -412,40 +476,43 @@ static void tcg_out_nullary_gadget(TCGContext *s, const void *gadget)
 /* Write gadget pointer, plus 64b immediate. */
 static void tcg_out_imm64_gadget(TCGContext *s, const void *gadget, tcg_target_ulong immediate)
 {
-    tcg_out_nullary_gadget(s, gadget);
+    tcg_out_gadget(s, gadget);
     tcg_out64(s, immediate);
 }
 
 
 /* Write gadget pointer (one register). */
-static void tcg_out_unary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_NB_REGS], unsigned reg0)
+static void tcg_out_unary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_GP_REGS], unsigned reg0)
 {
-    tcg_out_nullary_gadget(s, gadget_base[reg0]);
+    tcg_out_gadget(s, gadget_base[reg0]);
 }
 
 
 /* Write gadget pointer (two registers). */
-static void tcg_out_binary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1)
+static void tcg_out_binary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_GP_REGS][TCG_TARGET_GP_REGS], unsigned reg0, unsigned reg1)
 {
-    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1]);
+    tcg_out_gadget(s, gadget_base[reg0][reg1]);
 }
 
 
 /* Write gadget pointer (three registers). */
-static void tcg_out_ternary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1, unsigned reg2)
+static void tcg_out_ternary_gadget(TCGContext *s, const void *gadget_base[TCG_TARGET_GP_REGS][TCG_TARGET_GP_REGS][TCG_TARGET_GP_REGS], unsigned reg0, unsigned reg1, unsigned reg2)
 {
-    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1][reg2]);
+    tcg_out_gadget(s, gadget_base[reg0][reg1][reg2]);
 }
 
+/***************************
+ *  TCG Scalar Operations  *
+ ***************************/
 
 /**
  * Version of our LDST generator that defers to more optimized gadgets selectively.
  */
 static void tcg_out_ldst_gadget_inner(TCGContext *s,
-    const void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS],
-    const void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
-    const void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
-    const void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
+    const void *gadget_base[TCG_TARGET_GP_REGS][TCG_TARGET_GP_REGS],
+    const void *gadget_pos_imm[TCG_TARGET_GP_REGS][TCG_TARGET_GP_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
+    const void *gadget_shifted_imm[TCG_TARGET_GP_REGS][TCG_TARGET_GP_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
+    const void *gadget_neg_imm[TCG_TARGET_GP_REGS][TCG_TARGET_GP_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN],
     unsigned reg0, unsigned reg1, uint32_t offset)
 {
     int64_t extended_offset = (int32_t)offset;
@@ -466,14 +533,14 @@ static void tcg_out_ldst_gadget_inner(TCGContext *s,
 
         // More optimal case: we have a gadget that directly encodes the argument.
         if (have_optimized_gadget) {
-            tcg_out_nullary_gadget(s, gadget_pos_imm[reg0][reg1][extended_offset]);
+            tcg_out_gadget(s, gadget_pos_imm[reg0][reg1][extended_offset]);
             return;
         }
 
         // Special case: it's frequent to have low-numbered positive offsets that are aligned
         // to 16B boundaries
         else if(aligned_to_8B && have_shifted_gadget) {
-            tcg_out_nullary_gadget(s, gadget_shifted_imm[reg0][reg1][shifted_offset]);
+            tcg_out_gadget(s, gadget_shifted_imm[reg0][reg1][shifted_offset]);
             return;
         }
     }
@@ -482,7 +549,7 @@ static void tcg_out_ldst_gadget_inner(TCGContext *s,
 
         // More optimal case: we have a gadget that directly encodes the argument.
         if (negated_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN) {
-            tcg_out_nullary_gadget(s, gadget_neg_imm[reg0][reg1][negated_offset]);
+            tcg_out_gadget(s, gadget_neg_imm[reg0][reg1][negated_offset]);
             return;
         }
     }
@@ -542,7 +609,7 @@ static void tcg_out_movi_i32(TCGContext *s, TCGReg t0, tcg_target_long arg)
     {
         // More optimal case: we have a gadget that directly encodes the argument.
         if (arg < ARRAY_SIZE(gadget_movi_imm_i32[t0])) {
-            tcg_out_nullary_gadget(s, gadget_movi_imm_i32[t0][arg]);
+            tcg_out_gadget(s, gadget_movi_imm_i32[t0][arg]);
             return;
         }
     }
@@ -566,7 +633,7 @@ static void tcg_out_movi_i64(TCGContext *s, TCGReg t0, tcg_target_long arg)
     {
         // More optimal case: we have a gadget that directly encodes the argument.
         if (arg < ARRAY_SIZE(gadget_movi_imm_i64[t0])) {
-            tcg_out_nullary_gadget(s, gadget_movi_imm_i64[t0][arg]);
+            tcg_out_gadget(s, gadget_movi_imm_i64[t0][arg]);
             return;
         }
     }
@@ -599,7 +666,7 @@ static void tcg_out_movi(TCGContext *s, TCGType type, TCGReg t0, tcg_target_long
  */
 static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
 {
-    tcg_out_nullary_gadget(s, gadget_call);
+    tcg_out_gadget(s, gadget_call);
     tcg_out64(s, (uintptr_t)arg);
 }
 
@@ -618,12 +685,6 @@ static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,
 }
 
 
-static void warn_slow_memop(const TCGArg arg)
-{
-    fprintf(stderr, "--- NOTE: emitting non-optimized memop at offset %i\n", TLB_MASK_TABLE_OFS(get_mmuidx(arg)));
-}
-
-
 /**
  * Generate every other operation.
  */
@@ -645,7 +706,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         // to patch our gadget stream with the target address, later.
         if (s->tb_jmp_insn_offset) {
             // Emit our gadget.
-            tcg_out_nullary_gadget(s, gadget_br);
+            tcg_out_gadget(s, gadget_br);
 
             // Place our current instruction into our "relocation table", so it can
             // be patched once we know where the branch will target...
@@ -664,7 +725,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
 
     // Simple branch.
     case INDEX_op_br:
-        tcg_out_nullary_gadget(s, gadget_br);
+        tcg_out_gadget(s, gadget_br);
         tcti_out_label(s, arg_label(args[0]));
         break;
 
@@ -959,7 +1020,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         // helps the processor's branch prediction be less "squished", as not every
         // branch is going throuh the same instruction.
         tcg_out_ternary_gadget(s, gadget, last_brcond_i64, args[0], args[1]);
-        last_brcond_i64 = (last_brcond_i64 + 1) % TCG_TARGET_NB_REGS;
+        last_brcond_i64 = (last_brcond_i64 + 1) % TCG_TARGET_GP_REGS;
 
         // Branch target immediate.
         tcti_out_label(s, arg_label(args[3]));
@@ -1099,7 +1160,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
         // helps the processor's branch prediction be less "squished", as not every
         // branch is going throuh the same instruction.
         tcg_out_ternary_gadget(s, gadget, last_brcond_i32, args[0], args[1]);
-        last_brcond_i32 = (last_brcond_i32 + 1) % TCG_TARGET_NB_REGS;
+        last_brcond_i32 = (last_brcond_i32 + 1) % TCG_TARGET_GP_REGS;
 
         // Branch target immediate.
         tcti_out_label(s, arg_label(args[3]));
@@ -1121,7 +1182,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
             case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
             case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
             case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
-            default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); warn_slow_memop(args[2]); break;
+            default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
         }
 
         // Args:
@@ -1159,7 +1220,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
                 case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
                 case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
                 case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
-                default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); warn_slow_memop(args[2]); break;
+                default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
             }
 
             // Args:
@@ -1185,7 +1246,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
             case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
             case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
             case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
-            default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); warn_slow_memop(args[2]); break;
+            default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
         }
 
         // Args:
@@ -1224,7 +1285,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
                 case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
                 case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
                 case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
-                default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); warn_slow_memop(args[2]); break;
+                default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
             }
 
             // Args:
@@ -1247,7 +1308,7 @@ void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *con
             [TCG_MO_LD_ST]                = gadget_mb_ld,
             [TCG_MO_LD_ST | TCG_MO_LD_LD] = gadget_mb_ld,
         };
-        tcg_out_nullary_gadget(s, sync[args[0] & TCG_MO_ALL]);
+        tcg_out_gadget(s, sync[args[0] & TCG_MO_ALL]);
 
         break;
     }
@@ -1287,19 +1348,630 @@ static int tcg_target_const_match(tcg_target_long val, TCGType type,
     return arg_ct->ct & TCG_CT_CONST;
 }
 
+/***************************
+ *  TCG Vector Operations  *
+ ***************************/
+
+//
+// Helper for emitting DUPI (immediate DUP) instructions.
+//
+#define tcg_out_dupi_gadget(s, name, q, rd, op, cmode, arg) \
+    if (q) { \
+        tcg_out_gadget(s, gadget_ ## name ## _cmode_ ## cmode ## _op ## op ## _q1[rd][arg]); \
+    } else { \
+        tcg_out_gadget(s, gadget_ ## name ## _cmode_ ## cmode ## _op ## op ## _q0[rd][arg]); \
+    }
+
+
+//
+// Helpers for emitting D/Q variant instructions.
+//
+#define tcg_out_dq_gadget(s, name, arity, is_q, args...) \
+    if (is_q) { \
+        tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _q, args); \
+    } else { \
+        tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _d, args); \
+    }
+
+#define tcg_out_unary_dq_gadget(s, name, is_q, a) \
+    tcg_out_dq_gadget(s, name, unary, is_q, a) 
+#define tcg_out_binary_dq_gadget(s, name, is_q, a, b) \
+    tcg_out_dq_gadget(s, name, binary, is_q, a, b)
+#define tcg_out_ternary_dq_gadget(s, name, is_q, a, b, c) \
+    tcg_out_dq_gadget(s, name, ternary, is_q, a, b, c)
+
+
+//
+// Helper for emitting the gadget appropriate for a vector's size.
+//
+#define tcg_out_sized_vector_gadget(s, name, arity, vece, args...) \
+    switch(vece) { \
+        case MO_8: \
+            if (type == TCG_TYPE_V64) { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _8b, args); \
+            } else { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _16b, args); \
+            } \
+            break; \
+        case MO_16: \
+            if (type == TCG_TYPE_V64) { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _4h, args); \
+            } else { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _8h, args); \
+            } \
+            break; \
+        case MO_32: \
+            if (type == TCG_TYPE_V64) { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _2s, args); \
+            } else { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _4s, args); \
+            } \
+            break; \
+        case MO_64: \
+            if (type == TCG_TYPE_V128) { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _2d, args); \
+            } \
+            else { \
+                g_assert_not_reached(); \
+            } \
+            break;  \
+        default: \
+            g_assert_not_reached(); \
+    } 
+#define tcg_out_sized_vector_gadget_no64(s, name, arity, vece, args...) \
+    switch(vece) { \
+        case MO_8: \
+            if (type == TCG_TYPE_V64) { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _8b, args); \
+            } else { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _16b, args); \
+            } \
+            break; \
+        case MO_16: \
+            if (type == TCG_TYPE_V64) { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _4h, args); \
+            } else { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _8h, args); \
+            } \
+            break; \
+        case MO_32: \
+            if (type == TCG_TYPE_V64) { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _2s, args); \
+            } else { \
+                tcg_out_ ## arity ## _gadget(s, gadget_ ## name ## _4s, args); \
+            } \
+            break; \
+        default: \
+            g_assert_not_reached(); \
+    } 
+
+
+#define tcg_out_unary_vector_gadget(s, name, vece, a) \
+    tcg_out_sized_vector_gadget(s, name, unary, vece, a)
+#define tcg_out_binary_vector_gadget(s, name, vece, a, b) \
+    tcg_out_sized_vector_gadget(s, name, binary, vece, a, b)
+#define tcg_out_ternary_vector_gadget(s, name, vece, a, b, c) \
+    tcg_out_sized_vector_gadget(s, name, ternary, vece, a, b, c)
+
+#define tcg_out_ternary_vector_gadget_no64(s, name, vece, a, b, c) \
+    tcg_out_sized_vector_gadget_no64(s, name, ternary, vece, a, b, c)
+
+
+#define tcg_out_ternary_vector_gadget_with_scalar(s, name, is_scalar, vece, a, b, c) \
+    if (is_scalar) { \
+        tcg_out_ternary_gadget(s, gadget_ ## name ## _scalar, w0, w1, w2); \
+    } else { \
+        tcg_out_ternary_vector_gadget(s, name, vece, w0, w1, w2); \
+    }
+
+
+/* Return true if v16 is a valid 16-bit shifted immediate.  */
+/*
+static bool is_shimm16(uint16_t v16, int *cmode, int *imm8)
+{
+    if (v16 == (v16 & 0xff)) {
+        *cmode = 0x8;
+        *imm8 = v16 & 0xff;
+        return true;
+    } else if (v16 == (v16 & 0xff00)) {
+        *cmode = 0xa;
+        *imm8 = v16 >> 8;
+        return true;
+    }
+    return false;
+}
+*/
+
+/* Return true if v64 is a valid float64 immediate.  */
+/*
+static bool is_fimm64(uint64_t v64, int *cmode, int *imm8)
+{
+    if (extract64(v64, 0, 48) == 0
+        && (extract64(v64, 54, 9) == 0x100
+            || extract64(v64, 54, 9) == 0x0ff)) {
+        *cmode = 0xf;
+        *imm8 = (extract64(v64, 63, 1) << 7)
+              | (extract64(v64, 54, 1) << 6)
+              | extract64(v64, 48, 6);
+        return true;
+    }
+    return false;
+}
+*/
+
+/** Core vector operation emission. */
+static void tcg_out_vec_op(TCGContext *s, TCGOpcode opc, unsigned vecl, unsigned vece,
+    const TCGArg args[TCG_MAX_OP_ARGS], const int const_args[TCG_MAX_OP_ARGS])
+{
+    TCGType type = vecl + TCG_TYPE_V64;
+    TCGArg r0, r1, r2, w0, w1, w2;
+
+    // Typing flags for vector operations.
+    bool is_v128 = (type == TCG_TYPE_V128);
+    bool is_scalar = !is_v128 && (vece == MO_64);
+
+    // Argument shortcuts.
+    r0 = args[0];
+    r1 = args[1];
+    r2 = args[2];
+
+    // Offset argument shortcuts; offset to convert register numbers to gadget numberes.
+    w0 = args[0] - TCG_REG_V16;
+    w1 = args[1] - TCG_REG_V16;
+    w2 = args[2] - TCG_REG_V16;
+
+    // Argument shortcuts, as signed.
+    int64_t signed_offset_arg = (int32_t)args[2];
+
+    switch (opc) {
+
+    // Load memory -> vector: followed by a 64-bit offset immediate
+    case INDEX_op_ld_vec:
+        tcg_out_binary_dq_gadget(s, ldr, is_v128, w0, r1);
+        tcg_out64(s, signed_offset_arg);
+        break;
+    
+    // Store memory -> vector: followed by a 64-bit offset immediate
+    case INDEX_op_st_vec:
+        tcg_out_binary_dq_gadget(s, str, is_v128, w0, r1);
+        tcg_out64(s, signed_offset_arg);
+        break;
+
+    // Duplciate memory to all vector elements.
+    case INDEX_op_dupm_vec:
+        // DUPM handles normalization itself; pass arguments raw.
+        tcg_out_dupm_vec(s, type, vece, r0, r1, r2);
+        break;
+
+    case INDEX_op_add_vec:
+        tcg_out_ternary_vector_gadget_with_scalar(s, add, is_scalar, vece, w0, w1, w2);
+        break;
+
+    case INDEX_op_sub_vec:
+        tcg_out_ternary_vector_gadget_with_scalar(s, sub, is_scalar, vece, w0, w1, w2);
+        break;
+
+    case INDEX_op_mul_vec: // optional
+        tcg_out_ternary_vector_gadget_no64(s, mul, vece, w0, w1, w2);
+        break;
+
+    case INDEX_op_neg_vec: // optional
+        tcg_out_binary_vector_gadget(s, neg, vece, w0, w1);
+        break;
+
+    case INDEX_op_abs_vec: // optional
+        tcg_out_binary_vector_gadget(s, abs, vece, w0, w1);
+        break;
+
+    case INDEX_op_and_vec: // optional
+        tcg_out_ternary_dq_gadget(s, and, is_v128, w0, w1, w2);
+        break;
+
+    case INDEX_op_or_vec:
+        tcg_out_ternary_dq_gadget(s, or, is_v128, w0, w1, w2);
+        break;
+
+    case INDEX_op_andc_vec:
+        tcg_out_ternary_dq_gadget(s, andc, is_v128, w0, w1, w2);
+        break;
+
+    case INDEX_op_orc_vec: // optional
+        tcg_out_ternary_dq_gadget(s, orc, is_v128, w0, w1, w2);
+        break;
+
+    case INDEX_op_xor_vec:
+        tcg_out_ternary_dq_gadget(s, xor, is_v128, w0, w1, w2);
+        break;
+
+    case INDEX_op_ssadd_vec:
+        tcg_out_ternary_vector_gadget_with_scalar(s, ssadd, is_scalar, vece, w0, w1, w2);
+        break;
+
+    case INDEX_op_sssub_vec:
+        tcg_out_ternary_vector_gadget_with_scalar(s, sssub, is_scalar, vece, w0, w1, w2);
+        break;
+
+    case INDEX_op_usadd_vec:
+        tcg_out_ternary_vector_gadget_with_scalar(s, usadd, is_scalar, vece, w0, w1, w2);
+        break;
+
+    case INDEX_op_ussub_vec:
+        tcg_out_ternary_vector_gadget_with_scalar(s, ussub, is_scalar, vece, w0, w1, w2);
+        break;
+
+    case INDEX_op_smax_vec:
+        TODO();
+        break;
+
+    case INDEX_op_smin_vec:
+        TODO();
+        break;
+
+    case INDEX_op_umax_vec:
+        TODO();
+        break;
+
+    case INDEX_op_umin_vec:
+        TODO();
+        break;
+
+    case INDEX_op_not_vec: // optional
+        tcg_out_binary_dq_gadget(s, not, is_v128, w0, w1);
+        break;
+
+    case INDEX_op_shli_vec:
+        TODO();
+        break;
+
+    case INDEX_op_shri_vec:
+        TODO();
+        break;
+
+    case INDEX_op_sari_vec:
+        TODO();
+        break;
+
+    case INDEX_op_aa64_sli_vec:
+        TODO();
+        break;
+    case INDEX_op_shlv_vec:
+        TODO();
+        break;
+    case INDEX_op_aa64_sshl_vec:
+        TODO();
+        break;
+    case INDEX_op_cmp_vec:
+        TODO();
+        break;
+    case INDEX_op_bitsel_vec: // optional
+        TODO();
+        break;
+
+    case INDEX_op_mov_vec:  /* Always emitted via tcg_out_mov.  */
+    case INDEX_op_dup_vec:  /* Always emitted via tcg_out_dup_vec.  */
+    default:
+        g_assert_not_reached();
+    }
+}
+
+
+int tcg_can_emit_vec_op(TCGOpcode opc, TCGType type, unsigned vece)
+{
+    switch (opc) {
+    case INDEX_op_add_vec:
+    case INDEX_op_sub_vec:
+    case INDEX_op_and_vec:
+    case INDEX_op_or_vec:
+    case INDEX_op_xor_vec:
+    case INDEX_op_andc_vec:
+    case INDEX_op_orc_vec:
+    case INDEX_op_neg_vec:
+    case INDEX_op_abs_vec:
+    case INDEX_op_not_vec:
+    //case INDEX_op_cmp_vec:
+    //case INDEX_op_shli_vec:
+    //case INDEX_op_shri_vec:
+    //case INDEX_op_sari_vec:
+    case INDEX_op_ssadd_vec:
+    case INDEX_op_sssub_vec:
+    case INDEX_op_usadd_vec:
+    case INDEX_op_ussub_vec:
+    //case INDEX_op_shlv_vec:
+    //case INDEX_op_bitsel_vec:
+        return 1;
+    case INDEX_op_rotli_vec:
+    case INDEX_op_shrv_vec:
+    case INDEX_op_sarv_vec:
+    case INDEX_op_rotlv_vec:
+    case INDEX_op_rotrv_vec:
+        return -1;
+    case INDEX_op_mul_vec:
+    //case INDEX_op_smax_vec:
+    //case INDEX_op_smin_vec:
+    //case INDEX_op_umax_vec:
+    //case INDEX_op_umin_vec:
+        return vece < MO_64;
+
+    default:
+        return 0;
+    }
+}
+
+void tcg_expand_vec_op(TCGOpcode opc, TCGType type, unsigned vece,
+                       TCGArg a0, ...)
+{
+    va_list va;
+    TCGv_vec v0, v1, v2, t1, t2, c1;
+    TCGArg a2;
+
+
+    va_start(va, a0);
+    v0 = temp_tcgv_vec(arg_temp(a0));
+    v1 = temp_tcgv_vec(arg_temp(va_arg(va, TCGArg)));
+    a2 = va_arg(va, TCGArg);
+    va_end(va);
+
+    switch (opc) {
+    case INDEX_op_rotli_vec:
+        t1 = tcg_temp_new_vec(type);
+        tcg_gen_shri_vec(vece, t1, v1, -a2 & ((8 << vece) - 1));
+        vec_gen_4(INDEX_op_aa64_sli_vec, type, vece,
+                  tcgv_vec_arg(v0), tcgv_vec_arg(t1), tcgv_vec_arg(v1), a2);
+        tcg_temp_free_vec(t1);
+        break;
+
+    case INDEX_op_shrv_vec:
+    case INDEX_op_sarv_vec:
+        /* Right shifts are negative left shifts for AArch64.  */
+        v2 = temp_tcgv_vec(arg_temp(a2));
+        t1 = tcg_temp_new_vec(type);
+        tcg_gen_neg_vec(vece, t1, v2);
+        opc = (opc == INDEX_op_shrv_vec
+               ? INDEX_op_shlv_vec : INDEX_op_aa64_sshl_vec);
+        vec_gen_3(opc, type, vece, tcgv_vec_arg(v0),
+                  tcgv_vec_arg(v1), tcgv_vec_arg(t1));
+        tcg_temp_free_vec(t1);
+        break;
+
+    case INDEX_op_rotlv_vec:
+        v2 = temp_tcgv_vec(arg_temp(a2));
+        t1 = tcg_temp_new_vec(type);
+        c1 = tcg_constant_vec(type, vece, 8 << vece);
+        tcg_gen_sub_vec(vece, t1, v2, c1);
+        /* Right shifts are negative left shifts for AArch64.  */
+        vec_gen_3(INDEX_op_shlv_vec, type, vece, tcgv_vec_arg(t1),
+                  tcgv_vec_arg(v1), tcgv_vec_arg(t1));
+        vec_gen_3(INDEX_op_shlv_vec, type, vece, tcgv_vec_arg(v0),
+                  tcgv_vec_arg(v1), tcgv_vec_arg(v2));
+        tcg_gen_or_vec(vece, v0, v0, t1);
+        tcg_temp_free_vec(t1);
+        break;
+
+    case INDEX_op_rotrv_vec:
+        v2 = temp_tcgv_vec(arg_temp(a2));
+        t1 = tcg_temp_new_vec(type);
+        t2 = tcg_temp_new_vec(type);
+        c1 = tcg_constant_vec(type, vece, 8 << vece);
+        tcg_gen_neg_vec(vece, t1, v2);
+        tcg_gen_sub_vec(vece, t2, c1, v2);
+        /* Right shifts are negative left shifts for AArch64.  */
+        vec_gen_3(INDEX_op_shlv_vec, type, vece, tcgv_vec_arg(t1),
+                  tcgv_vec_arg(v1), tcgv_vec_arg(t1));
+        vec_gen_3(INDEX_op_shlv_vec, type, vece, tcgv_vec_arg(t2),
+                  tcgv_vec_arg(v1), tcgv_vec_arg(t2));
+        tcg_gen_or_vec(vece, v0, t1, t2);
+        tcg_temp_free_vec(t1);
+        tcg_temp_free_vec(t2);
+        break;
+
+    default:
+        g_assert_not_reached();
+    }
+}
+
+
+/* Generate DUPI (move immediate) vector ops. */
+/*
+static bool tcg_out_optimized_dupi_vec(TCGContext *s, TCGType type, unsigned vece, TCGReg rd, int64_t v64)
+{
+    bool is_v128 = (type == TCG_TYPE_V128);
+    int cmode, imm8, i;
+
+    // If we're copying an 8b immediate, we implicitly have a simple gadget for this,
+    // since there are only 256 possible values * 16 registers. Emit a MOVI gadget implicitly.
+    if (vece == MO_8) {
+        imm8 = (uint8_t)v64;
+        tcg_out_dupi_gadget(s, movi, q, rd, 0, e, imm8);
+        return true;
+    }
+
+    // Otherwise, if we have a value that's all 0x00 and 0xFF bytes,
+    // we can use the scalar variant of MOVI (op=1, cmode=e), which handles
+    // that case directly.
+    for (i = imm8 = 0; i < 8; i++) {
+        uint8_t byte = v64 >> (i * 8);
+        if (byte == 0xff) {
+            imm8 |= 1 << i;
+        } else if (byte != 0) {
+            goto fail_bytes;
+        }
+    }
+    tcg_out_dupi_gadget(s, movi, q, rd, 1, e, imm8);
+    return true;
+ fail_bytes:
+
+    // Handle 16B moves.
+    if (vece == MO_16) {
+        uint16_t v16 = v64;
+
+        // Check to see if we have a value representable in as a MOV imm8, possibly via a shift.
+        if (is_shimm16(v16, &cmode, &imm8)) {
+            // Output the corret instruction CMode for either a regular MOVI (8) or a LSL8 MOVI (a).
+            if (cmode == 0x8) {
+                tcg_out_dupi_gadget(s, movi, q, rd, 0, 8, imm8);
+            } else {
+                tcg_out_dupi_gadget(s, movi, q, rd, 0, a, imm8);
+            }
+            return true;
+        }
+
+        // Check to see if we have a value representable in as an inverted MOV imm8, possibly via a shift.
+        if (is_shimm16(~v16, &cmode, &imm8)) {
+            // Output the corret instruction CMode for either a regular MOVI (8) or a LSL8 MOVI (a).
+            if (cmode == 0x8) {
+                tcg_out_dupi_gadget(s, mvni, q, rd, 0, 8, imm8);
+            } else {
+                tcg_out_dupi_gadget(s, mvni, q, rd, 0, a, imm8);
+            }
+            return true;
+        }
+
+        // If we can't perform either of the optimizations, we'll need to do this in two steps.
+        // Normally, we'd emit a gadget for both steps, but in this case that'd result in needing -way-
+        // too many gadgets. We'll emit two, instead.
+        tcg_out_dupi_gadget(s, movi, q, rd, 0, 8, v16 & 0xff);
+        tcg_out_dupi_gadget(s, orr,  q, rd, 0, a, v16 >> 8);
+        return true;
+    }
+
+    // FIXME: implement 32B move optimizations
+
+     
+    // Try to create optimized 32B moves.
+    //else if (vece == MO_32) {
+    //    uint32_t v32 = v64;
+    //    uint32_t n32 = ~v32;
+
+    //    if (is_shimm32(v32, &cmode, &imm8) ||
+    //        is_soimm32(v32, &cmode, &imm8) ||
+    //        is_fimm32(v32, &cmode, &imm8)) {
+    //        tcg_out_insn(s, 3606, MOVI, q, rd, 0, cmode, imm8);
+    //        return;
+    //    }
+    //    if (is_shimm32(n32, &cmode, &imm8) ||
+    //        is_soimm32(n32, &cmode, &imm8)) {
+    //        tcg_out_insn(s, 3606, MVNI, q, rd, 0, cmode, imm8);
+    //        return;
+    //    }
+
+    //    //
+    //    // Restrict the set of constants to those we can load with
+    //    // two instructions.  Others we load from the pool.
+    //    //
+    //    i = is_shimm32_pair(v32, &cmode, &imm8);
+    //    if (i) {
+    //        tcg_out_insn(s, 3606, MOVI, q, rd, 0, cmode, imm8);
+    //        tcg_out_insn(s, 3606, ORR, q, rd, 0, i, extract32(v32, i * 4, 8));
+    //        return;
+    //    }
+    //    i = is_shimm32_pair(n32, &cmode, &imm8);
+    //    if (i) {
+    //        tcg_out_insn(s, 3606, MVNI, q, rd, 0, cmode, imm8);
+    //        tcg_out_insn(s, 3606, BIC, q, rd, 0, i, extract32(n32, i * 4, 8));
+    //        return;
+    //    }
+    //} 
+    
+    else if (is_fimm64(v64, &cmode, &imm8)) {
+        tcg_out_insn(s, 3606, MOVI, q, rd, 1, cmode, imm8);
+        return true;
+    }
+
+}
+*/
+
+/* Emits instructions that can load an immediate into a vector. */
+static void tcg_out_dupi_vec(TCGContext *s, TCGType type, unsigned vece, TCGReg rd, int64_t v64)
+{
+    // Convert Rd into a simple gadget number.
+    rd = rd - (TCG_REG_V16);
+
+    // First, try to create an optimized implementation, if possible.
+    /*
+    if (tcg_out_optimized_dupi_vec(s, type, vece, rd, v64)) {
+        return;
+    }
+    */
+
+    // If we didn't, we'll need to load the full vector from memory.
+    // Emit it into our bytecode stream as an immediate; which we'll then
+    // load inside the gadget.
+    if (type == TCG_TYPE_V128) {
+        tcg_out_unary_gadget(s, gadget_ldi_q, rd);
+        tcg_out64(s, v64);
+        tcg_out64(s, v64);
+    } else {
+        tcg_out_unary_gadget(s, gadget_ldi_d, rd);
+        tcg_out64(s, v64);
+    }
+}
+
+
+/* Emits instructions that can load a register into a vector. */
+static bool tcg_out_dup_vec(TCGContext *s, TCGType type, unsigned vece, TCGReg rd, TCGReg rs)
+{
+    // Compute the gadget index for the relevant vector register.
+    TCGReg wd = rd - (TCG_REG_V16);
+
+    // Emit a DUP gadget to handles the operation.
+    tcg_out_binary_vector_gadget(s, dup, vece, wd, rs);
+    return true;
+}
+
+static bool tcg_out_dupm_vec(TCGContext *s, TCGType type, unsigned vece, TCGReg r, TCGReg base, intptr_t offset)
+{
+    int64_t extended_offset = (int32_t)offset;
+
+    // Convert the register into a simple register number for our gadgets.
+    r = r - TCG_REG_V16;
+
+    // Emit a DUPM gadget...
+    tcg_out_binary_vector_gadget(s, dupm, vece, r, base);
+
+    // ... and emit its int64 immediate offset.
+    tcg_out64(s, extended_offset);
+
+    return true;
+}
+
+
+/********************************
+ *  TCG Runtime & Platform Def  *
+ *******************************/
+
 static void tcg_target_init(TCGContext *s)
 {
     /* The current code uses uint8_t for tcg operations. */
     tcg_debug_assert(tcg_op_defs_max <= UINT8_MAX);
 
-    /* Registers available for 32 bit operations. */
-    tcg_target_available_regs[TCG_TYPE_I32] = BIT(TCG_TARGET_NB_REGS) - 1;
-    /* Registers available for 64 bit operations. */
-    tcg_target_available_regs[TCG_TYPE_I64] = BIT(TCG_TARGET_NB_REGS) - 1;
-
-    /* TODO: Which registers should be set here? */
-    tcg_target_call_clobber_regs = BIT(TCG_TARGET_NB_REGS) - 1;
+    // Registers available for each type of operation.
+    tcg_target_available_regs[TCG_TYPE_I32]  = TCG_MASK_GP_REGISTERS;
+    tcg_target_available_regs[TCG_TYPE_I64]  = TCG_MASK_GP_REGISTERS;
+    tcg_target_available_regs[TCG_TYPE_V64]  = TCG_MASK_VECTOR_REGISTERS;
+    tcg_target_available_regs[TCG_TYPE_V128] = TCG_MASK_VECTOR_REGISTERS;
+
+    TCGReg unclobbered_registers[] = {
+        // We don't use registers R16+ in our runtime, so we'll not bother protecting them.
+        TCG_REG_R16, TCG_REG_R17, TCG_REG_R18, TCG_REG_R19,
+        TCG_REG_R20, TCG_REG_R21, TCG_REG_R22, TCG_REG_R23,
+        TCG_REG_R24, TCG_REG_R25, TCG_REG_R26, TCG_REG_R27,
+        TCG_REG_R28, TCG_REG_R29, TCG_REG_R30, TCG_REG_R31,
+
+        // Per our calling convention.
+        TCG_REG_V8,  TCG_REG_V9,  TCG_REG_V10, TCG_REG_V11,
+        TCG_REG_V12, TCG_REG_V13, TCG_REG_V14, TCG_REG_V15,
+   };
+
+    // Specify which registers are clobbered during call.
+    tcg_target_call_clobber_regs = -1ull;
+    for (unsigned i = 0; i < ARRAY_SIZE(unclobbered_registers); ++i) {
+        tcg_regset_reset_reg(tcg_target_call_clobber_regs, unclobbered_registers[i]);
+    }
 
+    // Specify which local registers we're reserving.
+    //
+    // Note that we only have to specify registers that are used in the runtime,
+    // and so not e.g. the register that contains AREG0, which can never be allocated.
     s->reserved_regs = 0;
     tcg_regset_set_reg(s->reserved_regs, TCG_REG_CALL_STACK);
 
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
index 7087321de68a..f48060dcbfeb 100644
--- a/tcg/aarch64-tcti/tcg-target.h
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -122,7 +122,26 @@
 // Supported optional vector instructions.
 //
 
-// TODO!
+#define TCG_TARGET_HAS_v64              1
+#define TCG_TARGET_HAS_v128             1
+#define TCG_TARGET_HAS_v256             0
+
+#define TCG_TARGET_HAS_andc_vec         1
+#define TCG_TARGET_HAS_orc_vec          1
+#define TCG_TARGET_HAS_not_vec          1
+#define TCG_TARGET_HAS_neg_vec          1
+#define TCG_TARGET_HAS_abs_vec          1
+#define TCG_TARGET_HAS_roti_vec         0
+#define TCG_TARGET_HAS_rots_vec         0
+#define TCG_TARGET_HAS_rotv_vec         0
+#define TCG_TARGET_HAS_shi_vec          1
+#define TCG_TARGET_HAS_shs_vec          0
+#define TCG_TARGET_HAS_shv_vec          1
+#define TCG_TARGET_HAS_mul_vec          1
+#define TCG_TARGET_HAS_sat_vec          1
+#define TCG_TARGET_HAS_minmax_vec       1
+#define TCG_TARGET_HAS_bitsel_vec       1
+#define TCG_TARGET_HAS_cmpsel_vec       0
 
 //
 // Unsupported instructions.
@@ -174,30 +193,48 @@
 //
 
 // Number of registers available.
-// It might make sense to up these, since we can also use x16 -> x25?
-#define TCG_TARGET_NB_REGS 16
+#define TCG_TARGET_NB_REGS 64
+
+// Number of general purpose registers.
+#define TCG_TARGET_GP_REGS 16
 
 /* List of registers which are used by TCG. */
 typedef enum {
-    TCG_REG_R0 = 0,
-    TCG_REG_R1,
-    TCG_REG_R2,
-    TCG_REG_R3,
-    TCG_REG_R4,
-    TCG_REG_R5,
-    TCG_REG_R6,
-    TCG_REG_R7,
-    TCG_REG_R8,
-    TCG_REG_R9,
-    TCG_REG_R10,
-    TCG_REG_R11,
-    TCG_REG_R12,
-    TCG_REG_R13,
-    TCG_REG_R14,
-    TCG_REG_R15,
-
-    TCG_AREG0          = TCG_REG_R14,
-    TCG_REG_CALL_STACK = TCG_REG_R15,
+
+    // General purpose registers.
+    // Note that we name every _host_ register here; but don't 
+    // necessarily use them; that's determined by the allocation order
+    // and the number of registers setting above. These just give us the ability
+    // to refer to these by name.
+    TCG_REG_R0, TCG_REG_R1, TCG_REG_R2, TCG_REG_R3,
+    TCG_REG_R4, TCG_REG_R5, TCG_REG_R6, TCG_REG_R7,
+    TCG_REG_R8, TCG_REG_R9, TCG_REG_R10, TCG_REG_R11,
+    TCG_REG_R12, TCG_REG_R13, TCG_REG_R14, TCG_REG_R15,
+    TCG_REG_R16, TCG_REG_R17, TCG_REG_R18, TCG_REG_R19,
+    TCG_REG_R20, TCG_REG_R21, TCG_REG_R22, TCG_REG_R23,
+    TCG_REG_R24, TCG_REG_R25, TCG_REG_R26, TCG_REG_R27,
+    TCG_REG_R28, TCG_REG_R29, TCG_REG_R30, TCG_REG_R31,
+
+    // Register aliases.
+    TCG_AREG0             = TCG_REG_R14,
+    TCG_REG_CALL_STACK    = TCG_REG_R15,
+
+    // Mask that refers to the GP registers.
+    TCG_MASK_GP_REGISTERS = 0xFFFFul, 
+
+    // Vector registers.
+    TCG_REG_V0 = 32, TCG_REG_V1, TCG_REG_V2, TCG_REG_V3,
+    TCG_REG_V4, TCG_REG_V5, TCG_REG_V6, TCG_REG_V7,
+    TCG_REG_V8, TCG_REG_V9, TCG_REG_V10, TCG_REG_V11,
+    TCG_REG_V12, TCG_REG_V13, TCG_REG_V14, TCG_REG_V15,
+    TCG_REG_V16, TCG_REG_V17, TCG_REG_V18, TCG_REG_V19,
+    TCG_REG_V20, TCG_REG_V21, TCG_REG_V22, TCG_REG_V23,
+    TCG_REG_V24, TCG_REG_V25, TCG_REG_V26, TCG_REG_V27,
+    TCG_REG_V28, TCG_REG_V29, TCG_REG_V30, TCG_REG_V31,
+
+    // Mask that refers to the vector registers.
+    TCG_MASK_VECTOR_REGISTERS = 0xFFFF000000000000ul, 
+
 } TCGReg;
 
 // Specify the shape of the stack our runtime will use.
diff --git a/tcg/aarch64-tcti/tcg-target.opc.h b/tcg/aarch64-tcti/tcg-target.opc.h
new file mode 100644
index 000000000000..bce30accd936
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target.opc.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) 2019 Linaro
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or
+ * (at your option) any later version.
+ *
+ * See the COPYING file in the top-level directory for details.
+ *
+ * Target-specific opcodes for host vector expansion.  These will be
+ * emitted by tcg_expand_vec_op.  For those familiar with GCC internals,
+ * consider these to be UNSPEC with names.
+ */
+
+DEF(aa64_sshl_vec, 1, 2, 0, IMPLVEC)
+DEF(aa64_sli_vec, 1, 2, 1, IMPLVEC)
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 0c0e575c4d24..17c76fd82f25 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -25,6 +25,9 @@
 # Helper that provides each of the AArch64 condition codes of interest.
 ARCH_CONDITION_CODES = ["eq", "ne", "lt", "ge", "le", "gt", "lo", "hs", "ls", "hi"]
 
+# The list of vector size codes supported on this platform.
+VECTOR_SIZES = ['16b', '8b', '4h', '8h', '2s', '4s', '2d']
+
 # We'll create a variety of gadgets that assume the MMU's TLB is stored at certain
 # offsets into its structure. These should match the offsets in tcg-target.c.in.
 QEMU_ALLOWED_MMU_OFFSETS = [ 32, 48, 64, 96, 128 ]
@@ -109,9 +112,30 @@ def simple(name, *lines, export=True):
     print("}\n", file=c_file)
 
 
+
+
+
+
+
 def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
     """ Generates a collection of gadgtes with register substitutions. """
 
+    def _expand_op1_immediate(num):
+        """ Gets a uncompressed bitfield argument for a given immediate; for NEON instructions. 
+        
+        Duplciates each bit eight times; converting 0b0100 to 0x00FF0000.
+        """
+
+        # Get the number as a binary string...
+        binstring = bin(num)[2:]
+
+        # ... expand out the values to hex...
+        hex_string = binstring.replace('1', 'FF').replace('0', '00') 
+
+        # ... and return out the new constant.
+        return f"0x{hex_string}"
+
+
     def substitutions_for_letter(letter, number, line):
         """ Helper that transforms Wd => w1, implementing gadget substitutions. """
 
@@ -119,8 +143,16 @@ def substitutions_for_letter(letter, number, line):
         line = line.replace(f"X{letter}", f"x{number}")
         line = line.replace(f"W{letter}", f"w{number}")
 
-        # ... immediate substitutions.
+        # ... vector register substitutions...
+        line = line.replace(f"V{letter}", f"v{number + 16}")
+        line = line.replace(f"D{letter}", f"d{number + 16}")
+        line = line.replace(f"Q{letter}", f"q{number + 16}")
+
+        # ... regular immediate substitutions...
         line = line.replace(f"I{letter}", f"{number}")
+
+        # ... and compressed immediate substitutions.
+        line = line.replace(f"S{letter}", f"{_expand_op1_immediate(number)}")
         return line
 
         
@@ -558,6 +590,63 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
             )
 
 
+
+def vector_dn(name, *lines):
+    """ Creates a set of gadgets for every size of a given vector op. Accepts 'S' as a size placeholder. """
+
+    def do_size_replacement(line, size):
+        line = line.replace(".S", f".{size}")
+        
+        # If this size requires a 32b register, replace Wd with Xd.
+        if size == "2d":
+            line = line.replace("Wn", "Xn")
+
+        return line
+
+
+    # Create a variant for each size, replacing any placeholders.
+    for size in VECTOR_SIZES:
+        sized_lines = (do_size_replacement(line, size) for line in lines)
+        with_dn(f"{name}_{size}", *sized_lines)
+
+
+def vector_dnm(name, *lines, scalar=None, omit_sizes=()):
+    """ Creates a set of gadgets for every size of a given vector op. Accepts 'S' as a size placeholder. """
+
+    def do_size_replacement(line, size):
+        return line.replace(".S", f".{size}")
+        
+    # Create a variant for each size, replacing any placeholders.
+    for size in VECTOR_SIZES:
+        if size in omit_sizes:
+            continue
+
+        sized_lines = (do_size_replacement(line, size) for line in lines)
+        with_dnm(f"{name}_{size}", *sized_lines)
+
+    if scalar:
+        if isinstance(scalar, str):
+            sized_lines = (scalar,)
+        with_dnm(f"{name}_scalar", *sized_lines)
+
+
+def vector_math_dnm(name, operation):
+    """ Generates a collection of gadgets for vector math instructions. """
+    vector_dnm(name, f"{operation} Vd.S, Vn.S, Vm.S", scalar=f"{operation} Dd, Dn, Dm")
+
+
+def vector_logic_dn(name, operation):
+    """ Generates a pair of gadgets for vector bitwise logic instructions. """
+    with_dn(f"{name}_d", f"{operation} Vd.8b, Vn.8b")
+    with_dn(f"{name}_q", f"{operation} Vd.16b, Vn.16b")
+
+
+def vector_logic_dnm(name, operation):
+    """ Generates a pair of gadgets for vector bitwise logic instructions. """
+    with_dnm(f"{name}_d", f"{operation} Vd.8b, Vn.8b, Vm.8b")
+    with_dnm(f"{name}_q", f"{operation} Vd.16b, Vn.16b, Vm.16b")
+
+
 #
 # Gadget definitions.
 #
@@ -953,6 +1042,86 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
             is_aligned=is_aligned, force_slowpath=is_slowpath)
 
 
+#
+# SIMD/Vector ops
+#
+
+# SIMD MOVI instructions.
+START_COLLECTION(f"simd_base")
+
+# Unoptimized/unoptimizable load of a vector64; grabbing an immediate.
+with_d("ldi_d", "ldr Dd, [x28], #8")
+with_d("ldi_q", "ldr Qd, [x28], #16")
+
+# General purpose reg -> vec rec loads
+vector_dn("dup", "dup Vd.S, Wn")
+
+# Memory -> vec reg loads.
+# The offset of the load is stored in a 64b immediate.
+
+# Duplicating load.
+# TODO: possibly squish the add into the ld1r, if that's valid?
+vector_dn("dupm", "ldr x27, [x28], #8", "add x27, x27, Xn", "ld1r {Vd.S}, [x27]")
+
+# Direct loads.
+with_dn("ldr_d",  "ldr x27, [x28], #8", "ldr Dd, [Xn, x27]")
+with_dn("ldr_q",  "ldr x27, [x28], #8", "ldr Qd, [Xn, x27]")
+
+# vec -> reg stores.
+# The offset of the stores is stored in a 64b immediate.
+with_dn("str_d",  "ldr x27, [x28], #8", "str Dd, [Xn, x27]")
+with_dn("str_q",  "ldr x27, [x28], #8", "str Qd, [Xn, x27]")
+
+
+START_COLLECTION(f"simd_arithmetic")
+
+vector_math_dnm("add",   "add")
+vector_math_dnm("usadd", "uqadd")
+vector_math_dnm("ssadd", "sqadd")
+vector_math_dnm("sub",   "sub")
+vector_math_dnm("ussub", "uqsub")
+vector_math_dnm("sssub", "sqsub")
+vector_dnm("mul", "mul Vd.S, Vn.S, Vm.S", omit_sizes=("2d",))
+
+START_COLLECTION(f"simd_logical")
+
+vector_logic_dnm("and",  "and")
+vector_logic_dnm("andc", "bic")
+vector_logic_dnm("or",   "orr")
+vector_logic_dnm("orc",  "orn")
+vector_logic_dnm("xor",  "eor")
+vector_logic_dn( "not",  "not")
+vector_dn("neg", "neg Vd.S, Vn.S")
+vector_dn("abs", "abs Vd.S, Vn.S")
+
+
+"""
+START_COLLECTION(f"simd_dupi_optimizations")
+
+# Simple imm8 movs...
+with_d_immediate("movi_cmode_e_op0_q0",  "mov Vd.8b, #Ii",          immediate_range=range(256))
+with_d_immediate("movi_cmode_e_op0_q1",  "mov Vd.16b, #Ii",         immediate_range=range(256))
+
+# ... all 00/FF movs...
+with_d_immediate("movi_cmode_e_op1_q0",  "mov Dd, #Si",             immediate_range=range(256))
+with_d_immediate("movi_cmode_e_op1_q1",  "mov Vd.2d, #Si",          immediate_range=range(256))
+
+# Halfword MOVs.
+with_d_immediate("movi_cmode_8_op0_q0",  "movi v0.4h, #Ii",         immediate_range=range(256))
+with_d_immediate("movi_cmode_8_op0_q1",  "movi v0.8h, #Ii",         immediate_range=range(256))
+with_d_immediate("movi_cmode_8_op0_q0",  "mvni v0.4h, #Ii",         immediate_range=range(256))
+with_d_immediate("movi_cmode_8_op0_q1",  "mvni v0.8h, #Ii",         immediate_range=range(256))
+with_d_immediate("movi_cmode_a_op0_q0",  "movi v0.4h, #Ii, lsl #8", immediate_range=range(256))
+with_d_immediate("movi_cmode_a_op0_q1",  "movi v0.8h, #Ii, lsl #8", immediate_range=range(256))
+with_d_immediate("movi_cmode_a_op0_q0",  "mvni v0.4h, #Ii, lsl #8", immediate_range=range(256))
+with_d_immediate("movi_cmode_a_op0_q1",  "mvni v0.8h, #Ii, lsl #8", immediate_range=range(256))
+
+# Halfword ORIs, for building complex MOVs.
+with_d_immediate("movi_orr_a_op0_q0",    "orr v0.4h, #Ii, lsl #8", immediate_range=range(256))
+with_d_immediate("movi_orr_a_op0_q1",    "orr v0.8h, #Ii, lsl #8", immediate_range=range(256))
+"""
+
+
 # Print a list of output files generated.
 output_c_filenames = (f"'tcti_{name}_gadgets.c'" for name in output_files.keys())
 output_h_filenames = (f"'tcti_{name}_gadgets.h'" for name in output_files.keys())
@@ -962,10 +1131,10 @@ def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None,
 print("      tcti_gadgets.h,", file=sys.stderr)
 
 for name in output_files.keys():
-    print(f"      tcti_{name}_gadgets.c,", file=sys.stderr)
-    print(f"      tcti_{name}_gadgets.h,", file=sys.stderr)
+    print(f"      'tcti_{name}_gadgets.c',", file=sys.stderr)
+    print(f"      'tcti_{name}_gadgets.h',", file=sys.stderr)
 
 print(f"]", file=sys.stderr)
 
 # Statistics.
-sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions ({instructions * 4} B).\n\n")
+sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions (~{(instructions * 4) // 1024 // 1024} B).\n\n")

From 13c9a7c820df2754b308f8b30a4f0a56f47aa023 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Thu, 6 May 2021 16:58:56 -0600
Subject: [PATCH 045/180] TCTI: expand vector support to all ops

---
 meson.build                         |   2 +
 tcg/aarch64-tcti/tcg-target.c.inc   | 216 +++++++++++++++++-----------
 tcg/aarch64-tcti/tcg-target.h       |   2 +-
 tcg/aarch64-tcti/tcg-target.opc.h   |   1 -
 tcg/aarch64-tcti/tcti-gadget-gen.py |  69 ++++++---
 5 files changed, 179 insertions(+), 111 deletions(-)

diff --git a/meson.build b/meson.build
index cdbe0933ac9d..d87943c90234 100644
--- a/meson.build
+++ b/meson.build
@@ -323,6 +323,8 @@ if not get_option('tcg').disabled()
         'tcti_simd_arithmetic_gadgets.h',
         'tcti_simd_logical_gadgets.c',
         'tcti_simd_logical_gadgets.h',
+        'tcti_simd_immediate_gadgets.c',
+        'tcti_simd_immediate_gadgets.h',
     ]
     tcti_gadgets = custom_target('tcti-gadgets.h',
                               output: tcti_sources,
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index 9852650ca6fe..ea6dfc56f6de 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -207,8 +207,6 @@ static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
         return C_O1_I2(w, w, w);
     case INDEX_op_bitsel_vec:
         return C_O1_I3(w, w, w, w);
-    case INDEX_op_aa64_sli_vec:
-        return C_O1_I2(w, 0, w);
 
     default:
         g_assert_not_reached();
@@ -581,24 +579,77 @@ static void tcti_out_label(TCGContext *s, TCGLabel *label)
     }
 }
 
-/**
- * Generate a register-to-register MOV.
- */
+
+/* Register to register move using ORR (shifted register with no shift). */
+static void tcg_out_movr(TCGContext *s, TCGType ext, TCGReg rd, TCGReg rm)
+{
+    switch(ext) {
+        case TCG_TYPE_I32:
+            tcg_out_binary_gadget(s, gadget_mov_i32, rd, rm);
+            break;
+
+        case TCG_TYPE_I64:
+            tcg_out_binary_gadget(s, gadget_mov_i64, rd, rm);
+            break;
+
+        default:
+            g_assert_not_reached();
+
+    }
+}
+
+
 static bool tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
 {
-    tcg_debug_assert(ret != arg);
+    TCGReg w_ret = (ret - TCG_REG_V16);
+    TCGReg w_arg = (arg - TCG_REG_V16);
 
-    if (type == TCG_TYPE_I32) {
-        tcg_out_binary_gadget(s, gadget_mov_i32, ret, arg);
-    } else {
-        tcg_out_binary_gadget(s, gadget_mov_i64, ret, arg);
+    if (ret == arg) {
+        return true;
     }
 
+    switch (type) {
+    case TCG_TYPE_I32:
+    case TCG_TYPE_I64:
+
+        // If this is a GP to GP register mov, issue our standard MOV.
+        if (ret < 32 && arg < 32) {
+            tcg_out_movr(s, type, ret, arg);
+            break;
+        } 
+        // If this is a vector register to GP, issue a UMOV.
+        else if (ret < 32) {
+            void *gadget = (type == TCG_TYPE_I32) ? gadget_umov_s0 : gadget_umov_d0;
+            tcg_out_binary_gadget(s, gadget, ret, w_arg);
+            break;
+        } 
+        
+        // If this is a GP to vector move, insert the vealue using INS.
+        else if (arg < 32) {
+            void *gadget = (type == TCG_TYPE_I32) ? gadget_ins_s0 : gadget_ins_d0;
+            tcg_out_binary_gadget(s, gadget, w_ret, arg);
+            break;
+        }
+        /* FALLTHRU */
+
+    case TCG_TYPE_V64:
+        tcg_debug_assert(ret >= 32 && arg >= 32);
+        tcg_out_ternary_gadget(s, gadget_or_d, w_ret, w_arg, w_arg);
+        break;
+
+    case TCG_TYPE_V128:
+        tcg_debug_assert(ret >= 32 && arg >= 32);
+        tcg_out_ternary_gadget(s, gadget_or_q, w_ret, w_arg, w_arg);
+        break;
 
+    default:
+        g_assert_not_reached();
+    }
     return true;
 }
 
 
+
 static void tcg_out_movi_i32(TCGContext *s, TCGReg t0, tcg_target_long arg)
 {
     bool is_negative = (arg < 0);
@@ -613,9 +664,6 @@ static void tcg_out_movi_i32(TCGContext *s, TCGReg t0, tcg_target_long arg)
             return;
         }
     }
-    else {
-
-    }
 
     // Emit the mov and its immediate.
     tcg_out_unary_gadget(s, gadget_movi_i32, t0);
@@ -637,9 +685,6 @@ static void tcg_out_movi_i64(TCGContext *s, TCGReg t0, tcg_target_long arg)
             return;
         }
     }
-    else {
-
-    }
 
     // TODO: optimize the negative case, too?
 
@@ -1466,7 +1511,6 @@ static int tcg_target_const_match(tcg_target_long val, TCGType type,
 
 
 /* Return true if v16 is a valid 16-bit shifted immediate.  */
-/*
 static bool is_shimm16(uint16_t v16, int *cmode, int *imm8)
 {
     if (v16 == (v16 & 0xff)) {
@@ -1480,31 +1524,14 @@ static bool is_shimm16(uint16_t v16, int *cmode, int *imm8)
     }
     return false;
 }
-*/
 
-/* Return true if v64 is a valid float64 immediate.  */
-/*
-static bool is_fimm64(uint64_t v64, int *cmode, int *imm8)
-{
-    if (extract64(v64, 0, 48) == 0
-        && (extract64(v64, 54, 9) == 0x100
-            || extract64(v64, 54, 9) == 0x0ff)) {
-        *cmode = 0xf;
-        *imm8 = (extract64(v64, 63, 1) << 7)
-              | (extract64(v64, 54, 1) << 6)
-              | extract64(v64, 48, 6);
-        return true;
-    }
-    return false;
-}
-*/
 
 /** Core vector operation emission. */
 static void tcg_out_vec_op(TCGContext *s, TCGOpcode opc, unsigned vecl, unsigned vece,
     const TCGArg args[TCG_MAX_OP_ARGS], const int const_args[TCG_MAX_OP_ARGS])
 {
     TCGType type = vecl + TCG_TYPE_V64;
-    TCGArg r0, r1, r2, w0, w1, w2;
+    TCGArg r0, r1, r2, r3, w0, w1, w2, w3;
 
     // Typing flags for vector operations.
     bool is_v128 = (type == TCG_TYPE_V128);
@@ -1514,11 +1541,13 @@ static void tcg_out_vec_op(TCGContext *s, TCGOpcode opc, unsigned vecl, unsigned
     r0 = args[0];
     r1 = args[1];
     r2 = args[2];
+    r3 = args[3];
 
     // Offset argument shortcuts; offset to convert register numbers to gadget numberes.
     w0 = args[0] - TCG_REG_V16;
     w1 = args[1] - TCG_REG_V16;
     w2 = args[2] - TCG_REG_V16;
+    w3 = args[3] - TCG_REG_V16;
 
     // Argument shortcuts, as signed.
     int64_t signed_offset_arg = (int32_t)args[2];
@@ -1600,52 +1629,85 @@ static void tcg_out_vec_op(TCGContext *s, TCGOpcode opc, unsigned vecl, unsigned
         break;
 
     case INDEX_op_smax_vec:
-        TODO();
+        tcg_out_ternary_vector_gadget_no64(s, smax, vece, w0, w1, w2);
         break;
 
     case INDEX_op_smin_vec:
-        TODO();
+        tcg_out_ternary_vector_gadget_no64(s, smin, vece, w0, w1, w2);
         break;
 
     case INDEX_op_umax_vec:
-        TODO();
+        tcg_out_ternary_vector_gadget_no64(s, umax, vece, w0, w1, w2);
         break;
 
     case INDEX_op_umin_vec:
-        TODO();
+        tcg_out_ternary_vector_gadget_no64(s, umin, vece, w0, w1, w2);
         break;
 
     case INDEX_op_not_vec: // optional
         tcg_out_binary_dq_gadget(s, not, is_v128, w0, w1);
         break;
 
-    case INDEX_op_shli_vec:
-        TODO();
-        break;
-
-    case INDEX_op_shri_vec:
-        TODO();
-        break;
-
-    case INDEX_op_sari_vec:
-        TODO();
-        break;
-
-    case INDEX_op_aa64_sli_vec:
-        TODO();
-        break;
     case INDEX_op_shlv_vec:
-        TODO();
+        tcg_out_ternary_vector_gadget_with_scalar(s, shlv, is_scalar, vece, w0, w1, w2);
         break;
+
     case INDEX_op_aa64_sshl_vec:
-        TODO();
+        tcg_out_ternary_vector_gadget_with_scalar(s, sshl, is_scalar, vece, w0, w1, w2);
         break;
+
     case INDEX_op_cmp_vec:
-        TODO();
+        switch (args[3]) {
+            case TCG_COND_EQ:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmeq, is_scalar, vece, w0, w1, w2);
+                break;
+            case TCG_COND_NE:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmeq, is_scalar, vece, w0, w1, w2);
+                tcg_out_binary_dq_gadget(s, not, is_v128, w0, w0);
+                break;
+            case TCG_COND_GT:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmgt, is_scalar, vece, w0, w1, w2);
+                break;
+            case TCG_COND_LE:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmgt, is_scalar, vece, w0, w2, w1);
+                break;
+            case TCG_COND_GE:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmge, is_scalar, vece, w0, w1, w2);
+                break;
+            case TCG_COND_LT:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmge, is_scalar, vece, w0, w2, w1);
+                break;
+            case TCG_COND_GTU:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmhi, is_scalar, vece, w0, w1, w2);
+                break;
+            case TCG_COND_LEU:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmhi, is_scalar, vece, w0, w2, w1);
+                break;
+            case TCG_COND_GEU:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmhs, is_scalar, vece, w0, w1, w2);
+                break;
+            case TCG_COND_LTU:
+                tcg_out_ternary_vector_gadget_with_scalar(s, cmhs, is_scalar, vece, w0, w2, w1);
+                break;
+            default:
+                g_assert_not_reached();
+        }
         break;
+
     case INDEX_op_bitsel_vec: // optional
-        TODO();
+    {
+        if (r0 == r3) {
+            tcg_out_ternary_dq_gadget(s, bit, is_v128, w0, w2, w1);
+        } else if (r0 == r2) {
+            tcg_out_ternary_dq_gadget(s, bif, is_v128, w0, w3, w1);
+        } else {
+            if (r0 != r1) {
+                tcg_out_mov(s, type, r0, r1);
+            }
+            tcg_out_ternary_dq_gadget(s, bsl, is_v128, w0, w2, w3);
+        }
         break;
+    }
 
     case INDEX_op_mov_vec:  /* Always emitted via tcg_out_mov.  */
     case INDEX_op_dup_vec:  /* Always emitted via tcg_out_dup_vec.  */
@@ -1668,16 +1730,13 @@ int tcg_can_emit_vec_op(TCGOpcode opc, TCGType type, unsigned vece)
     case INDEX_op_neg_vec:
     case INDEX_op_abs_vec:
     case INDEX_op_not_vec:
-    //case INDEX_op_cmp_vec:
-    //case INDEX_op_shli_vec:
-    //case INDEX_op_shri_vec:
-    //case INDEX_op_sari_vec:
+    case INDEX_op_cmp_vec:
     case INDEX_op_ssadd_vec:
     case INDEX_op_sssub_vec:
     case INDEX_op_usadd_vec:
     case INDEX_op_ussub_vec:
-    //case INDEX_op_shlv_vec:
-    //case INDEX_op_bitsel_vec:
+    case INDEX_op_shlv_vec:
+    case INDEX_op_bitsel_vec:
         return 1;
     case INDEX_op_rotli_vec:
     case INDEX_op_shrv_vec:
@@ -1686,10 +1745,10 @@ int tcg_can_emit_vec_op(TCGOpcode opc, TCGType type, unsigned vece)
     case INDEX_op_rotrv_vec:
         return -1;
     case INDEX_op_mul_vec:
-    //case INDEX_op_smax_vec:
-    //case INDEX_op_smin_vec:
-    //case INDEX_op_umax_vec:
-    //case INDEX_op_umin_vec:
+    case INDEX_op_smax_vec:
+    case INDEX_op_smin_vec:
+    case INDEX_op_umax_vec:
+    case INDEX_op_umin_vec:
         return vece < MO_64;
 
     default:
@@ -1712,14 +1771,6 @@ void tcg_expand_vec_op(TCGOpcode opc, TCGType type, unsigned vece,
     va_end(va);
 
     switch (opc) {
-    case INDEX_op_rotli_vec:
-        t1 = tcg_temp_new_vec(type);
-        tcg_gen_shri_vec(vece, t1, v1, -a2 & ((8 << vece) - 1));
-        vec_gen_4(INDEX_op_aa64_sli_vec, type, vece,
-                  tcgv_vec_arg(v0), tcgv_vec_arg(t1), tcgv_vec_arg(v1), a2);
-        tcg_temp_free_vec(t1);
-        break;
-
     case INDEX_op_shrv_vec:
     case INDEX_op_sarv_vec:
         /* Right shifts are negative left shifts for AArch64.  */
@@ -1771,10 +1822,9 @@ void tcg_expand_vec_op(TCGOpcode opc, TCGType type, unsigned vece,
 
 
 /* Generate DUPI (move immediate) vector ops. */
-/*
 static bool tcg_out_optimized_dupi_vec(TCGContext *s, TCGType type, unsigned vece, TCGReg rd, int64_t v64)
 {
-    bool is_v128 = (type == TCG_TYPE_V128);
+    bool q = (type == TCG_TYPE_V128);
     int cmode, imm8, i;
 
     // If we're copying an 8b immediate, we implicitly have a simple gadget for this,
@@ -1871,14 +1921,10 @@ static bool tcg_out_optimized_dupi_vec(TCGContext *s, TCGType type, unsigned vec
     //        return;
     //    }
     //} 
-    
-    else if (is_fimm64(v64, &cmode, &imm8)) {
-        tcg_out_insn(s, 3606, MOVI, q, rd, 1, cmode, imm8);
-        return true;
-    }
 
+    return false;
 }
-*/
+
 
 /* Emits instructions that can load an immediate into a vector. */
 static void tcg_out_dupi_vec(TCGContext *s, TCGType type, unsigned vece, TCGReg rd, int64_t v64)
@@ -1887,11 +1933,9 @@ static void tcg_out_dupi_vec(TCGContext *s, TCGType type, unsigned vece, TCGReg
     rd = rd - (TCG_REG_V16);
 
     // First, try to create an optimized implementation, if possible.
-    /*
     if (tcg_out_optimized_dupi_vec(s, type, vece, rd, v64)) {
         return;
     }
-    */
 
     // If we didn't, we'll need to load the full vector from memory.
     // Emit it into our bytecode stream as an immediate; which we'll then
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
index f48060dcbfeb..b4a3c225002b 100644
--- a/tcg/aarch64-tcti/tcg-target.h
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -134,7 +134,7 @@
 #define TCG_TARGET_HAS_roti_vec         0
 #define TCG_TARGET_HAS_rots_vec         0
 #define TCG_TARGET_HAS_rotv_vec         0
-#define TCG_TARGET_HAS_shi_vec          1
+#define TCG_TARGET_HAS_shi_vec          0
 #define TCG_TARGET_HAS_shs_vec          0
 #define TCG_TARGET_HAS_shv_vec          1
 #define TCG_TARGET_HAS_mul_vec          1
diff --git a/tcg/aarch64-tcti/tcg-target.opc.h b/tcg/aarch64-tcti/tcg-target.opc.h
index bce30accd936..26bfd9c46093 100644
--- a/tcg/aarch64-tcti/tcg-target.opc.h
+++ b/tcg/aarch64-tcti/tcg-target.opc.h
@@ -12,4 +12,3 @@
  */
 
 DEF(aa64_sshl_vec, 1, 2, 0, IMPLVEC)
-DEF(aa64_sli_vec, 1, 2, 1, IMPLVEC)
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 17c76fd82f25..4e127ff8c3be 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -113,10 +113,6 @@ def simple(name, *lines, export=True):
 
 
 
-
-
-
-
 def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
     """ Generates a collection of gadgtes with register substitutions. """
 
@@ -635,6 +631,11 @@ def vector_math_dnm(name, operation):
     vector_dnm(name, f"{operation} Vd.S, Vn.S, Vm.S", scalar=f"{operation} Dd, Dn, Dm")
 
 
+def vector_math_dnm_no64(name, operation):
+    """ Generates a collection of gadgets for vector math instructions. """
+    vector_dnm(name, f"{operation} Vd.S, Vn.S, Vm.S", omit_sizes=('2d',))
+
+
 def vector_logic_dn(name, operation):
     """ Generates a pair of gadgets for vector bitwise logic instructions. """
     with_dn(f"{name}_d", f"{operation} Vd.8b, Vn.8b")
@@ -1056,6 +1057,15 @@ def vector_logic_dnm(name, operation):
 # General purpose reg -> vec rec loads
 vector_dn("dup", "dup Vd.S, Wn")
 
+# move vector -> GP reg
+with_dn("umov_s0", "umov Wd, Vn.s[0]")
+with_dn("umov_d0", "umov Xd, Vn.d[0]")
+
+# mov GP reg -> vector
+with_dn("ins_s0", "ins Vd.s[0], Wn")
+with_dn("ins_d0", "ins Vd.d[0], Xn")
+
+
 # Memory -> vec reg loads.
 # The offset of the load is stored in a 64b immediate.
 
@@ -1081,7 +1091,11 @@ def vector_logic_dnm(name, operation):
 vector_math_dnm("sub",   "sub")
 vector_math_dnm("ussub", "uqsub")
 vector_math_dnm("sssub", "sqsub")
-vector_dnm("mul", "mul Vd.S, Vn.S, Vm.S", omit_sizes=("2d",))
+vector_math_dnm_no64("mul",  "mul")
+vector_math_dnm_no64("smax", "smax")
+vector_math_dnm_no64("smin", "smin")
+vector_math_dnm_no64("umax", "umax")
+vector_math_dnm_no64("umin", "umin")
 
 START_COLLECTION(f"simd_logical")
 
@@ -1093,33 +1107,42 @@ def vector_logic_dnm(name, operation):
 vector_logic_dn( "not",  "not")
 vector_dn("neg", "neg Vd.S, Vn.S")
 vector_dn("abs", "abs Vd.S, Vn.S")
+vector_logic_dnm( "bit",  "bit")
+vector_logic_dnm( "bif",  "bif")
+vector_logic_dnm( "bsl",  "bsl")
 
+vector_math_dnm("shlv", "ushl")
+vector_math_dnm("sshl", "sshl")
 
-"""
-START_COLLECTION(f"simd_dupi_optimizations")
+vector_dnm("cmeq", "cmeq Vd.S, Vn.S, Vm.S", scalar="cmeq Dd, Dn, Dm")
+vector_dnm("cmgt", "cmgt Vd.S, Vn.S, Vm.S", scalar="cmgt Dd, Dn, Dm")
+vector_dnm("cmge", "cmge Vd.S, Vn.S, Vm.S", scalar="cmge Dd, Dn, Dm")
+vector_dnm("cmhi", "cmhi Vd.S, Vn.S, Vm.S", scalar="cmhi Dd, Dn, Dm")
+vector_dnm("cmhs", "cmhs Vd.S, Vn.S, Vm.S", scalar="cmhs Dd, Dn, Dm")
+
+START_COLLECTION(f"simd_immediate")
 
 # Simple imm8 movs...
-with_d_immediate("movi_cmode_e_op0_q0",  "mov Vd.8b, #Ii",          immediate_range=range(256))
-with_d_immediate("movi_cmode_e_op0_q1",  "mov Vd.16b, #Ii",         immediate_range=range(256))
+with_d_immediate("movi_cmode_e_op0_q0",  "movi Vd.8b, #Ii",          immediate_range=range(256))
+with_d_immediate("movi_cmode_e_op0_q1",  "movi Vd.16b, #Ii",         immediate_range=range(256))
 
 # ... all 00/FF movs...
-with_d_immediate("movi_cmode_e_op1_q0",  "mov Dd, #Si",             immediate_range=range(256))
-with_d_immediate("movi_cmode_e_op1_q1",  "mov Vd.2d, #Si",          immediate_range=range(256))
+with_d_immediate("movi_cmode_e_op1_q0",  "movi Dd, #Si",             immediate_range=range(256))
+with_d_immediate("movi_cmode_e_op1_q1",  "movi Vd.2d, #Si",          immediate_range=range(256))
 
 # Halfword MOVs.
-with_d_immediate("movi_cmode_8_op0_q0",  "movi v0.4h, #Ii",         immediate_range=range(256))
-with_d_immediate("movi_cmode_8_op0_q1",  "movi v0.8h, #Ii",         immediate_range=range(256))
-with_d_immediate("movi_cmode_8_op0_q0",  "mvni v0.4h, #Ii",         immediate_range=range(256))
-with_d_immediate("movi_cmode_8_op0_q1",  "mvni v0.8h, #Ii",         immediate_range=range(256))
-with_d_immediate("movi_cmode_a_op0_q0",  "movi v0.4h, #Ii, lsl #8", immediate_range=range(256))
-with_d_immediate("movi_cmode_a_op0_q1",  "movi v0.8h, #Ii, lsl #8", immediate_range=range(256))
-with_d_immediate("movi_cmode_a_op0_q0",  "mvni v0.4h, #Ii, lsl #8", immediate_range=range(256))
-with_d_immediate("movi_cmode_a_op0_q1",  "mvni v0.8h, #Ii, lsl #8", immediate_range=range(256))
+with_d_immediate("movi_cmode_8_op0_q0",  "movi Vd.4h, #Ii",         immediate_range=range(256))
+with_d_immediate("movi_cmode_8_op0_q1",  "movi Vd.8h, #Ii",         immediate_range=range(256))
+with_d_immediate("mvni_cmode_8_op0_q0",  "mvni Vd.4h, #Ii",         immediate_range=range(256))
+with_d_immediate("mvni_cmode_8_op0_q1",  "mvni Vd.8h, #Ii",         immediate_range=range(256))
+with_d_immediate("movi_cmode_a_op0_q0",  "movi Vd.4h, #Ii, lsl #8", immediate_range=range(256))
+with_d_immediate("movi_cmode_a_op0_q1",  "movi Vd.8h, #Ii, lsl #8", immediate_range=range(256))
+with_d_immediate("mvni_cmode_a_op0_q0",  "mvni Vd.4h, #Ii, lsl #8", immediate_range=range(256))
+with_d_immediate("mvni_cmode_a_op0_q1",  "mvni Vd.8h, #Ii, lsl #8", immediate_range=range(256))
 
 # Halfword ORIs, for building complex MOVs.
-with_d_immediate("movi_orr_a_op0_q0",    "orr v0.4h, #Ii, lsl #8", immediate_range=range(256))
-with_d_immediate("movi_orr_a_op0_q1",    "orr v0.8h, #Ii, lsl #8", immediate_range=range(256))
-"""
+with_d_immediate("orr_cmode_a_op0_q0",   "orr Vd.4h, #Ii, lsl #8",  immediate_range=range(256))
+with_d_immediate("orr_cmode_a_op0_q1",   "orr Vd.8h, #Ii, lsl #8",  immediate_range=range(256))
 
 
 # Print a list of output files generated.
@@ -1137,4 +1160,4 @@ def vector_logic_dnm(name, operation):
 print(f"]", file=sys.stderr)
 
 # Statistics.
-sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions (~{(instructions * 4) // 1024 // 1024} B).\n\n")
+sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions (~{(instructions * 4) // 1024 // 1024} MiB).\n\n")

From 71f21b796f57c8cfbafbdb250305db9a81d25ce7 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:35 +0200
Subject: [PATCH 046/180] hvf: Move assert_hvf_ok() into common directory

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch moves assert_hvf_ok() and introduces generic build infrastructure.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-2-agraf@csgraf.de>
---
 MAINTAINERS              |  8 +++++++
 accel/hvf/hvf-all.c      | 47 ++++++++++++++++++++++++++++++++++++++++
 accel/hvf/meson.build    |  6 +++++
 accel/meson.build        |  1 +
 include/sysemu/hvf_int.h | 18 +++++++++++++++
 target/i386/hvf/hvf.c    | 33 +---------------------------
 6 files changed, 81 insertions(+), 32 deletions(-)
 create mode 100644 accel/hvf/hvf-all.c
 create mode 100644 accel/hvf/meson.build
 create mode 100644 include/sysemu/hvf_int.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 36055f14c594..275bfe10931c 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -462,7 +462,15 @@ M: Roman Bolshakov <r.bolshakov@yadro.com>
 W: https://wiki.qemu.org/Features/HVF
 S: Maintained
 F: target/i386/hvf/
+
+HVF
+M: Cameron Esfahani <dirty@apple.com>
+M: Roman Bolshakov <r.bolshakov@yadro.com>
+W: https://wiki.qemu.org/Features/HVF
+S: Maintained
+F: accel/hvf/
 F: include/sysemu/hvf.h
+F: include/sysemu/hvf_int.h
 
 WHPX CPUs
 M: Sunil Muthuswamy <sunilmut@microsoft.com>
diff --git a/accel/hvf/hvf-all.c b/accel/hvf/hvf-all.c
new file mode 100644
index 000000000000..f185b0830a75
--- /dev/null
+++ b/accel/hvf/hvf-all.c
@@ -0,0 +1,47 @@
+/*
+ * QEMU Hypervisor.framework support
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ * Contributions after 2012-01-13 are licensed under the terms of the
+ * GNU GPL, version 2 or (at your option) any later version.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "qemu/error-report.h"
+#include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
+
+void assert_hvf_ok(hv_return_t ret)
+{
+    if (ret == HV_SUCCESS) {
+        return;
+    }
+
+    switch (ret) {
+    case HV_ERROR:
+        error_report("Error: HV_ERROR");
+        break;
+    case HV_BUSY:
+        error_report("Error: HV_BUSY");
+        break;
+    case HV_BAD_ARGUMENT:
+        error_report("Error: HV_BAD_ARGUMENT");
+        break;
+    case HV_NO_RESOURCES:
+        error_report("Error: HV_NO_RESOURCES");
+        break;
+    case HV_NO_DEVICE:
+        error_report("Error: HV_NO_DEVICE");
+        break;
+    case HV_UNSUPPORTED:
+        error_report("Error: HV_UNSUPPORTED");
+        break;
+    default:
+        error_report("Unknown Error");
+    }
+
+    abort();
+}
diff --git a/accel/hvf/meson.build b/accel/hvf/meson.build
new file mode 100644
index 000000000000..227b11cd717b
--- /dev/null
+++ b/accel/hvf/meson.build
@@ -0,0 +1,6 @@
+hvf_ss = ss.source_set()
+hvf_ss.add(files(
+  'hvf-all.c',
+))
+
+specific_ss.add_all(when: 'CONFIG_HVF', if_true: hvf_ss)
diff --git a/accel/meson.build b/accel/meson.build
index b44ba30c864c..dfd808d2c8e5 100644
--- a/accel/meson.build
+++ b/accel/meson.build
@@ -2,6 +2,7 @@ specific_ss.add(files('accel-common.c'))
 softmmu_ss.add(files('accel-softmmu.c'))
 user_ss.add(files('accel-user.c'))
 
+subdir('hvf')
 subdir('qtest')
 subdir('kvm')
 subdir('tcg')
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
new file mode 100644
index 000000000000..3deb4cfacc4f
--- /dev/null
+++ b/include/sysemu/hvf_int.h
@@ -0,0 +1,18 @@
+/*
+ * QEMU Hypervisor.framework (HVF) support
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+/* header to be included in HVF-specific code */
+
+#ifndef HVF_INT_H
+#define HVF_INT_H
+
+#include <Hypervisor/hv.h>
+
+void assert_hvf_ok(hv_return_t ret);
+
+#endif
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index 15f14ac69e7f..4ceae48fc35a 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -51,6 +51,7 @@
 #include "qemu/error-report.h"
 
 #include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
 #include "sysemu/runstate.h"
 #include "hvf-i386.h"
 #include "vmcs.h"
@@ -77,38 +78,6 @@
 
 HVFState *hvf_state;
 
-static void assert_hvf_ok(hv_return_t ret)
-{
-    if (ret == HV_SUCCESS) {
-        return;
-    }
-
-    switch (ret) {
-    case HV_ERROR:
-        error_report("Error: HV_ERROR");
-        break;
-    case HV_BUSY:
-        error_report("Error: HV_BUSY");
-        break;
-    case HV_BAD_ARGUMENT:
-        error_report("Error: HV_BAD_ARGUMENT");
-        break;
-    case HV_NO_RESOURCES:
-        error_report("Error: HV_NO_RESOURCES");
-        break;
-    case HV_NO_DEVICE:
-        error_report("Error: HV_NO_DEVICE");
-        break;
-    case HV_UNSUPPORTED:
-        error_report("Error: HV_UNSUPPORTED");
-        break;
-    default:
-        error_report("Unknown Error");
-    }
-
-    abort();
-}
-
 /* Memory slots */
 hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
 {

From 7a64de81cec628d0972da534368278573706453c Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:36 +0200
Subject: [PATCH 047/180] hvf: Move vcpu thread functions into common directory

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch moves the vCPU thread loop over.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-3-agraf@csgraf.de>
---
 {target/i386 => accel}/hvf/hvf-accel-ops.c | 0
 {target/i386 => accel}/hvf/hvf-accel-ops.h | 0
 accel/hvf/meson.build                      | 1 +
 target/i386/hvf/meson.build                | 1 -
 target/i386/hvf/x86hvf.c                   | 2 +-
 5 files changed, 2 insertions(+), 2 deletions(-)
 rename {target/i386 => accel}/hvf/hvf-accel-ops.c (100%)
 rename {target/i386 => accel}/hvf/hvf-accel-ops.h (100%)

diff --git a/target/i386/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
similarity index 100%
rename from target/i386/hvf/hvf-accel-ops.c
rename to accel/hvf/hvf-accel-ops.c
diff --git a/target/i386/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
similarity index 100%
rename from target/i386/hvf/hvf-accel-ops.h
rename to accel/hvf/hvf-accel-ops.h
diff --git a/accel/hvf/meson.build b/accel/hvf/meson.build
index 227b11cd717b..fc52cb78433a 100644
--- a/accel/hvf/meson.build
+++ b/accel/hvf/meson.build
@@ -1,6 +1,7 @@
 hvf_ss = ss.source_set()
 hvf_ss.add(files(
   'hvf-all.c',
+  'hvf-accel-ops.c',
 ))
 
 specific_ss.add_all(when: 'CONFIG_HVF', if_true: hvf_ss)
diff --git a/target/i386/hvf/meson.build b/target/i386/hvf/meson.build
index e9eb5a5da8a2..c8a43717eee8 100644
--- a/target/i386/hvf/meson.build
+++ b/target/i386/hvf/meson.build
@@ -1,6 +1,5 @@
 i386_softmmu_ss.add(when: [hvf, 'CONFIG_HVF'], if_true: files(
   'hvf.c',
-  'hvf-accel-ops.c',
   'x86.c',
   'x86_cpuid.c',
   'x86_decode.c',
diff --git a/target/i386/hvf/x86hvf.c b/target/i386/hvf/x86hvf.c
index 0d7533742ebf..2b99f3eaa2d5 100644
--- a/target/i386/hvf/x86hvf.c
+++ b/target/i386/hvf/x86hvf.c
@@ -32,7 +32,7 @@
 #include <Hypervisor/hv.h>
 #include <Hypervisor/hv_vmx.h>
 
-#include "hvf-accel-ops.h"
+#include "accel/hvf/hvf-accel-ops.h"
 
 void hvf_set_segment(struct CPUState *cpu, struct vmx_segment *vmx_seg,
                      SegmentCache *qseg, bool is_tr)

From be54898fd5917c001a5616bf7c1ad8e641f97569 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:37 +0200
Subject: [PATCH 048/180] hvf: Move cpu functions into common directory

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch moves CPU and memory operations over. While at it, make sure
the code is consumable on non-i386 systems.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-4-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c  | 308 ++++++++++++++++++++++++++++++++++++-
 include/sysemu/hvf_int.h   |   4 +
 target/i386/hvf/hvf-i386.h |   2 -
 target/i386/hvf/hvf.c      | 302 ------------------------------------
 target/i386/hvf/x86hvf.h   |   2 -
 5 files changed, 311 insertions(+), 307 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index cbaad238e0d5..c2136dfbb8c7 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -50,13 +50,319 @@
 #include "qemu/osdep.h"
 #include "qemu/error-report.h"
 #include "qemu/main-loop.h"
+#include "exec/address-spaces.h"
+#include "exec/exec-all.h"
+#include "sysemu/cpus.h"
 #include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
 #include "sysemu/runstate.h"
-#include "target/i386/cpu.h"
 #include "qemu/guest-random.h"
 
 #include "hvf-accel-ops.h"
 
+HVFState *hvf_state;
+
+/* Memory slots */
+
+hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
+{
+    hvf_slot *slot;
+    int x;
+    for (x = 0; x < hvf_state->num_slots; ++x) {
+        slot = &hvf_state->slots[x];
+        if (slot->size && start < (slot->start + slot->size) &&
+            (start + size) > slot->start) {
+            return slot;
+        }
+    }
+    return NULL;
+}
+
+struct mac_slot {
+    int present;
+    uint64_t size;
+    uint64_t gpa_start;
+    uint64_t gva;
+};
+
+struct mac_slot mac_slots[32];
+
+static int do_hvf_set_memory(hvf_slot *slot, hv_memory_flags_t flags)
+{
+    struct mac_slot *macslot;
+    hv_return_t ret;
+
+    macslot = &mac_slots[slot->slot_id];
+
+    if (macslot->present) {
+        if (macslot->size != slot->size) {
+            macslot->present = 0;
+            ret = hv_vm_unmap(macslot->gpa_start, macslot->size);
+            assert_hvf_ok(ret);
+        }
+    }
+
+    if (!slot->size) {
+        return 0;
+    }
+
+    macslot->present = 1;
+    macslot->gpa_start = slot->start;
+    macslot->size = slot->size;
+    ret = hv_vm_map((hv_uvaddr_t)slot->mem, slot->start, slot->size, flags);
+    assert_hvf_ok(ret);
+    return 0;
+}
+
+void hvf_set_phys_mem(MemoryRegionSection *section, bool add)
+{
+    hvf_slot *mem;
+    MemoryRegion *area = section->mr;
+    bool writeable = !area->readonly && !area->rom_device;
+    hv_memory_flags_t flags;
+
+    if (!memory_region_is_ram(area)) {
+        if (writeable) {
+            return;
+        } else if (!memory_region_is_romd(area)) {
+            /*
+             * If the memory device is not in romd_mode, then we actually want
+             * to remove the hvf memory slot so all accesses will trap.
+             */
+             add = false;
+        }
+    }
+
+    mem = hvf_find_overlap_slot(
+            section->offset_within_address_space,
+            int128_get64(section->size));
+
+    if (mem && add) {
+        if (mem->size == int128_get64(section->size) &&
+            mem->start == section->offset_within_address_space &&
+            mem->mem == (memory_region_get_ram_ptr(area) +
+            section->offset_within_region)) {
+            return; /* Same region was attempted to register, go away. */
+        }
+    }
+
+    /* Region needs to be reset. set the size to 0 and remap it. */
+    if (mem) {
+        mem->size = 0;
+        if (do_hvf_set_memory(mem, 0)) {
+            error_report("Failed to reset overlapping slot");
+            abort();
+        }
+    }
+
+    if (!add) {
+        return;
+    }
+
+    if (area->readonly ||
+        (!memory_region_is_ram(area) && memory_region_is_romd(area))) {
+        flags = HV_MEMORY_READ | HV_MEMORY_EXEC;
+    } else {
+        flags = HV_MEMORY_READ | HV_MEMORY_WRITE | HV_MEMORY_EXEC;
+    }
+
+    /* Now make a new slot. */
+    int x;
+
+    for (x = 0; x < hvf_state->num_slots; ++x) {
+        mem = &hvf_state->slots[x];
+        if (!mem->size) {
+            break;
+        }
+    }
+
+    if (x == hvf_state->num_slots) {
+        error_report("No free slots");
+        abort();
+    }
+
+    mem->size = int128_get64(section->size);
+    mem->mem = memory_region_get_ram_ptr(area) + section->offset_within_region;
+    mem->start = section->offset_within_address_space;
+    mem->region = area;
+
+    if (do_hvf_set_memory(mem, flags)) {
+        error_report("Error registering new memory slot");
+        abort();
+    }
+}
+
+static void do_hvf_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
+{
+    if (!cpu->vcpu_dirty) {
+        hvf_get_registers(cpu);
+        cpu->vcpu_dirty = true;
+    }
+}
+
+void hvf_cpu_synchronize_state(CPUState *cpu)
+{
+    if (!cpu->vcpu_dirty) {
+        run_on_cpu(cpu, do_hvf_cpu_synchronize_state, RUN_ON_CPU_NULL);
+    }
+}
+
+static void do_hvf_cpu_synchronize_post_reset(CPUState *cpu,
+                                              run_on_cpu_data arg)
+{
+    hvf_put_registers(cpu);
+    cpu->vcpu_dirty = false;
+}
+
+void hvf_cpu_synchronize_post_reset(CPUState *cpu)
+{
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
+}
+
+static void do_hvf_cpu_synchronize_post_init(CPUState *cpu,
+                                             run_on_cpu_data arg)
+{
+    hvf_put_registers(cpu);
+    cpu->vcpu_dirty = false;
+}
+
+void hvf_cpu_synchronize_post_init(CPUState *cpu)
+{
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+}
+
+static void do_hvf_cpu_synchronize_pre_loadvm(CPUState *cpu,
+                                              run_on_cpu_data arg)
+{
+    cpu->vcpu_dirty = true;
+}
+
+void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
+{
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
+}
+
+static void hvf_set_dirty_tracking(MemoryRegionSection *section, bool on)
+{
+    hvf_slot *slot;
+
+    slot = hvf_find_overlap_slot(
+            section->offset_within_address_space,
+            int128_get64(section->size));
+
+    /* protect region against writes; begin tracking it */
+    if (on) {
+        slot->flags |= HVF_SLOT_LOG;
+        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
+                      HV_MEMORY_READ);
+    /* stop tracking region*/
+    } else {
+        slot->flags &= ~HVF_SLOT_LOG;
+        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
+                      HV_MEMORY_READ | HV_MEMORY_WRITE);
+    }
+}
+
+static void hvf_log_start(MemoryListener *listener,
+                          MemoryRegionSection *section, int old, int new)
+{
+    if (old != 0) {
+        return;
+    }
+
+    hvf_set_dirty_tracking(section, 1);
+}
+
+static void hvf_log_stop(MemoryListener *listener,
+                         MemoryRegionSection *section, int old, int new)
+{
+    if (new != 0) {
+        return;
+    }
+
+    hvf_set_dirty_tracking(section, 0);
+}
+
+static void hvf_log_sync(MemoryListener *listener,
+                         MemoryRegionSection *section)
+{
+    /*
+     * sync of dirty pages is handled elsewhere; just make sure we keep
+     * tracking the region.
+     */
+    hvf_set_dirty_tracking(section, 1);
+}
+
+static void hvf_region_add(MemoryListener *listener,
+                           MemoryRegionSection *section)
+{
+    hvf_set_phys_mem(section, true);
+}
+
+static void hvf_region_del(MemoryListener *listener,
+                           MemoryRegionSection *section)
+{
+    hvf_set_phys_mem(section, false);
+}
+
+static MemoryListener hvf_memory_listener = {
+    .priority = 10,
+    .region_add = hvf_region_add,
+    .region_del = hvf_region_del,
+    .log_start = hvf_log_start,
+    .log_stop = hvf_log_stop,
+    .log_sync = hvf_log_sync,
+};
+
+static void dummy_signal(int sig)
+{
+}
+
+bool hvf_allowed;
+
+static int hvf_accel_init(MachineState *ms)
+{
+    int x;
+    hv_return_t ret;
+    HVFState *s;
+
+    ret = hv_vm_create(HV_VM_DEFAULT);
+    assert_hvf_ok(ret);
+
+    s = g_new0(HVFState, 1);
+
+    s->num_slots = 32;
+    for (x = 0; x < s->num_slots; ++x) {
+        s->slots[x].size = 0;
+        s->slots[x].slot_id = x;
+    }
+
+    hvf_state = s;
+    memory_listener_register(&hvf_memory_listener, &address_space_memory);
+    return 0;
+}
+
+static void hvf_accel_class_init(ObjectClass *oc, void *data)
+{
+    AccelClass *ac = ACCEL_CLASS(oc);
+    ac->name = "HVF";
+    ac->init_machine = hvf_accel_init;
+    ac->allowed = &hvf_allowed;
+}
+
+static const TypeInfo hvf_accel_type = {
+    .name = TYPE_HVF_ACCEL,
+    .parent = TYPE_ACCEL,
+    .class_init = hvf_accel_class_init,
+};
+
+static void hvf_type_init(void)
+{
+    type_register_static(&hvf_accel_type);
+}
+
+type_init(hvf_type_init);
+
 /*
  * The HVF-specific vCPU thread function. This one should only run when the host
  * CPU supports the VMX "unrestricted guest" feature.
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 3deb4cfacc4f..4c657b054c14 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -13,6 +13,10 @@
 
 #include <Hypervisor/hv.h>
 
+void hvf_set_phys_mem(MemoryRegionSection *, bool);
 void assert_hvf_ok(hv_return_t ret);
+hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
+int hvf_put_registers(CPUState *);
+int hvf_get_registers(CPUState *);
 
 #endif
diff --git a/target/i386/hvf/hvf-i386.h b/target/i386/hvf/hvf-i386.h
index 59cfca8875ef..94e5c788c480 100644
--- a/target/i386/hvf/hvf-i386.h
+++ b/target/i386/hvf/hvf-i386.h
@@ -51,9 +51,7 @@ struct HVFState {
 };
 extern HVFState *hvf_state;
 
-void hvf_set_phys_mem(MemoryRegionSection *, bool);
 void hvf_handle_io(CPUArchState *, uint16_t, void *, int, int, int);
-hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 
 #ifdef NEED_CPU_H
 /* Functions exported to host specific mode */
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index 4ceae48fc35a..2dbc998c7570 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -76,137 +76,6 @@
 
 #include "hvf-accel-ops.h"
 
-HVFState *hvf_state;
-
-/* Memory slots */
-hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
-{
-    hvf_slot *slot;
-    int x;
-    for (x = 0; x < hvf_state->num_slots; ++x) {
-        slot = &hvf_state->slots[x];
-        if (slot->size && start < (slot->start + slot->size) &&
-            (start + size) > slot->start) {
-            return slot;
-        }
-    }
-    return NULL;
-}
-
-struct mac_slot {
-    int present;
-    uint64_t size;
-    uint64_t gpa_start;
-    uint64_t gva;
-};
-
-struct mac_slot mac_slots[32];
-
-static int do_hvf_set_memory(hvf_slot *slot, hv_memory_flags_t flags)
-{
-    struct mac_slot *macslot;
-    hv_return_t ret;
-
-    macslot = &mac_slots[slot->slot_id];
-
-    if (macslot->present) {
-        if (macslot->size != slot->size) {
-            macslot->present = 0;
-            ret = hv_vm_unmap(macslot->gpa_start, macslot->size);
-            assert_hvf_ok(ret);
-        }
-    }
-
-    if (!slot->size) {
-        return 0;
-    }
-
-    macslot->present = 1;
-    macslot->gpa_start = slot->start;
-    macslot->size = slot->size;
-    ret = hv_vm_map((hv_uvaddr_t)slot->mem, slot->start, slot->size, flags);
-    assert_hvf_ok(ret);
-    return 0;
-}
-
-void hvf_set_phys_mem(MemoryRegionSection *section, bool add)
-{
-    hvf_slot *mem;
-    MemoryRegion *area = section->mr;
-    bool writeable = !area->readonly && !area->rom_device;
-    hv_memory_flags_t flags;
-
-    if (!memory_region_is_ram(area)) {
-        if (writeable) {
-            return;
-        } else if (!memory_region_is_romd(area)) {
-            /*
-             * If the memory device is not in romd_mode, then we actually want
-             * to remove the hvf memory slot so all accesses will trap.
-             */
-             add = false;
-        }
-    }
-
-    mem = hvf_find_overlap_slot(
-            section->offset_within_address_space,
-            int128_get64(section->size));
-
-    if (mem && add) {
-        if (mem->size == int128_get64(section->size) &&
-            mem->start == section->offset_within_address_space &&
-            mem->mem == (memory_region_get_ram_ptr(area) +
-            section->offset_within_region)) {
-            return; /* Same region was attempted to register, go away. */
-        }
-    }
-
-    /* Region needs to be reset. set the size to 0 and remap it. */
-    if (mem) {
-        mem->size = 0;
-        if (do_hvf_set_memory(mem, 0)) {
-            error_report("Failed to reset overlapping slot");
-            abort();
-        }
-    }
-
-    if (!add) {
-        return;
-    }
-
-    if (area->readonly ||
-        (!memory_region_is_ram(area) && memory_region_is_romd(area))) {
-        flags = HV_MEMORY_READ | HV_MEMORY_EXEC;
-    } else {
-        flags = HV_MEMORY_READ | HV_MEMORY_WRITE | HV_MEMORY_EXEC;
-    }
-
-    /* Now make a new slot. */
-    int x;
-
-    for (x = 0; x < hvf_state->num_slots; ++x) {
-        mem = &hvf_state->slots[x];
-        if (!mem->size) {
-            break;
-        }
-    }
-
-    if (x == hvf_state->num_slots) {
-        error_report("No free slots");
-        abort();
-    }
-
-    mem->size = int128_get64(section->size);
-    mem->mem = memory_region_get_ram_ptr(area) + section->offset_within_region;
-    mem->start = section->offset_within_address_space;
-    mem->region = area;
-
-    if (do_hvf_set_memory(mem, flags)) {
-        error_report("Error registering new memory slot");
-        abort();
-    }
-}
-
 void vmx_update_tpr(CPUState *cpu)
 {
     /* TODO: need integrate APIC handling */
@@ -246,56 +115,6 @@ void hvf_handle_io(CPUArchState *env, uint16_t port, void *buffer,
     }
 }
 
-static void do_hvf_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
-{
-    if (!cpu->vcpu_dirty) {
-        hvf_get_registers(cpu);
-        cpu->vcpu_dirty = true;
-    }
-}
-
-void hvf_cpu_synchronize_state(CPUState *cpu)
-{
-    if (!cpu->vcpu_dirty) {
-        run_on_cpu(cpu, do_hvf_cpu_synchronize_state, RUN_ON_CPU_NULL);
-    }
-}
-
-static void do_hvf_cpu_synchronize_post_reset(CPUState *cpu,
-                                              run_on_cpu_data arg)
-{
-    hvf_put_registers(cpu);
-    cpu->vcpu_dirty = false;
-}
-
-void hvf_cpu_synchronize_post_reset(CPUState *cpu)
-{
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
-}
-
-static void do_hvf_cpu_synchronize_post_init(CPUState *cpu,
-                                             run_on_cpu_data arg)
-{
-    hvf_put_registers(cpu);
-    cpu->vcpu_dirty = false;
-}
-
-void hvf_cpu_synchronize_post_init(CPUState *cpu)
-{
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
-}
-
-static void do_hvf_cpu_synchronize_pre_loadvm(CPUState *cpu,
-                                              run_on_cpu_data arg)
-{
-    cpu->vcpu_dirty = true;
-}
-
-void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
-{
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
-}
-
 static bool ept_emulation_fault(hvf_slot *slot, uint64_t gpa, uint64_t ept_qual)
 {
     int read, write;
@@ -340,78 +159,6 @@ static bool ept_emulation_fault(hvf_slot *slot, uint64_t gpa, uint64_t ept_qual)
     return false;
 }
 
-static void hvf_set_dirty_tracking(MemoryRegionSection *section, bool on)
-{
-    hvf_slot *slot;
-
-    slot = hvf_find_overlap_slot(
-            section->offset_within_address_space,
-            int128_get64(section->size));
-
-    /* protect region against writes; begin tracking it */
-    if (on) {
-        slot->flags |= HVF_SLOT_LOG;
-        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
-                      HV_MEMORY_READ);
-    /* stop tracking region*/
-    } else {
-        slot->flags &= ~HVF_SLOT_LOG;
-        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
-                      HV_MEMORY_READ | HV_MEMORY_WRITE);
-    }
-}
-
-static void hvf_log_start(MemoryListener *listener,
-                          MemoryRegionSection *section, int old, int new)
-{
-    if (old != 0) {
-        return;
-    }
-
-    hvf_set_dirty_tracking(section, 1);
-}
-
-static void hvf_log_stop(MemoryListener *listener,
-                         MemoryRegionSection *section, int old, int new)
-{
-    if (new != 0) {
-        return;
-    }
-
-    hvf_set_dirty_tracking(section, 0);
-}
-
-static void hvf_log_sync(MemoryListener *listener,
-                         MemoryRegionSection *section)
-{
-    /*
-     * sync of dirty pages is handled elsewhere; just make sure we keep
-     * tracking the region.
-     */
-    hvf_set_dirty_tracking(section, 1);
-}
-
-static void hvf_region_add(MemoryListener *listener,
-                           MemoryRegionSection *section)
-{
-    hvf_set_phys_mem(section, true);
-}
-
-static void hvf_region_del(MemoryListener *listener,
-                           MemoryRegionSection *section)
-{
-    hvf_set_phys_mem(section, false);
-}
-
-static MemoryListener hvf_memory_listener = {
-    .priority = 10,
-    .region_add = hvf_region_add,
-    .region_del = hvf_region_del,
-    .log_start = hvf_log_start,
-    .log_stop = hvf_log_stop,
-    .log_sync = hvf_log_sync,
-};
-
 void hvf_vcpu_destroy(CPUState *cpu)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -422,10 +169,6 @@ void hvf_vcpu_destroy(CPUState *cpu)
     assert_hvf_ok(ret);
 }
 
-static void dummy_signal(int sig)
-{
-}
-
 static void init_tsc_freq(CPUX86State *env)
 {
     size_t length;
@@ -932,48 +675,3 @@ int hvf_vcpu_exec(CPUState *cpu)
 
     return ret;
 }
-
-bool hvf_allowed;
-
-static int hvf_accel_init(MachineState *ms)
-{
-    int x;
-    hv_return_t ret;
-    HVFState *s;
-
-    ret = hv_vm_create(HV_VM_DEFAULT);
-    assert_hvf_ok(ret);
-
-    s = g_new0(HVFState, 1);
- 
-    s->num_slots = 32;
-    for (x = 0; x < s->num_slots; ++x) {
-        s->slots[x].size = 0;
-        s->slots[x].slot_id = x;
-    }
-  
-    hvf_state = s;
-    memory_listener_register(&hvf_memory_listener, &address_space_memory);
-    return 0;
-}
-
-static void hvf_accel_class_init(ObjectClass *oc, void *data)
-{
-    AccelClass *ac = ACCEL_CLASS(oc);
-    ac->name = "HVF";
-    ac->init_machine = hvf_accel_init;
-    ac->allowed = &hvf_allowed;
-}
-
-static const TypeInfo hvf_accel_type = {
-    .name = TYPE_HVF_ACCEL,
-    .parent = TYPE_ACCEL,
-    .class_init = hvf_accel_class_init,
-};
-
-static void hvf_type_init(void)
-{
-    type_register_static(&hvf_accel_type);
-}
-
-type_init(hvf_type_init);
diff --git a/target/i386/hvf/x86hvf.h b/target/i386/hvf/x86hvf.h
index 635ab0f34e48..99ed8d608ddc 100644
--- a/target/i386/hvf/x86hvf.h
+++ b/target/i386/hvf/x86hvf.h
@@ -21,8 +21,6 @@
 #include "x86_descr.h"
 
 int hvf_process_events(CPUState *);
-int hvf_put_registers(CPUState *);
-int hvf_get_registers(CPUState *);
 bool hvf_inject_interrupts(CPUState *);
 void hvf_set_segment(struct CPUState *cpu, struct vmx_segment *vmx_seg,
                      SegmentCache *qseg, bool is_tr);

From aa7ebf9a77ee163f936bedfef6fd836b970e7afa Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:38 +0200
Subject: [PATCH 049/180] hvf: Move hvf internal definitions into common header

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch moves a few internal struct and constant defines over.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-5-agraf@csgraf.de>
---
 include/sysemu/hvf_int.h   | 30 ++++++++++++++++++++++++++++++
 target/i386/hvf/hvf-i386.h | 31 +------------------------------
 2 files changed, 31 insertions(+), 30 deletions(-)

diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 4c657b054c14..ef84a24dd968 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -13,6 +13,36 @@
 
 #include <Hypervisor/hv.h>
 
+/* hvf_slot flags */
+#define HVF_SLOT_LOG (1 << 0)
+
+typedef struct hvf_slot {
+    uint64_t start;
+    uint64_t size;
+    uint8_t *mem;
+    int slot_id;
+    uint32_t flags;
+    MemoryRegion *region;
+} hvf_slot;
+
+typedef struct hvf_vcpu_caps {
+    uint64_t vmx_cap_pinbased;
+    uint64_t vmx_cap_procbased;
+    uint64_t vmx_cap_procbased2;
+    uint64_t vmx_cap_entry;
+    uint64_t vmx_cap_exit;
+    uint64_t vmx_cap_preemption_timer;
+} hvf_vcpu_caps;
+
+struct HVFState {
+    AccelState parent;
+    hvf_slot slots[32];
+    int num_slots;
+
+    hvf_vcpu_caps *hvf_caps;
+};
+extern HVFState *hvf_state;
+
 void hvf_set_phys_mem(MemoryRegionSection *, bool);
 void assert_hvf_ok(hv_return_t ret);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
diff --git a/target/i386/hvf/hvf-i386.h b/target/i386/hvf/hvf-i386.h
index 94e5c788c480..76e9235524c5 100644
--- a/target/i386/hvf/hvf-i386.h
+++ b/target/i386/hvf/hvf-i386.h
@@ -18,39 +18,10 @@
 
 #include "qemu/accel.h"
 #include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
 #include "cpu.h"
 #include "x86.h"
 
-/* hvf_slot flags */
-#define HVF_SLOT_LOG (1 << 0)
-
-typedef struct hvf_slot {
-    uint64_t start;
-    uint64_t size;
-    uint8_t *mem;
-    int slot_id;
-    uint32_t flags;
-    MemoryRegion *region;
-} hvf_slot;
-
-typedef struct hvf_vcpu_caps {
-    uint64_t vmx_cap_pinbased;
-    uint64_t vmx_cap_procbased;
-    uint64_t vmx_cap_procbased2;
-    uint64_t vmx_cap_entry;
-    uint64_t vmx_cap_exit;
-    uint64_t vmx_cap_preemption_timer;
-} hvf_vcpu_caps;
-
-struct HVFState {
-    AccelState parent;
-    hvf_slot slots[32];
-    int num_slots;
-
-    hvf_vcpu_caps *hvf_caps;
-};
-extern HVFState *hvf_state;
-
 void hvf_handle_io(CPUArchState *, uint16_t, void *, int, int, int);
 
 #ifdef NEED_CPU_H

From e27df17c9c8fee150d7e049ed0357b7129fbfc44 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:39 +0200
Subject: [PATCH 050/180] hvf: Make hvf_set_phys_mem() static

The hvf_set_phys_mem() function is only called within the same file.
Make it static.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-6-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 2 +-
 include/sysemu/hvf_int.h  | 1 -
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index c2136dfbb8c7..5bec7b4d6dce 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -114,7 +114,7 @@ static int do_hvf_set_memory(hvf_slot *slot, hv_memory_flags_t flags)
     return 0;
 }
 
-void hvf_set_phys_mem(MemoryRegionSection *section, bool add)
+static void hvf_set_phys_mem(MemoryRegionSection *section, bool add)
 {
     hvf_slot *mem;
     MemoryRegion *area = section->mr;
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index ef84a24dd968..d15fa3302a97 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -43,7 +43,6 @@ struct HVFState {
 };
 extern HVFState *hvf_state;
 
-void hvf_set_phys_mem(MemoryRegionSection *, bool);
 void assert_hvf_ok(hv_return_t ret);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 int hvf_put_registers(CPUState *);

From 3a513c9db47c4d0e867a48b835451974d3057994 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:40 +0200
Subject: [PATCH 051/180] hvf: Remove use of hv_uvaddr_t and hv_gpaddr_t

The ARM version of Hypervisor.framework no longer defines these two
types, so let's just revert to standard ones.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-7-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 5bec7b4d6dce..7370fcfba09d 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -109,7 +109,7 @@ static int do_hvf_set_memory(hvf_slot *slot, hv_memory_flags_t flags)
     macslot->present = 1;
     macslot->gpa_start = slot->start;
     macslot->size = slot->size;
-    ret = hv_vm_map((hv_uvaddr_t)slot->mem, slot->start, slot->size, flags);
+    ret = hv_vm_map(slot->mem, slot->start, slot->size, flags);
     assert_hvf_ok(ret);
     return 0;
 }
@@ -253,12 +253,12 @@ static void hvf_set_dirty_tracking(MemoryRegionSection *section, bool on)
     /* protect region against writes; begin tracking it */
     if (on) {
         slot->flags |= HVF_SLOT_LOG;
-        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
+        hv_vm_protect((uintptr_t)slot->start, (size_t)slot->size,
                       HV_MEMORY_READ);
     /* stop tracking region*/
     } else {
         slot->flags &= ~HVF_SLOT_LOG;
-        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
+        hv_vm_protect((uintptr_t)slot->start, (size_t)slot->size,
                       HV_MEMORY_READ | HV_MEMORY_WRITE);
     }
 }

From 1534c4fe04522cccc174357995f68c4a950d3e33 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:41 +0200
Subject: [PATCH 052/180] hvf: Split out common code on vcpu init and destroy

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch splits the vcpu init and destroy functions into a generic and
an architecture specific portion. This also allows us to move the generic
functions into the generic hvf code, removing exported functions.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-8-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 30 ++++++++++++++++++++++++++++++
 accel/hvf/hvf-accel-ops.h |  2 --
 include/sysemu/hvf_int.h  |  2 ++
 target/i386/hvf/hvf.c     | 23 ++---------------------
 4 files changed, 34 insertions(+), 23 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 7370fcfba09d..b262efd8b6ce 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -363,6 +363,36 @@ static void hvf_type_init(void)
 
 type_init(hvf_type_init);
 
+static void hvf_vcpu_destroy(CPUState *cpu)
+{
+    hv_return_t ret = hv_vcpu_destroy(cpu->hvf_fd);
+    assert_hvf_ok(ret);
+
+    hvf_arch_vcpu_destroy(cpu);
+}
+
+static int hvf_init_vcpu(CPUState *cpu)
+{
+    int r;
+
+    /* init cpu signals */
+    sigset_t set;
+    struct sigaction sigact;
+
+    memset(&sigact, 0, sizeof(sigact));
+    sigact.sa_handler = dummy_signal;
+    sigaction(SIG_IPI, &sigact, NULL);
+
+    pthread_sigmask(SIG_BLOCK, NULL, &set);
+    sigdelset(&set, SIG_IPI);
+
+    r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf_fd, HV_VCPU_DEFAULT);
+    cpu->vcpu_dirty = 1;
+    assert_hvf_ok(r);
+
+    return hvf_arch_init_vcpu(cpu);
+}
+
 /*
  * The HVF-specific vCPU thread function. This one should only run when the host
  * CPU supports the VMX "unrestricted guest" feature.
diff --git a/accel/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
index 8f992da16866..09fcf2206762 100644
--- a/accel/hvf/hvf-accel-ops.h
+++ b/accel/hvf/hvf-accel-ops.h
@@ -12,12 +12,10 @@
 
 #include "sysemu/cpus.h"
 
-int hvf_init_vcpu(CPUState *);
 int hvf_vcpu_exec(CPUState *);
 void hvf_cpu_synchronize_state(CPUState *);
 void hvf_cpu_synchronize_post_reset(CPUState *);
 void hvf_cpu_synchronize_post_init(CPUState *);
 void hvf_cpu_synchronize_pre_loadvm(CPUState *);
-void hvf_vcpu_destroy(CPUState *);
 
 #endif /* HVF_CPUS_H */
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index d15fa3302a97..80c1a8f94667 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -44,6 +44,8 @@ struct HVFState {
 extern HVFState *hvf_state;
 
 void assert_hvf_ok(hv_return_t ret);
+int hvf_arch_init_vcpu(CPUState *cpu);
+void hvf_arch_vcpu_destroy(CPUState *cpu);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 int hvf_put_registers(CPUState *);
 int hvf_get_registers(CPUState *);
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index 2dbc998c7570..a7654681c714 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -159,14 +159,12 @@ static bool ept_emulation_fault(hvf_slot *slot, uint64_t gpa, uint64_t ept_qual)
     return false;
 }
 
-void hvf_vcpu_destroy(CPUState *cpu)
+void hvf_arch_vcpu_destroy(CPUState *cpu)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
     CPUX86State *env = &x86_cpu->env;
 
-    hv_return_t ret = hv_vcpu_destroy((hv_vcpuid_t)cpu->hvf_fd);
     g_free(env->hvf_mmio_buf);
-    assert_hvf_ok(ret);
 }
 
 static void init_tsc_freq(CPUX86State *env)
@@ -211,23 +209,10 @@ static inline bool apic_bus_freq_is_known(CPUX86State *env)
     return env->apic_bus_freq != 0;
 }
 
-int hvf_init_vcpu(CPUState *cpu)
+int hvf_arch_init_vcpu(CPUState *cpu)
 {
-
     X86CPU *x86cpu = X86_CPU(cpu);
     CPUX86State *env = &x86cpu->env;
-    int r;
-
-    /* init cpu signals */
-    sigset_t set;
-    struct sigaction sigact;
-
-    memset(&sigact, 0, sizeof(sigact));
-    sigact.sa_handler = dummy_signal;
-    sigaction(SIG_IPI, &sigact, NULL);
-
-    pthread_sigmask(SIG_BLOCK, NULL, &set);
-    sigdelset(&set, SIG_IPI);
 
     init_emu();
     init_decoder();
@@ -244,10 +229,6 @@ int hvf_init_vcpu(CPUState *cpu)
         }
     }
 
-    r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf_fd, HV_VCPU_DEFAULT);
-    cpu->vcpu_dirty = 1;
-    assert_hvf_ok(r);
-
     if (hv_vmx_read_capability(HV_VMX_CAP_PINBASED,
         &hvf_state->hvf_caps->vmx_cap_pinbased)) {
         abort();

From 2e77c788d8513772d037357ebe70593e76b8c341 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:42 +0200
Subject: [PATCH 053/180] hvf: Use cpu_synchronize_state()

There is no reason to call the hvf specific hvf_cpu_synchronize_state()
when we can just use the generic cpu_synchronize_state() instead. This
allows us to have less dependency on internal function definitions and
allows us to make hvf_cpu_synchronize_state() static.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-9-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 2 +-
 accel/hvf/hvf-accel-ops.h | 1 -
 target/i386/hvf/x86hvf.c  | 9 ++++-----
 3 files changed, 5 insertions(+), 7 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index b262efd8b6ce..3b599ac57ce0 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -200,7 +200,7 @@ static void do_hvf_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
-void hvf_cpu_synchronize_state(CPUState *cpu)
+static void hvf_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty) {
         run_on_cpu(cpu, do_hvf_cpu_synchronize_state, RUN_ON_CPU_NULL);
diff --git a/accel/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
index 09fcf2206762..f6192b56f0c7 100644
--- a/accel/hvf/hvf-accel-ops.h
+++ b/accel/hvf/hvf-accel-ops.h
@@ -13,7 +13,6 @@
 #include "sysemu/cpus.h"
 
 int hvf_vcpu_exec(CPUState *);
-void hvf_cpu_synchronize_state(CPUState *);
 void hvf_cpu_synchronize_post_reset(CPUState *);
 void hvf_cpu_synchronize_post_init(CPUState *);
 void hvf_cpu_synchronize_pre_loadvm(CPUState *);
diff --git a/target/i386/hvf/x86hvf.c b/target/i386/hvf/x86hvf.c
index 2b99f3eaa2d5..cc381307ab90 100644
--- a/target/i386/hvf/x86hvf.c
+++ b/target/i386/hvf/x86hvf.c
@@ -26,14 +26,13 @@
 #include "cpu.h"
 #include "x86_descr.h"
 #include "x86_decode.h"
+#include "sysemu/hw_accel.h"
 
 #include "hw/i386/apic_internal.h"
 
 #include <Hypervisor/hv.h>
 #include <Hypervisor/hv_vmx.h>
 
-#include "accel/hvf/hvf-accel-ops.h"
-
 void hvf_set_segment(struct CPUState *cpu, struct vmx_segment *vmx_seg,
                      SegmentCache *qseg, bool is_tr)
 {
@@ -437,7 +436,7 @@ int hvf_process_events(CPUState *cpu_state)
     env->eflags = rreg(cpu_state->hvf_fd, HV_X86_RFLAGS);
 
     if (cpu_state->interrupt_request & CPU_INTERRUPT_INIT) {
-        hvf_cpu_synchronize_state(cpu_state);
+        cpu_synchronize_state(cpu_state);
         do_cpu_init(cpu);
     }
 
@@ -451,12 +450,12 @@ int hvf_process_events(CPUState *cpu_state)
         cpu_state->halted = 0;
     }
     if (cpu_state->interrupt_request & CPU_INTERRUPT_SIPI) {
-        hvf_cpu_synchronize_state(cpu_state);
+        cpu_synchronize_state(cpu_state);
         do_cpu_sipi(cpu);
     }
     if (cpu_state->interrupt_request & CPU_INTERRUPT_TPR) {
         cpu_state->interrupt_request &= ~CPU_INTERRUPT_TPR;
-        hvf_cpu_synchronize_state(cpu_state);
+        cpu_synchronize_state(cpu_state);
         apic_handle_tpr_access_report(cpu->apic_state, env->eip,
                                       env->tpr_access_type);
     }

From 653cc15628d7742630565feba636b3e5130da915 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:43 +0200
Subject: [PATCH 054/180] hvf: Make synchronize functions static

The hvf accel synchronize functions are only used as input for local
callback functions, so we can make them static.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-10-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 6 +++---
 accel/hvf/hvf-accel-ops.h | 3 ---
 2 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 3b599ac57ce0..69741ce7081d 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -214,7 +214,7 @@ static void do_hvf_cpu_synchronize_post_reset(CPUState *cpu,
     cpu->vcpu_dirty = false;
 }
 
-void hvf_cpu_synchronize_post_reset(CPUState *cpu)
+static void hvf_cpu_synchronize_post_reset(CPUState *cpu)
 {
     run_on_cpu(cpu, do_hvf_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
 }
@@ -226,7 +226,7 @@ static void do_hvf_cpu_synchronize_post_init(CPUState *cpu,
     cpu->vcpu_dirty = false;
 }
 
-void hvf_cpu_synchronize_post_init(CPUState *cpu)
+static void hvf_cpu_synchronize_post_init(CPUState *cpu)
 {
     run_on_cpu(cpu, do_hvf_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
 }
@@ -237,7 +237,7 @@ static void do_hvf_cpu_synchronize_pre_loadvm(CPUState *cpu,
     cpu->vcpu_dirty = true;
 }
 
-void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
+static void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
     run_on_cpu(cpu, do_hvf_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
 }
diff --git a/accel/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
index f6192b56f0c7..018a4e22f6dc 100644
--- a/accel/hvf/hvf-accel-ops.h
+++ b/accel/hvf/hvf-accel-ops.h
@@ -13,8 +13,5 @@
 #include "sysemu/cpus.h"
 
 int hvf_vcpu_exec(CPUState *);
-void hvf_cpu_synchronize_post_reset(CPUState *);
-void hvf_cpu_synchronize_post_init(CPUState *);
-void hvf_cpu_synchronize_pre_loadvm(CPUState *);
 
 #endif /* HVF_CPUS_H */

From c803fc9d7d6f5f62a9ad49560db22f24e40ee1b3 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:44 +0200
Subject: [PATCH 055/180] hvf: Remove hvf-accel-ops.h

We can move the definition of hvf_vcpu_exec() into our internal
hvf header, obsoleting the need for hvf-accel-ops.h.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-11-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c |  2 --
 accel/hvf/hvf-accel-ops.h | 17 -----------------
 include/sysemu/hvf_int.h  |  1 +
 target/i386/hvf/hvf.c     |  2 --
 4 files changed, 1 insertion(+), 21 deletions(-)
 delete mode 100644 accel/hvf/hvf-accel-ops.h

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 69741ce7081d..14fc49791e34 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -58,8 +58,6 @@
 #include "sysemu/runstate.h"
 #include "qemu/guest-random.h"
 
-#include "hvf-accel-ops.h"
-
 HVFState *hvf_state;
 
 /* Memory slots */
diff --git a/accel/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
deleted file mode 100644
index 018a4e22f6dc..000000000000
--- a/accel/hvf/hvf-accel-ops.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * Accelerator CPUS Interface
- *
- * Copyright 2020 SUSE LLC
- *
- * This work is licensed under the terms of the GNU GPL, version 2 or later.
- * See the COPYING file in the top-level directory.
- */
-
-#ifndef HVF_CPUS_H
-#define HVF_CPUS_H
-
-#include "sysemu/cpus.h"
-
-int hvf_vcpu_exec(CPUState *);
-
-#endif /* HVF_CPUS_H */
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 80c1a8f94667..fd1dcaf26e08 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -46,6 +46,7 @@ extern HVFState *hvf_state;
 void assert_hvf_ok(hv_return_t ret);
 int hvf_arch_init_vcpu(CPUState *cpu);
 void hvf_arch_vcpu_destroy(CPUState *cpu);
+int hvf_vcpu_exec(CPUState *);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 int hvf_put_registers(CPUState *);
 int hvf_get_registers(CPUState *);
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index a7654681c714..e985967b892f 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -74,8 +74,6 @@
 #include "qemu/accel.h"
 #include "target/i386/cpu.h"
 
-#include "hvf-accel-ops.h"
-
 void vmx_update_tpr(CPUState *cpu)
 {
     /* TODO: need integrate APIC handling */

From a6bff5ccc82bb0885e2940fe56ae90b973b948bd Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:45 +0200
Subject: [PATCH 056/180] hvf: Introduce hvf vcpu struct
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We will need more than a single field for hvf going forward. To keep
the global vcpu struct uncluttered, let's allocate a special hvf vcpu
struct, similar to how hax does it.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reviewed-by: Roman Bolshakov <r.bolshakov@yadro.com>
Tested-by: Roman Bolshakov <r.bolshakov@yadro.com>
Reviewed-by: Alex Bennée <alex.bennee@linaro.org>

Message-Id: <20210519202253.76782-12-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c   |   8 +-
 include/hw/core/cpu.h       |   3 +-
 include/sysemu/hvf_int.h    |   4 +
 target/i386/hvf/hvf.c       | 104 +++++++++---------
 target/i386/hvf/vmx.h       |  24 +++--
 target/i386/hvf/x86.c       |  28 ++---
 target/i386/hvf/x86_descr.c |  26 ++---
 target/i386/hvf/x86_emu.c   |  62 +++++------
 target/i386/hvf/x86_mmu.c   |   4 +-
 target/i386/hvf/x86_task.c  |  12 +--
 target/i386/hvf/x86hvf.c    | 210 ++++++++++++++++++------------------
 11 files changed, 248 insertions(+), 237 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 14fc49791e34..ded918c443d9 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -363,16 +363,20 @@ type_init(hvf_type_init);
 
 static void hvf_vcpu_destroy(CPUState *cpu)
 {
-    hv_return_t ret = hv_vcpu_destroy(cpu->hvf_fd);
+    hv_return_t ret = hv_vcpu_destroy(cpu->hvf->fd);
     assert_hvf_ok(ret);
 
     hvf_arch_vcpu_destroy(cpu);
+    g_free(cpu->hvf);
+    cpu->hvf = NULL;
 }
 
 static int hvf_init_vcpu(CPUState *cpu)
 {
     int r;
 
+    cpu->hvf = g_malloc0(sizeof(*cpu->hvf));
+
     /* init cpu signals */
     sigset_t set;
     struct sigaction sigact;
@@ -384,7 +388,7 @@ static int hvf_init_vcpu(CPUState *cpu)
     pthread_sigmask(SIG_BLOCK, NULL, &set);
     sigdelset(&set, SIG_IPI);
 
-    r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf_fd, HV_VCPU_DEFAULT);
+    r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf->fd, HV_VCPU_DEFAULT);
     cpu->vcpu_dirty = 1;
     assert_hvf_ok(r);
 
diff --git a/include/hw/core/cpu.h b/include/hw/core/cpu.h
index c68bc3ba8aff..f93fee54169b 100644
--- a/include/hw/core/cpu.h
+++ b/include/hw/core/cpu.h
@@ -245,6 +245,7 @@ struct KVMState;
 struct kvm_run;
 
 struct hax_vcpu_state;
+struct hvf_vcpu_state;
 
 #define TB_JMP_CACHE_BITS 12
 #define TB_JMP_CACHE_SIZE (1 << TB_JMP_CACHE_BITS)
@@ -430,7 +431,7 @@ struct CPUState {
 
     struct hax_vcpu_state *hax_vcpu;
 
-    int hvf_fd;
+    struct hvf_vcpu_state *hvf;
 
     /* track IOMMUs whose translations we've cached in the TCG TLB */
     GArray *iommu_notifiers;
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index fd1dcaf26e08..8b66a4e7d0dc 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -43,6 +43,10 @@ struct HVFState {
 };
 extern HVFState *hvf_state;
 
+struct hvf_vcpu_state {
+    int fd;
+};
+
 void assert_hvf_ok(hv_return_t ret);
 int hvf_arch_init_vcpu(CPUState *cpu);
 void hvf_arch_vcpu_destroy(CPUState *cpu);
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index e985967b892f..be21ce4db1a4 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -81,11 +81,11 @@ void vmx_update_tpr(CPUState *cpu)
     int tpr = cpu_get_apic_tpr(x86_cpu->apic_state) << 4;
     int irr = apic_get_highest_priority_irr(x86_cpu->apic_state);
 
-    wreg(cpu->hvf_fd, HV_X86_TPR, tpr);
+    wreg(cpu->hvf->fd, HV_X86_TPR, tpr);
     if (irr == -1) {
-        wvmcs(cpu->hvf_fd, VMCS_TPR_THRESHOLD, 0);
+        wvmcs(cpu->hvf->fd, VMCS_TPR_THRESHOLD, 0);
     } else {
-        wvmcs(cpu->hvf_fd, VMCS_TPR_THRESHOLD, (irr > tpr) ? tpr >> 4 :
+        wvmcs(cpu->hvf->fd, VMCS_TPR_THRESHOLD, (irr > tpr) ? tpr >> 4 :
               irr >> 4);
     }
 }
@@ -93,7 +93,7 @@ void vmx_update_tpr(CPUState *cpu)
 static void update_apic_tpr(CPUState *cpu)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
-    int tpr = rreg(cpu->hvf_fd, HV_X86_TPR) >> 4;
+    int tpr = rreg(cpu->hvf->fd, HV_X86_TPR) >> 4;
     cpu_set_apic_tpr(x86_cpu->apic_state, tpr);
 }
 
@@ -245,43 +245,43 @@ int hvf_arch_init_vcpu(CPUState *cpu)
     }
 
     /* set VMCS control fields */
-    wvmcs(cpu->hvf_fd, VMCS_PIN_BASED_CTLS,
+    wvmcs(cpu->hvf->fd, VMCS_PIN_BASED_CTLS,
           cap2ctrl(hvf_state->hvf_caps->vmx_cap_pinbased,
           VMCS_PIN_BASED_CTLS_EXTINT |
           VMCS_PIN_BASED_CTLS_NMI |
           VMCS_PIN_BASED_CTLS_VNMI));
-    wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS,
+    wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS,
           cap2ctrl(hvf_state->hvf_caps->vmx_cap_procbased,
           VMCS_PRI_PROC_BASED_CTLS_HLT |
           VMCS_PRI_PROC_BASED_CTLS_MWAIT |
           VMCS_PRI_PROC_BASED_CTLS_TSC_OFFSET |
           VMCS_PRI_PROC_BASED_CTLS_TPR_SHADOW) |
           VMCS_PRI_PROC_BASED_CTLS_SEC_CONTROL);
-    wvmcs(cpu->hvf_fd, VMCS_SEC_PROC_BASED_CTLS,
+    wvmcs(cpu->hvf->fd, VMCS_SEC_PROC_BASED_CTLS,
           cap2ctrl(hvf_state->hvf_caps->vmx_cap_procbased2,
                    VMCS_PRI_PROC_BASED2_CTLS_APIC_ACCESSES));
 
-    wvmcs(cpu->hvf_fd, VMCS_ENTRY_CTLS, cap2ctrl(hvf_state->hvf_caps->vmx_cap_entry,
+    wvmcs(cpu->hvf->fd, VMCS_ENTRY_CTLS, cap2ctrl(hvf_state->hvf_caps->vmx_cap_entry,
           0));
-    wvmcs(cpu->hvf_fd, VMCS_EXCEPTION_BITMAP, 0); /* Double fault */
+    wvmcs(cpu->hvf->fd, VMCS_EXCEPTION_BITMAP, 0); /* Double fault */
 
-    wvmcs(cpu->hvf_fd, VMCS_TPR_THRESHOLD, 0);
+    wvmcs(cpu->hvf->fd, VMCS_TPR_THRESHOLD, 0);
 
     x86cpu = X86_CPU(cpu);
     x86cpu->env.xsave_buf = qemu_memalign(4096, 4096);
 
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_STAR, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_LSTAR, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_CSTAR, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_FMASK, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_FSBASE, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_GSBASE, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_KERNELGSBASE, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_TSC_AUX, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_IA32_TSC, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_IA32_SYSENTER_CS, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_IA32_SYSENTER_EIP, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_IA32_SYSENTER_ESP, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_STAR, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_LSTAR, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_CSTAR, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_FMASK, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_FSBASE, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_GSBASE, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_KERNELGSBASE, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_TSC_AUX, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_IA32_TSC, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_IA32_SYSENTER_CS, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_IA32_SYSENTER_EIP, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_IA32_SYSENTER_ESP, 1);
 
     return 0;
 }
@@ -322,16 +322,16 @@ static void hvf_store_events(CPUState *cpu, uint32_t ins_len, uint64_t idtvec_in
         }
         if (idtvec_info & VMCS_IDT_VEC_ERRCODE_VALID) {
             env->has_error_code = true;
-            env->error_code = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_ERROR);
+            env->error_code = rvmcs(cpu->hvf->fd, VMCS_IDT_VECTORING_ERROR);
         }
     }
-    if ((rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY) &
+    if ((rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY) &
         VMCS_INTERRUPTIBILITY_NMI_BLOCKING)) {
         env->hflags2 |= HF2_NMI_MASK;
     } else {
         env->hflags2 &= ~HF2_NMI_MASK;
     }
-    if (rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY) &
+    if (rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY) &
          (VMCS_INTERRUPTIBILITY_STI_BLOCKING |
          VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING)) {
         env->hflags |= HF_INHIBIT_IRQ_MASK;
@@ -410,20 +410,20 @@ int hvf_vcpu_exec(CPUState *cpu)
             return EXCP_HLT;
         }
 
-        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);
+        hv_return_t r  = hv_vcpu_run(cpu->hvf->fd);
         assert_hvf_ok(r);
 
         /* handle VMEXIT */
-        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);
-        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);
-        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,
+        uint64_t exit_reason = rvmcs(cpu->hvf->fd, VMCS_EXIT_REASON);
+        uint64_t exit_qual = rvmcs(cpu->hvf->fd, VMCS_EXIT_QUALIFICATION);
+        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf->fd,
                                            VMCS_EXIT_INSTRUCTION_LENGTH);
 
-        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);
+        uint64_t idtvec_info = rvmcs(cpu->hvf->fd, VMCS_IDT_VECTORING_INFO);
 
         hvf_store_events(cpu, ins_len, idtvec_info);
-        rip = rreg(cpu->hvf_fd, HV_X86_RIP);
-        env->eflags = rreg(cpu->hvf_fd, HV_X86_RFLAGS);
+        rip = rreg(cpu->hvf->fd, HV_X86_RIP);
+        env->eflags = rreg(cpu->hvf->fd, HV_X86_RFLAGS);
 
         qemu_mutex_lock_iothread();
 
@@ -453,7 +453,7 @@ int hvf_vcpu_exec(CPUState *cpu)
         case EXIT_REASON_EPT_FAULT:
         {
             hvf_slot *slot;
-            uint64_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);
+            uint64_t gpa = rvmcs(cpu->hvf->fd, VMCS_GUEST_PHYSICAL_ADDRESS);
 
             if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&
                 ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {
@@ -498,7 +498,7 @@ int hvf_vcpu_exec(CPUState *cpu)
                 store_regs(cpu);
                 break;
             } else if (!string && !in) {
-                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);
+                RAX(env) = rreg(cpu->hvf->fd, HV_X86_RAX);
                 hvf_handle_io(env, port, &RAX(env), 1, size, 1);
                 macvm_set_rip(cpu, rip + ins_len);
                 break;
@@ -514,21 +514,21 @@ int hvf_vcpu_exec(CPUState *cpu)
             break;
         }
         case EXIT_REASON_CPUID: {
-            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);
-            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);
-            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);
-            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);
+            uint32_t rax = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RAX);
+            uint32_t rbx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RBX);
+            uint32_t rcx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RCX);
+            uint32_t rdx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RDX);
 
             if (rax == 1) {
                 /* CPUID1.ecx.OSXSAVE needs to know CR4 */
-                env->cr[4] = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR4);
+                env->cr[4] = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR4);
             }
             hvf_cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);
 
-            wreg(cpu->hvf_fd, HV_X86_RAX, rax);
-            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);
-            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);
-            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);
+            wreg(cpu->hvf->fd, HV_X86_RAX, rax);
+            wreg(cpu->hvf->fd, HV_X86_RBX, rbx);
+            wreg(cpu->hvf->fd, HV_X86_RCX, rcx);
+            wreg(cpu->hvf->fd, HV_X86_RDX, rdx);
 
             macvm_set_rip(cpu, rip + ins_len);
             break;
@@ -536,16 +536,16 @@ int hvf_vcpu_exec(CPUState *cpu)
         case EXIT_REASON_XSETBV: {
             X86CPU *x86_cpu = X86_CPU(cpu);
             CPUX86State *env = &x86_cpu->env;
-            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);
-            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);
-            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);
+            uint32_t eax = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RAX);
+            uint32_t ecx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RCX);
+            uint32_t edx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RDX);
 
             if (ecx) {
                 macvm_set_rip(cpu, rip + ins_len);
                 break;
             }
             env->xcr0 = ((uint64_t)edx << 32) | eax;
-            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);
+            wreg(cpu->hvf->fd, HV_X86_XCR0, env->xcr0 | 1);
             macvm_set_rip(cpu, rip + ins_len);
             break;
         }
@@ -584,11 +584,11 @@ int hvf_vcpu_exec(CPUState *cpu)
 
             switch (cr) {
             case 0x0: {
-                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));
+                macvm_set_cr0(cpu->hvf->fd, RRX(env, reg));
                 break;
             }
             case 4: {
-                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));
+                macvm_set_cr4(cpu->hvf->fd, RRX(env, reg));
                 break;
             }
             case 8: {
@@ -624,7 +624,7 @@ int hvf_vcpu_exec(CPUState *cpu)
             break;
         }
         case EXIT_REASON_TASK_SWITCH: {
-            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);
+            uint64_t vinfo = rvmcs(cpu->hvf->fd, VMCS_IDT_VECTORING_INFO);
             x68_segment_selector sel = {.sel = exit_qual & 0xffff};
             vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,
              vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo
@@ -637,8 +637,8 @@ int hvf_vcpu_exec(CPUState *cpu)
             break;
         }
         case EXIT_REASON_RDPMC:
-            wreg(cpu->hvf_fd, HV_X86_RAX, 0);
-            wreg(cpu->hvf_fd, HV_X86_RDX, 0);
+            wreg(cpu->hvf->fd, HV_X86_RAX, 0);
+            wreg(cpu->hvf->fd, HV_X86_RDX, 0);
             macvm_set_rip(cpu, rip + ins_len);
             break;
         case VMX_REASON_VMCALL:
diff --git a/target/i386/hvf/vmx.h b/target/i386/hvf/vmx.h
index 24c4cdf0be0c..6df87116f62f 100644
--- a/target/i386/hvf/vmx.h
+++ b/target/i386/hvf/vmx.h
@@ -30,6 +30,8 @@
 #include "vmcs.h"
 #include "cpu.h"
 #include "x86.h"
+#include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
 
 #include "exec/address-spaces.h"
 
@@ -179,15 +181,15 @@ static inline void macvm_set_rip(CPUState *cpu, uint64_t rip)
     uint64_t val;
 
     /* BUG, should take considering overlap.. */
-    wreg(cpu->hvf_fd, HV_X86_RIP, rip);
+    wreg(cpu->hvf->fd, HV_X86_RIP, rip);
     env->eip = rip;
 
     /* after moving forward in rip, we need to clean INTERRUPTABILITY */
-   val = rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY);
+   val = rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY);
    if (val & (VMCS_INTERRUPTIBILITY_STI_BLOCKING |
                VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING)) {
         env->hflags &= ~HF_INHIBIT_IRQ_MASK;
-        wvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY,
+        wvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY,
                val & ~(VMCS_INTERRUPTIBILITY_STI_BLOCKING |
                VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING));
    }
@@ -199,9 +201,9 @@ static inline void vmx_clear_nmi_blocking(CPUState *cpu)
     CPUX86State *env = &x86_cpu->env;
 
     env->hflags2 &= ~HF2_NMI_MASK;
-    uint32_t gi = (uint32_t) rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY);
+    uint32_t gi = (uint32_t) rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY);
     gi &= ~VMCS_INTERRUPTIBILITY_NMI_BLOCKING;
-    wvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY, gi);
+    wvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY, gi);
 }
 
 static inline void vmx_set_nmi_blocking(CPUState *cpu)
@@ -210,16 +212,16 @@ static inline void vmx_set_nmi_blocking(CPUState *cpu)
     CPUX86State *env = &x86_cpu->env;
 
     env->hflags2 |= HF2_NMI_MASK;
-    uint32_t gi = (uint32_t)rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY);
+    uint32_t gi = (uint32_t)rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY);
     gi |= VMCS_INTERRUPTIBILITY_NMI_BLOCKING;
-    wvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY, gi);
+    wvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY, gi);
 }
 
 static inline void vmx_set_nmi_window_exiting(CPUState *cpu)
 {
     uint64_t val;
-    val = rvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS);
-    wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS, val |
+    val = rvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS);
+    wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS, val |
           VMCS_PRI_PROC_BASED_CTLS_NMI_WINDOW_EXITING);
 
 }
@@ -228,8 +230,8 @@ static inline void vmx_clear_nmi_window_exiting(CPUState *cpu)
 {
 
     uint64_t val;
-    val = rvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS);
-    wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS, val &
+    val = rvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS);
+    wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS, val &
           ~VMCS_PRI_PROC_BASED_CTLS_NMI_WINDOW_EXITING);
 }
 
diff --git a/target/i386/hvf/x86.c b/target/i386/hvf/x86.c
index cd045183a811..2898bb70a84e 100644
--- a/target/i386/hvf/x86.c
+++ b/target/i386/hvf/x86.c
@@ -62,11 +62,11 @@ bool x86_read_segment_descriptor(struct CPUState *cpu,
     }
 
     if (GDT_SEL == sel.ti) {
-        base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_GDTR_BASE);
-        limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_GDTR_LIMIT);
+        base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_GDTR_BASE);
+        limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_GDTR_LIMIT);
     } else {
-        base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_LDTR_BASE);
-        limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_LDTR_LIMIT);
+        base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_LDTR_BASE);
+        limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_LDTR_LIMIT);
     }
 
     if (sel.index * 8 >= limit) {
@@ -85,11 +85,11 @@ bool x86_write_segment_descriptor(struct CPUState *cpu,
     uint32_t limit;
     
     if (GDT_SEL == sel.ti) {
-        base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_GDTR_BASE);
-        limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_GDTR_LIMIT);
+        base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_GDTR_BASE);
+        limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_GDTR_LIMIT);
     } else {
-        base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_LDTR_BASE);
-        limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_LDTR_LIMIT);
+        base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_LDTR_BASE);
+        limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_LDTR_LIMIT);
     }
     
     if (sel.index * 8 >= limit) {
@@ -103,8 +103,8 @@ bool x86_write_segment_descriptor(struct CPUState *cpu,
 bool x86_read_call_gate(struct CPUState *cpu, struct x86_call_gate *idt_desc,
                         int gate)
 {
-    target_ulong base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_IDTR_BASE);
-    uint32_t limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_IDTR_LIMIT);
+    target_ulong base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_IDTR_BASE);
+    uint32_t limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_IDTR_LIMIT);
 
     memset(idt_desc, 0, sizeof(*idt_desc));
     if (gate * 8 >= limit) {
@@ -118,7 +118,7 @@ bool x86_read_call_gate(struct CPUState *cpu, struct x86_call_gate *idt_desc,
 
 bool x86_is_protected(struct CPUState *cpu)
 {
-    uint64_t cr0 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR0);
+    uint64_t cr0 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR0);
     return cr0 & CR0_PE;
 }
 
@@ -136,7 +136,7 @@ bool x86_is_v8086(struct CPUState *cpu)
 
 bool x86_is_long_mode(struct CPUState *cpu)
 {
-    return rvmcs(cpu->hvf_fd, VMCS_GUEST_IA32_EFER) & MSR_EFER_LMA;
+    return rvmcs(cpu->hvf->fd, VMCS_GUEST_IA32_EFER) & MSR_EFER_LMA;
 }
 
 bool x86_is_long64_mode(struct CPUState *cpu)
@@ -149,13 +149,13 @@ bool x86_is_long64_mode(struct CPUState *cpu)
 
 bool x86_is_paging_mode(struct CPUState *cpu)
 {
-    uint64_t cr0 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR0);
+    uint64_t cr0 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR0);
     return cr0 & CR0_PG;
 }
 
 bool x86_is_pae_enabled(struct CPUState *cpu)
 {
-    uint64_t cr4 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR4);
+    uint64_t cr4 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR4);
     return cr4 & CR4_PAE;
 }
 
diff --git a/target/i386/hvf/x86_descr.c b/target/i386/hvf/x86_descr.c
index 9f539e73f6dd..af15c06ac5db 100644
--- a/target/i386/hvf/x86_descr.c
+++ b/target/i386/hvf/x86_descr.c
@@ -48,47 +48,47 @@ static const struct vmx_segment_field {
 
 uint32_t vmx_read_segment_limit(CPUState *cpu, X86Seg seg)
 {
-    return (uint32_t)rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].limit);
+    return (uint32_t)rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].limit);
 }
 
 uint32_t vmx_read_segment_ar(CPUState *cpu, X86Seg seg)
 {
-    return (uint32_t)rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].ar_bytes);
+    return (uint32_t)rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].ar_bytes);
 }
 
 uint64_t vmx_read_segment_base(CPUState *cpu, X86Seg seg)
 {
-    return rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].base);
+    return rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].base);
 }
 
 x68_segment_selector vmx_read_segment_selector(CPUState *cpu, X86Seg seg)
 {
     x68_segment_selector sel;
-    sel.sel = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].selector);
+    sel.sel = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].selector);
     return sel;
 }
 
 void vmx_write_segment_selector(struct CPUState *cpu, x68_segment_selector selector, X86Seg seg)
 {
-    wvmcs(cpu->hvf_fd, vmx_segment_fields[seg].selector, selector.sel);
+    wvmcs(cpu->hvf->fd, vmx_segment_fields[seg].selector, selector.sel);
 }
 
 void vmx_read_segment_descriptor(struct CPUState *cpu, struct vmx_segment *desc, X86Seg seg)
 {
-    desc->sel = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].selector);
-    desc->base = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].base);
-    desc->limit = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].limit);
-    desc->ar = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].ar_bytes);
+    desc->sel = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].selector);
+    desc->base = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].base);
+    desc->limit = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].limit);
+    desc->ar = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].ar_bytes);
 }
 
 void vmx_write_segment_descriptor(CPUState *cpu, struct vmx_segment *desc, X86Seg seg)
 {
     const struct vmx_segment_field *sf = &vmx_segment_fields[seg];
 
-    wvmcs(cpu->hvf_fd, sf->base, desc->base);
-    wvmcs(cpu->hvf_fd, sf->limit, desc->limit);
-    wvmcs(cpu->hvf_fd, sf->selector, desc->sel);
-    wvmcs(cpu->hvf_fd, sf->ar_bytes, desc->ar);
+    wvmcs(cpu->hvf->fd, sf->base, desc->base);
+    wvmcs(cpu->hvf->fd, sf->limit, desc->limit);
+    wvmcs(cpu->hvf->fd, sf->selector, desc->sel);
+    wvmcs(cpu->hvf->fd, sf->ar_bytes, desc->ar);
 }
 
 void x86_segment_descriptor_to_vmx(struct CPUState *cpu, x68_segment_selector selector, struct x86_segment_descriptor *desc, struct vmx_segment *vmx_desc)
diff --git a/target/i386/hvf/x86_emu.c b/target/i386/hvf/x86_emu.c
index e52c39ddb1f0..7c8203b21fb9 100644
--- a/target/i386/hvf/x86_emu.c
+++ b/target/i386/hvf/x86_emu.c
@@ -674,7 +674,7 @@ void simulate_rdmsr(struct CPUState *cpu)
 
     switch (msr) {
     case MSR_IA32_TSC:
-        val = rdtscp() + rvmcs(cpu->hvf_fd, VMCS_TSC_OFFSET);
+        val = rdtscp() + rvmcs(cpu->hvf->fd, VMCS_TSC_OFFSET);
         break;
     case MSR_IA32_APICBASE:
         val = cpu_get_apic_base(X86_CPU(cpu)->apic_state);
@@ -683,16 +683,16 @@ void simulate_rdmsr(struct CPUState *cpu)
         val = x86_cpu->ucode_rev;
         break;
     case MSR_EFER:
-        val = rvmcs(cpu->hvf_fd, VMCS_GUEST_IA32_EFER);
+        val = rvmcs(cpu->hvf->fd, VMCS_GUEST_IA32_EFER);
         break;
     case MSR_FSBASE:
-        val = rvmcs(cpu->hvf_fd, VMCS_GUEST_FS_BASE);
+        val = rvmcs(cpu->hvf->fd, VMCS_GUEST_FS_BASE);
         break;
     case MSR_GSBASE:
-        val = rvmcs(cpu->hvf_fd, VMCS_GUEST_GS_BASE);
+        val = rvmcs(cpu->hvf->fd, VMCS_GUEST_GS_BASE);
         break;
     case MSR_KERNELGSBASE:
-        val = rvmcs(cpu->hvf_fd, VMCS_HOST_FS_BASE);
+        val = rvmcs(cpu->hvf->fd, VMCS_HOST_FS_BASE);
         break;
     case MSR_STAR:
         abort();
@@ -780,13 +780,13 @@ void simulate_wrmsr(struct CPUState *cpu)
         cpu_set_apic_base(X86_CPU(cpu)->apic_state, data);
         break;
     case MSR_FSBASE:
-        wvmcs(cpu->hvf_fd, VMCS_GUEST_FS_BASE, data);
+        wvmcs(cpu->hvf->fd, VMCS_GUEST_FS_BASE, data);
         break;
     case MSR_GSBASE:
-        wvmcs(cpu->hvf_fd, VMCS_GUEST_GS_BASE, data);
+        wvmcs(cpu->hvf->fd, VMCS_GUEST_GS_BASE, data);
         break;
     case MSR_KERNELGSBASE:
-        wvmcs(cpu->hvf_fd, VMCS_HOST_FS_BASE, data);
+        wvmcs(cpu->hvf->fd, VMCS_HOST_FS_BASE, data);
         break;
     case MSR_STAR:
         abort();
@@ -799,9 +799,9 @@ void simulate_wrmsr(struct CPUState *cpu)
         break;
     case MSR_EFER:
         /*printf("new efer %llx\n", EFER(cpu));*/
-        wvmcs(cpu->hvf_fd, VMCS_GUEST_IA32_EFER, data);
+        wvmcs(cpu->hvf->fd, VMCS_GUEST_IA32_EFER, data);
         if (data & MSR_EFER_NXE) {
-            hv_vcpu_invalidate_tlb(cpu->hvf_fd);
+            hv_vcpu_invalidate_tlb(cpu->hvf->fd);
         }
         break;
     case MSR_MTRRphysBase(0):
@@ -1425,21 +1425,21 @@ void load_regs(struct CPUState *cpu)
     CPUX86State *env = &x86_cpu->env;
 
     int i = 0;
-    RRX(env, R_EAX) = rreg(cpu->hvf_fd, HV_X86_RAX);
-    RRX(env, R_EBX) = rreg(cpu->hvf_fd, HV_X86_RBX);
-    RRX(env, R_ECX) = rreg(cpu->hvf_fd, HV_X86_RCX);
-    RRX(env, R_EDX) = rreg(cpu->hvf_fd, HV_X86_RDX);
-    RRX(env, R_ESI) = rreg(cpu->hvf_fd, HV_X86_RSI);
-    RRX(env, R_EDI) = rreg(cpu->hvf_fd, HV_X86_RDI);
-    RRX(env, R_ESP) = rreg(cpu->hvf_fd, HV_X86_RSP);
-    RRX(env, R_EBP) = rreg(cpu->hvf_fd, HV_X86_RBP);
+    RRX(env, R_EAX) = rreg(cpu->hvf->fd, HV_X86_RAX);
+    RRX(env, R_EBX) = rreg(cpu->hvf->fd, HV_X86_RBX);
+    RRX(env, R_ECX) = rreg(cpu->hvf->fd, HV_X86_RCX);
+    RRX(env, R_EDX) = rreg(cpu->hvf->fd, HV_X86_RDX);
+    RRX(env, R_ESI) = rreg(cpu->hvf->fd, HV_X86_RSI);
+    RRX(env, R_EDI) = rreg(cpu->hvf->fd, HV_X86_RDI);
+    RRX(env, R_ESP) = rreg(cpu->hvf->fd, HV_X86_RSP);
+    RRX(env, R_EBP) = rreg(cpu->hvf->fd, HV_X86_RBP);
     for (i = 8; i < 16; i++) {
-        RRX(env, i) = rreg(cpu->hvf_fd, HV_X86_RAX + i);
+        RRX(env, i) = rreg(cpu->hvf->fd, HV_X86_RAX + i);
     }
 
-    env->eflags = rreg(cpu->hvf_fd, HV_X86_RFLAGS);
+    env->eflags = rreg(cpu->hvf->fd, HV_X86_RFLAGS);
     rflags_to_lflags(env);
-    env->eip = rreg(cpu->hvf_fd, HV_X86_RIP);
+    env->eip = rreg(cpu->hvf->fd, HV_X86_RIP);
 }
 
 void store_regs(struct CPUState *cpu)
@@ -1448,20 +1448,20 @@ void store_regs(struct CPUState *cpu)
     CPUX86State *env = &x86_cpu->env;
 
     int i = 0;
-    wreg(cpu->hvf_fd, HV_X86_RAX, RAX(env));
-    wreg(cpu->hvf_fd, HV_X86_RBX, RBX(env));
-    wreg(cpu->hvf_fd, HV_X86_RCX, RCX(env));
-    wreg(cpu->hvf_fd, HV_X86_RDX, RDX(env));
-    wreg(cpu->hvf_fd, HV_X86_RSI, RSI(env));
-    wreg(cpu->hvf_fd, HV_X86_RDI, RDI(env));
-    wreg(cpu->hvf_fd, HV_X86_RBP, RBP(env));
-    wreg(cpu->hvf_fd, HV_X86_RSP, RSP(env));
+    wreg(cpu->hvf->fd, HV_X86_RAX, RAX(env));
+    wreg(cpu->hvf->fd, HV_X86_RBX, RBX(env));
+    wreg(cpu->hvf->fd, HV_X86_RCX, RCX(env));
+    wreg(cpu->hvf->fd, HV_X86_RDX, RDX(env));
+    wreg(cpu->hvf->fd, HV_X86_RSI, RSI(env));
+    wreg(cpu->hvf->fd, HV_X86_RDI, RDI(env));
+    wreg(cpu->hvf->fd, HV_X86_RBP, RBP(env));
+    wreg(cpu->hvf->fd, HV_X86_RSP, RSP(env));
     for (i = 8; i < 16; i++) {
-        wreg(cpu->hvf_fd, HV_X86_RAX + i, RRX(env, i));
+        wreg(cpu->hvf->fd, HV_X86_RAX + i, RRX(env, i));
     }
 
     lflags_to_rflags(env);
-    wreg(cpu->hvf_fd, HV_X86_RFLAGS, env->eflags);
+    wreg(cpu->hvf->fd, HV_X86_RFLAGS, env->eflags);
     macvm_set_rip(cpu, env->eip);
 }
 
diff --git a/target/i386/hvf/x86_mmu.c b/target/i386/hvf/x86_mmu.c
index 882a6237eea3..b7e3f8568f68 100644
--- a/target/i386/hvf/x86_mmu.c
+++ b/target/i386/hvf/x86_mmu.c
@@ -128,7 +128,7 @@ static bool test_pt_entry(struct CPUState *cpu, struct gpt_translation *pt,
         pt->err_code |= MMU_PAGE_PT;
     }
 
-    uint32_t cr0 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR0);
+    uint32_t cr0 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR0);
     /* check protection */
     if (cr0 & CR0_WP) {
         if (pt->write_access && !pte_write_access(pte)) {
@@ -173,7 +173,7 @@ static bool walk_gpt(struct CPUState *cpu, target_ulong addr, int err_code,
 {
     int top_level, level;
     bool is_large = false;
-    target_ulong cr3 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR3);
+    target_ulong cr3 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR3);
     uint64_t page_mask = pae ? PAE_PTE_PAGE_MASK : LEGACY_PTE_PAGE_MASK;
     
     memset(pt, 0, sizeof(*pt));
diff --git a/target/i386/hvf/x86_task.c b/target/i386/hvf/x86_task.c
index d66dfd766902..422156128b7a 100644
--- a/target/i386/hvf/x86_task.c
+++ b/target/i386/hvf/x86_task.c
@@ -62,7 +62,7 @@ static void load_state_from_tss32(CPUState *cpu, struct x86_tss_segment32 *tss)
     X86CPU *x86_cpu = X86_CPU(cpu);
     CPUX86State *env = &x86_cpu->env;
 
-    wvmcs(cpu->hvf_fd, VMCS_GUEST_CR3, tss->cr3);
+    wvmcs(cpu->hvf->fd, VMCS_GUEST_CR3, tss->cr3);
 
     env->eip = tss->eip;
     env->eflags = tss->eflags | 2;
@@ -111,11 +111,11 @@ static int task_switch_32(CPUState *cpu, x68_segment_selector tss_sel, x68_segme
 
 void vmx_handle_task_switch(CPUState *cpu, x68_segment_selector tss_sel, int reason, bool gate_valid, uint8_t gate, uint64_t gate_type)
 {
-    uint64_t rip = rreg(cpu->hvf_fd, HV_X86_RIP);
+    uint64_t rip = rreg(cpu->hvf->fd, HV_X86_RIP);
     if (!gate_valid || (gate_type != VMCS_INTR_T_HWEXCEPTION &&
                         gate_type != VMCS_INTR_T_HWINTR &&
                         gate_type != VMCS_INTR_T_NMI)) {
-        int ins_len = rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);
+        int ins_len = rvmcs(cpu->hvf->fd, VMCS_EXIT_INSTRUCTION_LENGTH);
         macvm_set_rip(cpu, rip + ins_len);
         return;
     }
@@ -174,12 +174,12 @@ void vmx_handle_task_switch(CPUState *cpu, x68_segment_selector tss_sel, int rea
         //ret = task_switch_16(cpu, tss_sel, old_tss_sel, old_tss_base, &next_tss_desc);
         VM_PANIC("task_switch_16");
 
-    macvm_set_cr0(cpu->hvf_fd, rvmcs(cpu->hvf_fd, VMCS_GUEST_CR0) | CR0_TS);
+    macvm_set_cr0(cpu->hvf->fd, rvmcs(cpu->hvf->fd, VMCS_GUEST_CR0) | CR0_TS);
     x86_segment_descriptor_to_vmx(cpu, tss_sel, &next_tss_desc, &vmx_seg);
     vmx_write_segment_descriptor(cpu, &vmx_seg, R_TR);
 
     store_regs(cpu);
 
-    hv_vcpu_invalidate_tlb(cpu->hvf_fd);
-    hv_vcpu_flush(cpu->hvf_fd);
+    hv_vcpu_invalidate_tlb(cpu->hvf->fd);
+    hv_vcpu_flush(cpu->hvf->fd);
 }
diff --git a/target/i386/hvf/x86hvf.c b/target/i386/hvf/x86hvf.c
index cc381307ab90..28cfee4f6087 100644
--- a/target/i386/hvf/x86hvf.c
+++ b/target/i386/hvf/x86hvf.c
@@ -80,7 +80,7 @@ void hvf_put_xsave(CPUState *cpu_state)
 
     x86_cpu_xsave_all_areas(X86_CPU(cpu_state), xsave);
 
-    if (hv_vcpu_write_fpstate(cpu_state->hvf_fd, (void*)xsave, 4096)) {
+    if (hv_vcpu_write_fpstate(cpu_state->hvf->fd, (void*)xsave, 4096)) {
         abort();
     }
 }
@@ -90,19 +90,19 @@ void hvf_put_segments(CPUState *cpu_state)
     CPUX86State *env = &X86_CPU(cpu_state)->env;
     struct vmx_segment seg;
     
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_IDTR_LIMIT, env->idt.limit);
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_IDTR_BASE, env->idt.base);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_IDTR_LIMIT, env->idt.limit);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_IDTR_BASE, env->idt.base);
 
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_GDTR_LIMIT, env->gdt.limit);
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_GDTR_BASE, env->gdt.base);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_GDTR_LIMIT, env->gdt.limit);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_GDTR_BASE, env->gdt.base);
 
-    /* wvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR2, env->cr[2]); */
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR3, env->cr[3]);
+    /* wvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR2, env->cr[2]); */
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR3, env->cr[3]);
     vmx_update_tpr(cpu_state);
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_IA32_EFER, env->efer);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_IA32_EFER, env->efer);
 
-    macvm_set_cr4(cpu_state->hvf_fd, env->cr[4]);
-    macvm_set_cr0(cpu_state->hvf_fd, env->cr[0]);
+    macvm_set_cr4(cpu_state->hvf->fd, env->cr[4]);
+    macvm_set_cr0(cpu_state->hvf->fd, env->cr[0]);
 
     hvf_set_segment(cpu_state, &seg, &env->segs[R_CS], false);
     vmx_write_segment_descriptor(cpu_state, &seg, R_CS);
@@ -128,31 +128,31 @@ void hvf_put_segments(CPUState *cpu_state)
     hvf_set_segment(cpu_state, &seg, &env->ldt, false);
     vmx_write_segment_descriptor(cpu_state, &seg, R_LDTR);
     
-    hv_vcpu_flush(cpu_state->hvf_fd);
+    hv_vcpu_flush(cpu_state->hvf->fd);
 }
     
 void hvf_put_msrs(CPUState *cpu_state)
 {
     CPUX86State *env = &X86_CPU(cpu_state)->env;
 
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_CS,
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_CS,
                       env->sysenter_cs);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_ESP,
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_ESP,
                       env->sysenter_esp);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_EIP,
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_EIP,
                       env->sysenter_eip);
 
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_STAR, env->star);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_STAR, env->star);
 
 #ifdef TARGET_X86_64
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_CSTAR, env->cstar);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_KERNELGSBASE, env->kernelgsbase);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_FMASK, env->fmask);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_LSTAR, env->lstar);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_CSTAR, env->cstar);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_KERNELGSBASE, env->kernelgsbase);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_FMASK, env->fmask);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_LSTAR, env->lstar);
 #endif
 
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_GSBASE, env->segs[R_GS].base);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_FSBASE, env->segs[R_FS].base);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_GSBASE, env->segs[R_GS].base);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_FSBASE, env->segs[R_FS].base);
 }
 
 
@@ -162,7 +162,7 @@ void hvf_get_xsave(CPUState *cpu_state)
 
     xsave = X86_CPU(cpu_state)->env.xsave_buf;
 
-    if (hv_vcpu_read_fpstate(cpu_state->hvf_fd, (void*)xsave, 4096)) {
+    if (hv_vcpu_read_fpstate(cpu_state->hvf->fd, (void*)xsave, 4096)) {
         abort();
     }
 
@@ -201,17 +201,17 @@ void hvf_get_segments(CPUState *cpu_state)
     vmx_read_segment_descriptor(cpu_state, &seg, R_LDTR);
     hvf_get_segment(&env->ldt, &seg);
 
-    env->idt.limit = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_IDTR_LIMIT);
-    env->idt.base = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_IDTR_BASE);
-    env->gdt.limit = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_GDTR_LIMIT);
-    env->gdt.base = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_GDTR_BASE);
+    env->idt.limit = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_IDTR_LIMIT);
+    env->idt.base = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_IDTR_BASE);
+    env->gdt.limit = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_GDTR_LIMIT);
+    env->gdt.base = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_GDTR_BASE);
 
-    env->cr[0] = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR0);
+    env->cr[0] = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR0);
     env->cr[2] = 0;
-    env->cr[3] = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR3);
-    env->cr[4] = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR4);
+    env->cr[3] = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR3);
+    env->cr[4] = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR4);
     
-    env->efer = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_IA32_EFER);
+    env->efer = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_IA32_EFER);
 }
 
 void hvf_get_msrs(CPUState *cpu_state)
@@ -219,27 +219,27 @@ void hvf_get_msrs(CPUState *cpu_state)
     CPUX86State *env = &X86_CPU(cpu_state)->env;
     uint64_t tmp;
     
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_CS, &tmp);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_CS, &tmp);
     env->sysenter_cs = tmp;
     
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_ESP, &tmp);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_ESP, &tmp);
     env->sysenter_esp = tmp;
 
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_EIP, &tmp);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_EIP, &tmp);
     env->sysenter_eip = tmp;
 
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_STAR, &env->star);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_STAR, &env->star);
 
 #ifdef TARGET_X86_64
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_CSTAR, &env->cstar);
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_KERNELGSBASE, &env->kernelgsbase);
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_FMASK, &env->fmask);
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_LSTAR, &env->lstar);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_CSTAR, &env->cstar);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_KERNELGSBASE, &env->kernelgsbase);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_FMASK, &env->fmask);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_LSTAR, &env->lstar);
 #endif
 
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_IA32_APICBASE, &tmp);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_IA32_APICBASE, &tmp);
     
-    env->tsc = rdtscp() + rvmcs(cpu_state->hvf_fd, VMCS_TSC_OFFSET);
+    env->tsc = rdtscp() + rvmcs(cpu_state->hvf->fd, VMCS_TSC_OFFSET);
 }
 
 int hvf_put_registers(CPUState *cpu_state)
@@ -247,26 +247,26 @@ int hvf_put_registers(CPUState *cpu_state)
     X86CPU *x86cpu = X86_CPU(cpu_state);
     CPUX86State *env = &x86cpu->env;
 
-    wreg(cpu_state->hvf_fd, HV_X86_RAX, env->regs[R_EAX]);
-    wreg(cpu_state->hvf_fd, HV_X86_RBX, env->regs[R_EBX]);
-    wreg(cpu_state->hvf_fd, HV_X86_RCX, env->regs[R_ECX]);
-    wreg(cpu_state->hvf_fd, HV_X86_RDX, env->regs[R_EDX]);
-    wreg(cpu_state->hvf_fd, HV_X86_RBP, env->regs[R_EBP]);
-    wreg(cpu_state->hvf_fd, HV_X86_RSP, env->regs[R_ESP]);
-    wreg(cpu_state->hvf_fd, HV_X86_RSI, env->regs[R_ESI]);
-    wreg(cpu_state->hvf_fd, HV_X86_RDI, env->regs[R_EDI]);
-    wreg(cpu_state->hvf_fd, HV_X86_R8, env->regs[8]);
-    wreg(cpu_state->hvf_fd, HV_X86_R9, env->regs[9]);
-    wreg(cpu_state->hvf_fd, HV_X86_R10, env->regs[10]);
-    wreg(cpu_state->hvf_fd, HV_X86_R11, env->regs[11]);
-    wreg(cpu_state->hvf_fd, HV_X86_R12, env->regs[12]);
-    wreg(cpu_state->hvf_fd, HV_X86_R13, env->regs[13]);
-    wreg(cpu_state->hvf_fd, HV_X86_R14, env->regs[14]);
-    wreg(cpu_state->hvf_fd, HV_X86_R15, env->regs[15]);
-    wreg(cpu_state->hvf_fd, HV_X86_RFLAGS, env->eflags);
-    wreg(cpu_state->hvf_fd, HV_X86_RIP, env->eip);
+    wreg(cpu_state->hvf->fd, HV_X86_RAX, env->regs[R_EAX]);
+    wreg(cpu_state->hvf->fd, HV_X86_RBX, env->regs[R_EBX]);
+    wreg(cpu_state->hvf->fd, HV_X86_RCX, env->regs[R_ECX]);
+    wreg(cpu_state->hvf->fd, HV_X86_RDX, env->regs[R_EDX]);
+    wreg(cpu_state->hvf->fd, HV_X86_RBP, env->regs[R_EBP]);
+    wreg(cpu_state->hvf->fd, HV_X86_RSP, env->regs[R_ESP]);
+    wreg(cpu_state->hvf->fd, HV_X86_RSI, env->regs[R_ESI]);
+    wreg(cpu_state->hvf->fd, HV_X86_RDI, env->regs[R_EDI]);
+    wreg(cpu_state->hvf->fd, HV_X86_R8, env->regs[8]);
+    wreg(cpu_state->hvf->fd, HV_X86_R9, env->regs[9]);
+    wreg(cpu_state->hvf->fd, HV_X86_R10, env->regs[10]);
+    wreg(cpu_state->hvf->fd, HV_X86_R11, env->regs[11]);
+    wreg(cpu_state->hvf->fd, HV_X86_R12, env->regs[12]);
+    wreg(cpu_state->hvf->fd, HV_X86_R13, env->regs[13]);
+    wreg(cpu_state->hvf->fd, HV_X86_R14, env->regs[14]);
+    wreg(cpu_state->hvf->fd, HV_X86_R15, env->regs[15]);
+    wreg(cpu_state->hvf->fd, HV_X86_RFLAGS, env->eflags);
+    wreg(cpu_state->hvf->fd, HV_X86_RIP, env->eip);
    
-    wreg(cpu_state->hvf_fd, HV_X86_XCR0, env->xcr0);
+    wreg(cpu_state->hvf->fd, HV_X86_XCR0, env->xcr0);
     
     hvf_put_xsave(cpu_state);
     
@@ -274,14 +274,14 @@ int hvf_put_registers(CPUState *cpu_state)
     
     hvf_put_msrs(cpu_state);
     
-    wreg(cpu_state->hvf_fd, HV_X86_DR0, env->dr[0]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR1, env->dr[1]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR2, env->dr[2]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR3, env->dr[3]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR4, env->dr[4]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR5, env->dr[5]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR6, env->dr[6]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR7, env->dr[7]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR0, env->dr[0]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR1, env->dr[1]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR2, env->dr[2]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR3, env->dr[3]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR4, env->dr[4]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR5, env->dr[5]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR6, env->dr[6]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR7, env->dr[7]);
     
     return 0;
 }
@@ -291,40 +291,40 @@ int hvf_get_registers(CPUState *cpu_state)
     X86CPU *x86cpu = X86_CPU(cpu_state);
     CPUX86State *env = &x86cpu->env;
 
-    env->regs[R_EAX] = rreg(cpu_state->hvf_fd, HV_X86_RAX);
-    env->regs[R_EBX] = rreg(cpu_state->hvf_fd, HV_X86_RBX);
-    env->regs[R_ECX] = rreg(cpu_state->hvf_fd, HV_X86_RCX);
-    env->regs[R_EDX] = rreg(cpu_state->hvf_fd, HV_X86_RDX);
-    env->regs[R_EBP] = rreg(cpu_state->hvf_fd, HV_X86_RBP);
-    env->regs[R_ESP] = rreg(cpu_state->hvf_fd, HV_X86_RSP);
-    env->regs[R_ESI] = rreg(cpu_state->hvf_fd, HV_X86_RSI);
-    env->regs[R_EDI] = rreg(cpu_state->hvf_fd, HV_X86_RDI);
-    env->regs[8] = rreg(cpu_state->hvf_fd, HV_X86_R8);
-    env->regs[9] = rreg(cpu_state->hvf_fd, HV_X86_R9);
-    env->regs[10] = rreg(cpu_state->hvf_fd, HV_X86_R10);
-    env->regs[11] = rreg(cpu_state->hvf_fd, HV_X86_R11);
-    env->regs[12] = rreg(cpu_state->hvf_fd, HV_X86_R12);
-    env->regs[13] = rreg(cpu_state->hvf_fd, HV_X86_R13);
-    env->regs[14] = rreg(cpu_state->hvf_fd, HV_X86_R14);
-    env->regs[15] = rreg(cpu_state->hvf_fd, HV_X86_R15);
+    env->regs[R_EAX] = rreg(cpu_state->hvf->fd, HV_X86_RAX);
+    env->regs[R_EBX] = rreg(cpu_state->hvf->fd, HV_X86_RBX);
+    env->regs[R_ECX] = rreg(cpu_state->hvf->fd, HV_X86_RCX);
+    env->regs[R_EDX] = rreg(cpu_state->hvf->fd, HV_X86_RDX);
+    env->regs[R_EBP] = rreg(cpu_state->hvf->fd, HV_X86_RBP);
+    env->regs[R_ESP] = rreg(cpu_state->hvf->fd, HV_X86_RSP);
+    env->regs[R_ESI] = rreg(cpu_state->hvf->fd, HV_X86_RSI);
+    env->regs[R_EDI] = rreg(cpu_state->hvf->fd, HV_X86_RDI);
+    env->regs[8] = rreg(cpu_state->hvf->fd, HV_X86_R8);
+    env->regs[9] = rreg(cpu_state->hvf->fd, HV_X86_R9);
+    env->regs[10] = rreg(cpu_state->hvf->fd, HV_X86_R10);
+    env->regs[11] = rreg(cpu_state->hvf->fd, HV_X86_R11);
+    env->regs[12] = rreg(cpu_state->hvf->fd, HV_X86_R12);
+    env->regs[13] = rreg(cpu_state->hvf->fd, HV_X86_R13);
+    env->regs[14] = rreg(cpu_state->hvf->fd, HV_X86_R14);
+    env->regs[15] = rreg(cpu_state->hvf->fd, HV_X86_R15);
     
-    env->eflags = rreg(cpu_state->hvf_fd, HV_X86_RFLAGS);
-    env->eip = rreg(cpu_state->hvf_fd, HV_X86_RIP);
+    env->eflags = rreg(cpu_state->hvf->fd, HV_X86_RFLAGS);
+    env->eip = rreg(cpu_state->hvf->fd, HV_X86_RIP);
    
     hvf_get_xsave(cpu_state);
-    env->xcr0 = rreg(cpu_state->hvf_fd, HV_X86_XCR0);
+    env->xcr0 = rreg(cpu_state->hvf->fd, HV_X86_XCR0);
     
     hvf_get_segments(cpu_state);
     hvf_get_msrs(cpu_state);
     
-    env->dr[0] = rreg(cpu_state->hvf_fd, HV_X86_DR0);
-    env->dr[1] = rreg(cpu_state->hvf_fd, HV_X86_DR1);
-    env->dr[2] = rreg(cpu_state->hvf_fd, HV_X86_DR2);
-    env->dr[3] = rreg(cpu_state->hvf_fd, HV_X86_DR3);
-    env->dr[4] = rreg(cpu_state->hvf_fd, HV_X86_DR4);
-    env->dr[5] = rreg(cpu_state->hvf_fd, HV_X86_DR5);
-    env->dr[6] = rreg(cpu_state->hvf_fd, HV_X86_DR6);
-    env->dr[7] = rreg(cpu_state->hvf_fd, HV_X86_DR7);
+    env->dr[0] = rreg(cpu_state->hvf->fd, HV_X86_DR0);
+    env->dr[1] = rreg(cpu_state->hvf->fd, HV_X86_DR1);
+    env->dr[2] = rreg(cpu_state->hvf->fd, HV_X86_DR2);
+    env->dr[3] = rreg(cpu_state->hvf->fd, HV_X86_DR3);
+    env->dr[4] = rreg(cpu_state->hvf->fd, HV_X86_DR4);
+    env->dr[5] = rreg(cpu_state->hvf->fd, HV_X86_DR5);
+    env->dr[6] = rreg(cpu_state->hvf->fd, HV_X86_DR6);
+    env->dr[7] = rreg(cpu_state->hvf->fd, HV_X86_DR7);
     
     x86_update_hflags(env);
     return 0;
@@ -333,16 +333,16 @@ int hvf_get_registers(CPUState *cpu_state)
 static void vmx_set_int_window_exiting(CPUState *cpu)
 {
      uint64_t val;
-     val = rvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS);
-     wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS, val |
+     val = rvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS);
+     wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS, val |
              VMCS_PRI_PROC_BASED_CTLS_INT_WINDOW_EXITING);
 }
 
 void vmx_clear_int_window_exiting(CPUState *cpu)
 {
      uint64_t val;
-     val = rvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS);
-     wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS, val &
+     val = rvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS);
+     wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS, val &
              ~VMCS_PRI_PROC_BASED_CTLS_INT_WINDOW_EXITING);
 }
 
@@ -378,7 +378,7 @@ bool hvf_inject_interrupts(CPUState *cpu_state)
     uint64_t info = 0;
     if (have_event) {
         info = vector | intr_type | VMCS_INTR_VALID;
-        uint64_t reason = rvmcs(cpu_state->hvf_fd, VMCS_EXIT_REASON);
+        uint64_t reason = rvmcs(cpu_state->hvf->fd, VMCS_EXIT_REASON);
         if (env->nmi_injected && reason != EXIT_REASON_TASK_SWITCH) {
             vmx_clear_nmi_blocking(cpu_state);
         }
@@ -387,17 +387,17 @@ bool hvf_inject_interrupts(CPUState *cpu_state)
             info &= ~(1 << 12); /* clear undefined bit */
             if (intr_type == VMCS_INTR_T_SWINTR ||
                 intr_type == VMCS_INTR_T_SWEXCEPTION) {
-                wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_INST_LENGTH, env->ins_len);
+                wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_INST_LENGTH, env->ins_len);
             }
             
             if (env->has_error_code) {
-                wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_EXCEPTION_ERROR,
+                wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_EXCEPTION_ERROR,
                       env->error_code);
                 /* Indicate that VMCS_ENTRY_EXCEPTION_ERROR is valid */
                 info |= VMCS_INTR_DEL_ERRCODE;
             }
             /*printf("reinject  %lx err %d\n", info, err);*/
-            wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_INTR_INFO, info);
+            wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_INTR_INFO, info);
         };
     }
 
@@ -405,7 +405,7 @@ bool hvf_inject_interrupts(CPUState *cpu_state)
         if (!(env->hflags2 & HF2_NMI_MASK) && !(info & VMCS_INTR_VALID)) {
             cpu_state->interrupt_request &= ~CPU_INTERRUPT_NMI;
             info = VMCS_INTR_VALID | VMCS_INTR_T_NMI | EXCP02_NMI;
-            wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_INTR_INFO, info);
+            wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_INTR_INFO, info);
         } else {
             vmx_set_nmi_window_exiting(cpu_state);
         }
@@ -417,7 +417,7 @@ bool hvf_inject_interrupts(CPUState *cpu_state)
         int line = cpu_get_pic_interrupt(&x86cpu->env);
         cpu_state->interrupt_request &= ~CPU_INTERRUPT_HARD;
         if (line >= 0) {
-            wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_INTR_INFO, line |
+            wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_INTR_INFO, line |
                   VMCS_INTR_VALID | VMCS_INTR_T_HWINTR);
         }
     }
@@ -433,7 +433,7 @@ int hvf_process_events(CPUState *cpu_state)
     X86CPU *cpu = X86_CPU(cpu_state);
     CPUX86State *env = &cpu->env;
 
-    env->eflags = rreg(cpu_state->hvf_fd, HV_X86_RFLAGS);
+    env->eflags = rreg(cpu_state->hvf->fd, HV_X86_RFLAGS);
 
     if (cpu_state->interrupt_request & CPU_INTERRUPT_INIT) {
         cpu_synchronize_state(cpu_state);

From 365294d55a832edeff47b5e6c97a46775b845769 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:46 +0200
Subject: [PATCH 057/180] hvf: Simplify post reset/init/loadvm hooks

The hooks we have that call us after reset, init and loadvm really all
just want to say "The reference of all register state is in the QEMU
vcpu struct, please push it".

We already have a working pushing mechanism though called cpu->vcpu_dirty,
so we can just reuse that for all of the above, syncing state properly the
next time we actually execute a vCPU.

This fixes PSCI resets on ARM, as they modify CPU state even after the
post init call has completed, but before we execute the vCPU again.

To also make the scheme work for x86, we have to make sure we don't
move stale eflags into our env when the vcpu state is dirty.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reviewed-by: Roman Bolshakov <r.bolshakov@yadro.com>
Tested-by: Roman Bolshakov <r.bolshakov@yadro.com>
Message-Id: <20210519202253.76782-13-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 27 +++++++--------------------
 target/i386/hvf/x86hvf.c  |  5 ++++-
 2 files changed, 11 insertions(+), 21 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index ded918c443d9..d1691be9896e 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -205,39 +205,26 @@ static void hvf_cpu_synchronize_state(CPUState *cpu)
     }
 }
 
-static void do_hvf_cpu_synchronize_post_reset(CPUState *cpu,
-                                              run_on_cpu_data arg)
+static void do_hvf_cpu_synchronize_set_dirty(CPUState *cpu,
+                                             run_on_cpu_data arg)
 {
-    hvf_put_registers(cpu);
-    cpu->vcpu_dirty = false;
+    /* QEMU state is the reference, push it to HVF now and on next entry */
+    cpu->vcpu_dirty = true;
 }
 
 static void hvf_cpu_synchronize_post_reset(CPUState *cpu)
 {
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
-}
-
-static void do_hvf_cpu_synchronize_post_init(CPUState *cpu,
-                                             run_on_cpu_data arg)
-{
-    hvf_put_registers(cpu);
-    cpu->vcpu_dirty = false;
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_set_dirty, RUN_ON_CPU_NULL);
 }
 
 static void hvf_cpu_synchronize_post_init(CPUState *cpu)
 {
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
-}
-
-static void do_hvf_cpu_synchronize_pre_loadvm(CPUState *cpu,
-                                              run_on_cpu_data arg)
-{
-    cpu->vcpu_dirty = true;
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_set_dirty, RUN_ON_CPU_NULL);
 }
 
 static void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_set_dirty, RUN_ON_CPU_NULL);
 }
 
 static void hvf_set_dirty_tracking(MemoryRegionSection *section, bool on)
diff --git a/target/i386/hvf/x86hvf.c b/target/i386/hvf/x86hvf.c
index 28cfee4f6087..2ced2c24784e 100644
--- a/target/i386/hvf/x86hvf.c
+++ b/target/i386/hvf/x86hvf.c
@@ -433,7 +433,10 @@ int hvf_process_events(CPUState *cpu_state)
     X86CPU *cpu = X86_CPU(cpu_state);
     CPUX86State *env = &cpu->env;
 
-    env->eflags = rreg(cpu_state->hvf->fd, HV_X86_RFLAGS);
+    if (!cpu_state->vcpu_dirty) {
+        /* light weight sync for CPU_INTERRUPT_HARD and IF_MASK */
+        env->eflags = rreg(cpu_state->hvf->fd, HV_X86_RFLAGS);
+    }
 
     if (cpu_state->interrupt_request & CPU_INTERRUPT_INIT) {
         cpu_synchronize_state(cpu_state);

From 3354c800ac01d1d1e6b0243d7016960678d46119 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:47 +0200
Subject: [PATCH 058/180] hvf: Add Apple Silicon support

With Apple Silicon available to the masses, it's a good time to add support
for driving its virtualization extensions from QEMU.

This patch adds all necessary architecture specific code to get basic VMs
working. It's still pretty raw, but definitely functional.

Known limitations:

  - Vtimer acknowledgement is hacky
  - Should implement more sysregs and fault on invalid ones then
  - WFI handling is missing, need to marry it with vtimer

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reviewed-by: Roman Bolshakov <r.bolshakov@yadro.com>

Message-Id: <20210519202253.76782-14-agraf@csgraf.de>
---
 MAINTAINERS                 |   5 +
 accel/hvf/hvf-accel-ops.c   |  14 +
 include/sysemu/hvf_int.h    |   9 +-
 meson.build                 |   1 +
 target/arm/hvf/hvf.c        | 703 ++++++++++++++++++++++++++++++++++++
 target/arm/hvf/trace-events |  10 +
 6 files changed, 741 insertions(+), 1 deletion(-)
 create mode 100644 target/arm/hvf/hvf.c
 create mode 100644 target/arm/hvf/trace-events

diff --git a/MAINTAINERS b/MAINTAINERS
index 275bfe10931c..8352f1411b9c 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -456,6 +456,11 @@ F: accel/accel-*.c
 F: accel/Makefile.objs
 F: accel/stubs/Makefile.objs
 
+Apple Silicon HVF CPUs
+M: Alexander Graf <agraf@csgraf.de>
+S: Maintained
+F: target/arm/hvf/
+
 X86 HVF CPUs
 M: Cameron Esfahani <dirty@apple.com>
 M: Roman Bolshakov <r.bolshakov@yadro.com>
diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index d1691be9896e..48e402ef57bf 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -60,6 +60,10 @@
 
 HVFState *hvf_state;
 
+#ifdef __aarch64__
+#define HV_VM_DEFAULT NULL
+#endif
+
 /* Memory slots */
 
 hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
@@ -375,7 +379,11 @@ static int hvf_init_vcpu(CPUState *cpu)
     pthread_sigmask(SIG_BLOCK, NULL, &set);
     sigdelset(&set, SIG_IPI);
 
+#ifdef __aarch64__
+    r = hv_vcpu_create(&cpu->hvf->fd, (hv_vcpu_exit_t **)&cpu->hvf->exit, NULL);
+#else
     r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf->fd, HV_VCPU_DEFAULT);
+#endif
     cpu->vcpu_dirty = 1;
     assert_hvf_ok(r);
 
@@ -446,11 +454,17 @@ static void hvf_start_vcpu_thread(CPUState *cpu)
                        cpu, QEMU_THREAD_JOINABLE);
 }
 
+__attribute__((weak)) void hvf_kick_vcpu_thread(CPUState *cpu)
+{
+    cpus_kick_thread(cpu);
+}
+
 static void hvf_accel_ops_class_init(ObjectClass *oc, void *data)
 {
     AccelOpsClass *ops = ACCEL_OPS_CLASS(oc);
 
     ops->create_vcpu_thread = hvf_start_vcpu_thread;
+    ops->kick_vcpu_thread = hvf_kick_vcpu_thread;
 
     ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
     ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 8b66a4e7d0dc..e52d67ed5c74 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -11,7 +11,11 @@
 #ifndef HVF_INT_H
 #define HVF_INT_H
 
+#ifdef __aarch64__
+#include <Hypervisor/Hypervisor.h>
+#else
 #include <Hypervisor/hv.h>
+#endif
 
 /* hvf_slot flags */
 #define HVF_SLOT_LOG (1 << 0)
@@ -44,7 +48,9 @@ struct HVFState {
 extern HVFState *hvf_state;
 
 struct hvf_vcpu_state {
-    int fd;
+    uint64_t fd;
+    void *exit;
+    bool vtimer_masked;
 };
 
 void assert_hvf_ok(hv_return_t ret);
@@ -54,5 +60,6 @@ int hvf_vcpu_exec(CPUState *);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 int hvf_put_registers(CPUState *);
 int hvf_get_registers(CPUState *);
+void hvf_kick_vcpu_thread(CPUState *cpu);
 
 #endif
diff --git a/meson.build b/meson.build
index c6f4b0cf5e8a..93a293849d17 100644
--- a/meson.build
+++ b/meson.build
@@ -1844,6 +1844,7 @@ if have_system or have_user
     'accel/tcg',
     'hw/core',
     'target/arm',
+    'target/arm/hvf',
     'target/hppa',
     'target/i386',
     'target/i386/kvm',
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
new file mode 100644
index 000000000000..3934c05979d5
--- /dev/null
+++ b/target/arm/hvf/hvf.c
@@ -0,0 +1,703 @@
+/*
+ * QEMU Hypervisor.framework support for Apple Silicon
+
+ * Copyright 2020 Alexander Graf <agraf@csgraf.de>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "qemu/error-report.h"
+
+#include "sysemu/runstate.h"
+#include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
+#include "sysemu/hw_accel.h"
+
+#include "exec/address-spaces.h"
+#include "hw/irq.h"
+#include "qemu/main-loop.h"
+#include "sysemu/cpus.h"
+#include "target/arm/cpu.h"
+#include "target/arm/internals.h"
+#include "trace/trace-target_arm_hvf.h"
+
+#define HVF_SYSREG(crn, crm, op0, op1, op2) \
+        ENCODE_AA64_CP_REG(CP_REG_ARM64_SYSREG_CP, crn, crm, op0, op1, op2)
+#define PL1_WRITE_MASK 0x4
+
+#define SYSREG(op0, op1, crn, crm, op2) \
+    ((op0 << 20) | (op2 << 17) | (op1 << 14) | (crn << 10) | (crm << 1))
+#define SYSREG_MASK           SYSREG(0x3, 0x7, 0xf, 0xf, 0x7)
+#define SYSREG_CNTPCT_EL0     SYSREG(3, 3, 14, 0, 1)
+#define SYSREG_PMCCNTR_EL0    SYSREG(3, 3, 9, 13, 0)
+
+#define WFX_IS_WFE (1 << 0)
+
+#define TMR_CTL_ENABLE  (1 << 0)
+#define TMR_CTL_IMASK   (1 << 1)
+#define TMR_CTL_ISTATUS (1 << 2)
+
+struct hvf_reg_match {
+    int reg;
+    uint64_t offset;
+};
+
+static const struct hvf_reg_match hvf_reg_match[] = {
+    { HV_REG_X0,   offsetof(CPUARMState, xregs[0]) },
+    { HV_REG_X1,   offsetof(CPUARMState, xregs[1]) },
+    { HV_REG_X2,   offsetof(CPUARMState, xregs[2]) },
+    { HV_REG_X3,   offsetof(CPUARMState, xregs[3]) },
+    { HV_REG_X4,   offsetof(CPUARMState, xregs[4]) },
+    { HV_REG_X5,   offsetof(CPUARMState, xregs[5]) },
+    { HV_REG_X6,   offsetof(CPUARMState, xregs[6]) },
+    { HV_REG_X7,   offsetof(CPUARMState, xregs[7]) },
+    { HV_REG_X8,   offsetof(CPUARMState, xregs[8]) },
+    { HV_REG_X9,   offsetof(CPUARMState, xregs[9]) },
+    { HV_REG_X10,  offsetof(CPUARMState, xregs[10]) },
+    { HV_REG_X11,  offsetof(CPUARMState, xregs[11]) },
+    { HV_REG_X12,  offsetof(CPUARMState, xregs[12]) },
+    { HV_REG_X13,  offsetof(CPUARMState, xregs[13]) },
+    { HV_REG_X14,  offsetof(CPUARMState, xregs[14]) },
+    { HV_REG_X15,  offsetof(CPUARMState, xregs[15]) },
+    { HV_REG_X16,  offsetof(CPUARMState, xregs[16]) },
+    { HV_REG_X17,  offsetof(CPUARMState, xregs[17]) },
+    { HV_REG_X18,  offsetof(CPUARMState, xregs[18]) },
+    { HV_REG_X19,  offsetof(CPUARMState, xregs[19]) },
+    { HV_REG_X20,  offsetof(CPUARMState, xregs[20]) },
+    { HV_REG_X21,  offsetof(CPUARMState, xregs[21]) },
+    { HV_REG_X22,  offsetof(CPUARMState, xregs[22]) },
+    { HV_REG_X23,  offsetof(CPUARMState, xregs[23]) },
+    { HV_REG_X24,  offsetof(CPUARMState, xregs[24]) },
+    { HV_REG_X25,  offsetof(CPUARMState, xregs[25]) },
+    { HV_REG_X26,  offsetof(CPUARMState, xregs[26]) },
+    { HV_REG_X27,  offsetof(CPUARMState, xregs[27]) },
+    { HV_REG_X28,  offsetof(CPUARMState, xregs[28]) },
+    { HV_REG_X29,  offsetof(CPUARMState, xregs[29]) },
+    { HV_REG_X30,  offsetof(CPUARMState, xregs[30]) },
+    { HV_REG_PC,   offsetof(CPUARMState, pc) },
+};
+
+static const struct hvf_reg_match hvf_fpreg_match[] = {
+    { HV_SIMD_FP_REG_Q0,  offsetof(CPUARMState, vfp.zregs[0]) },
+    { HV_SIMD_FP_REG_Q1,  offsetof(CPUARMState, vfp.zregs[1]) },
+    { HV_SIMD_FP_REG_Q2,  offsetof(CPUARMState, vfp.zregs[2]) },
+    { HV_SIMD_FP_REG_Q3,  offsetof(CPUARMState, vfp.zregs[3]) },
+    { HV_SIMD_FP_REG_Q4,  offsetof(CPUARMState, vfp.zregs[4]) },
+    { HV_SIMD_FP_REG_Q5,  offsetof(CPUARMState, vfp.zregs[5]) },
+    { HV_SIMD_FP_REG_Q6,  offsetof(CPUARMState, vfp.zregs[6]) },
+    { HV_SIMD_FP_REG_Q7,  offsetof(CPUARMState, vfp.zregs[7]) },
+    { HV_SIMD_FP_REG_Q8,  offsetof(CPUARMState, vfp.zregs[8]) },
+    { HV_SIMD_FP_REG_Q9,  offsetof(CPUARMState, vfp.zregs[9]) },
+    { HV_SIMD_FP_REG_Q10, offsetof(CPUARMState, vfp.zregs[10]) },
+    { HV_SIMD_FP_REG_Q11, offsetof(CPUARMState, vfp.zregs[11]) },
+    { HV_SIMD_FP_REG_Q12, offsetof(CPUARMState, vfp.zregs[12]) },
+    { HV_SIMD_FP_REG_Q13, offsetof(CPUARMState, vfp.zregs[13]) },
+    { HV_SIMD_FP_REG_Q14, offsetof(CPUARMState, vfp.zregs[14]) },
+    { HV_SIMD_FP_REG_Q15, offsetof(CPUARMState, vfp.zregs[15]) },
+    { HV_SIMD_FP_REG_Q16, offsetof(CPUARMState, vfp.zregs[16]) },
+    { HV_SIMD_FP_REG_Q17, offsetof(CPUARMState, vfp.zregs[17]) },
+    { HV_SIMD_FP_REG_Q18, offsetof(CPUARMState, vfp.zregs[18]) },
+    { HV_SIMD_FP_REG_Q19, offsetof(CPUARMState, vfp.zregs[19]) },
+    { HV_SIMD_FP_REG_Q20, offsetof(CPUARMState, vfp.zregs[20]) },
+    { HV_SIMD_FP_REG_Q21, offsetof(CPUARMState, vfp.zregs[21]) },
+    { HV_SIMD_FP_REG_Q22, offsetof(CPUARMState, vfp.zregs[22]) },
+    { HV_SIMD_FP_REG_Q23, offsetof(CPUARMState, vfp.zregs[23]) },
+    { HV_SIMD_FP_REG_Q24, offsetof(CPUARMState, vfp.zregs[24]) },
+    { HV_SIMD_FP_REG_Q25, offsetof(CPUARMState, vfp.zregs[25]) },
+    { HV_SIMD_FP_REG_Q26, offsetof(CPUARMState, vfp.zregs[26]) },
+    { HV_SIMD_FP_REG_Q27, offsetof(CPUARMState, vfp.zregs[27]) },
+    { HV_SIMD_FP_REG_Q28, offsetof(CPUARMState, vfp.zregs[28]) },
+    { HV_SIMD_FP_REG_Q29, offsetof(CPUARMState, vfp.zregs[29]) },
+    { HV_SIMD_FP_REG_Q30, offsetof(CPUARMState, vfp.zregs[30]) },
+    { HV_SIMD_FP_REG_Q31, offsetof(CPUARMState, vfp.zregs[31]) },
+};
+
+struct hvf_sreg_match {
+    int reg;
+    uint32_t key;
+};
+
+static const struct hvf_sreg_match hvf_sreg_match[] = {
+    { HV_SYS_REG_DBGBVR0_EL1, HVF_SYSREG(0, 0, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR0_EL1, HVF_SYSREG(0, 0, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR0_EL1, HVF_SYSREG(0, 0, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR0_EL1, HVF_SYSREG(0, 0, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR1_EL1, HVF_SYSREG(0, 1, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR1_EL1, HVF_SYSREG(0, 1, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR1_EL1, HVF_SYSREG(0, 1, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR1_EL1, HVF_SYSREG(0, 1, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR2_EL1, HVF_SYSREG(0, 2, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR2_EL1, HVF_SYSREG(0, 2, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR2_EL1, HVF_SYSREG(0, 2, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR2_EL1, HVF_SYSREG(0, 2, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR3_EL1, HVF_SYSREG(0, 3, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR3_EL1, HVF_SYSREG(0, 3, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR3_EL1, HVF_SYSREG(0, 3, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR3_EL1, HVF_SYSREG(0, 3, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR4_EL1, HVF_SYSREG(0, 4, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR4_EL1, HVF_SYSREG(0, 4, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR4_EL1, HVF_SYSREG(0, 4, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR4_EL1, HVF_SYSREG(0, 4, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR5_EL1, HVF_SYSREG(0, 5, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR5_EL1, HVF_SYSREG(0, 5, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR5_EL1, HVF_SYSREG(0, 5, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR5_EL1, HVF_SYSREG(0, 5, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR6_EL1, HVF_SYSREG(0, 6, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR6_EL1, HVF_SYSREG(0, 6, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR6_EL1, HVF_SYSREG(0, 6, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR6_EL1, HVF_SYSREG(0, 6, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR7_EL1, HVF_SYSREG(0, 7, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR7_EL1, HVF_SYSREG(0, 7, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR7_EL1, HVF_SYSREG(0, 7, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR7_EL1, HVF_SYSREG(0, 7, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR8_EL1, HVF_SYSREG(0, 8, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR8_EL1, HVF_SYSREG(0, 8, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR8_EL1, HVF_SYSREG(0, 8, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR8_EL1, HVF_SYSREG(0, 8, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR9_EL1, HVF_SYSREG(0, 9, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR9_EL1, HVF_SYSREG(0, 9, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR9_EL1, HVF_SYSREG(0, 9, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR9_EL1, HVF_SYSREG(0, 9, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR10_EL1, HVF_SYSREG(0, 10, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR10_EL1, HVF_SYSREG(0, 10, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR10_EL1, HVF_SYSREG(0, 10, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR10_EL1, HVF_SYSREG(0, 10, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR11_EL1, HVF_SYSREG(0, 11, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR11_EL1, HVF_SYSREG(0, 11, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR11_EL1, HVF_SYSREG(0, 11, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR11_EL1, HVF_SYSREG(0, 11, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR12_EL1, HVF_SYSREG(0, 12, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR12_EL1, HVF_SYSREG(0, 12, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR12_EL1, HVF_SYSREG(0, 12, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR12_EL1, HVF_SYSREG(0, 12, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR13_EL1, HVF_SYSREG(0, 13, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR13_EL1, HVF_SYSREG(0, 13, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR13_EL1, HVF_SYSREG(0, 13, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR13_EL1, HVF_SYSREG(0, 13, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR14_EL1, HVF_SYSREG(0, 14, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR14_EL1, HVF_SYSREG(0, 14, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR14_EL1, HVF_SYSREG(0, 14, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR14_EL1, HVF_SYSREG(0, 14, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR15_EL1, HVF_SYSREG(0, 15, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR15_EL1, HVF_SYSREG(0, 15, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR15_EL1, HVF_SYSREG(0, 15, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR15_EL1, HVF_SYSREG(0, 15, 14, 0, 7) },
+
+#ifdef SYNC_NO_RAW_REGS
+    /*
+     * The registers below are manually synced on init because they are
+     * marked as NO_RAW. We still list them to make number space sync easier.
+     */
+    { HV_SYS_REG_MDCCINT_EL1, HVF_SYSREG(0, 2, 2, 0, 0) },
+    { HV_SYS_REG_MIDR_EL1, HVF_SYSREG(0, 0, 3, 0, 0) },
+    { HV_SYS_REG_MPIDR_EL1, HVF_SYSREG(0, 0, 3, 0, 5) },
+    { HV_SYS_REG_ID_AA64PFR0_EL1, HVF_SYSREG(0, 4, 3, 0, 0) },
+#endif
+    { HV_SYS_REG_ID_AA64PFR1_EL1, HVF_SYSREG(0, 4, 3, 0, 2) },
+    { HV_SYS_REG_ID_AA64DFR0_EL1, HVF_SYSREG(0, 5, 3, 0, 0) },
+    { HV_SYS_REG_ID_AA64DFR1_EL1, HVF_SYSREG(0, 5, 3, 0, 1) },
+    { HV_SYS_REG_ID_AA64ISAR0_EL1, HVF_SYSREG(0, 6, 3, 0, 0) },
+    { HV_SYS_REG_ID_AA64ISAR1_EL1, HVF_SYSREG(0, 6, 3, 0, 1) },
+#ifdef SYNC_NO_MMFR0
+    /* We keep the hardware MMFR0 around. HW limits are there anyway */
+    { HV_SYS_REG_ID_AA64MMFR0_EL1, HVF_SYSREG(0, 7, 3, 0, 0) },
+#endif
+    { HV_SYS_REG_ID_AA64MMFR1_EL1, HVF_SYSREG(0, 7, 3, 0, 1) },
+    { HV_SYS_REG_ID_AA64MMFR2_EL1, HVF_SYSREG(0, 7, 3, 0, 2) },
+
+    { HV_SYS_REG_MDSCR_EL1, HVF_SYSREG(0, 2, 2, 0, 2) },
+    { HV_SYS_REG_SCTLR_EL1, HVF_SYSREG(1, 0, 3, 0, 0) },
+    { HV_SYS_REG_CPACR_EL1, HVF_SYSREG(1, 0, 3, 0, 2) },
+    { HV_SYS_REG_TTBR0_EL1, HVF_SYSREG(2, 0, 3, 0, 0) },
+    { HV_SYS_REG_TTBR1_EL1, HVF_SYSREG(2, 0, 3, 0, 1) },
+    { HV_SYS_REG_TCR_EL1, HVF_SYSREG(2, 0, 3, 0, 2) },
+
+    { HV_SYS_REG_APIAKEYLO_EL1, HVF_SYSREG(2, 1, 3, 0, 0) },
+    { HV_SYS_REG_APIAKEYHI_EL1, HVF_SYSREG(2, 1, 3, 0, 1) },
+    { HV_SYS_REG_APIBKEYLO_EL1, HVF_SYSREG(2, 1, 3, 0, 2) },
+    { HV_SYS_REG_APIBKEYHI_EL1, HVF_SYSREG(2, 1, 3, 0, 3) },
+    { HV_SYS_REG_APDAKEYLO_EL1, HVF_SYSREG(2, 2, 3, 0, 0) },
+    { HV_SYS_REG_APDAKEYHI_EL1, HVF_SYSREG(2, 2, 3, 0, 1) },
+    { HV_SYS_REG_APDBKEYLO_EL1, HVF_SYSREG(2, 2, 3, 0, 2) },
+    { HV_SYS_REG_APDBKEYHI_EL1, HVF_SYSREG(2, 2, 3, 0, 3) },
+    { HV_SYS_REG_APGAKEYLO_EL1, HVF_SYSREG(2, 3, 3, 0, 0) },
+    { HV_SYS_REG_APGAKEYHI_EL1, HVF_SYSREG(2, 3, 3, 0, 1) },
+
+    { HV_SYS_REG_SPSR_EL1, HVF_SYSREG(4, 0, 3, 1, 0) },
+    { HV_SYS_REG_ELR_EL1, HVF_SYSREG(4, 0, 3, 0, 1) },
+    { HV_SYS_REG_SP_EL0, HVF_SYSREG(4, 1, 3, 0, 0) },
+    { HV_SYS_REG_AFSR0_EL1, HVF_SYSREG(5, 1, 3, 0, 0) },
+    { HV_SYS_REG_AFSR1_EL1, HVF_SYSREG(5, 1, 3, 0, 1) },
+    { HV_SYS_REG_ESR_EL1, HVF_SYSREG(5, 2, 3, 0, 0) },
+    { HV_SYS_REG_FAR_EL1, HVF_SYSREG(6, 0, 3, 0, 0) },
+    { HV_SYS_REG_PAR_EL1, HVF_SYSREG(7, 4, 3, 0, 0) },
+    { HV_SYS_REG_MAIR_EL1, HVF_SYSREG(10, 2, 3, 0, 0) },
+    { HV_SYS_REG_AMAIR_EL1, HVF_SYSREG(10, 3, 3, 0, 0) },
+    { HV_SYS_REG_VBAR_EL1, HVF_SYSREG(12, 0, 3, 0, 0) },
+    { HV_SYS_REG_CONTEXTIDR_EL1, HVF_SYSREG(13, 0, 3, 0, 1) },
+    { HV_SYS_REG_TPIDR_EL1, HVF_SYSREG(13, 0, 3, 0, 4) },
+    { HV_SYS_REG_CNTKCTL_EL1, HVF_SYSREG(14, 1, 3, 0, 0) },
+    { HV_SYS_REG_CSSELR_EL1, HVF_SYSREG(0, 0, 3, 2, 0) },
+    { HV_SYS_REG_TPIDR_EL0, HVF_SYSREG(13, 0, 3, 3, 2) },
+    { HV_SYS_REG_TPIDRRO_EL0, HVF_SYSREG(13, 0, 3, 3, 3) },
+    { HV_SYS_REG_CNTV_CTL_EL0, HVF_SYSREG(14, 3, 3, 3, 1) },
+    { HV_SYS_REG_CNTV_CVAL_EL0, HVF_SYSREG(14, 3, 3, 3, 2) },
+    { HV_SYS_REG_SP_EL1, HVF_SYSREG(4, 1, 3, 4, 0) },
+};
+
+int hvf_get_registers(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    hv_return_t ret;
+    uint64_t val;
+    hv_simd_fp_uchar16_t fpval;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(hvf_reg_match); i++) {
+        ret = hv_vcpu_get_reg(cpu->hvf->fd, hvf_reg_match[i].reg, &val);
+        *(uint64_t *)((void *)env + hvf_reg_match[i].offset) = val;
+        assert_hvf_ok(ret);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(hvf_fpreg_match); i++) {
+        ret = hv_vcpu_get_simd_fp_reg(cpu->hvf->fd, hvf_fpreg_match[i].reg,
+                                      &fpval);
+        memcpy((void *)env + hvf_fpreg_match[i].offset, &fpval, sizeof(fpval));
+        assert_hvf_ok(ret);
+    }
+
+    val = 0;
+    ret = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_FPCR, &val);
+    assert_hvf_ok(ret);
+    vfp_set_fpcr(env, val);
+
+    val = 0;
+    ret = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_FPSR, &val);
+    assert_hvf_ok(ret);
+    vfp_set_fpsr(env, val);
+
+    ret = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_CPSR, &val);
+    assert_hvf_ok(ret);
+    pstate_write(env, val);
+
+    for (i = 0; i < ARRAY_SIZE(hvf_sreg_match); i++) {
+        ret = hv_vcpu_get_sys_reg(cpu->hvf->fd, hvf_sreg_match[i].reg, &val);
+        assert_hvf_ok(ret);
+
+        arm_cpu->cpreg_values[i] = val;
+    }
+    write_list_to_cpustate(arm_cpu);
+
+    return 0;
+}
+
+int hvf_put_registers(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    hv_return_t ret;
+    uint64_t val;
+    hv_simd_fp_uchar16_t fpval;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(hvf_reg_match); i++) {
+        val = *(uint64_t *)((void *)env + hvf_reg_match[i].offset);
+        ret = hv_vcpu_set_reg(cpu->hvf->fd, hvf_reg_match[i].reg, val);
+        assert_hvf_ok(ret);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(hvf_fpreg_match); i++) {
+        memcpy(&fpval, (void *)env + hvf_fpreg_match[i].offset, sizeof(fpval));
+        ret = hv_vcpu_set_simd_fp_reg(cpu->hvf->fd, hvf_fpreg_match[i].reg,
+                                      fpval);
+        assert_hvf_ok(ret);
+    }
+
+    ret = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_FPCR, vfp_get_fpcr(env));
+    assert_hvf_ok(ret);
+
+    ret = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_FPSR, vfp_get_fpsr(env));
+    assert_hvf_ok(ret);
+
+    ret = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_CPSR, pstate_read(env));
+    assert_hvf_ok(ret);
+
+    write_cpustate_to_list(arm_cpu, false);
+    for (i = 0; i < ARRAY_SIZE(hvf_sreg_match); i++) {
+        val = arm_cpu->cpreg_values[i];
+        ret = hv_vcpu_set_sys_reg(cpu->hvf->fd, hvf_sreg_match[i].reg, val);
+        assert_hvf_ok(ret);
+    }
+
+    return 0;
+}
+
+static void flush_cpu_state(CPUState *cpu)
+{
+    if (cpu->vcpu_dirty) {
+        hvf_put_registers(cpu);
+        cpu->vcpu_dirty = false;
+    }
+}
+
+static void hvf_set_reg(CPUState *cpu, int rt, uint64_t val)
+{
+    hv_return_t r;
+
+    flush_cpu_state(cpu);
+
+    if (rt < 31) {
+        r = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_X0 + rt, val);
+        assert_hvf_ok(r);
+    }
+}
+
+static uint64_t hvf_get_reg(CPUState *cpu, int rt)
+{
+    uint64_t val = 0;
+    hv_return_t r;
+
+    flush_cpu_state(cpu);
+
+    if (rt < 31) {
+        r = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_X0 + rt, &val);
+        assert_hvf_ok(r);
+    }
+
+    return val;
+}
+
+void hvf_arch_vcpu_destroy(CPUState *cpu)
+{
+}
+
+int hvf_arch_init_vcpu(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    uint32_t sregs_match_len = ARRAY_SIZE(hvf_sreg_match);
+    uint64_t pfr;
+    hv_return_t ret;
+    int i;
+
+    env->aarch64 = 1;
+    asm volatile("mrs %0, cntfrq_el0" : "=r"(arm_cpu->gt_cntfrq_hz));
+
+    /* Allocate enough space for our sysreg sync */
+    arm_cpu->cpreg_indexes = g_renew(uint64_t, arm_cpu->cpreg_indexes,
+                                     sregs_match_len);
+    arm_cpu->cpreg_values = g_renew(uint64_t, arm_cpu->cpreg_values,
+                                    sregs_match_len);
+    arm_cpu->cpreg_vmstate_indexes = g_renew(uint64_t,
+                                             arm_cpu->cpreg_vmstate_indexes,
+                                             sregs_match_len);
+    arm_cpu->cpreg_vmstate_values = g_renew(uint64_t,
+                                            arm_cpu->cpreg_vmstate_values,
+                                            sregs_match_len);
+
+    memset(arm_cpu->cpreg_values, 0, sregs_match_len * sizeof(uint64_t));
+    arm_cpu->cpreg_array_len = sregs_match_len;
+    arm_cpu->cpreg_vmstate_array_len = sregs_match_len;
+
+    /* Populate cp list for all known sysregs */
+    for (i = 0; i < sregs_match_len; i++) {
+        const ARMCPRegInfo *ri;
+
+        arm_cpu->cpreg_indexes[i] = cpreg_to_kvm_id(hvf_sreg_match[i].key);
+
+        ri = get_arm_cp_reginfo(arm_cpu->cp_regs, hvf_sreg_match[i].key);
+        if (ri) {
+            assert(!(ri->type & ARM_CP_NO_RAW));
+        }
+    }
+    write_cpustate_to_list(arm_cpu, false);
+
+    /* Set CP_NO_RAW system registers on init */
+    ret = hv_vcpu_set_sys_reg(cpu->hvf->fd, HV_SYS_REG_MIDR_EL1,
+                              arm_cpu->midr);
+    assert_hvf_ok(ret);
+
+    ret = hv_vcpu_set_sys_reg(cpu->hvf->fd, HV_SYS_REG_MPIDR_EL1,
+                              arm_cpu->mp_affinity);
+    assert_hvf_ok(ret);
+
+    ret = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_ID_AA64PFR0_EL1, &pfr);
+    assert_hvf_ok(ret);
+    pfr |= env->gicv3state ? (1 << 24) : 0;
+    ret = hv_vcpu_set_sys_reg(cpu->hvf->fd, HV_SYS_REG_ID_AA64PFR0_EL1, pfr);
+    assert_hvf_ok(ret);
+
+    /* We're limited to underlying hardware caps, override internal versions */
+    ret = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_ID_AA64MMFR0_EL1,
+                              &arm_cpu->isar.id_aa64mmfr0);
+    assert_hvf_ok(ret);
+
+    return 0;
+}
+
+void hvf_kick_vcpu_thread(CPUState *cpu)
+{
+    hv_vcpus_exit(&cpu->hvf->fd, 1);
+}
+
+static void hvf_raise_exception(CPUARMState *env, uint32_t excp,
+                                uint32_t syndrome)
+{
+    unsigned int new_el = 1;
+    unsigned int old_mode = pstate_read(env);
+    unsigned int new_mode = aarch64_pstate_mode(new_el, true);
+    target_ulong addr = env->cp15.vbar_el[new_el];
+
+    env->cp15.esr_el[new_el] = syndrome;
+    aarch64_save_sp(env, arm_current_el(env));
+    env->elr_el[new_el] = env->pc;
+    env->banked_spsr[aarch64_banked_spsr_index(new_el)] = old_mode;
+    pstate_write(env, PSTATE_DAIF | new_mode);
+    aarch64_restore_sp(env, new_el);
+    env->pc = addr;
+}
+
+static uint64_t hvf_sysreg_read(CPUState *cpu, uint32_t reg)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    uint64_t val = 0;
+
+    switch (reg) {
+    case SYSREG_CNTPCT_EL0:
+        val = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) /
+              gt_cntfrq_period_ns(arm_cpu);
+        break;
+    case SYSREG_PMCCNTR_EL0:
+        val = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
+        break;
+    default:
+        trace_hvf_unhandled_sysreg_read(reg,
+                                        (reg >> 20) & 0x3,
+                                        (reg >> 14) & 0x7,
+                                        (reg >> 10) & 0xf,
+                                        (reg >> 1) & 0xf,
+                                        (reg >> 17) & 0x7);
+        break;
+    }
+
+    return val;
+}
+
+static void hvf_sysreg_write(CPUState *cpu, uint32_t reg, uint64_t val)
+{
+    switch (reg) {
+    case SYSREG_CNTPCT_EL0:
+        break;
+    default:
+        trace_hvf_unhandled_sysreg_write(reg,
+                                         (reg >> 20) & 0x3,
+                                         (reg >> 14) & 0x7,
+                                         (reg >> 10) & 0xf,
+                                         (reg >> 1) & 0xf,
+                                         (reg >> 17) & 0x7);
+        break;
+    }
+}
+
+static int hvf_inject_interrupts(CPUState *cpu)
+{
+    if (cpu->interrupt_request & CPU_INTERRUPT_FIQ) {
+        trace_hvf_inject_fiq();
+        hv_vcpu_set_pending_interrupt(cpu->hvf->fd, HV_INTERRUPT_TYPE_FIQ,
+                                      true);
+    }
+
+    if (cpu->interrupt_request & CPU_INTERRUPT_HARD) {
+        trace_hvf_inject_irq();
+        hv_vcpu_set_pending_interrupt(cpu->hvf->fd, HV_INTERRUPT_TYPE_IRQ,
+                                      true);
+    }
+
+    return 0;
+}
+
+static void hvf_sync_vtimer(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    hv_return_t r;
+    uint64_t ctl;
+    bool irq_state;
+
+    if (!cpu->hvf->vtimer_masked) {
+        /* We will get notified on vtimer changes by hvf, nothing to do */
+        return;
+    }
+
+    r = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_CNTV_CTL_EL0, &ctl);
+    assert_hvf_ok(r);
+
+    irq_state = (ctl & (TMR_CTL_ENABLE | TMR_CTL_IMASK | TMR_CTL_ISTATUS)) ==
+                (TMR_CTL_ENABLE | TMR_CTL_ISTATUS);
+    qemu_set_irq(arm_cpu->gt_timer_outputs[GTIMER_VIRT], irq_state);
+
+    if (!irq_state) {
+        /* Timer no longer asserting, we can unmask it */
+        hv_vcpu_set_vtimer_mask(cpu->hvf->fd, false);
+        cpu->hvf->vtimer_masked = false;
+    }
+}
+
+int hvf_vcpu_exec(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    hv_vcpu_exit_t *hvf_exit = cpu->hvf->exit;
+    hv_return_t r;
+    bool advance_pc = false;
+
+    flush_cpu_state(cpu);
+
+    hvf_sync_vtimer(cpu);
+
+    if (hvf_inject_interrupts(cpu)) {
+        return EXCP_INTERRUPT;
+    }
+
+    if (cpu->halted) {
+        return EXCP_HLT;
+    }
+
+    qemu_mutex_unlock_iothread();
+    assert_hvf_ok(hv_vcpu_run(cpu->hvf->fd));
+
+    /* handle VMEXIT */
+    uint64_t exit_reason = hvf_exit->reason;
+    uint64_t syndrome = hvf_exit->exception.syndrome;
+    uint32_t ec = syn_get_ec(syndrome);
+
+    qemu_mutex_lock_iothread();
+    switch (exit_reason) {
+    case HV_EXIT_REASON_EXCEPTION:
+        /* This is the main one, handle below. */
+        break;
+    case HV_EXIT_REASON_VTIMER_ACTIVATED:
+        qemu_set_irq(arm_cpu->gt_timer_outputs[GTIMER_VIRT], 1);
+        cpu->hvf->vtimer_masked = true;
+        return 0;
+    case HV_EXIT_REASON_CANCELED:
+        /* we got kicked, no exit to process */
+        return 0;
+    default:
+        assert(0);
+    }
+
+    switch (ec) {
+    case EC_DATAABORT: {
+        bool isv = syndrome & ARM_EL_ISV;
+        bool iswrite = (syndrome >> 6) & 1;
+        bool s1ptw = (syndrome >> 7) & 1;
+        uint32_t sas = (syndrome >> 22) & 3;
+        uint32_t len = 1 << sas;
+        uint32_t srt = (syndrome >> 16) & 0x1f;
+        uint64_t val = 0;
+
+        trace_hvf_data_abort(env->pc, hvf_exit->exception.virtual_address,
+                             hvf_exit->exception.physical_address, isv,
+                             iswrite, s1ptw, len, srt);
+
+        assert(isv);
+
+        if (iswrite) {
+            val = hvf_get_reg(cpu, srt);
+            address_space_write(&address_space_memory,
+                                hvf_exit->exception.physical_address,
+                                MEMTXATTRS_UNSPECIFIED, &val, len);
+        } else {
+            address_space_read(&address_space_memory,
+                               hvf_exit->exception.physical_address,
+                               MEMTXATTRS_UNSPECIFIED, &val, len);
+            hvf_set_reg(cpu, srt, val);
+        }
+
+        advance_pc = true;
+        break;
+    }
+    case EC_SYSTEMREGISTERTRAP: {
+        bool isread = (syndrome >> 0) & 1;
+        uint32_t rt = (syndrome >> 5) & 0x1f;
+        uint32_t reg = syndrome & SYSREG_MASK;
+        uint64_t val = 0;
+
+        if (isread) {
+            val = hvf_sysreg_read(cpu, reg);
+            trace_hvf_sysreg_read(reg,
+                                  (reg >> 20) & 0x3,
+                                  (reg >> 14) & 0x7,
+                                  (reg >> 10) & 0xf,
+                                  (reg >> 1) & 0xf,
+                                  (reg >> 17) & 0x7,
+                                  val);
+            hvf_set_reg(cpu, rt, val);
+        } else {
+            val = hvf_get_reg(cpu, rt);
+            trace_hvf_sysreg_write(reg,
+                                   (reg >> 20) & 0x3,
+                                   (reg >> 14) & 0x7,
+                                   (reg >> 10) & 0xf,
+                                   (reg >> 1) & 0xf,
+                                   (reg >> 17) & 0x7,
+                                   val);
+            hvf_sysreg_write(cpu, reg, val);
+        }
+
+        advance_pc = true;
+        break;
+    }
+    case EC_WFX_TRAP:
+        advance_pc = true;
+        break;
+    case EC_AA64_HVC:
+        cpu_synchronize_state(cpu);
+        trace_hvf_unknown_hvf(env->xregs[0]);
+        hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        break;
+    case EC_AA64_SMC:
+        cpu_synchronize_state(cpu);
+        trace_hvf_unknown_smc(env->xregs[0]);
+        hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        break;
+    default:
+        cpu_synchronize_state(cpu);
+        trace_hvf_exit(syndrome, ec, env->pc);
+        error_report("0x%llx: unhandled exit 0x%llx", env->pc, exit_reason);
+    }
+
+    if (advance_pc) {
+        uint64_t pc;
+
+        flush_cpu_state(cpu);
+
+        r = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_PC, &pc);
+        assert_hvf_ok(r);
+        pc += 4;
+        r = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_PC, pc);
+        assert_hvf_ok(r);
+    }
+
+    return 0;
+}
diff --git a/target/arm/hvf/trace-events b/target/arm/hvf/trace-events
new file mode 100644
index 000000000000..49a547dcf66e
--- /dev/null
+++ b/target/arm/hvf/trace-events
@@ -0,0 +1,10 @@
+hvf_unhandled_sysreg_read(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_t crm, uint32_t op2) "unhandled sysreg read 0x%08x (op0=%d op1=%d crn=%d crm=%d op2=%d)"
+hvf_unhandled_sysreg_write(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_t crm, uint32_t op2) "unhandled sysreg write 0x%08x (op0=%d op1=%d crn=%d crm=%d op2=%d)"
+hvf_inject_fiq(void) "injecting FIQ"
+hvf_inject_irq(void) "injecting IRQ"
+hvf_data_abort(uint64_t pc, uint64_t va, uint64_t pa, bool isv, bool iswrite, bool s1ptw, uint32_t len, uint32_t srt) "data abort: [pc=0x%"PRIx64" va=0x%016"PRIx64" pa=0x%016"PRIx64" isv=%d iswrite=%d s1ptw=%d len=%d srt=%d]"
+hvf_sysreg_read(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_t crm, uint32_t op2, uint64_t val) "sysreg read 0x%08x (op0=%d op1=%d crn=%d crm=%d op2=%d) = 0x%016"PRIx64
+hvf_sysreg_write(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_t crm, uint32_t op2, uint64_t val) "sysreg write 0x%08x (op0=%d op1=%d crn=%d crm=%d op2=%d, val=0x%016"PRIx64")"
+hvf_unknown_hvf(uint64_t x0) "unknown HVC! 0x%016"PRIx64
+hvf_unknown_smc(uint64_t x0) "unknown SMC! 0x%016"PRIx64
+hvf_exit(uint64_t syndrome, uint32_t ec, uint64_t pc) "exit: 0x%"PRIx64" [ec=0x%x pc=0x%"PRIx64"]"

From dc32fd2d898124f13d04bd42bf9ecae4925e8674 Mon Sep 17 00:00:00 2001
From: Peter Collingbourne <pcc@google.com>
Date: Wed, 19 May 2021 22:22:48 +0200
Subject: [PATCH 059/180] arm/hvf: Add a WFI handler

Sleep on WFI until the VTIMER is due but allow ourselves to be woken
up on IPI.

In this implementation IPI is blocked on the CPU thread at startup and
pselect() is used to atomically unblock the signal and begin sleeping.
The signal is sent unconditionally so there's no need to worry about
races between actually sleeping and the "we think we're sleeping"
state. It may lead to an extra wakeup but that's better than missing
it entirely.

Signed-off-by: Peter Collingbourne <pcc@google.com>
[agraf: Remove unused 'set' variable, always advance PC on WFX trap]
Signed-off-by: Alexander Graf <agraf@csgraf.de>
Acked-by: Roman Bolshakov <r.bolshakov@yadro.com>

Message-Id: <20210519202253.76782-15-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c |  5 ++-
 include/sysemu/hvf_int.h  |  1 +
 target/arm/hvf/hvf.c      | 68 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 71 insertions(+), 3 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 48e402ef57bf..63ec8a6f2558 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -369,15 +369,14 @@ static int hvf_init_vcpu(CPUState *cpu)
     cpu->hvf = g_malloc0(sizeof(*cpu->hvf));
 
     /* init cpu signals */
-    sigset_t set;
     struct sigaction sigact;
 
     memset(&sigact, 0, sizeof(sigact));
     sigact.sa_handler = dummy_signal;
     sigaction(SIG_IPI, &sigact, NULL);
 
-    pthread_sigmask(SIG_BLOCK, NULL, &set);
-    sigdelset(&set, SIG_IPI);
+    pthread_sigmask(SIG_BLOCK, NULL, &cpu->hvf->unblock_ipi_mask);
+    sigdelset(&cpu->hvf->unblock_ipi_mask, SIG_IPI);
 
 #ifdef __aarch64__
     r = hv_vcpu_create(&cpu->hvf->fd, (hv_vcpu_exit_t **)&cpu->hvf->exit, NULL);
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index e52d67ed5c74..6d4eef806529 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -51,6 +51,7 @@ struct hvf_vcpu_state {
     uint64_t fd;
     void *exit;
     bool vtimer_masked;
+    sigset_t unblock_ipi_mask;
 };
 
 void assert_hvf_ok(hv_return_t ret);
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 3934c05979d5..67002efd3668 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -2,6 +2,7 @@
  * QEMU Hypervisor.framework support for Apple Silicon
 
  * Copyright 2020 Alexander Graf <agraf@csgraf.de>
+ * Copyright 2020 Google LLC
  *
  * This work is licensed under the terms of the GNU GPL, version 2 or later.
  * See the COPYING file in the top-level directory.
@@ -17,6 +18,8 @@
 #include "sysemu/hvf_int.h"
 #include "sysemu/hw_accel.h"
 
+#include <mach/mach_time.h>
+
 #include "exec/address-spaces.h"
 #include "hw/irq.h"
 #include "qemu/main-loop.h"
@@ -457,6 +460,7 @@ int hvf_arch_init_vcpu(CPUState *cpu)
 
 void hvf_kick_vcpu_thread(CPUState *cpu)
 {
+    cpus_kick_thread(cpu);
     hv_vcpus_exit(&cpu->hvf->fd, 1);
 }
 
@@ -536,6 +540,67 @@ static int hvf_inject_interrupts(CPUState *cpu)
     return 0;
 }
 
+static void hvf_wait_for_ipi(CPUState *cpu, struct timespec *ts)
+{
+    /*
+     * Use pselect to sleep so that other threads can IPI us while we're
+     * sleeping.
+     */
+    qatomic_mb_set(&cpu->thread_kicked, false);
+    qemu_mutex_unlock_iothread();
+    pselect(0, 0, 0, 0, ts, &cpu->hvf->unblock_ipi_mask);
+    qemu_mutex_lock_iothread();
+}
+
+static void hvf_wfi(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    hv_return_t r;
+    uint64_t ctl;
+
+    if (cpu->interrupt_request & (CPU_INTERRUPT_HARD | CPU_INTERRUPT_FIQ)) {
+        /* Interrupt pending, no need to wait */
+        return;
+    }
+
+    r = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_CNTV_CTL_EL0,
+                            &ctl);
+    assert_hvf_ok(r);
+
+    if (!(ctl & 1) || (ctl & 2)) {
+        /* Timer disabled or masked, just wait for an IPI. */
+        hvf_wait_for_ipi(cpu, NULL);
+        return;
+    }
+
+    uint64_t cval;
+    r = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_CNTV_CVAL_EL0,
+                            &cval);
+    assert_hvf_ok(r);
+
+    int64_t ticks_to_sleep = cval - mach_absolute_time();
+    if (ticks_to_sleep < 0) {
+        return;
+    }
+
+    uint64_t seconds = ticks_to_sleep / arm_cpu->gt_cntfrq_hz;
+    uint64_t nanos =
+        (ticks_to_sleep - arm_cpu->gt_cntfrq_hz * seconds) *
+        1000000000 / arm_cpu->gt_cntfrq_hz;
+
+    /*
+     * Don't sleep for less than the time a context switch would take,
+     * so that we can satisfy fast timer requests on the same CPU.
+     * Measurements on M1 show the sweet spot to be ~2ms.
+     */
+    if (!seconds && nanos < 2000000) {
+        return;
+    }
+
+    struct timespec ts = { seconds, nanos };
+    hvf_wait_for_ipi(cpu, &ts);
+}
+
 static void hvf_sync_vtimer(CPUState *cpu)
 {
     ARMCPU *arm_cpu = ARM_CPU(cpu);
@@ -670,6 +735,9 @@ int hvf_vcpu_exec(CPUState *cpu)
     }
     case EC_WFX_TRAP:
         advance_pc = true;
+        if (!(syndrome & WFX_IS_WFE)) {
+            hvf_wfi(cpu);
+        }
         break;
     case EC_AA64_HVC:
         cpu_synchronize_state(cpu);

From dbbbd13bf65c1c915fb15fa4a261f303b83dbf7c Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:49 +0200
Subject: [PATCH 060/180] hvf: arm: Implement -cpu host

Now that we have working system register sync, we push more target CPU
properties into the virtual machine. That might be useful in some
situations, but is not the typical case that users want.

So let's add a -cpu host option that allows them to explicitly pass all
CPU capabilities of their host CPU into the guest.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Acked-by: Roman Bolshakov <r.bolshakov@yadro.com>

Message-Id: <20210519202253.76782-16-agraf@csgraf.de>
---
 target/arm/cpu.c     |  9 ++++--
 target/arm/cpu.h     |  2 ++
 target/arm/hvf/hvf.c | 72 ++++++++++++++++++++++++++++++++++++++++++++
 target/arm/hvf_arm.h | 19 ++++++++++++
 target/arm/kvm_arm.h |  2 --
 5 files changed, 100 insertions(+), 4 deletions(-)
 create mode 100644 target/arm/hvf_arm.h

diff --git a/target/arm/cpu.c b/target/arm/cpu.c
index 0dd623e59094..1f8b75292d7e 100644
--- a/target/arm/cpu.c
+++ b/target/arm/cpu.c
@@ -40,6 +40,7 @@
 #include "sysemu/tcg.h"
 #include "sysemu/hw_accel.h"
 #include "kvm_arm.h"
+#include "hvf_arm.h"
 #include "disas/capstone.h"
 #include "fpu/softfloat.h"
 
@@ -1999,15 +2000,19 @@ static void arm_cpu_class_init(ObjectClass *oc, void *data)
 #endif /* CONFIG_TCG */
 }
 
-#ifdef CONFIG_KVM
+#if defined(CONFIG_KVM) || defined(CONFIG_HVF)
 static void arm_host_initfn(Object *obj)
 {
     ARMCPU *cpu = ARM_CPU(obj);
 
+#ifdef CONFIG_KVM
     kvm_arm_set_cpu_features_from_host(cpu);
     if (arm_feature(&cpu->env, ARM_FEATURE_AARCH64)) {
         aarch64_add_sve_properties(obj);
     }
+#else
+    hvf_arm_set_cpu_features_from_host(cpu);
+#endif
     arm_cpu_post_init(obj);
 }
 
@@ -2067,7 +2072,7 @@ static void arm_cpu_register_types(void)
 {
     type_register_static(&arm_cpu_type_info);
 
-#ifdef CONFIG_KVM
+#if defined(CONFIG_KVM) || defined(CONFIG_HVF)
     type_register_static(&host_arm_cpu_type_info);
 #endif
 }
diff --git a/target/arm/cpu.h b/target/arm/cpu.h
index 193a49ec7fac..1beddfc8b8ca 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -2972,6 +2972,8 @@ bool write_cpustate_to_list(ARMCPU *cpu, bool kvm_sync);
 #define ARM_CPU_TYPE_NAME(name) (name ARM_CPU_TYPE_SUFFIX)
 #define CPU_RESOLVING_TYPE TYPE_ARM_CPU
 
+#define TYPE_ARM_HOST_CPU "host-" TYPE_ARM_CPU
+
 #define cpu_signal_handler cpu_arm_signal_handler
 #define cpu_list arm_cpu_list
 
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 67002efd3668..bce46f3ed811 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -17,6 +17,7 @@
 #include "sysemu/hvf.h"
 #include "sysemu/hvf_int.h"
 #include "sysemu/hw_accel.h"
+#include "hvf_arm.h"
 
 #include <mach/mach_time.h>
 
@@ -44,6 +45,16 @@
 #define TMR_CTL_IMASK   (1 << 1)
 #define TMR_CTL_ISTATUS (1 << 2)
 
+typedef struct ARMHostCPUFeatures {
+    ARMISARegisters isar;
+    uint64_t features;
+    uint64_t midr;
+    uint32_t reset_sctlr;
+    const char *dtb_compatible;
+} ARMHostCPUFeatures;
+
+static ARMHostCPUFeatures arm_host_cpu_features;
+
 struct hvf_reg_match {
     int reg;
     uint64_t offset;
@@ -390,6 +401,67 @@ static uint64_t hvf_get_reg(CPUState *cpu, int rt)
     return val;
 }
 
+static void hvf_arm_get_host_cpu_features(ARMHostCPUFeatures *ahcf)
+{
+    ARMISARegisters host_isar;
+    const struct isar_regs {
+        int reg;
+        uint64_t *val;
+    } regs[] = {
+        { HV_SYS_REG_ID_AA64PFR0_EL1, &host_isar.id_aa64pfr0 },
+        { HV_SYS_REG_ID_AA64PFR1_EL1, &host_isar.id_aa64pfr1 },
+        { HV_SYS_REG_ID_AA64DFR0_EL1, &host_isar.id_aa64dfr0 },
+        { HV_SYS_REG_ID_AA64DFR1_EL1, &host_isar.id_aa64dfr1 },
+        { HV_SYS_REG_ID_AA64ISAR0_EL1, &host_isar.id_aa64isar0 },
+        { HV_SYS_REG_ID_AA64ISAR1_EL1, &host_isar.id_aa64isar1 },
+        { HV_SYS_REG_ID_AA64MMFR0_EL1, &host_isar.id_aa64mmfr0 },
+        { HV_SYS_REG_ID_AA64MMFR1_EL1, &host_isar.id_aa64mmfr1 },
+        { HV_SYS_REG_ID_AA64MMFR2_EL1, &host_isar.id_aa64mmfr2 },
+    };
+    hv_vcpu_t fd;
+    hv_vcpu_exit_t *exit;
+    int i;
+
+    ahcf->dtb_compatible = "arm,arm-v8";
+    ahcf->features = (1ULL << ARM_FEATURE_V8) |
+                     (1ULL << ARM_FEATURE_NEON) |
+                     (1ULL << ARM_FEATURE_AARCH64) |
+                     (1ULL << ARM_FEATURE_PMU) |
+                     (1ULL << ARM_FEATURE_GENERIC_TIMER);
+
+    /* We set up a small vcpu to extract host registers */
+
+    assert_hvf_ok(hv_vcpu_create(&fd, &exit, NULL));
+    for (i = 0; i < ARRAY_SIZE(regs); i++) {
+        assert_hvf_ok(hv_vcpu_get_sys_reg(fd, regs[i].reg, regs[i].val));
+    }
+    assert_hvf_ok(hv_vcpu_get_sys_reg(fd, HV_SYS_REG_MIDR_EL1, &ahcf->midr));
+    assert_hvf_ok(hv_vcpu_destroy(fd));
+
+    ahcf->isar = host_isar;
+    ahcf->reset_sctlr = 0x00c50078;
+
+    /* Make sure we don't advertise AArch32 support for EL0/EL1 */
+    g_assert((host_isar.id_aa64pfr0 & 0xff) == 0x11);
+}
+
+void hvf_arm_set_cpu_features_from_host(ARMCPU *cpu)
+{
+    if (!arm_host_cpu_features.dtb_compatible) {
+        if (!hvf_enabled()) {
+            cpu->host_cpu_probe_failed = true;
+            return;
+        }
+        hvf_arm_get_host_cpu_features(&arm_host_cpu_features);
+    }
+
+    cpu->dtb_compatible = arm_host_cpu_features.dtb_compatible;
+    cpu->isar = arm_host_cpu_features.isar;
+    cpu->env.features = arm_host_cpu_features.features;
+    cpu->midr = arm_host_cpu_features.midr;
+    cpu->reset_sctlr = arm_host_cpu_features.reset_sctlr;
+}
+
 void hvf_arch_vcpu_destroy(CPUState *cpu)
 {
 }
diff --git a/target/arm/hvf_arm.h b/target/arm/hvf_arm.h
new file mode 100644
index 000000000000..603074a33132
--- /dev/null
+++ b/target/arm/hvf_arm.h
@@ -0,0 +1,19 @@
+/*
+ * QEMU Hypervisor.framework (HVF) support -- ARM specifics
+ *
+ * Copyright (c) 2021 Alexander Graf
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#ifndef QEMU_HVF_ARM_H
+#define QEMU_HVF_ARM_H
+
+#include "qemu/accel.h"
+#include "cpu.h"
+
+void hvf_arm_set_cpu_features_from_host(struct ARMCPU *cpu);
+
+#endif
diff --git a/target/arm/kvm_arm.h b/target/arm/kvm_arm.h
index 34f8daa37752..828dca4a4a9d 100644
--- a/target/arm/kvm_arm.h
+++ b/target/arm/kvm_arm.h
@@ -214,8 +214,6 @@ bool kvm_arm_create_scratch_host_vcpu(const uint32_t *cpus_to_try,
  */
 void kvm_arm_destroy_scratch_host_vcpu(int *fdarray);
 
-#define TYPE_ARM_HOST_CPU "host-" TYPE_ARM_CPU
-
 /**
  * ARMHostCPUFeatures: information about the host CPU (identified
  * by asking the host kernel)

From f479e7eacd95af6ed91dbec01263e2359619d073 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:50 +0200
Subject: [PATCH 061/180] hvf: arm: Implement PSCI handling

We need to handle PSCI calls. Most of the TCG code works for us,
but we can simplify it to only handle aa64 mode and we need to
handle SUSPEND differently.

This patch takes the TCG code as template and duplicates it in HVF.

To tell the guest that we support PSCI 0.2 now, update the check in
arm_cpu_initfn() as well.

Signed-off-by: Alexander Graf <agraf@csgraf.de>

Message-Id: <20210519202253.76782-17-agraf@csgraf.de>
---
 target/arm/cpu.c            |   4 +-
 target/arm/hvf/hvf.c        | 123 ++++++++++++++++++++++++++++++++++--
 target/arm/hvf/trace-events |   1 +
 3 files changed, 122 insertions(+), 6 deletions(-)

diff --git a/target/arm/cpu.c b/target/arm/cpu.c
index 1f8b75292d7e..93b9fe1020d1 100644
--- a/target/arm/cpu.c
+++ b/target/arm/cpu.c
@@ -1080,8 +1080,8 @@ static void arm_cpu_initfn(Object *obj)
     cpu->psci_version = 1; /* By default assume PSCI v0.1 */
     cpu->kvm_target = QEMU_KVM_ARM_TARGET_NONE;
 
-    if (tcg_enabled()) {
-        cpu->psci_version = 2; /* TCG implements PSCI 0.2 */
+    if (tcg_enabled() || hvf_enabled()) {
+        cpu->psci_version = 2; /* TCG and HVF implement PSCI 0.2 */
     }
 }
 
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index bce46f3ed811..65c33e2a1421 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -25,6 +25,7 @@
 #include "hw/irq.h"
 #include "qemu/main-loop.h"
 #include "sysemu/cpus.h"
+#include "arm-powerctl.h"
 #include "target/arm/cpu.h"
 #include "target/arm/internals.h"
 #include "trace/trace-target_arm_hvf.h"
@@ -45,6 +46,8 @@
 #define TMR_CTL_IMASK   (1 << 1)
 #define TMR_CTL_ISTATUS (1 << 2)
 
+static void hvf_wfi(CPUState *cpu);
+
 typedef struct ARMHostCPUFeatures {
     ARMISARegisters isar;
     uint64_t features;
@@ -553,6 +556,110 @@ static void hvf_raise_exception(CPUARMState *env, uint32_t excp,
     env->pc = addr;
 }
 
+static int hvf_psci_cpu_off(ARMCPU *arm_cpu)
+{
+    int32_t ret = 0;
+    ret = arm_set_cpu_off(arm_cpu->mp_affinity);
+    assert(ret == QEMU_ARM_POWERCTL_RET_SUCCESS);
+
+    return 0;
+}
+
+static int hvf_handle_psci_call(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    uint64_t param[4] = {
+        env->xregs[0],
+        env->xregs[1],
+        env->xregs[2],
+        env->xregs[3]
+    };
+    uint64_t context_id, mpidr;
+    bool target_aarch64 = true;
+    CPUState *target_cpu_state;
+    ARMCPU *target_cpu;
+    target_ulong entry;
+    int target_el = 1;
+    int32_t ret = 0;
+
+    trace_hvf_psci_call(param[0], param[1], param[2], param[3],
+                        arm_cpu->mp_affinity);
+
+    switch (param[0]) {
+    case QEMU_PSCI_0_2_FN_PSCI_VERSION:
+        ret = QEMU_PSCI_0_2_RET_VERSION_0_2;
+        break;
+    case QEMU_PSCI_0_2_FN_MIGRATE_INFO_TYPE:
+        ret = QEMU_PSCI_0_2_RET_TOS_MIGRATION_NOT_REQUIRED; /* No trusted OS */
+        break;
+    case QEMU_PSCI_0_2_FN_AFFINITY_INFO:
+    case QEMU_PSCI_0_2_FN64_AFFINITY_INFO:
+        mpidr = param[1];
+
+        switch (param[2]) {
+        case 0:
+            target_cpu_state = arm_get_cpu_by_id(mpidr);
+            if (!target_cpu_state) {
+                ret = QEMU_PSCI_RET_INVALID_PARAMS;
+                break;
+            }
+            target_cpu = ARM_CPU(target_cpu_state);
+
+            ret = target_cpu->power_state;
+            break;
+        default:
+            /* Everything above affinity level 0 is always on. */
+            ret = 0;
+        }
+        break;
+    case QEMU_PSCI_0_2_FN_SYSTEM_RESET:
+        qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);
+        /* QEMU reset and shutdown are async requests, but PSCI
+         * mandates that we never return from the reset/shutdown
+         * call, so power the CPU off now so it doesn't execute
+         * anything further.
+         */
+        return hvf_psci_cpu_off(arm_cpu);
+    case QEMU_PSCI_0_2_FN_SYSTEM_OFF:
+        qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);
+        return hvf_psci_cpu_off(arm_cpu);
+    case QEMU_PSCI_0_1_FN_CPU_ON:
+    case QEMU_PSCI_0_2_FN_CPU_ON:
+    case QEMU_PSCI_0_2_FN64_CPU_ON:
+        mpidr = param[1];
+        entry = param[2];
+        context_id = param[3];
+        ret = arm_set_cpu_on(mpidr, entry, context_id,
+                             target_el, target_aarch64);
+        break;
+    case QEMU_PSCI_0_1_FN_CPU_OFF:
+    case QEMU_PSCI_0_2_FN_CPU_OFF:
+        return hvf_psci_cpu_off(arm_cpu);
+    case QEMU_PSCI_0_1_FN_CPU_SUSPEND:
+    case QEMU_PSCI_0_2_FN_CPU_SUSPEND:
+    case QEMU_PSCI_0_2_FN64_CPU_SUSPEND:
+        /* Affinity levels are not supported in QEMU */
+        if (param[1] & 0xfffe0000) {
+            ret = QEMU_PSCI_RET_INVALID_PARAMS;
+            break;
+        }
+        /* Powerdown is not supported, we always go into WFI */
+        env->xregs[0] = 0;
+        hvf_wfi(cpu);
+        break;
+    case QEMU_PSCI_0_1_FN_MIGRATE:
+    case QEMU_PSCI_0_2_FN_MIGRATE:
+        ret = QEMU_PSCI_RET_NOT_SUPPORTED;
+        break;
+    default:
+        return 1;
+    }
+
+    env->xregs[0] = ret;
+    return 0;
+}
+
 static uint64_t hvf_sysreg_read(CPUState *cpu, uint32_t reg)
 {
     ARMCPU *arm_cpu = ARM_CPU(cpu);
@@ -716,6 +823,8 @@ int hvf_vcpu_exec(CPUState *cpu)
     }
 
     if (cpu->halted) {
+        /* On unhalt, we usually have CPU state changes. Prepare for them. */
+        cpu_synchronize_state(cpu);
         return EXCP_HLT;
     }
 
@@ -813,13 +922,19 @@ int hvf_vcpu_exec(CPUState *cpu)
         break;
     case EC_AA64_HVC:
         cpu_synchronize_state(cpu);
-        trace_hvf_unknown_hvf(env->xregs[0]);
-        hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        if (hvf_handle_psci_call(cpu)) {
+            trace_hvf_unknown_hvf(env->xregs[0]);
+            hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        }
         break;
     case EC_AA64_SMC:
         cpu_synchronize_state(cpu);
-        trace_hvf_unknown_smc(env->xregs[0]);
-        hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        if (!hvf_handle_psci_call(cpu)) {
+            advance_pc = true;
+        } else {
+            trace_hvf_unknown_smc(env->xregs[0]);
+            hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        }
         break;
     default:
         cpu_synchronize_state(cpu);
diff --git a/target/arm/hvf/trace-events b/target/arm/hvf/trace-events
index 49a547dcf66e..278b88cc62a6 100644
--- a/target/arm/hvf/trace-events
+++ b/target/arm/hvf/trace-events
@@ -8,3 +8,4 @@ hvf_sysreg_write(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_
 hvf_unknown_hvf(uint64_t x0) "unknown HVC! 0x%016"PRIx64
 hvf_unknown_smc(uint64_t x0) "unknown SMC! 0x%016"PRIx64
 hvf_exit(uint64_t syndrome, uint32_t ec, uint64_t pc) "exit: 0x%"PRIx64" [ec=0x%x pc=0x%"PRIx64"]"
+hvf_psci_call(uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint32_t cpuid) "PSCI Call x0=0x%016"PRIx64" x1=0x%016"PRIx64" x2=0x%016"PRIx64" x3=0x%016"PRIx64" cpu=0x%x"

From 6d6e43ebce1f9dc4326ff8fdb124f628b12c055d Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:51 +0200
Subject: [PATCH 062/180] arm: Add Hypervisor.framework build target

Now that we have all logic in place that we need to handle Hypervisor.framework
on Apple Silicon systems, let's add CONFIG_HVF for aarch64 as well so that we
can build it.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reviewed-by: Roman Bolshakov <r.bolshakov@yadro.com>
Tested-by: Roman Bolshakov <r.bolshakov@yadro.com> (x86 only)

Message-Id: <20210519202253.76782-18-agraf@csgraf.de>
---
 meson.build                | 7 +++++++
 target/arm/hvf/meson.build | 3 +++
 target/arm/meson.build     | 2 ++
 3 files changed, 12 insertions(+)
 create mode 100644 target/arm/hvf/meson.build

diff --git a/meson.build b/meson.build
index 93a293849d17..7027a92548ce 100644
--- a/meson.build
+++ b/meson.build
@@ -77,6 +77,13 @@ else
 endif
 
 accelerator_targets = { 'CONFIG_KVM': kvm_targets }
+
+if cpu in ['aarch64']
+  accelerator_targets += {
+    'CONFIG_HVF': ['aarch64-softmmu']
+  }
+endif
+
 if cpu in ['x86', 'x86_64', 'arm', 'aarch64']
   # i368 emulator provides xenpv machine type for multiple architectures
   accelerator_targets += {
diff --git a/target/arm/hvf/meson.build b/target/arm/hvf/meson.build
new file mode 100644
index 000000000000..855e6cce5ab6
--- /dev/null
+++ b/target/arm/hvf/meson.build
@@ -0,0 +1,3 @@
+arm_softmmu_ss.add(when: [hvf, 'CONFIG_HVF'], if_true: files(
+  'hvf.c',
+))
diff --git a/target/arm/meson.build b/target/arm/meson.build
index 15b936c10100..2efd6e672a4c 100644
--- a/target/arm/meson.build
+++ b/target/arm/meson.build
@@ -54,5 +54,7 @@ arm_softmmu_ss.add(files(
   'psci.c',
 ))
 
+subdir('hvf')
+
 target_arch += {'arm': arm_ss}
 target_softmmu_arch += {'arm': arm_softmmu_ss}

From fe1b754eab946d70b375204bdd8f51450cc2c7e5 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:52 +0200
Subject: [PATCH 063/180] arm: Enable Windows 10 trusted SMCCC boot call

Windows 10 calls an SMCCC call via SMC unconditionally on boot. It lives
in the trusted application call number space, but its purpose is unknown.

In our current SMC implementation, we inject a UDEF for unknown SMC calls,
including this one. However, Windows breaks on boot when we do this. Instead,
let's return an error code.

With this and -M virt,virtualization=on I can successfully boot the current
Windows 10 Insider Preview in TCG.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-19-agraf@csgraf.de>
---
 target/arm/kvm-consts.h | 2 ++
 target/arm/psci.c       | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/target/arm/kvm-consts.h b/target/arm/kvm-consts.h
index 580f1c1fee0c..4b64f98117c7 100644
--- a/target/arm/kvm-consts.h
+++ b/target/arm/kvm-consts.h
@@ -85,6 +85,8 @@ MISMATCH_CHECK(QEMU_PSCI_0_2_FN64_CPU_SUSPEND, PSCI_0_2_FN64_CPU_SUSPEND);
 MISMATCH_CHECK(QEMU_PSCI_0_2_FN64_CPU_ON, PSCI_0_2_FN64_CPU_ON);
 MISMATCH_CHECK(QEMU_PSCI_0_2_FN64_MIGRATE, PSCI_0_2_FN64_MIGRATE);
 
+#define QEMU_SMCCC_TC_WINDOWS10_BOOT 0xc3000001
+
 /* PSCI v0.2 return values used by TCG emulation of PSCI */
 
 /* No Trusted OS migration to worry about when offlining CPUs */
diff --git a/target/arm/psci.c b/target/arm/psci.c
index 6709e280133a..4d11dd59c498 100644
--- a/target/arm/psci.c
+++ b/target/arm/psci.c
@@ -69,6 +69,7 @@ bool arm_is_psci_call(ARMCPU *cpu, int excp_type)
     case QEMU_PSCI_0_2_FN64_CPU_SUSPEND:
     case QEMU_PSCI_0_1_FN_MIGRATE:
     case QEMU_PSCI_0_2_FN_MIGRATE:
+    case QEMU_SMCCC_TC_WINDOWS10_BOOT:
         return true;
     default:
         return false;
@@ -194,6 +195,7 @@ void arm_handle_psci_call(ARMCPU *cpu)
         break;
     case QEMU_PSCI_0_1_FN_MIGRATE:
     case QEMU_PSCI_0_2_FN_MIGRATE:
+    case QEMU_SMCCC_TC_WINDOWS10_BOOT:
         ret = QEMU_PSCI_RET_NOT_SUPPORTED;
         break;
     default:

From 9d9ca24b721c74ab9917aa5ef8f057ebc629b485 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:53 +0200
Subject: [PATCH 064/180] hvf: arm: Handle Windows 10 SMC call

Windows 10 calls an SMCCC call via SMC unconditionally on boot. It lives
in the trusted application call number space, but its purpose is unknown.

In our current SMC implementation, we inject a UDEF for unknown SMC calls,
including this one. However, Windows breaks on boot when we do this. Instead,
let's return an error code.

With this patch applied I can successfully boot the current Windows 10
Insider Preview in HVF.

Signed-off-by: Alexander Graf <agraf@csgraf.de>

Message-Id: <20210519202253.76782-20-agraf@csgraf.de>
---
 target/arm/hvf/hvf.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 65c33e2a1421..be670af578a0 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -931,6 +931,10 @@ int hvf_vcpu_exec(CPUState *cpu)
         cpu_synchronize_state(cpu);
         if (!hvf_handle_psci_call(cpu)) {
             advance_pc = true;
+        } else if (env->xregs[0] == QEMU_SMCCC_TC_WINDOWS10_BOOT) {
+            /* This special SMC is called by Windows 10 on boot. Return error */
+            env->xregs[0] = -1;
+            advance_pc = true;
         } else {
             trace_hvf_unknown_smc(env->xregs[0]);
             hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());

From 06962e1aaac6a2839ac0314e8d9feebb5ebc3b77 Mon Sep 17 00:00:00 2001
From: Phillip Tennen <phillip@axleos.com>
Date: Thu, 18 Mar 2021 12:54:27 +0900
Subject: [PATCH 065/180] net/macos: implement vmnet-based netdev
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This patch implements a new netdev device, reachable via -netdev
vmnet-macos, that’s backed by macOS’s vmnet framework.

The vmnet framework provides native bridging support, and its usage in
this patch is intended as a replacement for attempts to use a tap device
via the tuntaposx kernel extension. Notably, the tap/tuntaposx approach
never would have worked in the first place, as QEMU interacts with the
tap device via poll(), and macOS does not support polling device files.

vmnet requires either a special entitlement, granted via a provisioning
profile, or root access. Otherwise attempts to create the virtual
interface will fail with a “generic error” status code. QEMU may not
currently be signed with an entitlement granted in a provisioning
profile, as this would necessitate pre-signed binary build distribution,
rather than source-code distribution. As such, using this netdev
currently requires that qemu be run with root access. I’ve opened a
feedback report with Apple to allow the use of the relevant entitlement
with this use case:
https://openradar.appspot.com/radar?id=5007417364447232

vmnet offers three operating modes, all of which are supported by this
patch via the “mode=host|shared|bridge” option:

* "Host" mode: Allows the vmnet interface to communicate with other
* vmnet
interfaces that are in host mode and also with the native host.
* "Shared" mode: Allows traffic originating from the vmnet interface to
reach the Internet through a NAT. The vmnet interface can also
communicate with the native host.
* "Bridged" mode: Bridges the vmnet interface with a physical network
interface.

Each of these modes also provide some extra configuration that’s
supported by this patch:

* "Bridged" mode: The user may specify the physical interface to bridge
with. Defaults to en0.
* "Host" mode / "Shared" mode: The user may specify the DHCP range and
subnet. Allocated by vmnet if not provided.

vmnet also offers some extra configuration options that are not
supported by this patch:

* Enable isolation from other VMs using vmnet
* Port forwarding rules
* Enabling TCP segmentation offload
* Only applicable in "shared" mode: specifying the NAT IPv6 prefix
* Only available in "host" mode: specifying the IP address for the VM
within an isolated network

Note that this patch requires macOS 10.15 as a minimum, as this is when
bridging support was implemented in vmnet.framework.

Rebased to commit 571d413b5da6bc6f1c2aaca8484717642255ddb0 by Akihiko
Odaki.

Signed-off-by: Phillip Tennen <phillip@axleos.com>
Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
Message-Id: <20210318035427.13436-1-akihiko.odaki@gmail.com>
---
 meson.build       |   3 +
 net/clients.h     |   5 +
 net/meson.build   |   1 +
 net/net.c         |   3 +
 net/vmnet-macos.c | 446 ++++++++++++++++++++++++++++++++++++++++++++++
 qapi/net.json     | 120 ++++++++++++-
 qemu-options.hx   |   9 +
 7 files changed, 585 insertions(+), 2 deletions(-)
 create mode 100644 net/vmnet-macos.c

diff --git a/meson.build b/meson.build
index d56c25922d58..be62a60646af 100644
--- a/meson.build
+++ b/meson.build
@@ -176,6 +176,7 @@ socket = []
 version_res = []
 coref = []
 iokit = []
+vmnet = not_found
 emulator_link_args = []
 hvf = not_found
 if targetos == 'windows'
@@ -189,6 +190,7 @@ if targetos == 'windows'
 elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
   iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
+  vmnet = dependency('appleframeworks', modules: 'vmnet', required: false)
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
             cc.find_library('nsl'),
@@ -1148,6 +1150,7 @@ config_host_data.set('CONFIG_FUSE', fuse.found())
 config_host_data.set('CONFIG_FUSE_LSEEK', fuse_lseek.found())
 config_host_data.set('CONFIG_X11', x11.found())
 config_host_data.set('CONFIG_CFI', get_option('cfi'))
+config_host_data.set('CONFIG_VMNET', vmnet.found())
 config_host_data.set('QEMU_VERSION', '"@0@"'.format(meson.project_version()))
 config_host_data.set('QEMU_VERSION_MAJOR', meson.project_version().split('.')[0])
 config_host_data.set('QEMU_VERSION_MINOR', meson.project_version().split('.')[1])
diff --git a/net/clients.h b/net/clients.h
index 92f9b59aedce..2c2af67f82ab 100644
--- a/net/clients.h
+++ b/net/clients.h
@@ -63,4 +63,9 @@ int net_init_vhost_user(const Netdev *netdev, const char *name,
 
 int net_init_vhost_vdpa(const Netdev *netdev, const char *name,
                         NetClientState *peer, Error **errp);
+
+#ifdef CONFIG_VMNET
+int net_init_vmnet_macos(const Netdev *netdev, const char *name,
+                        NetClientState *peer, Error **errp);
+#endif
 #endif /* QEMU_NET_CLIENTS_H */
diff --git a/net/meson.build b/net/meson.build
index 1076b0a7ab43..ba6a5b7fa0ba 100644
--- a/net/meson.build
+++ b/net/meson.build
@@ -37,5 +37,6 @@ endif
 softmmu_ss.add(when: 'CONFIG_POSIX', if_true: files(tap_posix))
 softmmu_ss.add(when: 'CONFIG_WIN32', if_true: files('tap-win32.c'))
 softmmu_ss.add(when: 'CONFIG_VHOST_NET_VDPA', if_true: files('vhost-vdpa.c'))
+softmmu_ss.add(when: vmnet, if_true: files('vmnet-macos.c'))
 
 subdir('can')
diff --git a/net/net.c b/net/net.c
index edf9b954185f..4db4e1fb7c9f 100644
--- a/net/net.c
+++ b/net/net.c
@@ -1002,6 +1002,9 @@ static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
 #ifdef CONFIG_L2TPV3
         [NET_CLIENT_DRIVER_L2TPV3]    = net_init_l2tpv3,
 #endif
+#ifdef CONFIG_VMNET
+        [NET_CLIENT_DRIVER_VMNET_MACOS] = net_init_vmnet_macos,
+#endif
 };
 
 
diff --git a/net/vmnet-macos.c b/net/vmnet-macos.c
new file mode 100644
index 000000000000..b5cc3558330d
--- /dev/null
+++ b/net/vmnet-macos.c
@@ -0,0 +1,446 @@
+/*
+ * vmnet.framework backed netdev for macOS 10.15+ hosts
+ *
+ * Copyright (c) 2021 Phillip Tennen <phillip@axleos.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+#include "qemu/osdep.h"
+#include "qemu/main-loop.h"
+#include "qemu/error-report.h"
+#include "qapi/qapi-types-net.h"
+#include "net/net.h"
+/* macOS vmnet framework header */
+#include <vmnet/vmnet.h>
+
+typedef struct vmnet_state {
+    NetClientState nc;
+    interface_ref vmnet_iface_ref;
+    /* Switched on after vmnet informs us that the interface has started */
+    bool link_up;
+    /*
+     * If qemu_send_packet_async returns 0, this is switched off until our
+     * delivery callback is invoked
+     */
+    bool qemu_ready_to_receive;
+} vmnet_state_t;
+
+int net_init_vmnet_macos(const Netdev *netdev, const char *name,
+                         NetClientState *peer, Error **errp);
+
+static const char *_vmnet_status_repr(vmnet_return_t status)
+{
+    switch (status) {
+    case VMNET_SUCCESS:
+        return "success";
+    case VMNET_FAILURE:
+        return "generic failure";
+    case VMNET_MEM_FAILURE:
+        return "out of memory";
+    case VMNET_INVALID_ARGUMENT:
+        return "invalid argument";
+    case VMNET_SETUP_INCOMPLETE:
+        return "setup is incomplete";
+    case VMNET_INVALID_ACCESS:
+        return "insufficient permissions";
+    case VMNET_PACKET_TOO_BIG:
+        return "packet size exceeds MTU";
+    case VMNET_BUFFER_EXHAUSTED:
+        return "kernel buffers temporarily exhausted";
+    case VMNET_TOO_MANY_PACKETS:
+        return "number of packets exceeds system limit";
+    /* This error code was introduced in macOS 11.0 */
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
+    case VMNET_SHARING_SERVICE_BUSY:
+        return "sharing service busy";
+#endif
+    default:
+        return "unknown status code";
+    }
+}
+
+static operating_modes_t _vmnet_operating_mode_enum_compat(
+    VmnetOperatingMode mode)
+{
+    switch (mode) {
+    case VMNET_OPERATING_MODE_HOST:
+        return VMNET_HOST_MODE;
+    case VMNET_OPERATING_MODE_SHARED:
+        return VMNET_SHARED_MODE;
+    case VMNET_OPERATING_MODE_BRIDGED:
+        return VMNET_BRIDGED_MODE;
+    default:
+        /* Should never happen as the modes are parsed before we get here */
+        assert(false);
+    }
+}
+
+static bool vmnet_can_receive(NetClientState *nc)
+{
+    vmnet_state_t *s = DO_UPCAST(vmnet_state_t, nc, nc);
+    return s->link_up;
+}
+
+static ssize_t vmnet_receive_iov(NetClientState *nc,
+                                 const struct iovec *iovs,
+                                 int iovcnt)
+{
+    vmnet_state_t *s = DO_UPCAST(vmnet_state_t, nc, nc);
+
+    /* Combine the provided iovs into a single vmnet packet */
+    struct vmpktdesc *packet = g_new0(struct vmpktdesc, 1);
+    packet->vm_pkt_iov = g_new0(struct iovec, iovcnt);
+    memcpy(packet->vm_pkt_iov, iovs, sizeof(struct iovec) * iovcnt);
+    packet->vm_pkt_iovcnt = iovcnt;
+    packet->vm_flags = 0;
+
+    /* Figure out the packet size by iterating the iov's */
+    for (int i = 0; i < iovcnt; i++) {
+        const struct iovec *iov = iovs + i;
+        packet->vm_pkt_size += iov->iov_len;
+    }
+
+    /* Finally, write the packet to the vmnet interface */
+    int packet_count = 1;
+    vmnet_return_t result = vmnet_write(s->vmnet_iface_ref, packet,
+                                        &packet_count);
+    if (result != VMNET_SUCCESS || packet_count != 1) {
+        error_printf("Failed to send packet to host: %s\n",
+            _vmnet_status_repr(result));
+    }
+    ssize_t wrote_bytes = packet->vm_pkt_size;
+    g_free(packet->vm_pkt_iov);
+    g_free(packet);
+    return wrote_bytes;
+}
+
+static void vmnet_send_completed(NetClientState *nc, ssize_t len)
+{
+    vmnet_state_t *vmnet_client_state = DO_UPCAST(vmnet_state_t, nc, nc);
+    /* Ready to receive more packets! */
+    vmnet_client_state->qemu_ready_to_receive = true;
+}
+
+static NetClientInfo net_vmnet_macos_info = {
+    .type = NET_CLIENT_DRIVER_VMNET_MACOS,
+    .size = sizeof(vmnet_state_t),
+    .receive_iov = vmnet_receive_iov,
+    .can_receive = vmnet_can_receive,
+};
+
+static bool _validate_ifname_is_valid_bridge_target(const char *ifname)
+{
+    /* Iterate available bridge interfaces, ensure the provided one is valid */
+    xpc_object_t bridge_interfaces = vmnet_copy_shared_interface_list();
+    bool failed_to_match_iface_name = xpc_array_apply(
+        bridge_interfaces,
+        ^bool(size_t index, xpc_object_t  _Nonnull value) {
+        if (!strcmp(xpc_string_get_string_ptr(value), ifname)) {
+            /* The interface name is valid! Stop iterating */
+            return false;
+        }
+        return true;
+    });
+
+    if (failed_to_match_iface_name) {
+        error_printf("Invalid bridge interface name provided: %s\n", ifname);
+        error_printf("Valid bridge interfaces:\n");
+        xpc_array_apply(
+            vmnet_copy_shared_interface_list(),
+            ^bool(size_t index, xpc_object_t  _Nonnull value) {
+            error_printf("\t%s\n", xpc_string_get_string_ptr(value));
+            /* Keep iterating */
+            return true;
+        });
+        exit(1);
+        return false;
+    }
+
+    return true;
+}
+
+static xpc_object_t _construct_vmnet_interface_description(
+    const NetdevVmnetModeOptions *vmnet_opts)
+{
+    operating_modes_t mode = _vmnet_operating_mode_enum_compat(
+        vmnet_opts->mode);
+
+    /* Validate options */
+    if (mode == VMNET_HOST_MODE || mode == VMNET_SHARED_MODE) {
+        NetdevVmnetModeOptionsHostOrShared mode_opts = vmnet_opts->u.host;
+        /* If one DHCP parameter is configured, all 3 are required */
+        if (mode_opts.has_dhcp_start_address ||
+            mode_opts.has_dhcp_end_address ||
+            mode_opts.has_dhcp_subnet_mask) {
+            if (!(mode_opts.has_dhcp_start_address &&
+                  mode_opts.has_dhcp_end_address &&
+                  mode_opts.has_dhcp_subnet_mask)) {
+                error_printf("Incomplete DHCP configuration provided\n");
+                exit(1);
+            }
+        }
+    } else if (mode == VMNET_BRIDGED_MODE) {
+        /* Nothing to validate */
+    } else {
+        error_printf("Unknown vmnet mode %d\n", mode);
+        exit(1);
+    }
+
+    xpc_object_t interface_desc = xpc_dictionary_create(NULL, NULL, 0);
+    xpc_dictionary_set_uint64(
+        interface_desc,
+        vmnet_operation_mode_key,
+        mode
+    );
+
+    if (mode == VMNET_BRIDGED_MODE) {
+        /*
+         * Configure the provided physical interface to act
+         * as a bridge with QEMU
+         */
+        NetdevVmnetModeOptionsBridged mode_opts = vmnet_opts->u.bridged;
+        /* Bridge with en0 by default */
+        const char *physical_ifname = mode_opts.has_ifname ? mode_opts.ifname :
+                                                             "en0";
+        _validate_ifname_is_valid_bridge_target(physical_ifname);
+        xpc_dictionary_set_string(interface_desc,
+                                  vmnet_shared_interface_name_key,
+                                  physical_ifname);
+    } else if (mode == VMNET_HOST_MODE || mode == VMNET_SHARED_MODE) {
+        /* Pass the DHCP configuration to vmnet, if the user provided one */
+        NetdevVmnetModeOptionsHostOrShared mode_opts = vmnet_opts->u.host;
+        if (mode_opts.has_dhcp_start_address) {
+            /* All DHCP arguments are available, as per the checks above */
+            xpc_dictionary_set_string(interface_desc,
+                                      vmnet_start_address_key,
+                                      mode_opts.dhcp_start_address);
+            xpc_dictionary_set_string(interface_desc,
+                                      vmnet_end_address_key,
+                                      mode_opts.dhcp_end_address);
+            xpc_dictionary_set_string(interface_desc,
+                                      vmnet_subnet_mask_key,
+                                      mode_opts.dhcp_subnet_mask);
+        }
+    }
+
+    return interface_desc;
+}
+
+int net_init_vmnet_macos(const Netdev *netdev, const char *name,
+                        NetClientState *peer, Error **errp)
+{
+    assert(netdev->type == NET_CLIENT_DRIVER_VMNET_MACOS);
+
+    NetdevVmnetModeOptions *vmnet_opts = netdev->u.vmnet_macos.options;
+    xpc_object_t iface_desc = _construct_vmnet_interface_description(vmnet_opts);
+
+    NetClientState *nc = qemu_new_net_client(&net_vmnet_macos_info, peer,
+                                             "vmnet", name);
+    vmnet_state_t *vmnet_client_state = DO_UPCAST(vmnet_state_t, nc, nc);
+
+    dispatch_queue_t vmnet_dispatch_queue = dispatch_queue_create(
+        "org.qemu.vmnet.iface_queue",
+        DISPATCH_QUEUE_SERIAL
+    );
+
+    __block vmnet_return_t vmnet_start_status = 0;
+    __block uint64_t vmnet_iface_mtu = 0;
+    __block uint64_t vmnet_max_packet_size = 0;
+    __block const char *vmnet_mac_address = NULL;
+    /*
+     * We can't refer to an array type directly within a block,
+     * so hold a pointer instead.
+     */
+    uuid_string_t vmnet_iface_uuid = {0};
+    __block uuid_string_t *vmnet_iface_uuid_ptr = &vmnet_iface_uuid;
+    /* These are only provided in VMNET_HOST_MODE and VMNET_SHARED_MODE */
+    bool vmnet_provides_dhcp_info = (
+        vmnet_opts->mode == VMNET_OPERATING_MODE_HOST ||
+        vmnet_opts->mode == VMNET_OPERATING_MODE_SHARED);
+    __block const char *vmnet_subnet_mask = NULL;
+    __block const char *vmnet_dhcp_range_start = NULL;
+    __block const char *vmnet_dhcp_range_end = NULL;
+
+    /* Create the vmnet interface */
+    dispatch_semaphore_t vmnet_iface_sem = dispatch_semaphore_create(0);
+    interface_ref vmnet_iface_ref = vmnet_start_interface(
+        iface_desc,
+        vmnet_dispatch_queue,
+        ^(vmnet_return_t status, xpc_object_t  _Nullable interface_param) {
+        vmnet_start_status = status;
+        if (vmnet_start_status != VMNET_SUCCESS || !interface_param) {
+            /* Early return if the interface couldn't be started */
+            dispatch_semaphore_signal(vmnet_iface_sem);
+            return;
+        }
+
+        /*
+         * Read the configuration that vmnet provided us.
+         * The provided dictionary is owned by XPC and may be freed
+         * shortly after this block's execution.
+         * So, copy data buffers now.
+         */
+        vmnet_iface_mtu = xpc_dictionary_get_uint64(
+            interface_param,
+            vmnet_mtu_key
+        );
+        vmnet_max_packet_size = xpc_dictionary_get_uint64(
+            interface_param,
+            vmnet_max_packet_size_key
+        );
+        vmnet_mac_address = strdup(xpc_dictionary_get_string(
+            interface_param,
+            vmnet_mac_address_key
+        ));
+
+        const uint8_t *iface_uuid = xpc_dictionary_get_uuid(
+            interface_param,
+            vmnet_interface_id_key
+        );
+        uuid_unparse_upper(iface_uuid, *vmnet_iface_uuid_ptr);
+
+        /* If we're in a mode that provides DHCP info, read it out now */
+        if (vmnet_provides_dhcp_info) {
+            vmnet_dhcp_range_start = strdup(xpc_dictionary_get_string(
+                interface_param,
+                vmnet_start_address_key
+            ));
+            vmnet_dhcp_range_end = strdup(xpc_dictionary_get_string(
+                interface_param,
+                vmnet_end_address_key
+            ));
+            vmnet_subnet_mask = strdup(xpc_dictionary_get_string(
+                interface_param,
+                vmnet_subnet_mask_key
+            ));
+        }
+        dispatch_semaphore_signal(vmnet_iface_sem);
+    });
+
+    /* And block until we receive a response from vmnet */
+    dispatch_semaphore_wait(vmnet_iface_sem, DISPATCH_TIME_FOREVER);
+
+    /* Did we manage to start the interface? */
+    if (vmnet_start_status != VMNET_SUCCESS || !vmnet_iface_ref) {
+        error_printf("Failed to start interface: %s\n",
+            _vmnet_status_repr(vmnet_start_status));
+        if (vmnet_start_status == VMNET_FAILURE) {
+            error_printf("Hint: vmnet requires running with root access\n");
+        }
+        return -1;
+    }
+
+    info_report("Started vmnet interface with configuration:");
+    info_report("MTU:              %llu", vmnet_iface_mtu);
+    info_report("Max packet size:  %llu", vmnet_max_packet_size);
+    info_report("MAC:              %s", vmnet_mac_address);
+    if (vmnet_provides_dhcp_info) {
+        info_report("DHCP IPv4 start:  %s", vmnet_dhcp_range_start);
+        info_report("DHCP IPv4 end:    %s", vmnet_dhcp_range_end);
+        info_report("IPv4 subnet mask: %s", vmnet_subnet_mask);
+    }
+    info_report("UUID:             %s", vmnet_iface_uuid);
+
+    /* The interface is up! Set a block to run when packets are received */
+    vmnet_client_state->vmnet_iface_ref = vmnet_iface_ref;
+    vmnet_return_t event_cb_stat = vmnet_interface_set_event_callback(
+        vmnet_iface_ref,
+        VMNET_INTERFACE_PACKETS_AVAILABLE,
+        vmnet_dispatch_queue,
+        ^(interface_event_t event_mask, xpc_object_t  _Nonnull event) {
+        if (event_mask != VMNET_INTERFACE_PACKETS_AVAILABLE) {
+            error_printf("Unknown vmnet interface event 0x%08x\n", event_mask);
+            return;
+        }
+
+        /* If we're unable to handle more packets now, drop this packet */
+        if (!vmnet_client_state->qemu_ready_to_receive) {
+            return;
+        }
+
+        /*
+         * TODO(Phillip Tennen <phillip@axleos.com>): There may be more than
+         * one packet available.
+         * As an optimization, we could read
+         * vmnet_estimated_packets_available_key packets now.
+         */
+        char *packet_buf = g_malloc0(vmnet_max_packet_size);
+        struct iovec *iov = g_new0(struct iovec, 1);
+        iov->iov_base = packet_buf;
+        iov->iov_len = vmnet_max_packet_size;
+
+        int pktcnt = 1;
+        struct vmpktdesc *v = g_new0(struct vmpktdesc, pktcnt);
+        v->vm_pkt_size = vmnet_max_packet_size;
+        v->vm_pkt_iov = iov;
+        v->vm_pkt_iovcnt = 1;
+        v->vm_flags = 0;
+
+        vmnet_return_t result = vmnet_read(vmnet_iface_ref, v, &pktcnt);
+        if (result != VMNET_SUCCESS) {
+            error_printf("Failed to read packet from host: %s\n",
+                _vmnet_status_repr(result));
+        }
+
+        /* Ensure we read exactly one packet */
+        assert(pktcnt == 1);
+
+        /* Dispatch this block to a global queue instead of the main queue,
+         * which is only created when the program has a Cocoa event loop.
+         * If QEMU is started with -nographic, no Cocoa event loop will be
+         * created and thus the main queue will be unavailable.
+         */
+        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,
+                                                 0),
+                       ^{
+            qemu_mutex_lock_iothread();
+
+            /*
+             * Deliver the packet to the guest
+             * If the delivery succeeded synchronously, this returns the length
+             * of the sent packet.
+             */
+            if (qemu_send_packet_async(nc, iov->iov_base,
+                                       v->vm_pkt_size,
+                                       vmnet_send_completed) == 0) {
+                vmnet_client_state->qemu_ready_to_receive = false;
+            }
+
+            /*
+             * It's safe to free the packet buffers.
+             * Even if delivery needs to wait, qemu_net_queue_append copies
+             * the packet buffer.
+             */
+            g_free(v);
+            g_free(iov);
+            g_free(packet_buf);
+
+            qemu_mutex_unlock_iothread();
+        });
+    });
+
+    /* Did we manage to set an event callback? */
+    if (event_cb_stat != VMNET_SUCCESS) {
+        error_printf("Failed to set up a callback to receive packets: %s\n",
+            _vmnet_status_repr(vmnet_start_status));
+        exit(1);
+    }
+
+    /* We're now ready to receive packets */
+    vmnet_client_state->qemu_ready_to_receive = true;
+    vmnet_client_state->link_up = true;
+
+    /* Include DHCP info if we're in a relevant mode */
+    if (vmnet_provides_dhcp_info) {
+        snprintf(nc->info_str, sizeof(nc->info_str), "dhcp_start=%s,dhcp_end=%s,mask=%s",
+                                       vmnet_dhcp_range_start,
+                                       vmnet_dhcp_range_end,
+                                       vmnet_subnet_mask);
+    } else {
+        snprintf(nc->info_str, sizeof(nc->info_str), "mac=%s", vmnet_mac_address);
+    }
+
+    return 0;
+}
diff --git a/qapi/net.json b/qapi/net.json
index af3f5b0fdabd..9eea41a113b9 100644
--- a/qapi/net.json
+++ b/qapi/net.json
@@ -450,6 +450,115 @@
     '*vhostdev':     'str',
     '*queues':       'int' } }
 
+##
+# @VmnetOperatingMode:
+#
+# The operating modes in which a vmnet netdev can run
+# Only available on macOS
+#
+# @host: the guest may communicate with the host
+#        and other guest network interfaces
+#
+# @shared: the guest may reach the Internet through a NAT,
+#          and may communicate with the host and other guest
+#          network interfaces
+#
+# @bridged: the guest's traffic is bridged with a
+#           physical network interface of the host
+#
+# Since: 6.0
+##
+{ 'enum': 'VmnetOperatingMode',
+  'data': [ 'host', 'shared', 'bridged' ],
+  'if': 'defined(CONFIG_VMNET)' }
+
+##
+# @NetdevVmnetModeOptionsBridged:
+#
+# Options for the vmnet-macos netdev
+# that are only available in 'bridged' mode
+# Only available on macOS
+#
+# @ifname: the physical network interface to bridge with
+#          (defaults to en0 if not specified)
+#
+# Since: 6.0
+##
+{ 'struct': 'NetdevVmnetModeOptionsBridged',
+  'data': { '*ifname':  'str' },
+  'if': 'defined(CONFIG_VMNET)' }
+
+##
+# @NetdevVmnetModeOptionsHostOrShared:
+#
+# Options for the vmnet-macos netdev
+# that are only available in 'host' or 'shared' mode
+# Only available on macOS
+#
+# @dhcp-start-address: the gateway address to use for the interface.
+#                      The range to dhcp_end_address is placed in the DHCP pool.
+#                      (only valid with mode=host|shared)
+#                      (must be specified with dhcp-end-address and
+#                       dhcp-subnet-mask)
+#                      (allocated automatically if unset)
+#
+# @dhcp-end-address: the DHCP IPv4 range end address to use for the interface.
+#                      (only valid with mode=host|shared)
+#                      (must be specified with dhcp-start-address and
+#                       dhcp-subnet-mask)
+#                      (allocated automatically if unset)
+#
+# @dhcp-subnet-mask: the IPv4 subnet mask (string) to use on the interface.
+#                    (only valid with mode=host|shared)
+#                    (must be specified with dhcp-start-address and
+#                     dhcp-end-address)
+#                    (allocated automatically if unset)
+#
+# Since: 6.0
+##
+{ 'struct': 'NetdevVmnetModeOptionsHostOrShared',
+  'data': {
+    '*dhcp-start-address': 'str' ,
+    '*dhcp-end-address':   'str',
+    '*dhcp-subnet-mask':   'str' },
+  'if': 'defined(CONFIG_VMNET)' }
+
+##
+# @NetdevVmnetModeOptions:
+#
+# Options specific to different operating modes of a vmnet netdev
+# Only available on macOS
+#
+# @mode: the operating mode vmnet should run in
+#
+# Since: 6.0
+##
+{ 'union': 'NetdevVmnetModeOptions',
+  'base': { 'mode': 'VmnetOperatingMode' },
+  'discriminator': 'mode',
+  'data': {
+    'bridged':      'NetdevVmnetModeOptionsBridged',
+    'host':         'NetdevVmnetModeOptionsHostOrShared',
+    'shared':       'NetdevVmnetModeOptionsHostOrShared' },
+  'if': 'defined(CONFIG_VMNET)' }
+
+##
+# @NetdevVmnetOptions:
+#
+# vmnet network backend
+# Only available on macOS
+#
+# @options: a structure specifying the mode and mode-specific options
+#           (once QAPI supports a union type as a branch to another union type,
+#            this structure can be changed to a union, and the contents of
+#            NetdevVmnetModeOptions moved here)
+#
+# Since: 6.0
+##
+{ 'struct': 'NetdevVmnetOptions',
+  'data': {'options': 'NetdevVmnetModeOptions' },
+  'if': 'defined(CONFIG_VMNET)' }
+
 ##
 # @NetClientDriver:
 #
@@ -458,10 +567,13 @@
 # Since: 2.7
 #
 #        @vhost-vdpa since 5.1
+#
+#        @vmnet-macos since 6.0 (only available on macOS)
 ##
 { 'enum': 'NetClientDriver',
   'data': [ 'none', 'nic', 'user', 'tap', 'l2tpv3', 'socket', 'vde',
-            'bridge', 'hubport', 'netmap', 'vhost-user', 'vhost-vdpa' ] }
+            'bridge', 'hubport', 'netmap', 'vhost-user', 'vhost-vdpa',
+            { 'name': 'vmnet-macos', 'if': 'defined(CONFIG_VMNET)' } ] }
 
 ##
 # @Netdev:
@@ -475,6 +587,8 @@
 # Since: 1.2
 #
 #        'l2tpv3' - since 2.1
+#
+#        'vmnet-macos' since 6.0 (only available on macOS)
 ##
 { 'union': 'Netdev',
   'base': { 'id': 'str', 'type': 'NetClientDriver' },
@@ -490,7 +604,9 @@
     'hubport':  'NetdevHubPortOptions',
     'netmap':   'NetdevNetmapOptions',
     'vhost-user': 'NetdevVhostUserOptions',
-    'vhost-vdpa': 'NetdevVhostVDPAOptions' } }
+    'vhost-vdpa': 'NetdevVhostVDPAOptions',
+    'vmnet-macos': { 'type': 'NetdevVmnetOptions',
+                     'if': 'defined(CONFIG_VMNET)' } } }
 
 ##
 # @RxState:
diff --git a/qemu-options.hx b/qemu-options.hx
index fd21002bd61d..9aa72201c2f0 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -2542,6 +2542,15 @@ DEF("netdev", HAS_ARG, QEMU_OPTION_netdev,
 #ifdef __linux__
     "-netdev vhost-vdpa,id=str,vhostdev=/path/to/dev\n"
     "                configure a vhost-vdpa network,Establish a vhost-vdpa netdev\n"
+#endif
+#ifdef CONFIG_VMNET
+    "-netdev vmnet-macos,id=str,mode=bridged[,ifname=ifname]\n"
+    "         configure a macOS-provided vmnet network in \"physical interface bridge\" mode\n"
+    "         the physical interface to bridge with defaults to en0 if unspecified\n"
+    "-netdev vmnet-macos,id=str,mode=host|shared\n"
+    "                     [,dhcp_start_address=addr,dhcp_end_address=addr,dhcp_subnet_mask=mask]\n"
+    "         configure a macOS-provided vmnet network in \"host\" or \"shared\" mode\n"
+    "         the DHCP configuration will be set automatically if unspecified\n"
 #endif
     "-netdev hubport,id=str,hubid=n[,netdev=nd]\n"
     "                configure a hub port on the hub with ID 'n'\n", QEMU_ARCH_ALL)

From 64dcc3969b4ee47b7c791512f7462d1d83b9d8f0 Mon Sep 17 00:00:00 2001
From: Kate Temkin <k@ktemkin.com>
Date: Mon, 29 Mar 2021 13:26:08 -0600
Subject: [PATCH 066/180] TCTI: add TCTI TCG backend for acceleration on
 non-JIT AArch64

---
 accel/tcg/translate-all.c             |    6 +-
 configure                             |   10 +-
 disas.c                               |    2 +
 include/disas/dis-asm.h               |    1 +
 include/exec/exec-all.h               |    4 +
 include/tcg/tcg.h                     |    2 +-
 meson.build                           |   24 +
 meson_options.txt                     |    2 +
 scripts/mtest2make.py                 |   24 +-
 tcg/aarch64-tcti/README.md            | 1026 +++++++++++++++++++
 tcg/aarch64-tcti/tcg-target-con-set.h |   21 +
 tcg/aarch64-tcti/tcg-target-con-str.h |   11 +
 tcg/aarch64-tcti/tcg-target.c.inc     | 1347 +++++++++++++++++++++++++
 tcg/aarch64-tcti/tcg-target.h         |  220 ++++
 tcg/aarch64-tcti/tcti-gadget-gen.py   |  788 +++++++++++++++
 tcg/tcg.c                             |   14 +-
 16 files changed, 3476 insertions(+), 26 deletions(-)
 create mode 100644 tcg/aarch64-tcti/README.md
 create mode 100644 tcg/aarch64-tcti/tcg-target-con-set.h
 create mode 100644 tcg/aarch64-tcti/tcg-target-con-str.h
 create mode 100644 tcg/aarch64-tcti/tcg-target.c.inc
 create mode 100644 tcg/aarch64-tcti/tcg-target.h
 create mode 100755 tcg/aarch64-tcti/tcti-gadget-gen.py

diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index 28d563454e03..71676bbd2dea 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -1129,7 +1129,7 @@ static bool alloc_code_gen_buffer_anon(size_t size, int prot,
     return true;
 }
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 #ifdef CONFIG_POSIX
 #include "qemu/memfd.h"
 
@@ -1256,7 +1256,7 @@ static bool alloc_code_gen_buffer_splitwx_vmremap(size_t size, Error **errp)
 
 static bool alloc_code_gen_buffer_splitwx(size_t size, Error **errp)
 {
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 # ifdef CONFIG_DARWIN
     return alloc_code_gen_buffer_splitwx_vmremap(size, errp);
 # endif
@@ -1289,7 +1289,7 @@ static bool alloc_code_gen_buffer(size_t size, int splitwx, Error **errp)
 
     prot = PROT_READ | PROT_WRITE | PROT_EXEC;
     flags = MAP_PRIVATE | MAP_ANONYMOUS;
-#ifdef CONFIG_TCG_INTERPRETER
+#if defined(CONFIG_TCG_INTERPRETER) || defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* The tcg interpreter does not need execute permission. */
     prot = PROT_READ | PROT_WRITE;
 #elif defined(CONFIG_DARWIN)
diff --git a/configure b/configure
index 0e7dbc56c784..9296d29e4fd6 100755
--- a/configure
+++ b/configure
@@ -362,6 +362,7 @@ tsan="no"
 fortify_source="$default_feature"
 strip_opt="yes"
 tcg_interpreter="false"
+tcg_threaded_interpreter="false"
 bigendian="no"
 mingw32="no"
 gcov="no"
@@ -1115,6 +1116,10 @@ for opt do
   ;;
   --enable-tcg-interpreter) tcg_interpreter="true"
   ;;
+  --disable-tcg-tcti) tcg_threaded_interpreter="false"
+  ;;
+  --enable-tcg-tcti) tcg_threaded_interpreter="true"
+  ;;
   --disable-cap-ng)  cap_ng="disabled"
   ;;
   --enable-cap-ng) cap_ng="enabled"
@@ -6469,9 +6474,8 @@ NINJA=$ninja $meson setup \
         -Dvhost_user_blk_server=$vhost_user_blk_server -Dmultiprocess=$multiprocess \
         -Dfuse=$fuse -Dfuse_lseek=$fuse_lseek -Dguest_agent_msi=$guest_agent_msi \
         $(if test "$default_features" = no; then echo "-Dauto_features=disabled"; fi) \
-	-Dtcg_interpreter=$tcg_interpreter -Dshared_lib=$shared_lib \
-        $cross_arg \
-        "$PWD" "$source_path"
+	-Dtcg_interpreter=$tcg_interpreter -Dtcg_threaded_interpreter=$tcg_threaded_interpreter\
+	-Dshared_lib=$shared_lib $cross_arg "$PWD" "$source_path"
 
 if test "$?" -ne 0 ; then
     error_exit "meson setup failed"
diff --git a/disas.c b/disas.c
index a61f95b580b8..cea0f9019e49 100644
--- a/disas.c
+++ b/disas.c
@@ -152,6 +152,8 @@ static void initialize_debug_host(CPUDebug *s)
 #endif
 #if defined(CONFIG_TCG_INTERPRETER)
     s->info.print_insn = print_insn_tci;
+#elif defined(CONFIG_TCG_THREADED_INTERPRETER)
+    s->info.print_insn = print_insn_tcti;
 #elif defined(__i386__)
     s->info.mach = bfd_mach_i386_i386;
     s->info.print_insn = print_insn_i386;
diff --git a/include/disas/dis-asm.h b/include/disas/dis-asm.h
index 13fa1edd411e..ded69ba2ffaa 100644
--- a/include/disas/dis-asm.h
+++ b/include/disas/dis-asm.h
@@ -411,6 +411,7 @@ typedef struct disassemble_info {
 typedef int (*disassembler_ftype) (bfd_vma, disassemble_info *);
 
 int print_insn_tci(bfd_vma, disassemble_info*);
+int print_insn_tcti(bfd_vma, disassemble_info*);
 int print_insn_big_mips         (bfd_vma, disassemble_info*);
 int print_insn_little_mips      (bfd_vma, disassemble_info*);
 int print_insn_nanomips         (bfd_vma, disassemble_info*);
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index 6b036cae8f65..a8f2295decd2 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -543,7 +543,11 @@ void tb_set_jmp_target(TranslationBlock *tb, int n, uintptr_t addr);
 #if defined(CONFIG_TCG_INTERPRETER)
 extern __thread uintptr_t tci_tb_ptr;
 # define GETPC() tci_tb_ptr
+#elif defined(CONFIG_TCG_THREADED_INTERPRETER)
+extern __thread uintptr_t tcti_call_return_address;
+# define GETPC() tcti_call_return_address
 #else
+/* Note that this is correct for TCTI also; whose gadget behaves like native code. */
 # define GETPC() \
     ((uintptr_t)__builtin_extract_return_addr(__builtin_return_address(0)))
 #endif
diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 0f0695e90da2..cfcd069bf3f6 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -1296,7 +1296,7 @@ static inline unsigned get_mmuidx(TCGMemOpIdx oi)
 #define TB_EXIT_IDXMAX    1
 #define TB_EXIT_REQUESTED 3
 
-#ifdef CONFIG_TCG_INTERPRETER
+#if defined(CONFIG_TCG_INTERPRETER) || defined(CONFIG_TCG_THREADED_INTERPRETER)
 uintptr_t tcg_qemu_tb_exec(CPUArchState *env, const void *tb_ptr);
 #else
 typedef uintptr_t tcg_prologue_fn(CPUArchState *env, const void *tb_ptr);
diff --git a/meson.build b/meson.build
index be62a60646af..7a2ef92faf23 100644
--- a/meson.build
+++ b/meson.build
@@ -58,6 +58,7 @@ python = import('python').find_installation()
 supported_oses = ['windows', 'freebsd', 'netbsd', 'openbsd', 'darwin', 'sunos', 'linux']
 supported_cpus = ['ppc', 'ppc64', 's390x', 'riscv32', 'riscv64', 'x86', 'x86_64',
   'arm', 'aarch64', 'mips', 'mips64', 'sparc', 'sparc64']
+tcti_supported_cpus = ['aarch64']
 
 cpu = host_machine.cpu_family()
 targetos = host_machine.system()
@@ -255,6 +256,25 @@ if not get_option('tcg').disabled()
   endif
   if get_option('tcg_interpreter')
     tcg_arch = 'tci'
+  elif get_option('tcg_threaded_interpreter')
+    if cpu not in tcti_supported_cpus
+      error('Unsupported CPU @0@ for TCTI, try --enable-tcg-interpreter'.format(cpu))
+    else
+      warning('TCTI is extremely experimental and incomplete! Things might break!')
+      tcg_arch = '@0@-tcti'.format(cpu)
+    endif
+
+    # Tell our compiler how to generate our TCTI gadgets.
+    gadget_generator = 'tcg/@0@/tcti-gadget-gen.py'.format(tcg_arch)
+    tcti_gadgets = custom_target('tcti-gadgets.c.inc',
+                                output: 'tcti-gadgets.c.inc',
+                                input: gadget_generator,
+                                command: [find_program(gadget_generator), '@OUTPUT@'],
+                                build_by_default: true,
+                                build_always_stale: false)
+
+    genh += tcti_gadgets
+    
   elif config_host['ARCH'] == 'sparc64'
     tcg_arch = 'sparc'
   elif config_host['ARCH'] == 's390x'
@@ -1291,6 +1311,8 @@ foreach target : target_dirs
       config_all += { sym: 'y' }
       if sym == 'CONFIG_TCG' and tcg_arch == 'tci'
         config_target += { 'CONFIG_TCG_INTERPRETER': 'y' }
+      elif sym == 'CONFIG_TCG' and tcg_arch.endswith('tcti')
+        config_target += { 'CONFIG_TCG_THREADED_INTERPRETER': 'y' }
       elif sym == 'CONFIG_XEN' and have_xen_pci_passthrough
         config_target += { 'CONFIG_XEN_PCI_PASSTHROUGH': 'y' }
       endif
@@ -2583,6 +2605,8 @@ summary_info += {'TCG support':       config_all.has_key('CONFIG_TCG')}
 if config_all.has_key('CONFIG_TCG')
   if get_option('tcg_interpreter')
     summary_info += {'TCG backend':   'TCI (TCG with bytecode interpreter, experimental and slow)'}
+  elif get_option('tcg_threaded_interpreter')
+    summary_info += {'TCG backend':   'TCTI (TCG with threaded-dispatch bytecode interpreter, experimental and slow; but faster than TCI)'}
   else
     summary_info += {'TCG backend':   'native (@0@)'.format(cpu)}
   endif
diff --git a/meson_options.txt b/meson_options.txt
index 6c29ea93300a..5aa68672c2ff 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -43,6 +43,8 @@ option('tcg', type: 'feature', value: 'auto',
        description: 'TCG support')
 option('tcg_interpreter', type: 'boolean', value: false,
        description: 'TCG with bytecode interpreter (experimental and slow)')
+option('tcg_threaded_interpreter', type: 'boolean', value: false,
+       description: 'TCG with threaded-dispatch bytecode interpreter (experimental and slow, but less slow than TCI)')
 option('cfi', type: 'boolean', value: 'false',
        description: 'Control-Flow Integrity (CFI)')
 option('cfi_debug', type: 'boolean', value: 'false',
diff --git a/scripts/mtest2make.py b/scripts/mtest2make.py
index ee072c05025a..b0467ab56545 100644
--- a/scripts/mtest2make.py
+++ b/scripts/mtest2make.py
@@ -75,18 +75,18 @@ def process_tests(test, targets, suites):
     print('run-test-%d: $(.test.deps.%d)' % (i,i))
     print('\t@$(call .test.run,%d,$(.test.output-format))' % (i,))
 
-    test_suites = test['suite'] or ['default']
-    is_slow = any(s.endswith('-slow') for s in test_suites)
-    for s in test_suites:
-        # The suite name in the introspection info is "PROJECT:SUITE"
-        s = s.split(':')[1]
-        if s.endswith('-slow'):
-            s = s[:-5]
-        if is_slow:
-            suites[s].slow_tests.append(i)
-        else:
-            suites[s].tests.append(i)
-        suites[s].executables.add(executable)
+    #test_suites = test['suite'] or ['default']
+    #is_slow = any(s.endswith('-slow') for s in test_suites)
+    #for s in test_suites:
+    #    # The suite name in the introspection info is "PROJECT:SUITE"
+    #    s = s.split(':')[1]
+    #    if s.endswith('-slow'):
+    #        s = s[:-5]
+    #    if is_slow:
+    #        suites[s].slow_tests.append(i)
+    #    else:
+    #        suites[s].tests.append(i)
+    #    suites[s].executables.add(executable)
 
 def emit_prolog(suites, prefix):
     all_tap = ' '.join(('%s-report-%s.tap' % (prefix, k) for k in suites.keys()))
diff --git a/tcg/aarch64-tcti/README.md b/tcg/aarch64-tcti/README.md
new file mode 100644
index 000000000000..eb848e5a9e57
--- /dev/null
+++ b/tcg/aarch64-tcti/README.md
@@ -0,0 +1,1026 @@
+# QEMU Tiny-Code Threaded Interpreter (AArch64)
+
+A TCG backend that chains together JOP/ROP-ish gadgets to massively reduce interpreter overhead vs TCI.
+Platform-dependent; but usable when JIT isn't available; e.g. on platforms that lack WX mappings. The general idea squish the addresses of a gadget sequence into a "queue" and then write each gadget so it ends in a "dequeue-jump".
+
+Execution occurs by jumping into the first gadget, and letting it just play back some linear-overhead native code sequences for a while.
+
+Since TCG-TCI is optimized for sets of 16 GP registers and aarch64 has 30, we could easily keep JIT/QEMU and guest state separate, and since 16\*16 is reasonably small we could actually have a set of reasonable gadgets for each combination of operands.
+
+
+## Register Convention
+
+| Regs    | Use                   |
+| :------ | :-------------------- |
+| x1-x15  | Guest Registers       |
+| x24     | TCTI temporary        |
+| x25     | saved IP during call  |
+| x26     | TCTI temporary        |
+| x27     | TCTI temporary        |
+| x28     | Thread-stream pointer |
+| x30     | Link register         |
+| SP      | Stack Pointer, host   |
+| PC      | Program Counter, host |
+
+In pseudocode:
+
+| Symbol | Meaning                             |
+| :----- | :---------------------------------- |
+| Rd     | stand-in for destination register   |
+| Rn     | stand-in for first source register  |
+| Rm     | stand-in for second source register |
+
+## Gadget Structure
+
+### End of gadget
+
+Each gadget ends by advancing our bytecode pointer, and then executing from thew new location.
+
+```asm
+# Load our next gadget address from our bytecode stream, advancing it, and jump to the next gadget.
+
+ldr x27, [x28], #8\n
+br x27
+```
+
+## Calling into QEMU's C codebase
+
+When calling into C, we lose control over which registers are used. Accordingly, we'll need to save
+registers relevant to TCTI:
+
+```asm
+str x25,      [sp, #-16]!
+stp x14, x15, [sp, #-16]!
+stp x12, x13, [sp, #-16]!
+stp x10, x11, [sp, #-16]!
+stp x8,  x9,  [sp, #-16]!
+stp x6,  x7,  [sp, #-16]!
+stp x4,  x5,  [sp, #-16]!
+stp x2,  x3,  [sp, #-16]!
+stp x0,  x1,  [sp, #-16]!
+stp x28, lr,  [sp, #-16]!
+```
+
+Upon returning to the gadget stream, we'll then restore them.
+
+```asm
+ldp x28, lr, [sp], #16
+ldp x0,  x1, [sp], #16
+ldp x2,  x3, [sp], #16
+ldp x4,  x5, [sp], #16
+ldp x6,  x7, [sp], #16
+ldp x8,  x9, [sp], #16
+ldp x10, x11, [sp], #16
+ldp x12, x13, [sp], #16
+ldp x14, x15, [sp], #16
+ldr x25,      [sp], #16
+```
+
+## TCG Operations
+
+Each operation needs an implementation for every platform; and probably a set of gadgets for each possible set of operands.
+
+At 14 GP registers, that means that
+
+1 operand =\> 16 gadgets
+2 operands =\> 256 gadgets
+3 operands =\> 4096 gadgets
+
+### call
+
+Calls a helper function by address.
+
+**IR Format**: `br <ptr address>`  
+**Gadget type:** single
+
+```asm
+    # Get our C runtime function's location as a pointer-sized immediate...
+    "ldr x27, [x28], #8",
+
+    # Store our TB return address for our helper. This is necessary so the GETPC()
+    # macro works correctly as used in helper functions.
+    "str x28, [x25]",
+
+    # Prepare ourselves to call into our C runtime...
+    *C_CALL_PROLOGUE,
+
+    # ... perform the call itself ...
+    "blr x27",
+
+    # Save the result of our call for later.
+    "mov x27, x0",
+
+    # ... and restore our environment.
+    *C_CALL_EPILOGUE,
+
+    # Restore our return value.
+    "mov x0, x27"
+```
+
+### br
+
+Branches to a given immediate address. Branches are
+
+**IR Format**: `br <ptr address>`  
+**Gadget type:** single
+
+```asm
+# Use our immediate argument as our new bytecode-pointer location.
+ldr x28, [x28]
+```
+
+### setcond_i32
+
+Performs a comparison between two 32-bit operands.
+
+**IR Format**: `setcond32 <cond>, Rd, Rn, Rm`  
+**Gadget type:** treated as 10 operations with variants for every `Rd`/`Rn`/`Rm` (40,960)
+
+```asm
+subs Wd, Wn, Wm
+cset Wd, <cond>
+```
+
+| QEMU Cond | AArch64 Cond |
+| :-------- | :----------- |
+| EQ        | EQ           |
+| NE        | NE           |
+| LT        | LT           |
+| GE        | GE           |
+| LE        | LE           |
+| GT        | GT           |
+| LTU       | LO           |
+| GEU       | HS           |
+| LEU       | LS           |
+| GTU       | HI           |
+
+### setcond_i64
+
+Performs a comparison between two 32-bit operands.
+
+**IR Format**: `setcond64 <cond>, Rd, Rn, Rm`  
+**Gadget type:** treated as 10 operations with variants for every `Rd`/`Rn`/`Rm` (40,960)
+
+```asm
+subs Xd, Xn, Xm
+cset Xd, <cond>
+```
+
+Comparison chart is the same as the `_i32` variant.
+
+### brcond_i32
+
+Compares two 32-bit numbers, and branches if the comparison is true.
+
+**IR Format**: `brcond Rn, Rm, <cond>`  
+**Gadget type:** treated as 10 operations with variants for every `Rn`/`Rm` (2560)
+
+```asm
+# Perform our comparison and conditional branch.
+subs Wrz, Wn, Wm
+br<cond> taken
+
+    # Consume the branch target, without using it.
+    add x28, x28, #8
+
+    # Perform our end-of-instruction epilogue.
+    <epilogue here>
+
+taken:
+
+    # Update our bytecode pointer to take the label.
+    ldr x28, [x28]
+```
+
+Comparison chart is the same as in `setcond_i32` .
+
+### brcond_i64
+
+Compares two 64-bit numbers, and branches if the comparison is true.
+
+**IR Format**: `brcond Rn, Rm, <cond>`  
+**Gadget type:** treated as 10 operations with variants for every `Rn`/`Rm` (2560)
+
+```asm
+# Perform our comparison and conditional branch.
+subs Xrz, Xn, Xm
+br<cond> taken
+
+    # Consume the branch target, without using it.
+    add x28, x28, #8
+
+    # Perform our end-of-instruction epilogue.
+    <epilogue here>
+
+taken:
+
+    # Update our bytecode pointer to take the label.
+    ldr x28, [x28]
+```
+
+Comparison chart is the same as in `setcond_i32` .
+
+### mov_i32
+
+Moves a value from a register to another register.
+
+**IR Format**: `mov Rd, Rn`  
+**Gadget type:** gadget per `Rd` + `Rn` combo (256)
+
+```asm
+mov Rd, Rn
+```
+
+### mov_i64
+
+Moves a value from a register to another register.
+
+**IR Format**: `mov Rd, Rn`  
+**Gadget type:** gadget per `Rd` + `Rn` combo (256)
+
+```asm
+mov Xd, Xn
+```
+
+### tci_movi_i32
+
+Moves an 32b immediate into a register.
+
+**IR Format**: `mov Rd, #imm32`  
+**Gadget type:** gadget per `Rd` (16)
+
+```asm
+ldr w27, [x28], #4
+mov Wd, w27
+```
+
+### tci_movi_i64
+
+Moves an 64b immediate into a register.
+
+**IR Format**: `mov Rd, #imm64`  
+**Gadget type:** gadget per `Rd` (16)
+
+```asm
+ldr x27, [x28], #4
+mov Xd, x27
+```
+
+### ld8u_i32 / ld8u_i64
+
+Load byte from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrb Xd, [Xn, x27]
+```
+
+### ld8s_i32 / ld8s_i64
+
+Load byte from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsb Xd, [Xn, x27]
+```
+
+### ld16u_i32 / ld16u_i64
+
+Load 16b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrh Wd, [Xn, x27]
+```
+
+### ld16s_i32 / ld16s_i64
+
+Load 16b from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsh Xd, [Xn, x27]
+```
+
+### ld32u_i32 / ld32u_i64
+
+Load 32b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldr Wd, [Xn, x27]
+```
+
+### ld32s_i64
+
+Load 32b from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsw Xd, [Xn, x27]
+```
+
+### ld_i64
+
+Load 64b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldr Xd, [Xn, x27]
+```
+
+### st8_i32 / st8_i64
+
+Stores byte from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+strb Wd, [Xn, x27]
+```
+
+### st16_i32 / st16_i64
+
+Stores 16b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+strh Wd, [Xn, x27]
+```
+
+### st_i32 / st32_i64
+
+Stores 32b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+str Wd, [Xn, x27]
+```
+
+### st_i64
+
+Stores 64b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+str Xd, [Xn, x27]
+```
+
+### qemu_ld_i32
+
+Loads 32b from _guest_ memory to register.
+
+**IR Format**: `ld Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+### qemu_ld_i64
+
+Loads 64b from _guest_ memory to register.
+
+**IR Format**: `ld Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+### qemu_st_i32
+
+Stores 32b from a register to _guest_ memory.
+
+**IR Format**: `st Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl
+
+### qemu_st_i64
+
+Stores 64b from a register to _guest_ memory.
+
+**IR Format**: `st Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+#### Note
+
+See note on `qemu_ld_i32`.
+
+### add_i32
+
+Adds two 32-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+add Wd, Wn, Wm
+```
+
+### add_i64
+
+Adds two 64-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+add Xd, Xn, Xm
+```
+
+### sub_i32
+
+Subtracts two 32-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+Sub Wd, Wn, Wm
+```
+
+### sub_i64
+
+Subtracts two 64-bit numbers.
+
+**IR Format**: `sub Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sub Xd, Xn, Xm
+```
+
+### mul_i32
+
+Multiplies two 32-bit numbers.
+
+**IR Format**: `mul Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+mul Wd, Wn, Wm
+```
+
+### mul_i64
+
+Multiplies two 64-bit numbers.
+
+**IR Format**: `mul Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+mul Xd, Xn, Xm
+```
+
+### div_i32
+
+Divides two 32-bit numbers; considering them signed.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv Wd, Wn, Wm
+```
+
+### div_i64
+
+Divides two 64-bit numbers; considering them signed.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv Xd, Xn, Xm
+```
+
+### divu_i32
+
+Divides two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv Wd, Wn, Wm
+```
+
+### divu_i64
+
+Divides two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv Xd, Xn, Xm
+```
+
+### rem_i32
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them signed.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv    w27, Wn, Wm
+msub    Wd, w27, Wm, Wn
+```
+
+### rem_i64
+
+Computes the division remainder (modulus) of two 64-bit numbers; considering them signed.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv    x27, Xn, Xm
+msub    Xd, x27, Xm, Xn
+```
+
+### remu_i32
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv    w27, Wn, Wm
+msub    Wd, w27, Wm, Wn
+```
+
+### remu_i64
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv    x27, Xn, Xm
+msub    Xd, x27, Xm, Xn
+```
+
+### not_i32
+
+Logically inverts a 32-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+mvn Wd, Wn
+```
+
+### not_i64
+
+Logically inverts a 64-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+mvn Xd, Xn
+```
+
+### neg_i32
+
+Arithmetically inverts (two's compliment) a 32-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+neg Wd, Wn
+```
+
+### neg_i64
+
+Arithmetically inverts (two's compliment) a 64-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+neg Xd, Xn
+```
+
+### and_i32
+
+Logically ANDs two 32-bit numbers.
+
+**IR Format**: `and Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+and Wd, Wn, Wm
+```
+
+### and_i64
+
+Logically ANDs two 64-bit numbers.
+
+**IR Format**: `and Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+and Xd, Xn, Xm
+```
+
+### or_i32
+
+Logically ORs two 32-bit numbers.
+
+**IR Format**: `or Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+or Wd, Wn, Wm
+```
+
+### or_i64
+
+Logically ORs two 64-bit numbers.
+
+**IR Format**: `or Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+or Xd, Xn, Xm
+```
+
+### xor_i32
+
+Logically XORs two 32-bit numbers.
+
+**IR Format**: `xor Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+eor Wd, Wn, Wm
+```
+
+### xor_i64
+
+Logically XORs two 64-bit numbers.
+
+**IR Format**: `xor Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+eor Xd, Xn, Xm
+```
+
+### shl_i32
+
+Logically shifts a 32-bit number left.
+
+**IR Format**: `shl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsl Wd, Wn, Wm
+```
+
+### shl_i64
+
+Logically shifts a 64-bit number left.
+
+**IR Format**: `shl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsl Xd, Xn, Xm
+```
+
+### shr_i32
+
+Logically shifts a 32-bit number right.
+
+**IR Format**: `shr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsr Wd, Wn, Wm
+```
+
+### shr_i64
+
+Logically shifts a 64-bit number right.
+
+**IR Format**: `shr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsr Xd, Xn, Xm
+```
+
+### sar_i32
+
+Arithmetically shifts a 32-bit number right.
+
+**IR Format**: `sar Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+asr Wd, Wn, Wm
+```
+
+### sar_i64
+
+Arithmetically shifts a 64-bit number right.
+
+**IR Format**: `sar Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+asr Xd, Xn, Xm
+```
+
+### rotl_i32
+
+Rotates a 32-bit number left.
+
+**IR Format**: `rotl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+rol Wd, Wn, Wm
+```
+
+### rotl_i64
+
+Rotates a 64-bit number left.
+
+**IR Format**: `rotl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+rol Xd, Xn, Xm
+```
+
+### rotr_i32
+
+Rotates a 32-bit number right.
+
+**IR Format**: `rotr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+ror Wd, Wn, Wm
+```
+
+### rotr_i64
+
+Rotates a 64-bit number right.
+
+**IR Format**: `rotr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+ror Xd, Xn, Xm
+```
+
+### deposit_i32
+
+Optional; not currently implementing.
+
+### deposit_i64
+
+Optional; not currently implementing.
+
+### ext8s_i32
+
+Sign extends the lower 8b of a register into a 32b destination.
+
+**IR Format**: `ext8s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtb Wd, Wn
+```
+
+### ext8s_i64
+
+Sign extends the lower 8b of a register into a 64b destination.
+
+**IR Format**: `ext8s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtb Xd, Wn
+```
+
+### ext8u_i32
+
+Zero extends the lower 8b of a register into a 32b destination.
+
+**IR Format**: `ext8u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xff
+```
+
+### ext8u_i64
+
+Zero extends the lower 8b of a register into a 64b destination.
+
+**IR Format**: `ext8u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xff
+```
+
+### ext16s_i32
+
+Sign extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxth Xd, Wn
+```
+
+### ext16s_i64
+
+Sign extends the lower 16b of a register into a 64b destination.
+
+**IR Format**: `ext16s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxth Xd, Wn
+```
+
+### ext16u_i32
+
+Zero extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Wd, Wn, #0xffff
+```
+
+### ext16u_i64
+
+Zero extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Wd, Wn, #0xffff
+```
+
+### ext32s_i64
+
+Sign extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### ext32u_i64
+
+Zero extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### ext_i32_i64
+
+Sign extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### extu_i32_i64
+
+Zero extends the lower 32b of a register into a 32b destination.
+
+**IR Format**: `ext32u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xffffffff
+```
+
+### bswap16_i32
+
+Byte-swaps a 16b quantity.
+
+**IR Format**: `bswap16 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     w27, Wn
+lsr     Wd, w27, #16
+```
+
+### bswap16_i64
+
+Byte-swaps a 16b quantity.
+
+**IR Format**: `bswap16 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     w27, Wn
+lsr     Wd, w27, #16
+```
+
+### bswap32_i32
+
+Byte-swaps a 32b quantity.
+
+**IR Format**: `bswap32 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Wd, Wn
+```
+
+### bswap32_i64
+
+Byte-swaps a 32b quantity.
+
+**IR Format**: `bswap32 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Wd, Wn
+```
+
+### bswap64_i64
+
+Byte-swaps a 64b quantity.
+
+**IR Format**: `bswap64 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Xd, Xn
+```
+
+### exit_tb
+
+Exits the translation block. Has no gadget; but instead inserts the address of the translation block epilogue.
+
+
+### mb
+
+Memory barrier.
+
+**IR Format**: `mb <type>`  
+**Gadget type:** gadget per type
+
+```asm
+# !!! TODO
+```
+
+#### Note
+
+We still need to look up out how to map QEMU MB types map to AArch64 ones. This might take nuance.
diff --git a/tcg/aarch64-tcti/tcg-target-con-set.h b/tcg/aarch64-tcti/tcg-target-con-set.h
new file mode 100644
index 000000000000..f51b7bcb13e7
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target-con-set.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * TCI target-specific constraint sets.
+ * Copyright (c) 2021 Linaro
+ */
+
+/*
+ * C_On_Im(...) defines a constraint set with <n> outputs and <m> inputs.
+ * Each operand should be a sequence of constraint letters as defined by
+ * tcg-target-con-str.h; the constraint combination is inclusive or.
+ */
+C_O0_I2(r, r)
+C_O0_I3(r, r, r)
+C_O0_I4(r, r, r, r)
+C_O1_I1(r, r)
+C_O1_I2(r, 0, r)
+C_O1_I2(r, r, r)
+C_O1_I4(r, r, r, r, r)
+C_O2_I1(r, r, r)
+C_O2_I2(r, r, r, r)
+C_O2_I4(r, r, r, r, r, r)
diff --git a/tcg/aarch64-tcti/tcg-target-con-str.h b/tcg/aarch64-tcti/tcg-target-con-str.h
new file mode 100644
index 000000000000..87c0f19e9c2e
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target-con-str.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Define TCI target-specific operand constraints.
+ * Copyright (c) 2021 Linaro
+ */
+
+/*
+ * Define constraint letters for register sets:
+ * REGS(letter, register_mask)
+ */
+REGS('r', MAKE_64BIT_MASK(0, TCG_TARGET_NB_REGS))
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
new file mode 100644
index 000000000000..d7bb67a92140
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -0,0 +1,1347 @@
+/*
+ * Tiny Code Threaded Intepreter for QEMU
+ *
+ * Copyright (c) 2021 Kate Temkin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define TCTI_GADGET_IMMEDIATE_ARRAY_LEN 64
+
+// Grab our gadget definitions.
+// FIXME: use the system path instead of hardcoding this?
+#include "tcti-gadgets.c.inc"
+
+/* Marker for missing code. */
+#define TODO() \
+    do { \
+        fprintf(stderr, "TODO %s:%u: %s()\n", \
+                __FILE__, __LINE__, __func__); \
+        tcg_abort(); \
+    } while (0)
+
+
+/* Enable TCTI assertions only when debugging TCG (and without NDEBUG defined).
+ * Without assertions, the interpreter runs much faster. */
+#if defined(CONFIG_DEBUG_TCG)
+# define tcti_assert(cond) assert(cond)
+#else
+# define tcti_assert(cond) ((void)0)
+#endif
+
+/* Bitfield n...m (in 32 bit value). */
+#define BITS(n, m) (((0xffffffffU << (31 - n)) >> (31 - n + m)) << m)
+
+/**
+ * Macro that defines a look-up tree for named QEMU_LD gadgets.
+ */ 
+#define LD_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_ld_ub_   ## suffix; break; \
+        case MO_SB:   variable = gadget_qemu_ld_sb_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_ld_leuw_ ## suffix; break; \
+        case MO_LESW: variable = gadget_qemu_ld_lesw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_ld_leul_ ## suffix; break; \
+        case MO_LESL: variable = gadget_qemu_ld_lesl_ ## suffix; break; \
+        case MO_LEQ:  variable = gadget_qemu_ld_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_ld_beuw_ ## suffix; break; \
+        case MO_BESW: variable = gadget_qemu_ld_besw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_ld_beul_ ## suffix; break; \
+        case MO_BESL: variable = gadget_qemu_ld_besl_ ## suffix; break; \
+        case MO_BEQ:  variable = gadget_qemu_ld_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define LD_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            LD_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            LD_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+
+/**
+ * Macro that defines a look-up tree for named QEMU_ST gadgets.
+ */ 
+#define ST_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_st_ub_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_st_leuw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_st_leul_ ## suffix; break; \
+        case MO_LEQ:  variable = gadget_qemu_st_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_st_beuw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_st_beul_ ## suffix; break; \
+        case MO_BEQ:  variable = gadget_qemu_st_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define ST_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            ST_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            ST_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
+{
+    switch (op) {
+    case INDEX_op_ld8u_i32:
+    case INDEX_op_ld8s_i32:
+    case INDEX_op_ld16u_i32:
+    case INDEX_op_ld16s_i32:
+    case INDEX_op_ld_i32:
+    case INDEX_op_ld8u_i64:
+    case INDEX_op_ld8s_i64:
+    case INDEX_op_ld16u_i64:
+    case INDEX_op_ld16s_i64:
+    case INDEX_op_ld32u_i64:
+    case INDEX_op_ld32s_i64:
+    case INDEX_op_ld_i64:
+    case INDEX_op_not_i32:
+    case INDEX_op_not_i64:
+    case INDEX_op_neg_i32:
+    case INDEX_op_neg_i64:
+    case INDEX_op_ext8s_i32:
+    case INDEX_op_ext8s_i64:
+    case INDEX_op_ext16s_i32:
+    case INDEX_op_ext16s_i64:
+    case INDEX_op_ext8u_i32:
+    case INDEX_op_ext8u_i64:
+    case INDEX_op_ext16u_i32:
+    case INDEX_op_ext16u_i64:
+    case INDEX_op_ext32s_i64:
+    case INDEX_op_ext32u_i64:
+    case INDEX_op_ext_i32_i64:
+    case INDEX_op_extu_i32_i64:
+    case INDEX_op_bswap16_i32:
+    case INDEX_op_bswap16_i64:
+    case INDEX_op_bswap32_i32:
+    case INDEX_op_bswap32_i64:
+    case INDEX_op_bswap64_i64:
+        return C_O1_I1(r, r);
+
+    case INDEX_op_st8_i32:
+    case INDEX_op_st16_i32:
+    case INDEX_op_st_i32:
+    case INDEX_op_st8_i64:
+    case INDEX_op_st16_i64:
+    case INDEX_op_st32_i64:
+    case INDEX_op_st_i64:
+        return C_O0_I2(r, r);
+
+    case INDEX_op_div_i32:
+    case INDEX_op_div_i64:
+    case INDEX_op_divu_i32:
+    case INDEX_op_divu_i64:
+    case INDEX_op_rem_i32:
+    case INDEX_op_rem_i64:
+    case INDEX_op_remu_i32:
+    case INDEX_op_remu_i64:
+    case INDEX_op_add_i32:
+    case INDEX_op_add_i64:
+    case INDEX_op_sub_i32:
+    case INDEX_op_sub_i64:
+    case INDEX_op_mul_i32:
+    case INDEX_op_mul_i64:
+    case INDEX_op_and_i32:
+    case INDEX_op_and_i64:
+    case INDEX_op_andc_i32:
+    case INDEX_op_andc_i64:
+    case INDEX_op_eqv_i32:
+    case INDEX_op_eqv_i64:
+    case INDEX_op_nand_i32:
+    case INDEX_op_nand_i64:
+    case INDEX_op_nor_i32:
+    case INDEX_op_nor_i64:
+    case INDEX_op_or_i32:
+    case INDEX_op_or_i64:
+    case INDEX_op_orc_i32:
+    case INDEX_op_orc_i64:
+    case INDEX_op_xor_i32:
+    case INDEX_op_xor_i64:
+    case INDEX_op_shl_i32:
+    case INDEX_op_shl_i64:
+    case INDEX_op_shr_i32:
+    case INDEX_op_shr_i64:
+    case INDEX_op_sar_i32:
+    case INDEX_op_sar_i64:
+    case INDEX_op_rotl_i32:
+    case INDEX_op_rotl_i64:
+    case INDEX_op_rotr_i32:
+    case INDEX_op_rotr_i64:
+    case INDEX_op_setcond_i32:
+    case INDEX_op_setcond_i64:
+        return C_O1_I2(r, r, r);
+
+    case INDEX_op_brcond_i32:
+    case INDEX_op_brcond_i64:
+        return C_O0_I2(r, r);
+
+    case INDEX_op_qemu_ld_i32:
+    case INDEX_op_qemu_ld_i64:
+        return C_O1_I2(r, r, r);
+    case INDEX_op_qemu_st_i32:
+    case INDEX_op_qemu_st_i64:
+        return C_O0_I3(r, r, r);
+
+    default:
+        g_assert_not_reached();
+    }
+}
+
+static const int tcg_target_reg_alloc_order[] = {
+    TCG_REG_R0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+    TCG_REG_R6,
+    TCG_REG_R7,
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
+    /*
+    TCG_REG_R14,  // AREG0
+    TCG_REG_R15,  // SP
+    */
+};
+
+#if MAX_OPC_PARAM_IARGS != 6
+# error Fix needed, number of supported input arguments changed!
+#endif
+
+static const int tcg_target_call_iarg_regs[] = {
+    TCG_REG_R0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+};
+
+static const int tcg_target_call_oarg_regs[] = {
+    TCG_REG_R0,
+};
+
+#ifdef CONFIG_DEBUG_TCG
+static const char *const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {
+    "r00",
+    "r01",
+    "r02",
+    "r03",
+    "r04",
+    "r05",
+    "r06",
+    "r07",
+    "r08",
+    "r09",
+    "r10",
+    "r11",
+    "r12",
+    "r13",
+    "r14",
+    "r15",
+};
+#endif
+
+static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+                        intptr_t value, intptr_t addend)
+{
+    /* tcg_out_reloc always uses the same type, addend. */
+    tcg_debug_assert(type == sizeof(tcg_target_long));
+    tcg_debug_assert(addend == 0);
+    tcg_debug_assert(value != 0);
+    if (TCG_TARGET_REG_BITS == 32) {
+        tcg_patch32(code_ptr, value);
+    } else {
+        tcg_patch64(code_ptr, value);
+    }
+    return true;
+}
+
+#if defined(CONFIG_DEBUG_TCG_INTERPRETER)
+/* Show current bytecode. Used by tcg interpreter. */
+void tci_disas(uint8_t opc)
+{
+    const TCGOpDef *def = &tcg_op_defs[opc];
+    fprintf(stderr, "TCG %s %u, %u, %u\n",
+            def->name, def->nb_oargs, def->nb_iargs, def->nb_cargs);
+}
+#endif
+
+/* Write value (native size). */
+static void tcg_out_immediate(TCGContext *s, tcg_target_ulong v)
+{
+    if (TCG_TARGET_REG_BITS == 32) {
+        //tcg_out32(s, v);
+        tcg_out64(s, v);
+    } else {
+        tcg_out64(s, v);
+    }
+}
+
+void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_rx, uintptr_t jmp_rw, uintptr_t addr)
+{
+    /* Get a pointer to our immediate, which exists after a single pointer. */
+    uintptr_t immediate_addr = jmp_rw;
+
+    /* Patch it to be match our target address. */
+    qatomic_set((uint64_t *)immediate_addr, addr);
+}
+
+
+/**
+ * TCTI Thunk Helpers
+ */
+
+#ifdef CONFIG_SOFTMMU
+
+// TODO: relocate these prototypes?
+tcg_target_ulong helper_ret_ldub_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);
+
+tcg_target_ulong helper_ret_ldub_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int8_t)helper_ret_ldub_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_le_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int16_t)helper_le_lduw_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_le_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int32_t)helper_le_ldul_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_be_lduw_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int16_t)helper_be_lduw_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    return (int32_t)helper_be_ldul_mmu(env, addr, oi, retaddr);
+}
+
+#else
+#error TCTI currently only supports use of the soft MMU.
+#endif
+
+
+/**
+ * TCTI Emmiter Helpers
+ */
+
+
+/* Write gadget pointer. */
+static void tcg_out_nullary_gadget(TCGContext *s, void *gadget)
+{
+    tcg_out_immediate(s, (tcg_target_ulong)gadget);
+}
+
+/* Write gadget pointer, plus 64b immediate. */
+static void tcg_out_imm64_gadget(TCGContext *s, void *gadget, tcg_target_ulong immediate)
+{
+    tcg_out_nullary_gadget(s, gadget);
+    tcg_out64(s, immediate);
+}
+
+
+/* Write gadget pointer (one register). */
+static void tcg_out_unary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS], unsigned reg0)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0]);
+}
+
+
+/* Write gadget pointer (two registers). */
+static void tcg_out_binary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1]);
+}
+
+
+/* Write gadget pointer (three registers). */
+static void tcg_out_ternary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1, unsigned reg2)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1][reg2]);
+}
+
+
+/**
+ * Version of our LDST generator that defers to more optimized gadgets selectively.
+ */
+static void tcg_out_ldst_gadget_inner(TCGContext *s, 
+    void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], 
+    void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    unsigned reg0, unsigned reg1, uint32_t offset)
+{
+    int64_t extended_offset = (int32_t)offset;
+    bool is_negative = (extended_offset < 0);
+
+    // Optimal case: we have a gadget that handles our specific offset, so we don't need to encode
+    // an immediate. This saves us a bunch of speed. :)
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        uint64_t shifted_offset = (extended_offset >> 3);
+        bool aligned_to_8B = ((extended_offset & 0b111) == 0);
+
+        bool have_optimized_gadget = (extended_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN);
+        bool have_shifted_gadget   = (shifted_offset  < TCTI_GADGET_IMMEDIATE_ARRAY_LEN);
+
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (have_optimized_gadget) {
+            tcg_out_nullary_gadget(s, gadget_pos_imm[reg0][reg1][extended_offset]);
+            return;
+        } 
+
+        // Special case: it's frequent to have low-numbered positive offsets that are aligned
+        // to 16B boundaries
+        else if(aligned_to_8B && have_shifted_gadget) {
+            tcg_out_nullary_gadget(s, gadget_shifted_imm[reg0][reg1][shifted_offset]);
+            return;
+        }
+    } 
+    else {
+        uint64_t negated_offset = -(extended_offset);
+
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (negated_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN) {
+            tcg_out_nullary_gadget(s, gadget_neg_imm[reg0][reg1][negated_offset]);
+            return;
+        }
+    }
+
+    // Less optimal case: we don't have a gadget specifically for this. Emit the general case immediate.
+    tcg_out_binary_gadget(s, gadget_base, reg0, reg1);
+    tcg_out64(s, extended_offset); //tcg_out32(s, offset);
+}
+
+/* Shorthand for the above, that prevents us from having to specify the name three times. */
+#define tcg_out_ldst_gadget(s, name, a, b, c) \
+    tcg_out_ldst_gadget_inner(s, name, \
+        name ## _imm,  \
+        name ## _sh8_imm,  \
+        name ## _neg_imm, \
+    a, b, c)
+
+
+
+/* Write label. */
+static void tcti_out_label(TCGContext *s, TCGLabel *label)
+{
+    if (label->has_value) {
+        tcg_out64(s, label->u.value);
+        tcg_debug_assert(label->u.value);
+    } else {
+        tcg_out_reloc(s, s->code_ptr, sizeof(tcg_target_ulong), label, 0);
+        s->code_ptr += sizeof(tcg_target_ulong);
+    }
+}
+
+/**
+ * Generate a register-to-register MOV.
+ */
+static bool tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
+{
+    tcg_debug_assert(ret != arg);
+
+    if (type == TCG_TYPE_I32) {
+        tcg_out_binary_gadget(s, gadget_mov_i32, ret, arg);
+    } else {
+        tcg_out_binary_gadget(s, gadget_mov_i64, ret, arg);
+    }
+
+
+    return true;
+}
+
+
+static void tcg_out_movi_i32(TCGContext *s, TCGReg t0, tcg_target_long arg)
+{
+    bool is_negative = (arg < 0);
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (arg < ARRAY_SIZE(gadget_movi_imm_i32[t0])) {
+            tcg_out_nullary_gadget(s, gadget_movi_imm_i32[t0][arg]);
+            return;
+        }
+    } 
+    else {
+
+    }
+
+    // Emit the mov and its immediate.
+    tcg_out_unary_gadget(s, gadget_movi_i32, t0);
+    tcg_out64(s, arg); // TODO: make 32b?
+}
+
+
+static void tcg_out_movi_i64(TCGContext *s, TCGReg t0, tcg_target_long arg)
+{
+    uint8_t is_negative = arg < 0;
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (arg < ARRAY_SIZE(gadget_movi_imm_i64[t0])) {
+            tcg_out_nullary_gadget(s, gadget_movi_imm_i64[t0][arg]);
+            return;
+        }
+    } 
+    else {
+
+    }
+
+    // TODO: optimize the negative case, too?
+
+    // Less optimal case: emit the mov and its immediate.
+    tcg_out_unary_gadget(s, gadget_movi_i64, t0);
+    tcg_out64(s, arg);
+}
+
+
+/**
+ * Generate an immediate-to-register MOV.
+ */
+static void tcg_out_movi(TCGContext *s, TCGType type, TCGReg t0, tcg_target_long arg)
+{
+    if (type == TCG_TYPE_I32) {
+        tcg_out_movi_i32(s, t0, arg);
+    } else {
+        tcg_out_movi_i64(s, t0, arg);
+    }
+}
+
+/**
+ * Generate a CALL.
+ */
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
+{
+    tcg_out_nullary_gadget(s, gadget_call);
+    tcg_out64(s, (uintptr_t)arg);
+}
+
+/**
+ * Generates LD instructions.
+ */
+static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,
+                       intptr_t arg2)
+{
+
+    if (type == TCG_TYPE_I32) {
+        tcg_out_ldst_gadget(s, gadget_ld32u, ret, arg1, arg2); 
+    } else {
+        tcg_out_ldst_gadget(s, gadget_ld_i64, ret, arg1, arg2); 
+    }
+}
+
+
+/**
+ * Generate every other operation.
+ */
+//static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args)
+void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args)
+{
+    switch (opc) {
+
+    // Exit translation, and return back to QEMU.
+    case INDEX_op_exit_tb:
+        // Emit a simple gadget with a known return code.
+        tcg_out_imm64_gadget(s, gadget_exit_tb, args[0]);
+        break;
+
+    // Jump to a translation block.
+    case INDEX_op_goto_tb:
+
+        // If we're using a direct jump, we'll emit a "relocation" that can be usd
+        // to patch our gadget stream with the target address, later.
+        if (s->tb_jmp_insn_offset) {
+            // Emit our gadget.
+            tcg_out_nullary_gadget(s, gadget_br);
+
+            // Place our current instruction into our "relocation table", so it can
+            // be patched once we know where the branch will target...
+            s->tb_jmp_insn_offset[args[0]] = tcg_current_code_size(s);
+
+            // ... and emit our relocation.
+            tcg_out64(s, args[0]);
+
+
+        } else {
+            /* Indirect jump method. */
+            TODO();
+        }
+        set_jmp_reset_offset(s, args[0]);
+        break;
+
+    // Simple branch.
+    case INDEX_op_br:
+        tcg_out_nullary_gadget(s, gadget_br);
+        tcti_out_label(s, arg_label(args[0]));
+        break;
+
+
+    // Set condition flag.
+    // a0 = Rd, a1 = Rn, a2 = Rm
+    case INDEX_op_setcond_i32:
+    {
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[3]) {
+            case TCG_COND_EQ:  gadget = gadget_setcond_i32_eq; break;
+            case TCG_COND_NE:  gadget = gadget_setcond_i32_ne; break;
+            case TCG_COND_LT:  gadget = gadget_setcond_i32_lt; break;
+            case TCG_COND_GE:  gadget = gadget_setcond_i32_ge; break;
+            case TCG_COND_LE:  gadget = gadget_setcond_i32_le; break;
+            case TCG_COND_GT:  gadget = gadget_setcond_i32_gt; break;
+            case TCG_COND_LTU: gadget = gadget_setcond_i32_lo; break;
+            case TCG_COND_GEU: gadget = gadget_setcond_i32_hs; break;
+            case TCG_COND_LEU: gadget = gadget_setcond_i32_ls; break;
+            case TCG_COND_GTU: gadget = gadget_setcond_i32_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        tcg_out_ternary_gadget(s, gadget, args[0], args[1], args[2]);
+        break;
+    }
+
+    case INDEX_op_setcond_i64:
+    {
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[3]) {
+            case TCG_COND_EQ:  gadget = gadget_setcond_i64_eq; break;
+            case TCG_COND_NE:  gadget = gadget_setcond_i64_ne; break;
+            case TCG_COND_LT:  gadget = gadget_setcond_i64_lt; break;
+            case TCG_COND_GE:  gadget = gadget_setcond_i64_ge; break;
+            case TCG_COND_LE:  gadget = gadget_setcond_i64_le; break;
+            case TCG_COND_GT:  gadget = gadget_setcond_i64_gt; break;
+            case TCG_COND_LTU: gadget = gadget_setcond_i64_lo; break;
+            case TCG_COND_GEU: gadget = gadget_setcond_i64_hs; break;
+            case TCG_COND_LEU: gadget = gadget_setcond_i64_ls; break;
+            case TCG_COND_GTU: gadget = gadget_setcond_i64_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        tcg_out_ternary_gadget(s, gadget, args[0], args[1], args[2]);
+        break;
+    }
+
+    /**
+     * Load instructions.
+     */
+
+    case INDEX_op_ld8u_i32:
+    case INDEX_op_ld8u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld8u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld8s_i32:
+        tcg_out_ldst_gadget(s, gadget_ld8s_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld8s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld8s_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16u_i32:
+    case INDEX_op_ld16u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld16u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16s_i32:
+        tcg_out_ldst_gadget(s, gadget_ld16s_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld16s_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld_i32:
+    case INDEX_op_ld32u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld32u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld_i64:
+        tcg_out_ldst_gadget(s, gadget_ld_i64, args[0], args[1], args[2]); 
+        break;
+    
+    case INDEX_op_ld32s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld32s_i64, args[0], args[1], args[2]); 
+        break;
+
+
+    /**
+     * Store instructions.
+     */
+    case INDEX_op_st8_i32:
+    case INDEX_op_st8_i64:
+        tcg_out_ldst_gadget(s, gadget_st8, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st16_i32:
+    case INDEX_op_st16_i64:
+        tcg_out_ldst_gadget(s, gadget_st16, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st_i32:
+    case INDEX_op_st32_i64:
+        tcg_out_ldst_gadget(s, gadget_st_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st_i64:
+        tcg_out_ldst_gadget(s, gadget_st_i64, args[0], args[1], args[2]); 
+        break;
+
+    /**
+     * Arithmetic instructions.
+     */
+
+    case INDEX_op_add_i32: 
+        tcg_out_ternary_gadget(s, gadget_add_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sub_i32:
+        tcg_out_ternary_gadget(s, gadget_sub_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_mul_i32:
+        tcg_out_ternary_gadget(s, gadget_mul_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_and_i32:
+        tcg_out_ternary_gadget(s, gadget_and_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_andc_i32:     /* Optional (TCG_TARGET_HAS_andc_i32). */
+        tcg_out_ternary_gadget(s, gadget_andc_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_orc_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_orc_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_eqv_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_eqv_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_or_i32:
+        tcg_out_ternary_gadget(s, gadget_or_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_xor_i32:
+        tcg_out_ternary_gadget(s, gadget_xor_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shl_i32:
+        tcg_out_ternary_gadget(s, gadget_shl_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shr_i32:
+        tcg_out_ternary_gadget(s, gadget_shr_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sar_i32:
+        tcg_out_ternary_gadget(s, gadget_sar_i32, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_rotr_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+    //    tcg_out_ternary_gadget(s, gadget_rotr_i32, args[0], args[1], args[2]); 
+    //    break;
+
+    //case INDEX_op_rotl_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+    //    tcg_out_ternary_gadget(s, gadget_rotl_i32, args[0], args[1], args[2]); 
+
+    case INDEX_op_add_i64:
+        tcg_out_ternary_gadget(s, gadget_add_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sub_i64:
+        tcg_out_ternary_gadget(s, gadget_sub_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_mul_i64:
+        tcg_out_ternary_gadget(s, gadget_mul_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_and_i64:
+        tcg_out_ternary_gadget(s, gadget_and_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_andc_i64:     /* Optional (TCG_TARGET_HAS_andc_i64). */
+        tcg_out_ternary_gadget(s, gadget_andc_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_orc_i64:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_orc_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_eqv_i64:      /* Optional (TCG_TARGET_HAS_eqv_i64). */
+        tcg_out_ternary_gadget(s, gadget_eqv_i64, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_nand_i64:     /* Optional (TCG_TARGET_HAS_nand_i64). */
+    //case INDEX_op_nor_i64:      /* Optional (TCG_TARGET_HAS_nor_i64). */
+
+    case INDEX_op_or_i64:
+        tcg_out_ternary_gadget(s, gadget_or_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_xor_i64:
+        tcg_out_ternary_gadget(s, gadget_xor_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shl_i64:
+        tcg_out_ternary_gadget(s, gadget_shl_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shr_i64:
+        tcg_out_ternary_gadget(s, gadget_shr_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sar_i64:
+        tcg_out_ternary_gadget(s, gadget_sar_i64, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_rotl_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+    //    tcg_out_ternary_gadget(s, gadget_rotl_i64, args[0], args[1], args[2]); 
+    //    break;
+
+    //case INDEX_op_rotr_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+    //    tcg_out_ternary_gadget(s, gadget_rotr_i64, args[0], args[1], args[2]); 
+    //    break;
+
+    case INDEX_op_div_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_div_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_divu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_divu_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_rem_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_rem_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_remu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_remu_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_brcond_i64:
+    {
+        static uint8_t last_brcond_i64 = 0;
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[2]) {
+            case TCG_COND_EQ:  gadget = gadget_brcond_i64_eq; break;
+            case TCG_COND_NE:  gadget = gadget_brcond_i64_ne; break;
+            case TCG_COND_LT:  gadget = gadget_brcond_i64_lt; break;
+            case TCG_COND_GE:  gadget = gadget_brcond_i64_ge; break;
+            case TCG_COND_LE:  gadget = gadget_brcond_i64_le; break;
+            case TCG_COND_GT:  gadget = gadget_brcond_i64_gt; break;
+            case TCG_COND_LTU: gadget = gadget_brcond_i64_lo; break;
+            case TCG_COND_GEU: gadget = gadget_brcond_i64_hs; break;
+            case TCG_COND_LEU: gadget = gadget_brcond_i64_ls; break;
+            case TCG_COND_GTU: gadget = gadget_brcond_i64_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        // We'll select the which branch to used based on a cycling counter.
+        // This means we'll pick one of 16 identical brconds. Spreading this out
+        // helps the processor's branch prediction be less "squished", as not every
+        // branch is going throuh the same instruction.
+        tcg_out_ternary_gadget(s, gadget, last_brcond_i64, args[0], args[1]);
+        last_brcond_i64 = (last_brcond_i64 + 1) % TCG_TARGET_NB_REGS;
+
+        // Branch target immediate.
+        tcti_out_label(s, arg_label(args[3]));
+        break;
+    }
+
+
+    case INDEX_op_bswap16_i32:  /* Optional (TCG_TARGET_HAS_bswap16_i32). */
+    case INDEX_op_bswap16_i64:  /* Optional (TCG_TARGET_HAS_bswap16_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap16, args[0], args[1]);
+        break;
+
+    case INDEX_op_bswap32_i32:  /* Optional (TCG_TARGET_HAS_bswap32_i32). */
+    case INDEX_op_bswap32_i64:  /* Optional (TCG_TARGET_HAS_bswap32_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap32, args[0], args[1]);
+        break;
+
+    case INDEX_op_bswap64_i64:  /* Optional (TCG_TARGET_HAS_bswap64_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap64, args[0], args[1]);
+        break;
+
+    case INDEX_op_not_i64:      /* Optional (TCG_TARGET_HAS_not_i64). */
+        tcg_out_binary_gadget(s, gadget_not_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_neg_i64:      /* Optional (TCG_TARGET_HAS_neg_i64). */
+        tcg_out_binary_gadget(s, gadget_neg_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8s_i64:    /* Optional (TCG_TARGET_HAS_ext8s_i64). */
+        tcg_out_binary_gadget(s, gadget_ext8s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8u_i32:    /* Optional (TCG_TARGET_HAS_ext8u_i32). */
+    case INDEX_op_ext8u_i64:    /* Optional (TCG_TARGET_HAS_ext8u_i64). */
+        tcg_out_binary_gadget(s, gadget_ext8u, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16s_i64:   /* Optional (TCG_TARGET_HAS_ext16s_i64). */
+        tcg_out_binary_gadget(s, gadget_ext16s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16u_i32:   /* Optional (TCG_TARGET_HAS_ext16u_i32). */
+    case INDEX_op_ext16u_i64:   /* Optional (TCG_TARGET_HAS_ext16u_i64). */
+        tcg_out_binary_gadget(s, gadget_ext16u, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext32s_i64:   /* Optional (TCG_TARGET_HAS_ext32s_i64). */
+    case INDEX_op_ext_i32_i64:
+        tcg_out_binary_gadget(s, gadget_ext32s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext32u_i64:   /* Optional (TCG_TARGET_HAS_ext32u_i64). */
+    case INDEX_op_extu_i32_i64:
+        tcg_out_binary_gadget(s, gadget_ext32u_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_neg_i32:      /* Optional (TCG_TARGET_HAS_neg_i32). */
+        tcg_out_binary_gadget(s, gadget_neg_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_not_i32:      /* Optional (TCG_TARGET_HAS_not_i32). */
+        tcg_out_binary_gadget(s, gadget_not_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8s_i32:    /* Optional (TCG_TARGET_HAS_ext8s_i32). */
+        tcg_out_binary_gadget(s, gadget_ext8s_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16s_i32:   /* Optional (TCG_TARGET_HAS_ext16s_i32). */
+        tcg_out_binary_gadget(s, gadget_ext16s_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_div_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_div_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_divu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_divu_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_rem_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_rem_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_remu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_remu_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_brcond_i32:
+    {
+        static uint8_t last_brcond_i32 = 0;
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[2]) {
+            case TCG_COND_EQ:  gadget = gadget_brcond_i32_eq; break;
+            case TCG_COND_NE:  gadget = gadget_brcond_i32_ne; break;
+            case TCG_COND_LT:  gadget = gadget_brcond_i32_lt; break;
+            case TCG_COND_GE:  gadget = gadget_brcond_i32_ge; break;
+            case TCG_COND_LE:  gadget = gadget_brcond_i32_le; break;
+            case TCG_COND_GT:  gadget = gadget_brcond_i32_gt; break;
+            case TCG_COND_LTU: gadget = gadget_brcond_i32_lo; break;
+            case TCG_COND_GEU: gadget = gadget_brcond_i32_hs; break;
+            case TCG_COND_LEU: gadget = gadget_brcond_i32_ls; break;
+            case TCG_COND_GTU: gadget = gadget_brcond_i32_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        // We'll select the which branch to used based on a cycling counter.
+        // This means we'll pick one of 16 identical brconds. Spreading this out
+        // helps the processor's branch prediction be less "squished", as not every
+        // branch is going throuh the same instruction.
+        tcg_out_ternary_gadget(s, gadget, last_brcond_i32, args[0], args[1]);
+        last_brcond_i32 = (last_brcond_i32 + 1) % TCG_TARGET_NB_REGS;
+
+        // Branch target immediate.
+        tcti_out_label(s, arg_label(args[3]));
+
+        break;
+    }
+
+    case INDEX_op_qemu_ld_i32:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
+            case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
+            case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
+            default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+        }
+
+        // Args:
+        // - an immediate32 encodes our operation index 
+        tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
+        break;
+    }
+
+    case INDEX_op_qemu_ld_i64:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        // Special optimization case: if we have an operation/target of 0x3A, 
+        // this is a common case. Delegate to our special-case handler.
+        if (args[2] == 0x3a) {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+
+                case -64: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off64_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off64_i64;
+                    break;
+                case -96: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off96_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off96_i64;
+                    break;
+                case -128: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off128_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off128_i64;
+                    break;
+
+                default: 
+                    gadget = gadget_qemu_ld_leq_slowpath_mode3a_off0_i64;
+                    break;
+            }
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } 
+        // Otherwise, handle the generic case.
+        else {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
+                case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
+                case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
+                default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+            }
+            // Args:
+            // - an immediate32 encodes our operation index 
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+            tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
+        }
+
+        break;
+    }
+
+    case INDEX_op_qemu_st_i32:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
+            case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
+            case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
+            default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+        }
+
+        // Args:
+        // - our gadget encodes the target and address registers
+        // - an immediate32 encodes our operation index 
+        tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        tcg_out64(s, args[2]); // FIXME: double encoded
+        break;
+    }
+
+    case INDEX_op_qemu_st_i64:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        // Special optimization case: if we have an operation/target of 0x3A, 
+        // this is a common case. Delegate to our special-case handler.
+        if (args[2] == 0x3a) {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+
+                case -64: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off64_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off64_i64;
+                    break;
+                case -96: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off96_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off96_i64;
+                    break;
+                case -128: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off128_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off128_i64;
+                    break;
+
+                default: 
+                    gadget = gadget_qemu_st_leq_slowpath_mode3a_off0_i64;
+                    break;
+            }
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } 
+        // Otherwise, handle the generic case.
+        else {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
+                case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
+                case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
+                default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+            }
+
+            // Args:
+            // - our gadget encodes the target and address registers
+            // - an immediate32 encodes our operation index 
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+            tcg_out64(s, args[2]); // FIXME: double encoded
+        }
+
+        break;
+    }
+
+    // Memory barriers.
+    case INDEX_op_mb:
+    {
+        static void* sync[] = {
+            [0 ... TCG_MO_ALL]            = gadget_mb_all,
+            [TCG_MO_ST_ST]                = gadget_mb_st,
+            [TCG_MO_LD_LD]                = gadget_mb_ld,
+            [TCG_MO_LD_ST]                = gadget_mb_ld,
+            [TCG_MO_LD_ST | TCG_MO_LD_LD] = gadget_mb_ld,
+        };
+        tcg_out_nullary_gadget(s, sync[args[0] & TCG_MO_ALL]);
+
+        break;
+    }
+
+    case INDEX_op_mov_i32:  /* Always emitted via tcg_out_mov.  */
+    case INDEX_op_mov_i64:
+    case INDEX_op_call:     /* Always emitted via tcg_out_call.  */
+    default:
+        tcg_abort();
+    }
+}
+
+/**
+ * Generate immediate stores.
+ */
+static void tcg_out_st(TCGContext *s, TCGType type, TCGReg arg, TCGReg arg1,
+                       intptr_t arg2)
+{
+    if (type == TCG_TYPE_I32) {
+        tcg_out_ldst_gadget(s, gadget_st_i32, arg, arg1, arg2); 
+    } else {
+        tcg_out_ldst_gadget(s, gadget_st_i64, arg, arg1, arg2); 
+    }
+}
+
+static inline bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
+                               TCGReg base, intptr_t ofs)
+{
+    return false;
+}
+
+/* Test if a constant matches the constraint. */
+static int tcg_target_const_match(tcg_target_long val, TCGType type,
+                                  const TCGArgConstraint *arg_ct)
+{
+    /* No need to return 0 or 1, 0 or != 0 is good enough. */
+    return arg_ct->ct & TCG_CT_CONST;
+}
+
+static void tcg_target_init(TCGContext *s)
+{
+    /* The current code uses uint8_t for tcg operations. */
+    tcg_debug_assert(tcg_op_defs_max <= UINT8_MAX);
+
+    /* Registers available for 32 bit operations. */
+    tcg_target_available_regs[TCG_TYPE_I32] = BIT(TCG_TARGET_NB_REGS) - 1;
+    /* Registers available for 64 bit operations. */
+    tcg_target_available_regs[TCG_TYPE_I64] = BIT(TCG_TARGET_NB_REGS) - 1;
+
+    /* TODO: Which registers should be set here? */
+    tcg_target_call_clobber_regs = BIT(TCG_TARGET_NB_REGS) - 1;
+
+    s->reserved_regs = 0;
+    tcg_regset_set_reg(s->reserved_regs, TCG_REG_CALL_STACK);
+
+    /* We use negative offsets from "sp" so that we can distinguish
+       stores that might pretend to be call arguments.  */
+    tcg_set_frame(s, TCG_REG_CALL_STACK, -CPU_TEMP_BUF_NLONGS * sizeof(long), CPU_TEMP_BUF_NLONGS * sizeof(long));
+}
+
+/* Generate global QEMU prologue and epilogue code. */
+static inline void tcg_target_qemu_prologue(TCGContext *s)
+{
+    // No prologue; as we're interpreted.
+}
+
+
+/**
+ * TCTI 'interpreter' bootstrap.
+ */
+
+// Store the current return address during helper calls.
+__thread uintptr_t tcti_call_return_address;
+
+/* Dispatch the bytecode stream contained in our translation buffer. */
+uintptr_t QEMU_DISABLE_CFI tcg_qemu_tb_exec(CPUArchState *env, const void *v_tb_ptr)
+{
+    // Create our per-CPU temporary storage.
+    long tcg_temps[CPU_TEMP_BUF_NLONGS];
+
+    uint64_t return_value = 0;
+    uintptr_t sp_value    = (uintptr_t)(tcg_temps + CPU_TEMP_BUF_NLONGS);
+    uintptr_t pc_mirror   = (uintptr_t)&tcti_call_return_address;
+
+    // Ensure our target configuration hasn't changed.
+    tcti_assert(TCG_AREG0 == TCG_REG_R14);
+    tcti_assert(TCG_REG_CALL_STACK == TCG_REG_R15);
+
+    asm(
+        // Our threaded-dispatch prologue needs to set up things for our machine to run.
+        // This means:
+        //   - Set up TCG_AREG0 (R14) to point to our architectural state.
+        //   - Set up TCG_REG_CALL_STACK (R15) to point to our temporary buffer.
+        //   - Point x28 (our bytecode "instruction pointer") to the relevant stream address.
+        "ldr x14, %[areg0]\n"
+        "ldr x15, %[sp_value]\n"
+        "ldr x25, %[pc_mirror]\n"
+        "ldr x28, %[start_tb_ptr]\n"
+
+        // To start our code, we'll -call- the gadget at the first bytecode pointer.
+        // Note that we call/branch-with-link, here; so our TB_EXIT gadget can RET in order
+        // to return to this point when things are complete.
+        "ldr x27, [x28], #8\n"
+        "blr x27\n"
+
+        // Finally, we'll copy out our final return value.
+        "str x0, %[return_value]\n"
+
+        : [return_value] "=m" (return_value)
+
+        : [areg0]        "m"  (env), 
+          [sp_value]     "m"  (sp_value), 
+          [start_tb_ptr] "m"  (v_tb_ptr),
+          [pc_mirror]    "m"  (pc_mirror)
+
+        // We touch _every_ one of the lower registers, as we use these to execute directly.
+        : "x0", "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7",
+          "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
+
+        // We also use x26/x27 for temporary values, and x28 as our bytecode poitner.
+        "x25", "x26", "x27", "x28", "cc", "memory"
+    );
+
+    return return_value;
+}
+
+
+/**
+ *  Disassembly output support.
+ */
+#include <dlfcn.h>
+
+
+/* Disassemble TCI bytecode. */
+int print_insn_tcti(bfd_vma addr, disassemble_info *info)
+{
+    Dl_info symbol_info = {};
+    char symbol_name[48] ;
+
+    int status;
+    uint64_t block;
+
+    // Read the relevant pointer.
+    status = info->read_memory_func(addr, (void *)&block, sizeof(block), info);
+    if (status != 0) {
+        info->memory_error_func(status, addr, info);
+        return -1;
+    }
+
+    // Most of our disassembly stream will be gadgets. Try to get their names, for nice output.
+    dladdr((void *)block, &symbol_info);
+
+    if(symbol_info.dli_sname != 0) {
+        strlcpy(symbol_name, symbol_info.dli_sname, 47);
+        info->fprintf_func(info->stream, "%s", symbol_name);
+    } else {
+        info->fprintf_func(info->stream, "%016llx", block);
+    }
+
+    return sizeof(block);
+}
+
+
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
new file mode 100644
index 000000000000..fa2ae5c40a3e
--- /dev/null
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -0,0 +1,220 @@
+/*
+ * Tiny Code Generator for QEMU
+ *
+ * Copyright (c) 2009, 2011 Stefan Weil
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/*
+ * This code implements a TCG which does not generate machine code for some
+ * real target machine but which generates virtual machine code for an
+ * interpreter. Interpreted pseudo code is slow, but it works on any host.
+ *
+ * Some remarks might help in understanding the code:
+ *
+ * "target" or "TCG target" is the machine which runs the generated code.
+ * This is different to the usual meaning in QEMU where "target" is the
+ * emulated machine. So normally QEMU host is identical to TCG target.
+ * Here the TCG target is a virtual machine, but this virtual machine must
+ * use the same word size like the real machine.
+ * Therefore, we need both 32 and 64 bit virtual machines (interpreter).
+ */
+
+#ifndef TCG_TARGET_H
+#define TCG_TARGET_H
+
+#if UINTPTR_MAX == UINT32_MAX
+# error We only support AArch64 running in 64B mode.
+#elif UINTPTR_MAX == UINT64_MAX
+# define TCG_TARGET_REG_BITS 64
+#else
+# error Unknown pointer size for tcti target
+#endif
+
+#define TCG_TARGET_INSN_UNIT_SIZE        1
+#define TCG_TARGET_TLB_DISPLACEMENT_BITS 32
+
+// We're an interpreted target; even if we're JIT-compiling to our interpreter's
+// weird psuedo-native bytecode. We'll indicate that we're intepreted.
+#define TCG_TARGET_INTERPRETER 1
+
+//
+// Supported optional instructions.
+//
+
+// Divs.
+#define TCG_TARGET_HAS_div_i32          1
+#define TCG_TARGET_HAS_rem_i32          1
+#define TCG_TARGET_HAS_div_i64          1
+#define TCG_TARGET_HAS_rem_i64          1
+
+// Extends.
+#define TCG_TARGET_HAS_ext8s_i32        1
+#define TCG_TARGET_HAS_ext16s_i32       1
+#define TCG_TARGET_HAS_ext8u_i32        1
+#define TCG_TARGET_HAS_ext16u_i32       1
+#define TCG_TARGET_HAS_ext8s_i64        1
+#define TCG_TARGET_HAS_ext16s_i64       1
+#define TCG_TARGET_HAS_ext32s_i64       1
+#define TCG_TARGET_HAS_ext8u_i64        1
+#define TCG_TARGET_HAS_ext16u_i64       1
+#define TCG_TARGET_HAS_ext32u_i64       1
+
+// Logicals.
+#define TCG_TARGET_HAS_neg_i32          1
+#define TCG_TARGET_HAS_not_i32          1
+#define TCG_TARGET_HAS_neg_i64          1
+#define TCG_TARGET_HAS_not_i64          1
+
+#define TCG_TARGET_HAS_andc_i32         1
+#define TCG_TARGET_HAS_orc_i32          1
+#define TCG_TARGET_HAS_eqv_i32          1
+#define TCG_TARGET_HAS_andc_i64         1
+#define TCG_TARGET_HAS_eqv_i64          1
+#define TCG_TARGET_HAS_orc_i64          1
+
+// We don't curretly support rotates, since AArch64 lacks ROL.
+// We'll fix this later.
+#define TCG_TARGET_HAS_rot_i32          0
+#define TCG_TARGET_HAS_rot_i64          0
+
+// Swaps.
+#define TCG_TARGET_HAS_bswap16_i32      1
+#define TCG_TARGET_HAS_bswap32_i32      1
+#define TCG_TARGET_HAS_bswap16_i64      1
+#define TCG_TARGET_HAS_bswap32_i64      1
+#define TCG_TARGET_HAS_bswap64_i64      1
+#define TCG_TARGET_HAS_MEMORY_BSWAP     1
+
+// Specify we'll handle direct jumps.
+#define TCG_TARGET_HAS_direct_jump      1
+
+//
+// Potential TODOs.
+//
+
+// TODO: implement DEPOSIT as BFI.
+#define TCG_TARGET_HAS_deposit_i32      0
+#define TCG_TARGET_HAS_deposit_i64      0
+
+// TODO: implement EXTRACT as BFX.
+#define TCG_TARGET_HAS_extract_i32      0
+#define TCG_TARGET_HAS_sextract_i32     0
+#define TCG_TARGET_HAS_extract_i64      0
+#define TCG_TARGET_HAS_sextract_i64     0
+
+// TODO: it might be worth writing a gadget for this
+#define TCG_TARGET_HAS_movcond_i32      0
+#define TCG_TARGET_HAS_movcond_i64      0
+
+//
+// Unsupported instructions.
+//
+
+// ARMv8 doesn't have instructions for NAND/NOR.
+#define TCG_TARGET_HAS_nand_i32         0
+#define TCG_TARGET_HAS_nor_i32          0
+#define TCG_TARGET_HAS_nor_i64          0
+#define TCG_TARGET_HAS_nand_i64         0
+
+// aarch64's CLZ is implemented without a condition, so it
+#define TCG_TARGET_HAS_clz_i32          0
+#define TCG_TARGET_HAS_ctz_i32          0
+#define TCG_TARGET_HAS_ctpop_i32        0
+#define TCG_TARGET_HAS_clz_i64          0
+#define TCG_TARGET_HAS_ctz_i64          0
+#define TCG_TARGET_HAS_ctpop_i64        0
+
+
+// GOTO_PTR is too complex to emit a simple gadget for.
+// We'll let C handle it, since the overhead is similar.
+#define TCG_TARGET_HAS_goto_ptr         0
+
+// We don't have a simple gadget for this, since we're always assuming softmmu.
+#define TCG_TARGET_HAS_qemu_st8_i32     0
+
+// No AArch64 equivalent.a
+#define TCG_TARGET_HAS_extrl_i64_i32    0
+#define TCG_TARGET_HAS_extrh_i64_i32    0
+
+#define TCG_TARGET_HAS_extract2_i64     0
+
+// These should always be zero on our 64B platform.
+#define TCG_TARGET_HAS_muls2_i64        0
+#define TCG_TARGET_HAS_add2_i32         0
+#define TCG_TARGET_HAS_sub2_i32         0
+#define TCG_TARGET_HAS_mulu2_i32        0
+#define TCG_TARGET_HAS_add2_i64         0
+#define TCG_TARGET_HAS_sub2_i64         0
+#define TCG_TARGET_HAS_mulu2_i64        0
+#define TCG_TARGET_HAS_muluh_i64        0
+#define TCG_TARGET_HAS_mulsh_i64        0
+#define TCG_TARGET_HAS_extract2_i32     0
+#define TCG_TARGET_HAS_muls2_i32        0
+#define TCG_TARGET_HAS_muluh_i32        0
+#define TCG_TARGET_HAS_mulsh_i32        0
+
+//
+// Platform metadata.
+//
+
+// Number of registers available.
+// It might make sense to up these, since we can also use x16 -> x25?
+#define TCG_TARGET_NB_REGS 16
+
+/* List of registers which are used by TCG. */
+typedef enum {
+    TCG_REG_R0 = 0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+    TCG_REG_R6,
+    TCG_REG_R7,
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
+    TCG_REG_R14,
+    TCG_REG_R15,
+
+    TCG_AREG0          = TCG_REG_R14,
+    TCG_REG_CALL_STACK = TCG_REG_R15,
+} TCGReg;
+
+// Specify the shape of the stack our runtime will use.
+#define TCG_TARGET_CALL_STACK_OFFSET    0
+#define TCG_TARGET_STACK_ALIGN          16
+
+// We're interpreted, so we'll use our own code to run TB_EXEC.
+#define HAVE_TCG_QEMU_TB_EXEC
+
+// We'll need to enforce memory ordering with barriers.
+#define TCG_TARGET_DEFAULT_MO  (0)
+
+void tci_disas(uint8_t opc);
+
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+
+
+#endif /* TCG_TARGET_H */
diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
new file mode 100755
index 000000000000..1296f6d0c2d7
--- /dev/null
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -0,0 +1,788 @@
+#!/usr/bin/env python3
+""" Gadget-code generator for QEMU TCTI on AArch64. 
+
+Generates a C-code include file containing 'gadgets' for use by TCTI.
+"""
+
+import sys
+import itertools
+
+# Get a handle on the file we'll be working with, and redirect print to it.
+if len(sys.argv) > 1:
+    out_file = open(sys.argv[1], "w")
+
+    # Hook our print function, so it always outputs to the relevant file.
+    core_print = print
+    print = lambda *a, **k : core_print(*a, **k, file=out_file)
+
+# Epilogue code follows at the end of each gadget, and handles continuing execution.
+EPILOGUE = ( 
+    # Load our next gadget address from our bytecode stream, advancing it.
+    "ldr x27, [x28], #8",
+
+    # Jump to the next gadget.
+    "br x27"
+)
+
+# The number of general-purpose registers we're affording the TCG. This must match
+# the configuration in the TCTI target.
+TCG_REGISTER_COUNT   = 16
+TCG_REGISTER_NUMBERS = list(range(TCG_REGISTER_COUNT))
+
+# Helper that provides each of the AArch64 condition codes of interest.
+ARCH_CONDITION_CODES = ["eq", "ne", "lt", "ge", "le", "gt", "lo", "hs", "ls", "hi"]
+
+# We'll create a variety of gadgets that assume the MMU's TLB is stored at certain
+# offsets into its structure. These should match the offsets in tcg-target.c.in.
+QEMU_ALLOWED_MMU_OFFSETS = [ 64, 96, 128 ]
+
+# Statistics.
+gadgets      = 0
+instructions = 0
+
+def simple(name, *lines):
+    """ Generates a simple gadget that needs no per-register specialization. """
+
+    global gadgets, instructions
+
+    gadgets += 1
+
+    # Create our C/ASM framing.
+    #print(f"__attribute__((naked)) static void gadget_{name}(void)")
+    print(f"__attribute__((naked)) void gadget_{name}(void);")
+    print(f"__attribute__((naked)) void gadget_{name}(void)")
+    print("{")
+
+    # Add the core gadget
+    print("\tasm(")
+    for line in lines + EPILOGUE:
+        print(f"\t\t\"{line} \\n\"")
+        instructions += 1
+    print("\t);")
+
+    # End our framing.
+    print("}\n")
+
+
+def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
+    """ Generates a collection of gadgtes with register substitutions. """
+
+    def substitutions_for_letter(letter, number, line):
+        """ Helper that transforms Wd => w1, implementing gadget substitutions. """
+
+        # Register substitutions...
+        line = line.replace(f"X{letter}", f"x{number}")
+        line = line.replace(f"W{letter}", f"w{number}")
+
+        # ... immediate substitutions.
+        line = line.replace(f"I{letter}", f"{number}")
+        return line
+
+        
+    # Build a list of all the various stages we'll iterate over...
+    immediate_parameters = list(immediate_range)
+    parameters   = ([TCG_REGISTER_NUMBERS] * len(substitutions))
+
+    # ... adding immediates, if need be.
+    if immediate_parameters:
+        parameters.append(immediate_parameters)
+        substitutions = substitutions + ['i']
+
+    # Generate a list of register-combinations we'll support.
+    permutations = itertools.product(*parameters)
+
+    #  For each permutation...
+    for permutation in permutations:
+        new_lines = lines
+
+        # Replace each placeholder element with its proper value...
+        for index, element in enumerate(permutation):
+            letter = substitutions[index]
+            number = element
+
+            # Create new gadgets for the releavnt line...
+            new_lines = [substitutions_for_letter(letter, number, line) for line in new_lines]
+
+        # ... and emit the gadget.
+        permutation_id = "_arg".join(str(number) for number in permutation)
+        simple(f"{name}_arg{permutation_id}", *new_lines)
+
+
+def with_dnm(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
+    with_register_substitutions(name, ("d", "n", "m"), *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    # D array
+    for d in TCG_REGISTER_NUMBERS:
+        print("\t{")
+
+        # N array
+        for n in TCG_REGISTER_NUMBERS:
+            print("\t\t{", end="")
+
+            # M array
+            for m in TCG_REGISTER_NUMBERS:
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{m}", end=", ")
+
+            print("},")
+        print("\t},")
+    print("};")
+
+
+def with_dn_immediate(name, *lines, immediate_range):
+    """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
+    with_register_substitutions(name, ["d", "n"], *lines, immediate_range=immediate_range)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print("{")
+
+    # D array
+    for d in TCG_REGISTER_NUMBERS:
+        print("\t{")
+
+        # N array
+        for n in TCG_REGISTER_NUMBERS:
+            print("\t\t{", end="")
+
+            # M array
+            for i in immediate_range:
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{i}", end=", ")
+
+            print("},")
+        print("\t},")
+    print("};")
+
+
+def with_pair(name, substitutions, *lines):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, substitutions, *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    # N array
+    for a in TCG_REGISTER_NUMBERS:
+        print("\t\t{", end="")
+
+        # M array
+        for b in TCG_REGISTER_NUMBERS:
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+
+        print("},")
+    print("};")
+
+
+def math_dnm(name, mnemonic):
+    """ Equivalent to `with_dnm`, but creates a _i32 and _i64 variant. For simple math. """
+    with_dnm(f'{name}_i32', f"{mnemonic} Wd, Wn, Wm")
+    with_dnm(f'{name}_i64', f"{mnemonic} Xd, Xn, Xm")
+
+def math_dn(name, mnemonic):
+    """ Equivalent to `with_dn`, but creates a _i32 and _i64 variant. For simple math. """
+    with_dn(f'{name}_i32', f"{mnemonic} Wd, Wn")
+    with_dn(f'{name}_i64', f"{mnemonic} Xd, Xn")
+
+
+def with_nm(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xn, and Xm, and equivalents. """
+    with_pair(name, ('n', 'm',), *lines)
+
+
+def with_dn(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, and Xn, and equivalents. """
+    with_pair(name, ('d', 'n',), *lines)
+
+
+def ldst_dn(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, and Xn, and equivalents. 
+    
+    This variant is optimized for loads and stores, and optimizes common offset cases.
+    """
+
+    #
+    # Simple case: create our gadgets.
+    #
+    with_dn(name, "ldr x27, [x28], #8", *lines)
+
+    #
+    # Optimization case: create variants of our gadgets with our offsets replaced with common immediates.
+    #
+    immediate_lines_pos = [line.replace("x27", "#Ii") for line in lines]
+    with_dn_immediate(f"{name}_imm", *immediate_lines_pos, immediate_range=range(64))
+
+    immediate_lines_aligned = [line.replace("x27", "#(Ii << 3)") for line in lines]
+    with_dn_immediate(f"{name}_sh8_imm", *immediate_lines_aligned, immediate_range=range(64))
+
+    immediate_lines_neg = [line.replace("x27", "#-Ii") for line in lines]
+    with_dn_immediate(f"{name}_neg_imm", *immediate_lines_neg, immediate_range=range(64))
+
+
+def with_single(name, substitution, *lines):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, (substitution,), *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    for n in TCG_REGISTER_NUMBERS:
+        print(f"gadget_{name}_arg{n}", end=", ")
+
+    print("};")
+
+
+def with_d_immediate(name, *lines, immediate_range=range(0)):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, ['d'], *lines, immediate_range=immediate_range)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print("{")
+
+    # D array
+    for a in TCG_REGISTER_NUMBERS:
+        print("\t\t{", end="")
+
+        # I array
+        for b in immediate_range:
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+
+        print("},")
+    print("};")
+
+
+
+def with_d(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd. """
+    with_single(name, 'd', *lines)
+
+
+# Assembly code for saving our machine state before entering the C runtime.
+C_CALL_PROLOGUE = [
+    # Store our machine state.
+    "str x25,      [sp, #-16]!",
+    "stp x14, x15, [sp, #-16]!",
+    "stp x12, x13, [sp, #-16]!",
+    "stp x10, x11, [sp, #-16]!",
+    "stp x8,  x9,  [sp, #-16]!",
+    "stp x6,  x7,  [sp, #-16]!",
+    "stp x4,  x5,  [sp, #-16]!",
+    "stp x2,  x3,  [sp, #-16]!",
+    "stp x0,  x1,  [sp, #-16]!",
+    "stp x28, lr,  [sp, #-16]!",
+]
+
+# Assembly code for restoring our machine state after leaving the C runtime.
+C_CALL_EPILOGUE = [
+    "ldp x28, lr, [sp], #16",
+    "ldp x0,  x1, [sp], #16",
+    "ldp x2,  x3, [sp], #16",
+    "ldp x4,  x5, [sp], #16",
+    "ldp x6,  x7, [sp], #16",
+    "ldp x8,  x9, [sp], #16",
+    "ldp x10, x11, [sp], #16",
+    "ldp x12, x13, [sp], #16",
+    "ldp x14, x15, [sp], #16",
+    "ldr x25,      [sp], #16",
+]
+
+
+def create_tlb_fastpath(is_aligned, is_write, offset, miss_label="0"):
+    """ Creates a set of instructions that perform a soft-MMU TLB lookup.
+
+    This is used for `qemu_ld`/qemu_st` instructions; to emit a prologue that
+    hopefully helps us skip a slow call into the C runtime when a Guest Virtual 
+    -> Host Virtual mapping is in the softmmu's TLB.
+
+    This "fast-path" prelude behaves as follows:
+        - If a TLB entry is found for the address stored in Xn, then x27
+          is stored to an "addend" that can be added to the guest virtual addres
+          to get the host virtual address (the address in our local memory space).
+        - If a TLB entry isn't found, it branches to the "miss_label" (by default, 0:),
+          so address lookup can be handled by the fastpath.
+
+    Clobbers x24, and x26; provides output in x27.
+    """
+
+    fast_path = [
+        # Load env_tlb(env)->f[mmu_idx].{mask,table} into {x26,x27}.
+        f"ldp x26, x27, [x14, #-{offset}]",
+
+        # Extract the TLB index from the address into X26. 
+        "and x26, x26, Xn, lsr #7", # Xn = addr regsiter 
+
+        # Add the tlb_table pointer, creating the CPUTLBEntry address into X27. 
+        "add x27, x27, x26",
+
+        # Load the tlb comparator into X26, and the fast path addend into X27. 
+        "ldr x26, [x27, #8]" if is_write else "ldr x26, [x27]",
+        "ldr x27, [x27, #0x18]",
+
+    ]
+
+    if is_aligned:
+        fast_path.extend([
+            # Store the page mask part of the address into X24.
+            "and x24, Xn, #0xfffffffffffff000",
+
+            # Compare the masked address with the TLB value.
+            "cmp x26, x24",
+
+            # If we're not equal, this isn't a TLB hit. Jump to our miss handler.
+            f"b.ne {miss_label}f",
+        ])
+    else:
+        fast_path.extend([
+            # If we're not aligned, add in our alignment value to ensure we don't
+            # don't straddle the end of a page.
+            "add x24, Xn, #7",
+
+            # Store the page mask part of the address into X24.
+            "and x24, x24, #0xfffffffffffff000",
+
+            # Compare the masked address with the TLB value.
+            "cmp x26, x24",
+
+            # If we're not equal, this isn't a TLB hit. Jump to our miss handler.
+            f"b.ne {miss_label}f",
+        ])
+
+    return fast_path
+
+
+
+def ld_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None, is_aligned=False, force_slowpath=False):
+    """ Creates a thunk into our C runtime for a QEMU ST operation. """
+
+    # Use only offset 0 (no real offset) if we're forcing slowpath; 
+    # otherwise, use all of our allowed MMU offsets.
+    offsets = [0] if force_slowpath else QEMU_ALLOWED_MMU_OFFSETS
+    for offset in offsets:
+        for is_32b in (True, False):
+            fastpath = fastpath_32b if is_32b else fastpath_64b
+
+            gadget_name = f"{name}_off{offset}_i32" if is_32b else f"{name}_off{offset}_i64"
+            postscript = () if immediate else ("add x28, x28, #8",)
+
+            # If we have a pure-assembly fast path, start our gadget with it.
+            if fastpath and not force_slowpath:
+                fastpath_ops = [
+                    # Create a fastpath that jumps to miss_lable on a TLB miss,
+                    # or sets x27 to the TLB addend on a TLB hit.
+                    *create_tlb_fastpath(is_aligned=is_aligned, is_write=False, offset=offset),
+
+                    # On a hit, we can just perform an appropriate load...
+                    *fastpath,
+
+                    # Run our patch-up post-script, if we have one.
+                    *postscript,
+
+                    # ... and then we're done!
+                    *EPILOGUE,
+                ]
+            # Otherwise, we'll save arguments for our slow path.
+            else:
+                fastpath_ops = []
+
+            #
+            # If we're not taking our fast path, we'll call into our C runtime to take the slow path.
+            # 
+            with_dn(gadget_name, 
+                    *fastpath_ops,
+
+                "0:",
+                    "mov x27, Xn",
+
+                    # Save our registers in preparation for entering a C call.
+                    *C_CALL_PROLOGUE,
+
+                    # Per our calling convention:
+                    # - Move our architectural environment into x0, from x14.
+                    # - Move our target address into x1. [Placed in x27 below.]
+                    # - Move our operation info into x2, from an immediate32.
+                    # - Move the next bytecode pointer into x3, from x28.
+                    "mov   x0, x14",
+                    "mov   x1, x27",
+                    f"mov   x2, #{immediate}" if (immediate is not None) else "ldr   x2, [x28], #8", 
+                    "mov   x3, x28",
+
+                    # Perform our actual core code.
+                    f"bl _{slowpath_helper}",
+
+                    # Temporarily store our result in a register that won't get trashed.
+                    "mov x27, x0",
+
+                    # Restore our registers after our C call.
+                    *C_CALL_EPILOGUE,
+
+                    # Finally, call our postscript...
+                    *postscript,
+
+                    # ... and place our results in the target register.
+                    "mov Wd, w27" if is_32b else "mov Xd, x27"
+            )
+
+
+def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None, is_aligned=False, force_slowpath=False):
+    """ Creates a thunk into our C runtime for a QEMU ST operation. """
+
+    # Use only offset 0 (no real offset) if we're forcing slowpath; 
+    # otherwise, use all of our allowed MMU offsets.
+    offsets = [0] if force_slowpath else QEMU_ALLOWED_MMU_OFFSETS
+    for offset in offsets:
+
+        for is_32b in (True, False):
+            fastpath = fastpath_32b if is_32b else fastpath_64b
+
+            gadget_name = f"{name}_off{offset}_i32" if is_32b else f"{name}_off{offset}_i64"
+            postscript = () if immediate else ("add x28, x28, #8",)
+
+            # If we have a pure-assembly fast path, start our gadget with it.
+            if fastpath and not force_slowpath:
+                fastpath_ops = [
+
+                    # Create a fastpath that jumps to miss_lable on a TLB miss,
+                    # or sets x27 to the TLB addend on a TLB hit.
+                    *create_tlb_fastpath(is_aligned=is_aligned, is_write=True, offset=offset),
+
+                    # On a hit, we can just perform an appropriate load...
+                    *fastpath,
+
+                    # Run our patch-up post-script, if we have one.
+                    *postscript,
+
+                    # ... and then we're done!
+                    *EPILOGUE,
+                ]
+            else:
+                fastpath_ops = []
+
+
+            #
+            # If we're not taking our fast path, we'll call into our C runtime to take the slow path.
+            # 
+            with_dn(gadget_name, 
+                    *fastpath_ops,
+
+                "0:",
+                    # Move our arguments into registers that we're not actively using.
+                    # This ensures that they won't be trounced by our calling convention
+                    # if this is reading values from x0-x4.
+                    "mov w27, Wd" if is_32b else "mov x27, Xd",
+                    "mov x26, Xn",
+
+                    # Save our registers in preparation for entering a C call.
+                    *C_CALL_PROLOGUE,
+
+                    # Per our calling convention:
+                    # - Move our architectural environment into x0, from x14.
+                    # - Move our target address into x1. [Moved into x26 above].
+                    # - Move our target value into x2. [Moved into x27 above].
+                    # - Move our operation info into x3, from an immediate32.
+                    # - Move the next bytecode pointer into x4, from x28.
+                    "mov   x0, x14",
+                    "mov   x1, x26",
+                    "mov   x2, x27",
+                    f"mov  x3, #{immediate}" if (immediate is not None) else "ldr   x3, [x28], #8", 
+                    "mov   x4, x28",
+
+                    # Perform our actual core code.
+                    f"bl _{slowpath_helper}",
+
+                    # Restore our registers after our C call.
+                    *C_CALL_EPILOGUE,
+
+                    # Finally, call our postscript.
+                    *postscript
+            )
+
+
+#
+# Gadget definitions.
+#
+
+print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n")
+
+# Call a C language helper function by address.
+simple("call",
+    # Get our C runtime function's location as a pointer-sized immediate...
+    "ldr x27, [x28], #8",
+
+    # Store our TB return address for our helper.
+    "str x28, [x25]",
+
+    # Prepare ourselves to call into our C runtime...
+    *C_CALL_PROLOGUE,
+
+    # ... perform the call itself ...
+    "blr x27",
+
+    # Save the result of our call for later.
+    "mov x27, x0",
+
+    # ... and restore our environment.
+    *C_CALL_EPILOGUE,
+
+    # Restore our return value.
+    "mov x0, x27"
+)
+
+# Branch to a given immediate address.
+simple("br",
+    # Use our immediate argument as our new bytecode-pointer location.
+    "ldr x28, [x28]"
+)
+
+# Exit from a translation buffer execution.
+simple("exit_tb",
+
+    # We have a single immediate argument, which contains our return code.
+    # Place it into x0, as one would a return code.
+    "ldr x0, [x28], #8",
+
+    # And finally, return back to the code that invoked our gadget stream.
+    "ret"
+)
+
+
+for condition in ARCH_CONDITION_CODES:
+
+    # Performs a comparison between two operands.
+    with_dnm(f"setcond_i32_{condition}",
+        "subs Wd, Wn, Wm",
+        f"cset Wd, {condition}"
+    )
+    with_dnm(f"setcond_i64_{condition}",
+        "subs Xd, Xn, Xm",
+        f"cset Xd, {condition}"
+    )
+
+    #
+    # NOTE: we use _dnm for the conditional branches, even though we don't
+    # actually do anything different based on the d argument. This gemerates
+    # effectively 16 identical `brcond` gadgets for each condition; which we
+    # use in the backend to spread out the actual branch sources we use.
+    #
+    # This is a slight mercy for the branch predictor, as not every conditional
+    # branch is funneled throught the same address.
+    #
+
+    # Branches iff a given comparison is true.
+    with_dnm(f'brcond_i32_{condition}',
+
+        # Grab our immediate argument.
+        "ldr x27, [x28], #8",
+
+        # Perform our comparison and conditional branch.
+        "subs Wzr, Wn, Wm",
+        f"b{condition} 1f",
+
+        "0:", # not taken
+           # Perform our end-of-instruction epilogue.
+            *EPILOGUE,
+
+        "1:" # taken
+            # Update our bytecode pointer to take the label.
+            "mov x28, x27"
+    )
+
+    # Branches iff a given comparison is true.
+    with_dnm(f'brcond_i64_{condition}',
+
+        # Grab our immediate argument.
+        "ldr x27, [x28], #8",
+
+        # Perform our comparison and conditional branch.
+        "subs Xzr, Xn, Xm",
+        f"b{condition} 1f",
+
+        "0:", # not taken
+            # Perform our end-of-instruction epilogue.
+            *EPILOGUE,
+
+        "1:" # taken
+            # Update our bytecode pointer to take the label.
+            "mov x28, x27"
+    )
+
+
+# MOV variants.
+with_dn("mov_i32",     "mov Wd, Wn")
+with_dn("mov_i64",     "mov Xd, Xn")
+with_d("movi_i32", "ldr Wd, [x28], #8")
+with_d("movi_i64", "ldr Xd, [x28], #8")
+
+# Create MOV variants that have common constants built in to the gadget.
+# This optimization helps costly reads from memories for simple operations.
+with_d_immediate("movi_imm_i32", "mov Wd, #Ii", immediate_range=range(64))
+with_d_immediate("movi_imm_i64", "mov Xd, #Ii", immediate_range=range(64))
+
+# LOAD variants.
+# TODO: should the signed variants have X variants for _i64?
+ldst_dn("ld8u",      "ldrb  Wd, [Xn, x27]")
+ldst_dn("ld8s_i32",  "ldrsb Wd, [Xn, x27]")
+ldst_dn("ld8s_i64",  "ldrsb Xd, [Xn, x27]")
+ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
+ldst_dn("ld16s_i32", "ldrsh Wd, [Xn, x27]")
+ldst_dn("ld16s_i64", "ldrsh Xd, [Xn, x27]")
+ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
+ldst_dn("ld32s_i64", "ldrsw Xd, [Xn, x27]")
+ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
+
+# STORE variants.
+ldst_dn("st8",         "strb  Wd, [Xn, x27]")
+ldst_dn("st16",        "strh  Wd, [Xn, x27]")
+ldst_dn("st_i32",      "str   Wd, [Xn, x27]")
+ldst_dn("st_i64",      "str   Xd, [Xn, x27]")
+
+# QEMU LD/ST are handled in our C runtime rather than with simple gadgets,
+# as they're nontrivial.
+
+# Trivial arithmetic.
+math_dnm("add" , "add" )
+math_dnm("sub" , "sub" )
+math_dnm("mul" , "mul" )
+math_dnm("div" , "sdiv")
+math_dnm("divu", "udiv")
+
+# Division remainder
+with_dnm("rem_i32",  "sdiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
+with_dnm("rem_i64",  "sdiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
+with_dnm("remu_i32", "udiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
+with_dnm("remu_i64", "udiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
+
+# Trivial logical.
+math_dn( "not",  "mvn")
+math_dn( "neg",  "neg")
+math_dnm("and",  "and")
+math_dnm("andc", "bic")
+math_dnm("or",   "orr")
+math_dnm("orc",  "orn")
+math_dnm("xor",  "eor")
+math_dnm("eqv",  "eon")
+math_dnm("shl",  "lsl")
+math_dnm("shr",  "lsr")
+math_dnm("sar",  "asr")
+
+# AArch64 lacks a Rotate Left; so we instead rotate right by a negative.
+# TODO: validate this?
+#math_dnm("rotr", "ror")
+#with_dnm("rotl_i32", "neg w27, Wm", "ror Wd, Wn, w27")
+#with_dnm("rotl_i64", "neg x27, Xm", "ror Xd, Xn, x27")
+
+# Numeric extension.
+math_dn("ext8s",      "sxtb")
+with_dn("ext8u",      "and Xd, Xn, #0xff")
+math_dn("ext16s",     "sxth")
+with_dn("ext16u",     "and Wd, Wn, #0xffff")
+with_dn("ext32s_i64", "sxtw Xd, Wn")
+with_dn("ext32u_i64", "and Xd, Xn, #0xffffffff")
+
+# Byte swapping.
+with_dn("bswap16",    "rev w27, Wn", "lsr Wd, w27, #16")
+with_dn("bswap32",    "rev Wd, Wn")
+with_dn("bswap64",    "rev Xd, Xn")
+
+# Memory barriers.
+simple("mb_all", "dmb ish")
+simple("mb_st",  "dmb ishst")
+simple("mb_ld",  "dmb ishld")
+
+# Handlers for QEMU_LD, which handles guest <- host loads.
+for subtype in ('aligned', 'unaligned', 'slowpath'):
+    is_aligned  = (subtype == 'aligned')
+    is_slowpath = (subtype == 'slowpath')
+
+    ld_thunk(f"qemu_ld_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu",
+        fastpath_32b=["ldrb Wd, [Xn, x27]"], fastpath_64b=["ldrb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_sb_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu_signed",
+        fastpath_32b=["ldrsb Wd, [Xn, x27]"], fastpath_64b=["ldrsb Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu",
+        fastpath_32b=["ldrh Wd, [Xn, x27]"], fastpath_64b=["ldrh Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu_signed",
+        fastpath_32b=["ldrsh Wd, [Xn, x27]"], fastpath_64b=["ldrsh Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu",
+        fastpath_32b=["ldr Wd, [Xn, x27]"], fastpath_64b=["ldr Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesl_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu_signed",
+        fastpath_32b=["ldrsw Xd, [Xn, x27]"], fastpath_64b=["ldrsw Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+
+    # Special variant for the most common mode, as a speedup optimization.
+    ld_thunk(f"qemu_ld_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x3a
+    )
+
+    # For now, leave the rare/big-endian stuff slow-path only.
+    ld_thunk(f"qemu_ld_beuw_{subtype}", None, None, "helper_be_lduw_mmu",         
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_besw_{subtype}", None, None, "helper_be_lduw_mmu_signed",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_beul_{subtype}", None, None, "helper_be_ldul_mmu",         
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_besl_{subtype}", None, None, "helper_be_ldul_mmu_signed",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_beq_{subtype}",  None, None, "helper_be_ldq_mmu",          
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+
+
+# Handlers for QEMU_ST, which handles guest -> host stores.
+for subtype in ('aligned', 'unaligned', 'slowpath'):
+    is_aligned  = (subtype == 'aligned')
+    is_slowpath = (subtype == 'slowpath')
+
+    st_thunk(f"qemu_st_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_stb_mmu",
+        fastpath_32b=["strb Wd, [Xn, x27]"], fastpath_64b=["strb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stw_mmu",
+        fastpath_32b=["strh Wd, [Xn, x27]"], fastpath_64b=["strh Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stl_mmu",
+        fastpath_32b=["str Wd, [Xn, x27]"], fastpath_64b=["str Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    
+    # Special optimization for the most common modes.
+    st_thunk(f"qemu_st_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x3a
+    )
+
+    # For now, leave the rare/big-endian stuff slow-path only.
+    st_thunk(f"qemu_st_beuw_{subtype}", None, None, "helper_be_stw_mmu",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    st_thunk(f"qemu_st_beul_{subtype}", None, None, "helper_be_stl_mmu",
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    st_thunk(f"qemu_st_beq_{subtype}",  None, None, "helper_be_stq_mmu",
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+
+
+# Statistics.
+sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions ({instructions * 4} B).\n\n")
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 5b0750685102..ec832d92d0e6 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -165,7 +165,7 @@ TCGv_env cpu_env = 0;
 const void *tcg_code_gen_epilogue;
 uintptr_t tcg_splitwx_diff;
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 tcg_prologue_fn *tcg_qemu_tb_exec;
 #endif
 
@@ -1227,7 +1227,7 @@ void tcg_prologue_init(TCGContext *s)
     region.start = buf0;
     region.end = buf0 + total_size;
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     tcg_qemu_tb_exec = (tcg_prologue_fn *)tcg_splitwx_to_rx(buf0);
 #endif
 
@@ -1253,7 +1253,7 @@ void tcg_prologue_init(TCGContext *s)
 #endif
 
     buf1 = s->code_ptr;
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     flush_idcache_range((uintptr_t)tcg_splitwx_to_rx(buf0), (uintptr_t)buf0,
                         tcg_ptr_byte_diff(buf1, buf0));
 #endif
@@ -1981,7 +1981,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
 #endif
 
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* We have 64-bit values in one register, but need to pass as two
        separate parameters.  Split them.  */
     int orig_sizemask = sizemask;
@@ -2031,7 +2031,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
     pi = 0;
     if (ret != NULL) {
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
         if (orig_sizemask & 1) {
             /* The 32-bit ABI is going to return the 64-bit value in
                the %o0/%o1 register pair.  Prepare for this by using
@@ -2109,7 +2109,7 @@ void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)
     tcg_debug_assert(pi <= ARRAY_SIZE(op->args));
 
 #if defined(__sparc__) && !defined(__arch64__) \
-    && !defined(CONFIG_TCG_INTERPRETER)
+    && !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* Free all of the parts we allocated above.  */
     for (i = real_args = 0; i < orig_nargs; ++i) {
         int is_64bit = orig_sizemask & (1 << (i+1)*2);
@@ -4789,7 +4789,7 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
         return -2;
     }
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* flush instruction cache */
     flush_idcache_range((uintptr_t)tcg_splitwx_to_rx(s->code_buf),
                         (uintptr_t)s->code_buf,

From d35954d3c9bc2dd2a3f0034cbe12dd7ff85226af Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Thu, 29 Apr 2021 23:29:29 -0700
Subject: [PATCH 067/180] tcti: mark gadgets static to reduce symbol size in
 shared library builds

---
 tcg/aarch64-tcti/tcti-gadget-gen.py | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/tcg/aarch64-tcti/tcti-gadget-gen.py b/tcg/aarch64-tcti/tcti-gadget-gen.py
index 1296f6d0c2d7..fa0232fefac0 100755
--- a/tcg/aarch64-tcti/tcti-gadget-gen.py
+++ b/tcg/aarch64-tcti/tcti-gadget-gen.py
@@ -49,8 +49,8 @@ def simple(name, *lines):
 
     # Create our C/ASM framing.
     #print(f"__attribute__((naked)) static void gadget_{name}(void)")
-    print(f"__attribute__((naked)) void gadget_{name}(void);")
-    print(f"__attribute__((naked)) void gadget_{name}(void)")
+    print(f"__attribute__((naked)) static void gadget_{name}(void);")
+    print(f"__attribute__((naked)) static void gadget_{name}(void)")
     print("{")
 
     # Add the core gadget
@@ -113,7 +113,7 @@ def with_dnm(name, *lines):
     with_register_substitutions(name, ("d", "n", "m"), *lines)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
     print("{")
 
     # D array
@@ -138,7 +138,7 @@ def with_dn_immediate(name, *lines, immediate_range):
     with_register_substitutions(name, ["d", "n"], *lines, immediate_range=immediate_range)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
     print("{")
 
     # D array
@@ -163,7 +163,7 @@ def with_pair(name, substitutions, *lines):
     with_register_substitutions(name, substitutions, *lines)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
     print("{")
 
     # N array
@@ -228,7 +228,7 @@ def with_single(name, substitution, *lines):
     with_register_substitutions(name, (substitution,), *lines)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="")
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="")
     print("{")
 
     for n in TCG_REGISTER_NUMBERS:
@@ -242,7 +242,7 @@ def with_d_immediate(name, *lines, immediate_range=range(0)):
     with_register_substitutions(name, ['d'], *lines, immediate_range=immediate_range)
 
     # Print out an array that contains all of our gadgets, for lookup.
-    print(f"void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
     print("{")
 
     # D array

From 589722910574556490d5a3737ca62b28267db15d Mon Sep 17 00:00:00 2001
From: John Arbuckle <programmingkidx@gmail.com>
Date: Mon, 17 Feb 2020 20:22:28 -0500
Subject: [PATCH 068/180] Implement the Screamer sound chip for the mac99
 machine type

This patch enables the playback of audio on a Mac OS 9 or Mac OS X guest.

Signed-off-by: John Arbuckle <programmingkidx@gmail.com>
Message-Id: <20200218012228.7336-1-programmingkidx@gmail.com>
---
 hw/audio/Kconfig              |   3 +
 hw/audio/meson.build          |   1 +
 hw/audio/screamer.c           | 985 ++++++++++++++++++++++++++++++++++
 hw/misc/macio/macio.c         |  28 +
 hw/ppc/Kconfig                |   1 +
 hw/ppc/mac.h                  |   5 +
 include/hw/audio/screamer.h   |  42 ++
 include/hw/misc/macio/macio.h |   2 +
 8 files changed, 1067 insertions(+)
 create mode 100644 hw/audio/screamer.c
 create mode 100644 include/hw/audio/screamer.h

diff --git a/hw/audio/Kconfig b/hw/audio/Kconfig
index e9c6fed8261e..196da6c3fe76 100644
--- a/hw/audio/Kconfig
+++ b/hw/audio/Kconfig
@@ -50,3 +50,6 @@ config CS4231
 
 config MARVELL_88W8618
     bool
+
+config SCREAMER
+    bool
diff --git a/hw/audio/meson.build b/hw/audio/meson.build
index 32c42bdebe41..3f2b517468b3 100644
--- a/hw/audio/meson.build
+++ b/hw/audio/meson.build
@@ -13,3 +13,4 @@ softmmu_ss.add(when: 'CONFIG_PL041', if_true: files('pl041.c', 'lm4549.c'))
 softmmu_ss.add(when: 'CONFIG_SB16', if_true: files('sb16.c'))
 softmmu_ss.add(when: 'CONFIG_VT82C686', if_true: files('via-ac97.c'))
 softmmu_ss.add(when: 'CONFIG_WM8750', if_true: files('wm8750.c'))
+softmmu_ss.add(when: 'CONFIG_SCREAMER', if_true: files('screamer.c'))
diff --git a/hw/audio/screamer.c b/hw/audio/screamer.c
new file mode 100644
index 000000000000..4ebc8af9e864
--- /dev/null
+++ b/hw/audio/screamer.c
@@ -0,0 +1,985 @@
+/*
+ * File: Screamer.c
+ * Description: Implement the Screamer sound chip used in Apple Macintoshes.
+ * It works by filling a buffer, then playing the buffer.
+ */
+
+#include "qemu/osdep.h"
+#include "audio/audio.h"
+#include "hw/hw.h"
+#include "hw/irq.h"
+#include <inttypes.h>
+#include "hw/ppc/mac.h"
+#include "hw/qdev-properties.h"
+#include "migration/vmstate.h"
+#include "include/hw/audio/screamer.h"
+
+#define DEBUG_SCREAMER 0
+#define DPRINTF(fmt, ...) \
+do { if (DEBUG_SCREAMER) { printf(fmt , ## __VA_ARGS__); } } while (0)
+
+#define SOUND_CONTROL_REG  0
+#define CODEC_CONTROL_REG  1
+#define CODEC_STATUS_REG   2
+#define CLIP_COUNT_REG     3
+#define BYTE_SWAP_REG      4
+#define FRAME_COUNT_REG    5
+
+#define AWACS_BUSY         0x01000000
+
+/* Used with AWACS register 1 */
+#define RECALIBRATE         0x004
+#define LOOPTHRU            0x040
+#define SPEAKER_MUTE        0x080
+#define HEADPHONE_MUTE      0x200
+#define OUTPUT_ZERO         0x400
+#define OUTPUT_ONE          0x800
+#define PARALLEL_OUTPUT     0xc00
+
+/* Function prototypes */
+static uint32_t set_busy_bit(uint32_t value, int bit);
+static uint32_t set_part_ready_bit(uint32_t value, int bit_value);
+static uint32_t set_revision(uint32_t input_value);
+static uint32_t set_manufacturer(uint32_t input_value);
+static int get_sampling_rate(ScreamerState *s);
+static uint32_t get_frame_count_reg(ScreamerState *s);
+static void add_to_speaker_buffer(DBDMA_io *io);
+static void dma_request(DBDMA_io *io);
+
+
+/**************************** Getters *************************/
+
+/* Returns the codec control register's encoded AWACS address */
+static uint8_t get_codec_control_address(uint32_t value)
+{
+    uint8_t return_value;
+    return_value = (value >> 12) & 0x00000fff;
+    return return_value;
+}
+
+
+static uint32_t get_sound_control_reg(ScreamerState *s)
+{
+    DPRINTF("%s() called - returned 0x%x\n", __func__, s->sound_control);
+    return s->sound_control;
+}
+
+/* The AWACS registers are accessed thru this register */
+static uint32_t get_codec_control_reg(ScreamerState *s)
+{
+    int awacs_register = get_codec_control_address(s->codec_control);
+    uint32_t return_value = s->awacs[awacs_register];
+    return_value = set_busy_bit(return_value, 0); /* Tell CPU we are ready */
+    DPRINTF("%s() called - returned 0x%x\tAWACS register: %d\n", __func__,
+            return_value, awacs_register);
+    return return_value;
+}
+
+/*
+ * Determines if the readback bit is set.
+ * It is used by the Codec Control register.
+ */
+static bool readback_enabled(ScreamerState *s)
+{
+/* Note: bit zero is the readback enabled bit */
+    if (s->awacs[7] & 1) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static uint32_t get_codec_status_reg(ScreamerState *s)
+{
+    uint32_t return_value;
+
+    /* if in readback mode - return AWACS register value */
+    if (readback_enabled(s)) {
+        int awacs_register = (s->awacs[7] & 0xe) >> 1;
+        s->awacs[7] = s->awacs[7] & 0xfffffffe; /* turn off readback mode */
+        return_value = s->awacs[awacs_register] << 4;
+        DPRINTF("readback enable bit is set, returning AWACS register %d\t"
+                "value:0x%x\n", awacs_register, return_value);
+
+        return return_value;
+    }
+
+    /* Tell CPU we are ready */
+    return_value = set_part_ready_bit(s->codec_status, 1);
+
+    /* Set Revision to Screamer */
+    return_value = set_revision(return_value);
+
+    /* Set the Manufacturer to Crystal */
+    return_value = set_manufacturer(return_value);
+    DPRINTF("%s() called - returned 0x%x\n", __func__, return_value);
+
+    return return_value;
+}
+
+static uint32_t get_clip_count_reg(ScreamerState *s)
+{
+    DPRINTF("%s() called - returned 0x%x\n", __func__, s->clip_count);
+    uint32_t return_value;
+    return_value = s->clip_count;
+    /* This is reset everytime it is read */
+    s->clip_count = 0;
+    return return_value;
+}
+
+static uint32_t get_byte_swap_reg(ScreamerState *s)
+{
+    DPRINTF("%s() called - returned 0x%x\n", __func__, s->byte_swap);
+    /*
+     * If all you hear is noise, it could be this register reporting the
+     * wrong value.
+     */
+    return s->byte_swap ? 0 : 1;
+}
+
+/*
+ * Returns the frame (sample) count
+ */
+static uint32_t get_frame_count_reg(ScreamerState *s)
+{
+    DPRINTF("%s() called - returned 0x%x\n", __func__, s->frame_count);
+    return s->frame_count;
+}
+
+static uint8_t get_left_vol(uint32_t value)
+{
+    return value & 0xf;
+}
+
+static uint8_t get_right_vol(uint32_t value)
+{
+    return value & 0x3c0 >> 6;
+}
+
+/*
+ * Returns the sampling rate.
+ * If the audio is playing back too fast or too slow, this function may be the
+ * cause.
+ */
+static int get_sampling_rate(ScreamerState *s)
+{
+    uint32_t screamer_rate = s->sound_control & 0x700;
+    int return_value;
+
+    /* All return values are in Hertz */
+    switch (screamer_rate) {
+    case 0x0:
+        return_value = 44100;
+        break;
+    case 0x100:
+        return_value = 29400;
+        break;
+    case 0x200:
+        return_value = 22050;
+        break;
+    case 0x300:
+        return_value = 17640;
+        break;
+    case 0x400:
+        return_value = 14700;
+        break;
+    case 0x500:
+        return_value = 11025;
+        break;
+    case 0x600:
+        return_value = 8820;
+        break;
+    case 0x700:
+        return_value = 7350;
+        break;
+    default:
+        DPRINTF("get_sampling_rate() unknown value: 0x%x\nDefaulting to"
+                " 44100 Hz.\n", screamer_rate);
+        return 44100;
+}
+    DPRINTF("%s() called - returning %dHz\n", __func__, return_value);
+    return return_value;
+}
+
+/**************************** End of getters *************************/
+
+/***************************** Speaker call back *************************/
+
+/* resets the play and buffer position markers */
+static void reset_markers(ScreamerState *s)
+{
+    s->spk_play_position = 0;
+    s->spk_buffer_position = 0;
+}
+
+
+/* Sends the samples to the host for playing */
+static void send_samples_to_host(ScreamerState *s, int max_samples)
+{
+    int write_length, requested_length;
+    requested_length = MIN(max_samples, (s->spk_buffer_position -
+                                         s->spk_play_position));
+    write_length = AUD_write(s->speaker_voice,
+                             &s->spk_buffer[s->spk_play_position],
+                             requested_length);
+    DPRINTF("requested length: %d\twrite length: %d\t",
+            requested_length, write_length);
+    s->spk_play_position += write_length;
+    DPRINTF("AUD_write %d/%d\n", s->spk_play_position, s->spk_buffer_position);
+    s->frame_count += write_length;
+}
+
+
+/*
+ * Called by QEMU's audio system to tell the output backend to send samples
+ * from the buffer to the host sound system.
+ * opaque: a pointer to the ScreamerState instance.
+ * max_samples: the number of samples that can be sent to the hardware buffer.
+ */
+static void speaker_callback(void *opaque, int max_samples)
+{
+    ScreamerState *s = (ScreamerState *) opaque;
+
+    /* if we have more samples to play */
+    if (s->spk_buffer_position > 0) {
+        if (s->spk_buffer_position > s->spk_play_position) {
+            DPRINTF("%s() called - max_samples: %d\n", __func__, max_samples);
+            send_samples_to_host(s, max_samples);
+        }
+        if (s->spk_play_position >= s->spk_buffer_position) {
+            DPRINTF("done playing buffer\n");
+            DPRINTF("pp: %d\tbp: %d\n", s->spk_play_position,
+                    s->spk_buffer_position);
+            if (s->spk_play_position > s->spk_buffer_position) {
+                DPRINTF("Error detected! - pp > bp\n\a");
+            }
+            reset_markers(s);
+            /* play postponed samples */
+            if (s->dma_io.len > 0) {
+                DPRINTF("playing postponed samples\n");
+                add_to_speaker_buffer(&s->dma_io);
+                return;
+            }
+        }
+    }
+}
+
+/************************* End of speaker call back *************************/
+
+
+/* Opens the speaker's voice */
+static void open_speaker_voice(ScreamerState *s)
+{
+    DPRINTF("%s() called\n", __func__);
+
+    /* if voice is already open return from function */
+    if (s->speaker_voice != NULL) {
+        DPRINTF("closing speaker voice\n");
+        AUD_close_out(&s->card, s->speaker_voice);
+        s->speaker_voice = NULL;
+    }
+    struct audsettings audio_settings;
+    audio_settings.freq = get_sampling_rate(s);  /* in hertz */
+    audio_settings.nchannels = 2;                /* stereo output */
+    audio_settings.fmt = AUDIO_FORMAT_S16;       /* signed 16 bit */
+    audio_settings.endianness = get_byte_swap_reg(s); /* endianness */
+    s->speaker_voice = AUD_open_out(&s->card, s->speaker_voice, SOUND_CHIP_NAME
+                                    " speaker", s, speaker_callback,
+                                    &audio_settings);
+    if (!s->speaker_voice) {
+        AUD_log(SOUND_CHIP_NAME, "Out voice could not be opened\n");
+    } else {
+        AUD_set_active_out(s->speaker_voice, true);
+    }
+}
+
+
+/******************************* Setters *************************************/
+
+
+/* Updates QEMU's audio backend settings */
+static void set_QEMU_audio_settings(ScreamerState *s)
+{
+    DPRINTF("%s() called\n", __func__);
+    open_speaker_voice(s);
+}
+
+
+/* Return value: 1 = muted  0 = not muted */
+static int is_muted(ScreamerState *s)
+{
+    int mute_state = s->awacs[1] & SPEAKER_MUTE ? 1 : 0;
+    if (s->awacs[1] & SPEAKER_MUTE) {
+        DPRINTF("speaker is muted\n");
+    } else {
+        DPRINTF("speaker is unmuted\n");
+    }
+
+    if (s->awacs[1] & HEADPHONE_MUTE) {
+        DPRINTF("headphone is muted\n");
+    } else {
+        DPRINTF("headphone is unmuted\n");
+    }
+    return mute_state;
+}
+
+
+/* Converts Screamer's volume system to QEMU's system */
+static int screamer_to_qemu_volume(int x)
+{
+    return -16 * x + 240;
+}
+
+
+/* Sets QEMU's volume. */
+static void set_volume(ScreamerState *s)
+{
+    int should_mute = is_muted(s);
+
+    /* Get Screamer volume values */
+    uint8_t left_vol = get_left_vol(s->awacs[4]);
+    uint8_t right_vol = get_right_vol(s->awacs[4]);
+    DPRINTF("set_volume() called - M:%d\tL:%d\tR:%d\n", should_mute, left_vol,
+            right_vol);
+
+    /* Convert Screamer to QEMU volume values */
+    left_vol = screamer_to_qemu_volume(left_vol);
+    right_vol = screamer_to_qemu_volume(right_vol);
+    DPRINTF("QEMU volume: L:%d\tR:%d\n", left_vol, right_vol);
+    AUD_set_volume_out(s->speaker_voice, should_mute, left_vol, right_vol);
+}
+
+
+/* Sets the sound control register */
+static void set_sound_control_reg(ScreamerState *s, uint32_t value)
+{
+    DPRINTF("set_sound_control_reg() called - value: 0x%x\n", value);
+    s->sound_control = value;
+    set_QEMU_audio_settings(s);
+}
+
+
+/* Used for input gain only - can be ignored for now. */
+static void set_awacs_0_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 0 to 0x%x\n", s->awacs[0]);
+    s->awacs[0] = new_value;
+}
+
+
+static void set_awacs_1_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 1 to 0x%x\n", new_value);
+
+    s->awacs[1] = new_value;
+
+    /* If recalibration requested */
+    if (new_value & RECALIBRATE) {
+        DPRINTF("Recalibration requested - unimplemented\n");
+        new_value = new_value ^ RECALIBRATE; /* Turn off recalibrate bit */
+    }
+
+    /* If loop thru set - what does this mean? */
+    if (new_value & LOOPTHRU) {
+        DPRINTF("Loopthru enabled - doing nothing\n");
+    }
+
+    /* Set headphone jack mute state */
+    if (new_value & HEADPHONE_MUTE) {
+        DPRINTF("Headphone muted\n");
+    }
+
+    else {
+        DPRINTF("Headphone unmuted\n");
+    }
+
+    if (new_value & SPEAKER_MUTE) {
+        DPRINTF("Speaker muted\n");
+    }
+
+    else {
+        DPRINTF("Speaker unmuted\n");
+    }
+
+    if (new_value & OUTPUT_ZERO) {
+        DPRINTF("output zero set - not sure what this means\n");
+    }
+
+    if (new_value & OUTPUT_ONE) {
+        DPRINTF("output one set - not sure what this means\n");
+    }
+
+    if (new_value & PARALLEL_OUTPUT) {
+        DPRINTF("parallel port enabled - but no parallel port here\n");
+    }
+
+    set_volume(s);
+}
+
+
+/* This is used for headphone volume - not needed */
+static void set_awacs_2_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 2 to 0x%x\n"
+            "Ignoring change in headphone volume.\n", s->awacs[2]);
+    s->awacs[2] = new_value;
+}
+
+
+/* Unknown register purpose */
+static void set_awacs_3_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 3 to 0x%x\n"
+            "This register has an unknown purpose and does not do anything\n",
+            s->awacs[3]);
+    s->awacs[3] = new_value;
+}
+
+
+/* Mostly deals with speaker volume */
+static void set_awacs_4_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("AWACS register 4 write: 0x%x\n", new_value);
+    s->awacs[4] = new_value;
+    set_volume(s);
+}
+
+
+/* This register is about loop thru stuff I don't understand */
+static void set_awacs_5_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 5 to 0x%x\n"
+            "Loop thru update ignored.\n", s->awacs[5]);
+    s->awacs[5] = new_value;
+}
+
+
+/* Prints the states of the AWACS power register */
+static void print_power_reg_values(uint32_t value)
+{
+    if ((value & 0x3) == 0) {
+        printf("Screamer run state set\n");
+    }
+    if ((value & 0x3) == 1) {
+        printf("Screamer doze state set\n");
+    }
+    if ((value & 0x3) == 2) {
+        printf("Screamer idle state set\n");
+    }
+}
+
+
+/* Power Magement register */
+static void set_awacs_6_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 6 to 0x%x\n"
+            "Power management update ignored.\n", s->awacs[6]);
+    if (DEBUG_SCREAMER) {
+        print_power_reg_values(new_value);
+    }
+    s->awacs[6] = new_value;
+}
+
+
+/* Read Back - repeating something that was sent to this chip? */
+static void set_awacs_7_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 7 to 0x%x\n", new_value);
+    s->awacs[7] = new_value;
+}
+
+
+/* Sets the AWACs registers - a.k.a. shadow registers */
+static void set_awacs_register(ScreamerState *s, uint32_t value)
+{
+    int the_register = get_codec_control_address(value);
+
+    switch (the_register) {
+    case 0:
+        set_awacs_0_reg(s, value);
+        break;
+    case 1:
+        set_awacs_1_reg(s, value);
+        break;
+    case 2:
+        set_awacs_2_reg(s, value);
+        break;
+    case 3:
+        set_awacs_3_reg(s, value);
+        break;
+    case 4:
+        set_awacs_4_reg(s, value);
+        break;
+    case 5:
+        set_awacs_5_reg(s, value);
+        break;
+    case 6:
+        set_awacs_6_reg(s, value);
+        break;
+    case 7:
+        set_awacs_7_reg(s, value);
+        break;
+    default:
+        DPRINTF("Unhandled awacs registers %d\n", the_register);
+    }
+}
+
+
+/* Used to set the AWACS registers */
+static void set_codec_control_reg(ScreamerState *s, uint32_t value)
+{
+    DPRINTF("set_codec_control_reg() called - value: 0x%x\n", value);
+    s->codec_control = value;
+    set_awacs_register(s, value);
+}
+
+static void set_codec_status_reg(ScreamerState *s, uint32_t value)
+{
+    DPRINTF("set_codec_status_reg() called - value: 0x%x\n", value);
+    s->codec_status = value;
+}
+
+static void set_clip_count_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("set_clip_count_reg() called - value: 0x%x\n", new_value);
+    s->clip_count = new_value;
+}
+
+static void set_byte_swap_reg(ScreamerState *s, uint32_t value)
+{
+    DPRINTF("set_byte_swap_reg() called - value: 0x%x\n", value);
+    s->byte_swap = value;
+}
+
+static void set_frame_count_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("%s() called - value: 0x%x\n", __func__, new_value);
+    s->frame_count = new_value;
+}
+
+/*
+ * Sets the busy bit of codec control register.
+ * It is used to tell the CPU to wait.
+ * value: the codec control register's value
+ * bit_value: used to set or disable the busy bit
+ */
+static uint32_t set_busy_bit(uint32_t value, int bit_value)
+{
+    const int busy_bit = 0x01000000;
+    uint32_t return_value;
+    if (bit_value == 1)  /* Set this bit */
+        return_value = (value | busy_bit);
+    else /* bit_value == 0  Disable this bit */
+        return_value = (value & ~busy_bit);
+    return return_value;
+}
+
+
+/*
+ * Sets the part ready bit of the codec status register
+ * value: the codec status register's value
+ * bit_value: used to set or disable the part ready bit
+ */
+static uint32_t set_part_ready_bit(uint32_t value, int bit_value)
+{
+    const int part_ready_bit = 0x00400000;
+    uint32_t return_value;
+    if (bit_value == 1)  /* Set this bit */
+        return_value = (value | part_ready_bit);
+    else /* bit_value == 0  Disable this bit */
+        return_value = (value & ~part_ready_bit);
+    return return_value;
+}
+
+/* Sets bits 12 and 13 to 1 to indicate the Screamer revision */
+static uint32_t set_revision(uint32_t input_value)
+{
+    uint32_t return_value;
+    return_value = input_value | 0x3000;
+    return return_value;
+}
+
+/* Sets bit 8 to indicate Crystal as the manufacturer */
+static uint32_t set_manufacturer(uint32_t input_value)
+{
+    uint32_t return_value;
+    return_value = input_value | 0x100;
+    return return_value;
+}
+
+
+/************************** End of Setters *********************************/
+
+
+/*************************** DMA functions *********************************/
+
+/*
+ * Sends audio samples from a microphone or line-in to memory.
+ * Used for sound input.
+ * Currently only prevents a deadlock condition with Mac OS 9.
+ */
+static void screamer_to_dma(DBDMA_io *io)
+{
+    DPRINTF("%s() called\n", __func__);
+    ScreamerState *s = (ScreamerState *)io->opaque;
+    DBDMAState *dbs = s->dbdma;
+    DBDMA_channel *ch = &dbs->channels[0x12];
+    ch->regs[DBDMA_STATUS] |= DEAD;
+    ch->regs[DBDMA_STATUS] &= ~ACTIVE;
+    io->dma_end(io);
+    return;
+}
+
+
+static void print_dma_info(DBDMA_io *io)
+{
+    #define RUN        0x8000
+    #define PAUSE      0x4000
+    #define FLUSH      0x2000
+    #define WAKE       0x1000
+    #define DEAD       0x0800
+    #define ACTIVE     0x0400
+    #define BT         0x0100
+    #define DEVSTAT    0x00ff
+
+    /*
+     * RUN and PAUSE are bits under software control only.
+     * FLUSH and WAKE are set by SW and cleared by hardware.
+     * DEAD, ACTIVE and BT are only under hardware control.
+     */
+
+    DBDMA_channel *ch = io->channel;
+    printf("DMA FLAGS: ");
+
+    if (ch->regs[DBDMA_STATUS] & RUN) {
+        printf("RUN ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & ACTIVE) {
+        printf("ACTIVE ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & PAUSE) {
+        printf("PAUSE ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & DEAD) {
+        printf("DEAD ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & WAKE) {
+        printf("WAKE ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & BT) {
+        printf("BT ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & DEVSTAT) {
+        printf("DEVSTAT ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & FLUSH) {
+        printf("FLUSH ");
+    }
+
+    if (ch->io.processing == true) {
+        printf("processing  ");
+    }
+
+    printf("\n");
+}
+
+/* Tell the DMA controller we request more samples */
+static void dma_request(DBDMA_io *io)
+{
+    DPRINTF("%s() called\n", __func__);
+    if (DEBUG_SCREAMER) {
+        print_dma_info(io);
+    }
+    io->len = 0;
+    io->dma_end(io);
+}
+
+
+/* Adds sample data to the buffer */
+static void add_to_speaker_buffer(DBDMA_io *io)
+{
+    ScreamerState *s = (ScreamerState *) io->opaque;
+
+    if (s->spk_buffer_position + io->len > MAX_BUFFER_SIZE) {
+        /* postpone calling these samples until the buffer has been emptied */
+        memcpy(&s->dma_io, io, sizeof(DBDMA_io));
+        return;
+    }
+    dma_memory_read(&address_space_memory, io->addr,
+                    &s->spk_buffer[s->spk_buffer_position], io->len);
+    s->spk_buffer_position += io->len;
+    DPRINTF("%s() called - len: %d pos: %d/%d\n", __func__, io->len,
+            s->spk_buffer_position, MAX_BUFFER_SIZE);
+
+    dma_request(io);
+}
+
+/*
+ * Called by the DMA chip to transfer samples from memory to the
+ * Screamer chip.
+ * Used for sound output.
+ */
+static void dma_to_screamer(DBDMA_io *io)
+{
+    add_to_speaker_buffer(io);
+}
+
+
+/*
+ * This will flush the audio buffer of previous audio - eliminating previous
+ * audio playback.
+ */
+static void send_silence_to_speaker(ScreamerState *s)
+{
+    DPRINTF("Silencing audio buffer...\n");
+    int length = MAX_BUFFER_SIZE;
+    s->spk_buffer_position = length;
+    s->spk_play_position = 0;
+    memset(s->spk_buffer, 0, length);
+    s->dma_io.len = 0; /* stop any postponed samples from playing */
+}
+
+
+/* This is called after audio stops playing */
+static void dma_send_flush(DBDMA_io *io)
+{
+    DPRINTF("dma_send_flush() called\n");
+    if (DEBUG_SCREAMER) {
+        print_dma_info(io);
+    }
+    ScreamerState *s = (ScreamerState *)io->opaque;
+    reset_markers(s);
+    send_silence_to_speaker(s);
+    if (io->len > 0) {
+        dma_request(io);
+    }
+}
+
+
+static void dma_receive_flush(DBDMA_io *io)
+{
+    DPRINTF("dma_receive_flush() called\n");
+}
+
+
+/* Set the functions the DMA system will call */
+void screamer_register_dma_functions(ScreamerState *s, void *dbdma,
+                                   int send_channel, int receive_channel)
+{
+    DPRINTF("%s() called\n", __func__);
+    DPRINTF("send channel: %d\treceive channel: %d\n", send_channel,
+           receive_channel);
+    s->dbdma = dbdma;
+
+    /* Setup the DMA send system */
+    DBDMA_register_channel(s->dbdma, send_channel, s->dma_send_irq,
+                           dma_to_screamer, dma_send_flush, s);
+
+    /* Setup the DMA receive system */
+    DBDMA_register_channel(s->dbdma, receive_channel, s->dma_receive_irq,
+                           screamer_to_dma, dma_receive_flush, s);
+}
+
+/************************* End of DMA functions **************************/
+
+/* Resets this sound chip */
+static void screamer_reset(DeviceState *d)
+{
+    DPRINTF("screamer_reset() called\n");
+    ScreamerState *s = SCREAMER(d);
+    set_sound_control_reg(s, 0);
+    set_codec_control_reg(s, 0);
+    set_codec_status_reg(s, 0);
+    set_clip_count_reg(s, 0);
+    set_byte_swap_reg(s, 0);
+    set_frame_count_reg(s, 0);
+    int i, num_awacs_regs = 8;
+    for (i = 0; i < num_awacs_regs; i++) {
+        s->awacs[i] = 0;
+    }
+    set_QEMU_audio_settings(s);
+    reset_markers(s);
+    s->dma_io.len = 0;
+}
+
+/* Called when the CPU reads the memory addresses assigned to Screamer */
+static uint64_t screamer_mmio_read(void *opaque, hwaddr addr, unsigned size)
+{
+    ScreamerState *state = opaque;
+    uint32_t return_value;
+
+    addr = addr >> 4;
+    switch (addr) {
+    case SOUND_CONTROL_REG:
+        return_value = get_sound_control_reg(state);
+        break;
+    case CODEC_CONTROL_REG:
+        return_value = get_codec_control_reg(state);
+        break;
+    case CODEC_STATUS_REG:
+        return_value = get_codec_status_reg(state);
+        break;
+    case CLIP_COUNT_REG:
+        return_value = get_clip_count_reg(state);
+        break;
+    case BYTE_SWAP_REG:
+        return_value = get_byte_swap_reg(state);
+        break;
+    case FRAME_COUNT_REG:
+        return_value = get_frame_count_reg(state);
+        break;
+    default:
+        DPRINTF("Unknown register read - addr:%" HWADDR_PRIx "\tsize:%d\n",
+                addr, size);
+        return_value = 12021981; /* Value used for debugging purposes */
+    }
+    DPRINTF("screamer_mmio_read() called addr: %" HWADDR_PRIx "  size: %d",
+            addr >> 4, size);
+    DPRINTF("  returning 0x%x\n", return_value);
+    return return_value;
+}
+
+
+/* Called when the CPU writes to the memory addresses assigned to Screamer */
+static void screamer_mmio_write(void *opaque, hwaddr addr, uint64_t raw_value,
+                                unsigned size)
+{
+    DPRINTF("screamer_mmio_write() called - size: %d\n", size);
+    ScreamerState *state = opaque;
+    uint32_t value = raw_value & 0xffffffff;
+    addr = addr >> 4;
+
+    switch (addr) {
+    case SOUND_CONTROL_REG:
+        set_sound_control_reg(state, value);
+        break;
+    case CODEC_CONTROL_REG:
+        set_codec_control_reg(state, value);
+        break;
+    case CODEC_STATUS_REG:
+        set_codec_status_reg(state, value);
+        break;
+    case CLIP_COUNT_REG:
+        set_clip_count_reg(state, value);
+        break;
+    case BYTE_SWAP_REG:
+        set_byte_swap_reg(state, value);
+        break;
+    case FRAME_COUNT_REG:
+        set_frame_count_reg(state, value);
+        break;
+    default:
+        DPRINTF("Unknown register write - addr:%" HWADDR_PRIx "\tvalue:%d\n",
+                addr, value);
+    }
+}
+
+/* Used for memory_region_init_io() for memory mapped I/O */
+static const MemoryRegionOps screamer_ops = {
+    .read = screamer_mmio_read,
+    .write = screamer_mmio_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .valid = {
+        .min_access_size = 4,
+        .max_access_size = 4
+    }
+};
+
+/* Called when the device has become active */
+static void screamer_realize(DeviceState *dev, Error **errp)
+{
+    DPRINTF("screamer_realize() called\n");
+    screamer_reset(dev);
+}
+
+
+/*
+ * Called when an instance of the Screamer device is created.
+ * Also called when this HMP command is called: device_add screamer
+ */
+static void screamer_init(Object *obj)
+{
+    DPRINTF("screamer_init() called\n");
+
+    ScreamerState *s = (ScreamerState *)obj;
+    SysBusDevice *d = SYS_BUS_DEVICE(obj);
+    const int region_size = 5 * 32;
+
+    /* Makes the read and write ops work */
+    memory_region_init_io(&s->io_memory_region, OBJECT(s),
+                          &screamer_ops, s, SOUND_CHIP_NAME, region_size);
+
+    /* Sets the SysBusDevice's memory property */
+    sysbus_init_mmio(d, &s->io_memory_region);
+
+    /* Setup all the interrupt requests */
+    sysbus_init_irq(d, &s->irq);
+    sysbus_init_irq(d, &s->dma_send_irq);
+    sysbus_init_irq(d, &s->dma_receive_irq);
+
+    /* Registers Screamer with QEMU's audio system */
+    AUD_register_card(SOUND_CHIP_NAME, &s->card);
+}
+
+
+/*
+ * When saving and restoring the state of the VM, this is used to save and
+ * restore the registers.
+ */
+static const VMStateDescription vmstate_screamer = {
+    .name = "Screamer",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT16_ARRAY(awacs, ScreamerState, 8), /* 8 AWACS registers */
+        VMSTATE_UINT32(sound_control, ScreamerState),
+        VMSTATE_UINT32(codec_control, ScreamerState),
+        VMSTATE_UINT32(codec_status, ScreamerState),
+        VMSTATE_UINT32(clip_count, ScreamerState),
+        VMSTATE_UINT32(byte_swap, ScreamerState),
+        VMSTATE_UINT32(frame_count, ScreamerState),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+
+/*
+ * Sets the class data. It is like polymorphism and inheritance in object
+ * oriented languages.
+ */
+static void screamer_class_init(ObjectClass *class, void *data)
+{
+    DPRINTF("screamer_class_init() called\n");
+    DeviceClass *dc = DEVICE_CLASS(class);
+    dc->realize = screamer_realize;
+    dc->reset = screamer_reset;
+    dc->desc = "Apple Screamer";
+    dc->vmsd = &vmstate_screamer;
+    dc->hotpluggable = false;
+}
+
+/* Used for QOM function registration */
+static const TypeInfo screamer_info = {
+    .name          = "screamer",
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(ScreamerState),
+    .instance_init = screamer_init,
+    .class_init    = screamer_class_init,
+};
+
+/* QOM registration of above functions for calling */
+static void screamer_register_types(void)
+{
+    DPRINTF("screamer_register_types() called\n");
+    type_register_static(&screamer_info);
+}
+
+/* QEMU Object Model (QOM) stuff */
+type_init(screamer_register_types)
diff --git a/hw/misc/macio/macio.c b/hw/misc/macio/macio.c
index e6eeb575d53c..e74c4bb31903 100644
--- a/hw/misc/macio/macio.c
+++ b/hw/misc/macio/macio.c
@@ -37,6 +37,7 @@
 #include "hw/intc/heathrow_pic.h"
 #include "sysemu/sysemu.h"
 #include "trace.h"
+#include "include/hw/audio/screamer.h"
 
 /* Note: this code is strongly inspirated from the corresponding code
  * in PearPC */
@@ -105,6 +106,17 @@ static void macio_common_realize(PCIDevice *d, Error **errp)
     sysbus_dev = SYS_BUS_DEVICE(&s->dbdma);
     memory_region_add_subregion(&s->bar, 0x08000,
                                 sysbus_mmio_get_region(sysbus_dev, 0));
+    if (!qdev_realize(DEVICE(&s->screamer), BUS(&s->macio_bus), errp)) {
+        return;
+    }
+
+    /* Add the screamer sound chip */
+    sysbus_dev = SYS_BUS_DEVICE(&s->screamer);
+    const int offset = 0x14000; /* Offset from base address register (bar) */
+    const int region_number = 0; /* which memory region to use */
+    memory_region_add_subregion(&s->bar, offset,
+                                sysbus_mmio_get_region(sysbus_dev,
+                                                       region_number));
 
     qdev_prop_set_uint32(DEVICE(&s->escc), "disabled", 0);
     qdev_prop_set_uint32(DEVICE(&s->escc), "frequency", ESCC_CLOCK);
@@ -365,6 +377,19 @@ static void macio_newworld_realize(PCIDevice *d, Error **errp)
         memory_region_add_subregion(&s->bar, 0x16000,
                                     sysbus_mmio_get_region(sysbus_dev, 0));
     }
+
+    /* Screamer Sound Chip */
+    const int gpio_0 = 0;
+    const int gpio_1 = 1;
+    const int transmit_channel = 0x10;
+    const int receive_channel = 0x12;
+    sysbus_dev = SYS_BUS_DEVICE(&s->screamer);
+    sysbus_connect_irq(sysbus_dev, gpio_0, qdev_get_gpio_in(pic_dev,
+                                           NEWWORLD_SCREAMER_IRQ));
+    sysbus_connect_irq(sysbus_dev, gpio_1, qdev_get_gpio_in(pic_dev,
+                                           NEWWORLD_SCREAMER_DMA_IRQ));
+    screamer_register_dma_functions(SCREAMER(sysbus_dev), &s->dbdma,
+                                    transmit_channel, receive_channel);
 }
 
 static void macio_newworld_init(Object *obj)
@@ -394,6 +419,9 @@ static void macio_instance_init(Object *obj)
     object_initialize_child(OBJECT(s), "dbdma", &s->dbdma, TYPE_MAC_DBDMA);
 
     object_initialize_child(OBJECT(s), "escc", &s->escc, TYPE_ESCC);
+
+    object_initialize_child(OBJECT(s), SOUND_CHIP_NAME, &s->screamer,
+                            TYPE_SCREAMER);
 }
 
 static const VMStateDescription vmstate_macio_oldworld = {
diff --git a/hw/ppc/Kconfig b/hw/ppc/Kconfig
index d11dc30509df..65080e0ac3e0 100644
--- a/hw/ppc/Kconfig
+++ b/hw/ppc/Kconfig
@@ -106,6 +106,7 @@ config MAC_NEWWORLD
     select MAC_PMU
     select UNIN_PCI
     select FW_CFG_PPC
+    select SCREAMER
 
 config E500
     bool
diff --git a/hw/ppc/mac.h b/hw/ppc/mac.h
index 22c8408078d2..df623d66ced2 100644
--- a/hw/ppc/mac.h
+++ b/hw/ppc/mac.h
@@ -35,6 +35,8 @@
 #include "hw/pci/pci_host.h"
 #include "hw/pci-host/uninorth.h"
 #include "qom/object.h"
+#include "hw/ppc/mac_dbdma.h"
+#include "audio/audio.h"
 
 /* SMP is not enabled, for now */
 #define MAX_CPUS 1
@@ -67,6 +69,9 @@
 #define NEWWORLD_IDE1_DMA_IRQ  0x3
 #define NEWWORLD_EXTING_GPIO1  0x2f
 #define NEWWORLD_EXTING_GPIO9  0x37
+#define NEWWORLD_SCREAMER_IRQ  0x18
+#define NEWWORLD_SCREAMER_DMA_IRQ 0x9
+#define NEWWORLD_SCREAMER_RX_IRQ 0xa
 
 /* Core99 machine */
 #define TYPE_CORE99_MACHINE MACHINE_TYPE_NAME("mac99")
diff --git a/include/hw/audio/screamer.h b/include/hw/audio/screamer.h
new file mode 100644
index 000000000000..7155541688ba
--- /dev/null
+++ b/include/hw/audio/screamer.h
@@ -0,0 +1,42 @@
+/*
+ * File: screamer.h
+ * Description: header file to the hw/audio/screamer.c file
+ */
+
+#ifndef screamer_h
+#define screamer_h
+
+#include <inttypes.h>
+#include "audio/audio.h"
+#include "hw/ppc/mac_dbdma.h"
+
+#define TYPE_SCREAMER "screamer"
+#define SCREAMER(obj) OBJECT_CHECK(ScreamerState, (obj), TYPE_SCREAMER)
+#define SOUND_CHIP_NAME "Screamer Sound Chip"
+#define MAX_BUFFER_SIZE (128 * 64)
+
+typedef struct ScreamerState {
+    SysBusDevice parent_obj;
+    uint16_t awacs[8]; /* Shadow/awacs registers */
+    uint32_t sound_control;
+    uint32_t codec_control;
+    uint32_t codec_status;
+    uint32_t clip_count;
+    uint32_t byte_swap;
+    uint32_t frame_count;
+    SWVoiceOut *speaker_voice;
+    DBDMAState *dbdma;
+    qemu_irq dma_send_irq;
+    qemu_irq dma_receive_irq;
+    qemu_irq irq;
+    QEMUSoundCard card;
+    MemoryRegion io_memory_region;
+    uint8_t spk_buffer[MAX_BUFFER_SIZE];
+    uint16_t spk_buffer_position, spk_play_position;
+    DBDMA_io dma_io;
+} ScreamerState;
+
+void screamer_register_dma_functions(ScreamerState *s, void *dbdma,
+                                     int send_channel, int receive_channel);
+
+#endif /* screamer_h */
diff --git a/include/hw/misc/macio/macio.h b/include/hw/misc/macio/macio.h
index 6c05f3bfd222..3eb92d0f62fa 100644
--- a/include/hw/misc/macio/macio.h
+++ b/include/hw/misc/macio/macio.h
@@ -36,6 +36,7 @@
 #include "hw/ppc/mac.h"
 #include "hw/ppc/mac_dbdma.h"
 #include "hw/ppc/openpic.h"
+#include "hw/audio/screamer.h"
 #include "qom/object.h"
 
 /* MacIO virtual bus */
@@ -88,6 +89,7 @@ struct MacIOState {
     PMUState pmu;
     DBDMAState dbdma;
     ESCCState escc;
+    ScreamerState screamer;
     uint64_t frequency;
 };
 

From cf664b3a04a8206cda72d4cd7a7e0ece460c11e9 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:35 +0200
Subject: [PATCH 069/180] hvf: Move assert_hvf_ok() into common directory

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch moves assert_hvf_ok() and introduces generic build infrastructure.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-2-agraf@csgraf.de>
---
 MAINTAINERS              |  8 +++++++
 accel/hvf/hvf-all.c      | 47 ++++++++++++++++++++++++++++++++++++++++
 accel/hvf/meson.build    |  6 +++++
 accel/meson.build        |  1 +
 include/sysemu/hvf_int.h | 18 +++++++++++++++
 target/i386/hvf/hvf.c    | 33 +---------------------------
 6 files changed, 81 insertions(+), 32 deletions(-)
 create mode 100644 accel/hvf/hvf-all.c
 create mode 100644 accel/hvf/meson.build
 create mode 100644 include/sysemu/hvf_int.h

diff --git a/MAINTAINERS b/MAINTAINERS
index a77f24656946..6c87b683924d 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -437,7 +437,15 @@ M: Roman Bolshakov <r.bolshakov@yadro.com>
 W: https://wiki.qemu.org/Features/HVF
 S: Maintained
 F: target/i386/hvf/
+
+HVF
+M: Cameron Esfahani <dirty@apple.com>
+M: Roman Bolshakov <r.bolshakov@yadro.com>
+W: https://wiki.qemu.org/Features/HVF
+S: Maintained
+F: accel/hvf/
 F: include/sysemu/hvf.h
+F: include/sysemu/hvf_int.h
 
 WHPX CPUs
 M: Sunil Muthuswamy <sunilmut@microsoft.com>
diff --git a/accel/hvf/hvf-all.c b/accel/hvf/hvf-all.c
new file mode 100644
index 000000000000..f185b0830a75
--- /dev/null
+++ b/accel/hvf/hvf-all.c
@@ -0,0 +1,47 @@
+/*
+ * QEMU Hypervisor.framework support
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ * Contributions after 2012-01-13 are licensed under the terms of the
+ * GNU GPL, version 2 or (at your option) any later version.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "qemu/error-report.h"
+#include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
+
+void assert_hvf_ok(hv_return_t ret)
+{
+    if (ret == HV_SUCCESS) {
+        return;
+    }
+
+    switch (ret) {
+    case HV_ERROR:
+        error_report("Error: HV_ERROR");
+        break;
+    case HV_BUSY:
+        error_report("Error: HV_BUSY");
+        break;
+    case HV_BAD_ARGUMENT:
+        error_report("Error: HV_BAD_ARGUMENT");
+        break;
+    case HV_NO_RESOURCES:
+        error_report("Error: HV_NO_RESOURCES");
+        break;
+    case HV_NO_DEVICE:
+        error_report("Error: HV_NO_DEVICE");
+        break;
+    case HV_UNSUPPORTED:
+        error_report("Error: HV_UNSUPPORTED");
+        break;
+    default:
+        error_report("Unknown Error");
+    }
+
+    abort();
+}
diff --git a/accel/hvf/meson.build b/accel/hvf/meson.build
new file mode 100644
index 000000000000..227b11cd717b
--- /dev/null
+++ b/accel/hvf/meson.build
@@ -0,0 +1,6 @@
+hvf_ss = ss.source_set()
+hvf_ss.add(files(
+  'hvf-all.c',
+))
+
+specific_ss.add_all(when: 'CONFIG_HVF', if_true: hvf_ss)
diff --git a/accel/meson.build b/accel/meson.build
index b44ba30c864c..dfd808d2c8e5 100644
--- a/accel/meson.build
+++ b/accel/meson.build
@@ -2,6 +2,7 @@ specific_ss.add(files('accel-common.c'))
 softmmu_ss.add(files('accel-softmmu.c'))
 user_ss.add(files('accel-user.c'))
 
+subdir('hvf')
 subdir('qtest')
 subdir('kvm')
 subdir('tcg')
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
new file mode 100644
index 000000000000..3deb4cfacc4f
--- /dev/null
+++ b/include/sysemu/hvf_int.h
@@ -0,0 +1,18 @@
+/*
+ * QEMU Hypervisor.framework (HVF) support
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+/* header to be included in HVF-specific code */
+
+#ifndef HVF_INT_H
+#define HVF_INT_H
+
+#include <Hypervisor/hv.h>
+
+void assert_hvf_ok(hv_return_t ret);
+
+#endif
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index f044181d061c..32f42f15924d 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -51,6 +51,7 @@
 #include "qemu/error-report.h"
 
 #include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
 #include "sysemu/runstate.h"
 #include "hvf-i386.h"
 #include "vmcs.h"
@@ -76,38 +77,6 @@
 
 HVFState *hvf_state;
 
-static void assert_hvf_ok(hv_return_t ret)
-{
-    if (ret == HV_SUCCESS) {
-        return;
-    }
-
-    switch (ret) {
-    case HV_ERROR:
-        error_report("Error: HV_ERROR");
-        break;
-    case HV_BUSY:
-        error_report("Error: HV_BUSY");
-        break;
-    case HV_BAD_ARGUMENT:
-        error_report("Error: HV_BAD_ARGUMENT");
-        break;
-    case HV_NO_RESOURCES:
-        error_report("Error: HV_NO_RESOURCES");
-        break;
-    case HV_NO_DEVICE:
-        error_report("Error: HV_NO_DEVICE");
-        break;
-    case HV_UNSUPPORTED:
-        error_report("Error: HV_UNSUPPORTED");
-        break;
-    default:
-        error_report("Unknown Error");
-    }
-
-    abort();
-}
-
 /* Memory slots */
 hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
 {

From a13fec6c1729d3005256a5047e72d4281439abbc Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:36 +0200
Subject: [PATCH 070/180] hvf: Move vcpu thread functions into common directory

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch moves the vCPU thread loop over.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-3-agraf@csgraf.de>
---
 {target/i386 => accel}/hvf/hvf-accel-ops.c | 0
 {target/i386 => accel}/hvf/hvf-accel-ops.h | 0
 accel/hvf/meson.build                      | 1 +
 target/i386/hvf/meson.build                | 1 -
 target/i386/hvf/x86hvf.c                   | 2 +-
 5 files changed, 2 insertions(+), 2 deletions(-)
 rename {target/i386 => accel}/hvf/hvf-accel-ops.c (100%)
 rename {target/i386 => accel}/hvf/hvf-accel-ops.h (100%)

diff --git a/target/i386/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
similarity index 100%
rename from target/i386/hvf/hvf-accel-ops.c
rename to accel/hvf/hvf-accel-ops.c
diff --git a/target/i386/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
similarity index 100%
rename from target/i386/hvf/hvf-accel-ops.h
rename to accel/hvf/hvf-accel-ops.h
diff --git a/accel/hvf/meson.build b/accel/hvf/meson.build
index 227b11cd717b..fc52cb78433a 100644
--- a/accel/hvf/meson.build
+++ b/accel/hvf/meson.build
@@ -1,6 +1,7 @@
 hvf_ss = ss.source_set()
 hvf_ss.add(files(
   'hvf-all.c',
+  'hvf-accel-ops.c',
 ))
 
 specific_ss.add_all(when: 'CONFIG_HVF', if_true: hvf_ss)
diff --git a/target/i386/hvf/meson.build b/target/i386/hvf/meson.build
index d253d5fd1020..f6d4c394d3e3 100644
--- a/target/i386/hvf/meson.build
+++ b/target/i386/hvf/meson.build
@@ -1,6 +1,5 @@
 i386_softmmu_ss.add(when: [hvf, 'CONFIG_HVF'], if_true: files(
   'hvf.c',
-  'hvf-accel-ops.c',
   'x86.c',
   'x86_cpuid.c',
   'x86_decode.c',
diff --git a/target/i386/hvf/x86hvf.c b/target/i386/hvf/x86hvf.c
index 0d7533742ebf..2b99f3eaa2d5 100644
--- a/target/i386/hvf/x86hvf.c
+++ b/target/i386/hvf/x86hvf.c
@@ -32,7 +32,7 @@
 #include <Hypervisor/hv.h>
 #include <Hypervisor/hv_vmx.h>
 
-#include "hvf-accel-ops.h"
+#include "accel/hvf/hvf-accel-ops.h"
 
 void hvf_set_segment(struct CPUState *cpu, struct vmx_segment *vmx_seg,
                      SegmentCache *qseg, bool is_tr)

From ffb51175baf55008ebb3e83bad5601140045104b Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:37 +0200
Subject: [PATCH 071/180] hvf: Move cpu functions into common directory

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch moves CPU and memory operations over. While at it, make sure
the code is consumable on non-i386 systems.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-4-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c  | 308 ++++++++++++++++++++++++++++++++++++-
 include/sysemu/hvf_int.h   |   4 +
 target/i386/hvf/hvf-i386.h |   2 -
 target/i386/hvf/hvf.c      | 302 ------------------------------------
 target/i386/hvf/x86hvf.h   |   2 -
 5 files changed, 311 insertions(+), 307 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index cbaad238e0d5..c2136dfbb8c7 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -50,13 +50,319 @@
 #include "qemu/osdep.h"
 #include "qemu/error-report.h"
 #include "qemu/main-loop.h"
+#include "exec/address-spaces.h"
+#include "exec/exec-all.h"
+#include "sysemu/cpus.h"
 #include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
 #include "sysemu/runstate.h"
-#include "target/i386/cpu.h"
 #include "qemu/guest-random.h"
 
 #include "hvf-accel-ops.h"
 
+HVFState *hvf_state;
+
+/* Memory slots */
+
+hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
+{
+    hvf_slot *slot;
+    int x;
+    for (x = 0; x < hvf_state->num_slots; ++x) {
+        slot = &hvf_state->slots[x];
+        if (slot->size && start < (slot->start + slot->size) &&
+            (start + size) > slot->start) {
+            return slot;
+        }
+    }
+    return NULL;
+}
+
+struct mac_slot {
+    int present;
+    uint64_t size;
+    uint64_t gpa_start;
+    uint64_t gva;
+};
+
+struct mac_slot mac_slots[32];
+
+static int do_hvf_set_memory(hvf_slot *slot, hv_memory_flags_t flags)
+{
+    struct mac_slot *macslot;
+    hv_return_t ret;
+
+    macslot = &mac_slots[slot->slot_id];
+
+    if (macslot->present) {
+        if (macslot->size != slot->size) {
+            macslot->present = 0;
+            ret = hv_vm_unmap(macslot->gpa_start, macslot->size);
+            assert_hvf_ok(ret);
+        }
+    }
+
+    if (!slot->size) {
+        return 0;
+    }
+
+    macslot->present = 1;
+    macslot->gpa_start = slot->start;
+    macslot->size = slot->size;
+    ret = hv_vm_map((hv_uvaddr_t)slot->mem, slot->start, slot->size, flags);
+    assert_hvf_ok(ret);
+    return 0;
+}
+
+void hvf_set_phys_mem(MemoryRegionSection *section, bool add)
+{
+    hvf_slot *mem;
+    MemoryRegion *area = section->mr;
+    bool writeable = !area->readonly && !area->rom_device;
+    hv_memory_flags_t flags;
+
+    if (!memory_region_is_ram(area)) {
+        if (writeable) {
+            return;
+        } else if (!memory_region_is_romd(area)) {
+            /*
+             * If the memory device is not in romd_mode, then we actually want
+             * to remove the hvf memory slot so all accesses will trap.
+             */
+             add = false;
+        }
+    }
+
+    mem = hvf_find_overlap_slot(
+            section->offset_within_address_space,
+            int128_get64(section->size));
+
+    if (mem && add) {
+        if (mem->size == int128_get64(section->size) &&
+            mem->start == section->offset_within_address_space &&
+            mem->mem == (memory_region_get_ram_ptr(area) +
+            section->offset_within_region)) {
+            return; /* Same region was attempted to register, go away. */
+        }
+    }
+
+    /* Region needs to be reset. set the size to 0 and remap it. */
+    if (mem) {
+        mem->size = 0;
+        if (do_hvf_set_memory(mem, 0)) {
+            error_report("Failed to reset overlapping slot");
+            abort();
+        }
+    }
+
+    if (!add) {
+        return;
+    }
+
+    if (area->readonly ||
+        (!memory_region_is_ram(area) && memory_region_is_romd(area))) {
+        flags = HV_MEMORY_READ | HV_MEMORY_EXEC;
+    } else {
+        flags = HV_MEMORY_READ | HV_MEMORY_WRITE | HV_MEMORY_EXEC;
+    }
+
+    /* Now make a new slot. */
+    int x;
+
+    for (x = 0; x < hvf_state->num_slots; ++x) {
+        mem = &hvf_state->slots[x];
+        if (!mem->size) {
+            break;
+        }
+    }
+
+    if (x == hvf_state->num_slots) {
+        error_report("No free slots");
+        abort();
+    }
+
+    mem->size = int128_get64(section->size);
+    mem->mem = memory_region_get_ram_ptr(area) + section->offset_within_region;
+    mem->start = section->offset_within_address_space;
+    mem->region = area;
+
+    if (do_hvf_set_memory(mem, flags)) {
+        error_report("Error registering new memory slot");
+        abort();
+    }
+}
+
+static void do_hvf_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
+{
+    if (!cpu->vcpu_dirty) {
+        hvf_get_registers(cpu);
+        cpu->vcpu_dirty = true;
+    }
+}
+
+void hvf_cpu_synchronize_state(CPUState *cpu)
+{
+    if (!cpu->vcpu_dirty) {
+        run_on_cpu(cpu, do_hvf_cpu_synchronize_state, RUN_ON_CPU_NULL);
+    }
+}
+
+static void do_hvf_cpu_synchronize_post_reset(CPUState *cpu,
+                                              run_on_cpu_data arg)
+{
+    hvf_put_registers(cpu);
+    cpu->vcpu_dirty = false;
+}
+
+void hvf_cpu_synchronize_post_reset(CPUState *cpu)
+{
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
+}
+
+static void do_hvf_cpu_synchronize_post_init(CPUState *cpu,
+                                             run_on_cpu_data arg)
+{
+    hvf_put_registers(cpu);
+    cpu->vcpu_dirty = false;
+}
+
+void hvf_cpu_synchronize_post_init(CPUState *cpu)
+{
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+}
+
+static void do_hvf_cpu_synchronize_pre_loadvm(CPUState *cpu,
+                                              run_on_cpu_data arg)
+{
+    cpu->vcpu_dirty = true;
+}
+
+void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
+{
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
+}
+
+static void hvf_set_dirty_tracking(MemoryRegionSection *section, bool on)
+{
+    hvf_slot *slot;
+
+    slot = hvf_find_overlap_slot(
+            section->offset_within_address_space,
+            int128_get64(section->size));
+
+    /* protect region against writes; begin tracking it */
+    if (on) {
+        slot->flags |= HVF_SLOT_LOG;
+        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
+                      HV_MEMORY_READ);
+    /* stop tracking region*/
+    } else {
+        slot->flags &= ~HVF_SLOT_LOG;
+        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
+                      HV_MEMORY_READ | HV_MEMORY_WRITE);
+    }
+}
+
+static void hvf_log_start(MemoryListener *listener,
+                          MemoryRegionSection *section, int old, int new)
+{
+    if (old != 0) {
+        return;
+    }
+
+    hvf_set_dirty_tracking(section, 1);
+}
+
+static void hvf_log_stop(MemoryListener *listener,
+                         MemoryRegionSection *section, int old, int new)
+{
+    if (new != 0) {
+        return;
+    }
+
+    hvf_set_dirty_tracking(section, 0);
+}
+
+static void hvf_log_sync(MemoryListener *listener,
+                         MemoryRegionSection *section)
+{
+    /*
+     * sync of dirty pages is handled elsewhere; just make sure we keep
+     * tracking the region.
+     */
+    hvf_set_dirty_tracking(section, 1);
+}
+
+static void hvf_region_add(MemoryListener *listener,
+                           MemoryRegionSection *section)
+{
+    hvf_set_phys_mem(section, true);
+}
+
+static void hvf_region_del(MemoryListener *listener,
+                           MemoryRegionSection *section)
+{
+    hvf_set_phys_mem(section, false);
+}
+
+static MemoryListener hvf_memory_listener = {
+    .priority = 10,
+    .region_add = hvf_region_add,
+    .region_del = hvf_region_del,
+    .log_start = hvf_log_start,
+    .log_stop = hvf_log_stop,
+    .log_sync = hvf_log_sync,
+};
+
+static void dummy_signal(int sig)
+{
+}
+
+bool hvf_allowed;
+
+static int hvf_accel_init(MachineState *ms)
+{
+    int x;
+    hv_return_t ret;
+    HVFState *s;
+
+    ret = hv_vm_create(HV_VM_DEFAULT);
+    assert_hvf_ok(ret);
+
+    s = g_new0(HVFState, 1);
+
+    s->num_slots = 32;
+    for (x = 0; x < s->num_slots; ++x) {
+        s->slots[x].size = 0;
+        s->slots[x].slot_id = x;
+    }
+
+    hvf_state = s;
+    memory_listener_register(&hvf_memory_listener, &address_space_memory);
+    return 0;
+}
+
+static void hvf_accel_class_init(ObjectClass *oc, void *data)
+{
+    AccelClass *ac = ACCEL_CLASS(oc);
+    ac->name = "HVF";
+    ac->init_machine = hvf_accel_init;
+    ac->allowed = &hvf_allowed;
+}
+
+static const TypeInfo hvf_accel_type = {
+    .name = TYPE_HVF_ACCEL,
+    .parent = TYPE_ACCEL,
+    .class_init = hvf_accel_class_init,
+};
+
+static void hvf_type_init(void)
+{
+    type_register_static(&hvf_accel_type);
+}
+
+type_init(hvf_type_init);
+
 /*
  * The HVF-specific vCPU thread function. This one should only run when the host
  * CPU supports the VMX "unrestricted guest" feature.
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 3deb4cfacc4f..4c657b054c14 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -13,6 +13,10 @@
 
 #include <Hypervisor/hv.h>
 
+void hvf_set_phys_mem(MemoryRegionSection *, bool);
 void assert_hvf_ok(hv_return_t ret);
+hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
+int hvf_put_registers(CPUState *);
+int hvf_get_registers(CPUState *);
 
 #endif
diff --git a/target/i386/hvf/hvf-i386.h b/target/i386/hvf/hvf-i386.h
index 59cfca8875ef..94e5c788c480 100644
--- a/target/i386/hvf/hvf-i386.h
+++ b/target/i386/hvf/hvf-i386.h
@@ -51,9 +51,7 @@ struct HVFState {
 };
 extern HVFState *hvf_state;
 
-void hvf_set_phys_mem(MemoryRegionSection *, bool);
 void hvf_handle_io(CPUArchState *, uint16_t, void *, int, int, int);
-hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 
 #ifdef NEED_CPU_H
 /* Functions exported to host specific mode */
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index 32f42f15924d..100ede2a4d72 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -75,137 +75,6 @@
 
 #include "hvf-accel-ops.h"
 
-HVFState *hvf_state;
-
-/* Memory slots */
-hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
-{
-    hvf_slot *slot;
-    int x;
-    for (x = 0; x < hvf_state->num_slots; ++x) {
-        slot = &hvf_state->slots[x];
-        if (slot->size && start < (slot->start + slot->size) &&
-            (start + size) > slot->start) {
-            return slot;
-        }
-    }
-    return NULL;
-}
-
-struct mac_slot {
-    int present;
-    uint64_t size;
-    uint64_t gpa_start;
-    uint64_t gva;
-};
-
-struct mac_slot mac_slots[32];
-
-static int do_hvf_set_memory(hvf_slot *slot, hv_memory_flags_t flags)
-{
-    struct mac_slot *macslot;
-    hv_return_t ret;
-
-    macslot = &mac_slots[slot->slot_id];
-
-    if (macslot->present) {
-        if (macslot->size != slot->size) {
-            macslot->present = 0;
-            ret = hv_vm_unmap(macslot->gpa_start, macslot->size);
-            assert_hvf_ok(ret);
-        }
-    }
-
-    if (!slot->size) {
-        return 0;
-    }
-
-    macslot->present = 1;
-    macslot->gpa_start = slot->start;
-    macslot->size = slot->size;
-    ret = hv_vm_map((hv_uvaddr_t)slot->mem, slot->start, slot->size, flags);
-    assert_hvf_ok(ret);
-    return 0;
-}
-
-void hvf_set_phys_mem(MemoryRegionSection *section, bool add)
-{
-    hvf_slot *mem;
-    MemoryRegion *area = section->mr;
-    bool writeable = !area->readonly && !area->rom_device;
-    hv_memory_flags_t flags;
-
-    if (!memory_region_is_ram(area)) {
-        if (writeable) {
-            return;
-        } else if (!memory_region_is_romd(area)) {
-            /*
-             * If the memory device is not in romd_mode, then we actually want
-             * to remove the hvf memory slot so all accesses will trap.
-             */
-             add = false;
-        }
-    }
-
-    mem = hvf_find_overlap_slot(
-            section->offset_within_address_space,
-            int128_get64(section->size));
-
-    if (mem && add) {
-        if (mem->size == int128_get64(section->size) &&
-            mem->start == section->offset_within_address_space &&
-            mem->mem == (memory_region_get_ram_ptr(area) +
-            section->offset_within_region)) {
-            return; /* Same region was attempted to register, go away. */
-        }
-    }
-
-    /* Region needs to be reset. set the size to 0 and remap it. */
-    if (mem) {
-        mem->size = 0;
-        if (do_hvf_set_memory(mem, 0)) {
-            error_report("Failed to reset overlapping slot");
-            abort();
-        }
-    }
-
-    if (!add) {
-        return;
-    }
-
-    if (area->readonly ||
-        (!memory_region_is_ram(area) && memory_region_is_romd(area))) {
-        flags = HV_MEMORY_READ | HV_MEMORY_EXEC;
-    } else {
-        flags = HV_MEMORY_READ | HV_MEMORY_WRITE | HV_MEMORY_EXEC;
-    }
-
-    /* Now make a new slot. */
-    int x;
-
-    for (x = 0; x < hvf_state->num_slots; ++x) {
-        mem = &hvf_state->slots[x];
-        if (!mem->size) {
-            break;
-        }
-    }
-
-    if (x == hvf_state->num_slots) {
-        error_report("No free slots");
-        abort();
-    }
-
-    mem->size = int128_get64(section->size);
-    mem->mem = memory_region_get_ram_ptr(area) + section->offset_within_region;
-    mem->start = section->offset_within_address_space;
-    mem->region = area;
-
-    if (do_hvf_set_memory(mem, flags)) {
-        error_report("Error registering new memory slot");
-        abort();
-    }
-}
-
 void vmx_update_tpr(CPUState *cpu)
 {
     /* TODO: need integrate APIC handling */
@@ -245,56 +114,6 @@ void hvf_handle_io(CPUArchState *env, uint16_t port, void *buffer,
     }
 }
 
-static void do_hvf_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
-{
-    if (!cpu->vcpu_dirty) {
-        hvf_get_registers(cpu);
-        cpu->vcpu_dirty = true;
-    }
-}
-
-void hvf_cpu_synchronize_state(CPUState *cpu)
-{
-    if (!cpu->vcpu_dirty) {
-        run_on_cpu(cpu, do_hvf_cpu_synchronize_state, RUN_ON_CPU_NULL);
-    }
-}
-
-static void do_hvf_cpu_synchronize_post_reset(CPUState *cpu,
-                                              run_on_cpu_data arg)
-{
-    hvf_put_registers(cpu);
-    cpu->vcpu_dirty = false;
-}
-
-void hvf_cpu_synchronize_post_reset(CPUState *cpu)
-{
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
-}
-
-static void do_hvf_cpu_synchronize_post_init(CPUState *cpu,
-                                             run_on_cpu_data arg)
-{
-    hvf_put_registers(cpu);
-    cpu->vcpu_dirty = false;
-}
-
-void hvf_cpu_synchronize_post_init(CPUState *cpu)
-{
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
-}
-
-static void do_hvf_cpu_synchronize_pre_loadvm(CPUState *cpu,
-                                              run_on_cpu_data arg)
-{
-    cpu->vcpu_dirty = true;
-}
-
-void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
-{
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
-}
-
 static bool ept_emulation_fault(hvf_slot *slot, uint64_t gpa, uint64_t ept_qual)
 {
     int read, write;
@@ -339,78 +158,6 @@ static bool ept_emulation_fault(hvf_slot *slot, uint64_t gpa, uint64_t ept_qual)
     return false;
 }
 
-static void hvf_set_dirty_tracking(MemoryRegionSection *section, bool on)
-{
-    hvf_slot *slot;
-
-    slot = hvf_find_overlap_slot(
-            section->offset_within_address_space,
-            int128_get64(section->size));
-
-    /* protect region against writes; begin tracking it */
-    if (on) {
-        slot->flags |= HVF_SLOT_LOG;
-        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
-                      HV_MEMORY_READ);
-    /* stop tracking region*/
-    } else {
-        slot->flags &= ~HVF_SLOT_LOG;
-        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
-                      HV_MEMORY_READ | HV_MEMORY_WRITE);
-    }
-}
-
-static void hvf_log_start(MemoryListener *listener,
-                          MemoryRegionSection *section, int old, int new)
-{
-    if (old != 0) {
-        return;
-    }
-
-    hvf_set_dirty_tracking(section, 1);
-}
-
-static void hvf_log_stop(MemoryListener *listener,
-                         MemoryRegionSection *section, int old, int new)
-{
-    if (new != 0) {
-        return;
-    }
-
-    hvf_set_dirty_tracking(section, 0);
-}
-
-static void hvf_log_sync(MemoryListener *listener,
-                         MemoryRegionSection *section)
-{
-    /*
-     * sync of dirty pages is handled elsewhere; just make sure we keep
-     * tracking the region.
-     */
-    hvf_set_dirty_tracking(section, 1);
-}
-
-static void hvf_region_add(MemoryListener *listener,
-                           MemoryRegionSection *section)
-{
-    hvf_set_phys_mem(section, true);
-}
-
-static void hvf_region_del(MemoryListener *listener,
-                           MemoryRegionSection *section)
-{
-    hvf_set_phys_mem(section, false);
-}
-
-static MemoryListener hvf_memory_listener = {
-    .priority = 10,
-    .region_add = hvf_region_add,
-    .region_del = hvf_region_del,
-    .log_start = hvf_log_start,
-    .log_stop = hvf_log_stop,
-    .log_sync = hvf_log_sync,
-};
-
 void hvf_vcpu_destroy(CPUState *cpu)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -421,10 +168,6 @@ void hvf_vcpu_destroy(CPUState *cpu)
     assert_hvf_ok(ret);
 }
 
-static void dummy_signal(int sig)
-{
-}
-
 static void init_tsc_freq(CPUX86State *env)
 {
     size_t length;
@@ -931,48 +674,3 @@ int hvf_vcpu_exec(CPUState *cpu)
 
     return ret;
 }
-
-bool hvf_allowed;
-
-static int hvf_accel_init(MachineState *ms)
-{
-    int x;
-    hv_return_t ret;
-    HVFState *s;
-
-    ret = hv_vm_create(HV_VM_DEFAULT);
-    assert_hvf_ok(ret);
-
-    s = g_new0(HVFState, 1);
- 
-    s->num_slots = 32;
-    for (x = 0; x < s->num_slots; ++x) {
-        s->slots[x].size = 0;
-        s->slots[x].slot_id = x;
-    }
-  
-    hvf_state = s;
-    memory_listener_register(&hvf_memory_listener, &address_space_memory);
-    return 0;
-}
-
-static void hvf_accel_class_init(ObjectClass *oc, void *data)
-{
-    AccelClass *ac = ACCEL_CLASS(oc);
-    ac->name = "HVF";
-    ac->init_machine = hvf_accel_init;
-    ac->allowed = &hvf_allowed;
-}
-
-static const TypeInfo hvf_accel_type = {
-    .name = TYPE_HVF_ACCEL,
-    .parent = TYPE_ACCEL,
-    .class_init = hvf_accel_class_init,
-};
-
-static void hvf_type_init(void)
-{
-    type_register_static(&hvf_accel_type);
-}
-
-type_init(hvf_type_init);
diff --git a/target/i386/hvf/x86hvf.h b/target/i386/hvf/x86hvf.h
index 635ab0f34e48..99ed8d608ddc 100644
--- a/target/i386/hvf/x86hvf.h
+++ b/target/i386/hvf/x86hvf.h
@@ -21,8 +21,6 @@
 #include "x86_descr.h"
 
 int hvf_process_events(CPUState *);
-int hvf_put_registers(CPUState *);
-int hvf_get_registers(CPUState *);
 bool hvf_inject_interrupts(CPUState *);
 void hvf_set_segment(struct CPUState *cpu, struct vmx_segment *vmx_seg,
                      SegmentCache *qseg, bool is_tr);

From 82e6e2bdff5d06679cebb8bd617d50ce53c6edac Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:38 +0200
Subject: [PATCH 072/180] hvf: Move hvf internal definitions into common header

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch moves a few internal struct and constant defines over.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-5-agraf@csgraf.de>
---
 include/sysemu/hvf_int.h   | 30 ++++++++++++++++++++++++++++++
 target/i386/hvf/hvf-i386.h | 31 +------------------------------
 2 files changed, 31 insertions(+), 30 deletions(-)

diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 4c657b054c14..ef84a24dd968 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -13,6 +13,36 @@
 
 #include <Hypervisor/hv.h>
 
+/* hvf_slot flags */
+#define HVF_SLOT_LOG (1 << 0)
+
+typedef struct hvf_slot {
+    uint64_t start;
+    uint64_t size;
+    uint8_t *mem;
+    int slot_id;
+    uint32_t flags;
+    MemoryRegion *region;
+} hvf_slot;
+
+typedef struct hvf_vcpu_caps {
+    uint64_t vmx_cap_pinbased;
+    uint64_t vmx_cap_procbased;
+    uint64_t vmx_cap_procbased2;
+    uint64_t vmx_cap_entry;
+    uint64_t vmx_cap_exit;
+    uint64_t vmx_cap_preemption_timer;
+} hvf_vcpu_caps;
+
+struct HVFState {
+    AccelState parent;
+    hvf_slot slots[32];
+    int num_slots;
+
+    hvf_vcpu_caps *hvf_caps;
+};
+extern HVFState *hvf_state;
+
 void hvf_set_phys_mem(MemoryRegionSection *, bool);
 void assert_hvf_ok(hv_return_t ret);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
diff --git a/target/i386/hvf/hvf-i386.h b/target/i386/hvf/hvf-i386.h
index 94e5c788c480..76e9235524c5 100644
--- a/target/i386/hvf/hvf-i386.h
+++ b/target/i386/hvf/hvf-i386.h
@@ -18,39 +18,10 @@
 
 #include "qemu/accel.h"
 #include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
 #include "cpu.h"
 #include "x86.h"
 
-/* hvf_slot flags */
-#define HVF_SLOT_LOG (1 << 0)
-
-typedef struct hvf_slot {
-    uint64_t start;
-    uint64_t size;
-    uint8_t *mem;
-    int slot_id;
-    uint32_t flags;
-    MemoryRegion *region;
-} hvf_slot;
-
-typedef struct hvf_vcpu_caps {
-    uint64_t vmx_cap_pinbased;
-    uint64_t vmx_cap_procbased;
-    uint64_t vmx_cap_procbased2;
-    uint64_t vmx_cap_entry;
-    uint64_t vmx_cap_exit;
-    uint64_t vmx_cap_preemption_timer;
-} hvf_vcpu_caps;
-
-struct HVFState {
-    AccelState parent;
-    hvf_slot slots[32];
-    int num_slots;
-
-    hvf_vcpu_caps *hvf_caps;
-};
-extern HVFState *hvf_state;
-
 void hvf_handle_io(CPUArchState *, uint16_t, void *, int, int, int);
 
 #ifdef NEED_CPU_H

From ea9f45cec576c5ece176ff341e8c450028b1c390 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:39 +0200
Subject: [PATCH 073/180] hvf: Make hvf_set_phys_mem() static

The hvf_set_phys_mem() function is only called within the same file.
Make it static.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-6-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 2 +-
 include/sysemu/hvf_int.h  | 1 -
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index c2136dfbb8c7..5bec7b4d6dce 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -114,7 +114,7 @@ static int do_hvf_set_memory(hvf_slot *slot, hv_memory_flags_t flags)
     return 0;
 }
 
-void hvf_set_phys_mem(MemoryRegionSection *section, bool add)
+static void hvf_set_phys_mem(MemoryRegionSection *section, bool add)
 {
     hvf_slot *mem;
     MemoryRegion *area = section->mr;
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index ef84a24dd968..d15fa3302a97 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -43,7 +43,6 @@ struct HVFState {
 };
 extern HVFState *hvf_state;
 
-void hvf_set_phys_mem(MemoryRegionSection *, bool);
 void assert_hvf_ok(hv_return_t ret);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 int hvf_put_registers(CPUState *);

From 30c2f78449e4d52ba8dadea4794b836790b276d1 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:40 +0200
Subject: [PATCH 074/180] hvf: Remove use of hv_uvaddr_t and hv_gpaddr_t

The ARM version of Hypervisor.framework no longer defines these two
types, so let's just revert to standard ones.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-7-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 5bec7b4d6dce..7370fcfba09d 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -109,7 +109,7 @@ static int do_hvf_set_memory(hvf_slot *slot, hv_memory_flags_t flags)
     macslot->present = 1;
     macslot->gpa_start = slot->start;
     macslot->size = slot->size;
-    ret = hv_vm_map((hv_uvaddr_t)slot->mem, slot->start, slot->size, flags);
+    ret = hv_vm_map(slot->mem, slot->start, slot->size, flags);
     assert_hvf_ok(ret);
     return 0;
 }
@@ -253,12 +253,12 @@ static void hvf_set_dirty_tracking(MemoryRegionSection *section, bool on)
     /* protect region against writes; begin tracking it */
     if (on) {
         slot->flags |= HVF_SLOT_LOG;
-        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
+        hv_vm_protect((uintptr_t)slot->start, (size_t)slot->size,
                       HV_MEMORY_READ);
     /* stop tracking region*/
     } else {
         slot->flags &= ~HVF_SLOT_LOG;
-        hv_vm_protect((hv_gpaddr_t)slot->start, (size_t)slot->size,
+        hv_vm_protect((uintptr_t)slot->start, (size_t)slot->size,
                       HV_MEMORY_READ | HV_MEMORY_WRITE);
     }
 }

From 9517f7e873b5efca30b0b78c7a905b28cc22a5c9 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:41 +0200
Subject: [PATCH 075/180] hvf: Split out common code on vcpu init and destroy

Until now, Hypervisor.framework has only been available on x86_64 systems.
With Apple Silicon shipping now, it extends its reach to aarch64. To
prepare for support for multiple architectures, let's start moving common
code out into its own accel directory.

This patch splits the vcpu init and destroy functions into a generic and
an architecture specific portion. This also allows us to move the generic
functions into the generic hvf code, removing exported functions.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-8-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 30 ++++++++++++++++++++++++++++++
 accel/hvf/hvf-accel-ops.h |  2 --
 include/sysemu/hvf_int.h  |  2 ++
 target/i386/hvf/hvf.c     | 23 ++---------------------
 4 files changed, 34 insertions(+), 23 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 7370fcfba09d..b262efd8b6ce 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -363,6 +363,36 @@ static void hvf_type_init(void)
 
 type_init(hvf_type_init);
 
+static void hvf_vcpu_destroy(CPUState *cpu)
+{
+    hv_return_t ret = hv_vcpu_destroy(cpu->hvf_fd);
+    assert_hvf_ok(ret);
+
+    hvf_arch_vcpu_destroy(cpu);
+}
+
+static int hvf_init_vcpu(CPUState *cpu)
+{
+    int r;
+
+    /* init cpu signals */
+    sigset_t set;
+    struct sigaction sigact;
+
+    memset(&sigact, 0, sizeof(sigact));
+    sigact.sa_handler = dummy_signal;
+    sigaction(SIG_IPI, &sigact, NULL);
+
+    pthread_sigmask(SIG_BLOCK, NULL, &set);
+    sigdelset(&set, SIG_IPI);
+
+    r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf_fd, HV_VCPU_DEFAULT);
+    cpu->vcpu_dirty = 1;
+    assert_hvf_ok(r);
+
+    return hvf_arch_init_vcpu(cpu);
+}
+
 /*
  * The HVF-specific vCPU thread function. This one should only run when the host
  * CPU supports the VMX "unrestricted guest" feature.
diff --git a/accel/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
index 8f992da16866..09fcf2206762 100644
--- a/accel/hvf/hvf-accel-ops.h
+++ b/accel/hvf/hvf-accel-ops.h
@@ -12,12 +12,10 @@
 
 #include "sysemu/cpus.h"
 
-int hvf_init_vcpu(CPUState *);
 int hvf_vcpu_exec(CPUState *);
 void hvf_cpu_synchronize_state(CPUState *);
 void hvf_cpu_synchronize_post_reset(CPUState *);
 void hvf_cpu_synchronize_post_init(CPUState *);
 void hvf_cpu_synchronize_pre_loadvm(CPUState *);
-void hvf_vcpu_destroy(CPUState *);
 
 #endif /* HVF_CPUS_H */
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index d15fa3302a97..80c1a8f94667 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -44,6 +44,8 @@ struct HVFState {
 extern HVFState *hvf_state;
 
 void assert_hvf_ok(hv_return_t ret);
+int hvf_arch_init_vcpu(CPUState *cpu);
+void hvf_arch_vcpu_destroy(CPUState *cpu);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 int hvf_put_registers(CPUState *);
 int hvf_get_registers(CPUState *);
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index 100ede2a4d72..c7132ee370c9 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -158,14 +158,12 @@ static bool ept_emulation_fault(hvf_slot *slot, uint64_t gpa, uint64_t ept_qual)
     return false;
 }
 
-void hvf_vcpu_destroy(CPUState *cpu)
+void hvf_arch_vcpu_destroy(CPUState *cpu)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
     CPUX86State *env = &x86_cpu->env;
 
-    hv_return_t ret = hv_vcpu_destroy((hv_vcpuid_t)cpu->hvf_fd);
     g_free(env->hvf_mmio_buf);
-    assert_hvf_ok(ret);
 }
 
 static void init_tsc_freq(CPUX86State *env)
@@ -210,23 +208,10 @@ static inline bool apic_bus_freq_is_known(CPUX86State *env)
     return env->apic_bus_freq != 0;
 }
 
-int hvf_init_vcpu(CPUState *cpu)
+int hvf_arch_init_vcpu(CPUState *cpu)
 {
-
     X86CPU *x86cpu = X86_CPU(cpu);
     CPUX86State *env = &x86cpu->env;
-    int r;
-
-    /* init cpu signals */
-    sigset_t set;
-    struct sigaction sigact;
-
-    memset(&sigact, 0, sizeof(sigact));
-    sigact.sa_handler = dummy_signal;
-    sigaction(SIG_IPI, &sigact, NULL);
-
-    pthread_sigmask(SIG_BLOCK, NULL, &set);
-    sigdelset(&set, SIG_IPI);
 
     init_emu();
     init_decoder();
@@ -243,10 +228,6 @@ int hvf_init_vcpu(CPUState *cpu)
         }
     }
 
-    r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf_fd, HV_VCPU_DEFAULT);
-    cpu->vcpu_dirty = 1;
-    assert_hvf_ok(r);
-
     if (hv_vmx_read_capability(HV_VMX_CAP_PINBASED,
         &hvf_state->hvf_caps->vmx_cap_pinbased)) {
         abort();

From 0bc7389a8e25ff57d3605b67bf20cc2a736fb130 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:42 +0200
Subject: [PATCH 076/180] hvf: Use cpu_synchronize_state()

There is no reason to call the hvf specific hvf_cpu_synchronize_state()
when we can just use the generic cpu_synchronize_state() instead. This
allows us to have less dependency on internal function definitions and
allows us to make hvf_cpu_synchronize_state() static.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-9-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 2 +-
 accel/hvf/hvf-accel-ops.h | 1 -
 target/i386/hvf/x86hvf.c  | 9 ++++-----
 3 files changed, 5 insertions(+), 7 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index b262efd8b6ce..3b599ac57ce0 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -200,7 +200,7 @@ static void do_hvf_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
-void hvf_cpu_synchronize_state(CPUState *cpu)
+static void hvf_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty) {
         run_on_cpu(cpu, do_hvf_cpu_synchronize_state, RUN_ON_CPU_NULL);
diff --git a/accel/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
index 09fcf2206762..f6192b56f0c7 100644
--- a/accel/hvf/hvf-accel-ops.h
+++ b/accel/hvf/hvf-accel-ops.h
@@ -13,7 +13,6 @@
 #include "sysemu/cpus.h"
 
 int hvf_vcpu_exec(CPUState *);
-void hvf_cpu_synchronize_state(CPUState *);
 void hvf_cpu_synchronize_post_reset(CPUState *);
 void hvf_cpu_synchronize_post_init(CPUState *);
 void hvf_cpu_synchronize_pre_loadvm(CPUState *);
diff --git a/target/i386/hvf/x86hvf.c b/target/i386/hvf/x86hvf.c
index 2b99f3eaa2d5..cc381307ab90 100644
--- a/target/i386/hvf/x86hvf.c
+++ b/target/i386/hvf/x86hvf.c
@@ -26,14 +26,13 @@
 #include "cpu.h"
 #include "x86_descr.h"
 #include "x86_decode.h"
+#include "sysemu/hw_accel.h"
 
 #include "hw/i386/apic_internal.h"
 
 #include <Hypervisor/hv.h>
 #include <Hypervisor/hv_vmx.h>
 
-#include "accel/hvf/hvf-accel-ops.h"
-
 void hvf_set_segment(struct CPUState *cpu, struct vmx_segment *vmx_seg,
                      SegmentCache *qseg, bool is_tr)
 {
@@ -437,7 +436,7 @@ int hvf_process_events(CPUState *cpu_state)
     env->eflags = rreg(cpu_state->hvf_fd, HV_X86_RFLAGS);
 
     if (cpu_state->interrupt_request & CPU_INTERRUPT_INIT) {
-        hvf_cpu_synchronize_state(cpu_state);
+        cpu_synchronize_state(cpu_state);
         do_cpu_init(cpu);
     }
 
@@ -451,12 +450,12 @@ int hvf_process_events(CPUState *cpu_state)
         cpu_state->halted = 0;
     }
     if (cpu_state->interrupt_request & CPU_INTERRUPT_SIPI) {
-        hvf_cpu_synchronize_state(cpu_state);
+        cpu_synchronize_state(cpu_state);
         do_cpu_sipi(cpu);
     }
     if (cpu_state->interrupt_request & CPU_INTERRUPT_TPR) {
         cpu_state->interrupt_request &= ~CPU_INTERRUPT_TPR;
-        hvf_cpu_synchronize_state(cpu_state);
+        cpu_synchronize_state(cpu_state);
         apic_handle_tpr_access_report(cpu->apic_state, env->eip,
                                       env->tpr_access_type);
     }

From 056bdd9a510b44c10246550ada40e2baade58e60 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:43 +0200
Subject: [PATCH 077/180] hvf: Make synchronize functions static

The hvf accel synchronize functions are only used as input for local
callback functions, so we can make them static.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-10-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 6 +++---
 accel/hvf/hvf-accel-ops.h | 3 ---
 2 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 3b599ac57ce0..69741ce7081d 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -214,7 +214,7 @@ static void do_hvf_cpu_synchronize_post_reset(CPUState *cpu,
     cpu->vcpu_dirty = false;
 }
 
-void hvf_cpu_synchronize_post_reset(CPUState *cpu)
+static void hvf_cpu_synchronize_post_reset(CPUState *cpu)
 {
     run_on_cpu(cpu, do_hvf_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
 }
@@ -226,7 +226,7 @@ static void do_hvf_cpu_synchronize_post_init(CPUState *cpu,
     cpu->vcpu_dirty = false;
 }
 
-void hvf_cpu_synchronize_post_init(CPUState *cpu)
+static void hvf_cpu_synchronize_post_init(CPUState *cpu)
 {
     run_on_cpu(cpu, do_hvf_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
 }
@@ -237,7 +237,7 @@ static void do_hvf_cpu_synchronize_pre_loadvm(CPUState *cpu,
     cpu->vcpu_dirty = true;
 }
 
-void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
+static void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
     run_on_cpu(cpu, do_hvf_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
 }
diff --git a/accel/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
index f6192b56f0c7..018a4e22f6dc 100644
--- a/accel/hvf/hvf-accel-ops.h
+++ b/accel/hvf/hvf-accel-ops.h
@@ -13,8 +13,5 @@
 #include "sysemu/cpus.h"
 
 int hvf_vcpu_exec(CPUState *);
-void hvf_cpu_synchronize_post_reset(CPUState *);
-void hvf_cpu_synchronize_post_init(CPUState *);
-void hvf_cpu_synchronize_pre_loadvm(CPUState *);
 
 #endif /* HVF_CPUS_H */

From f3b4506f14ca8b39f30227d9024b562d4fffa324 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:44 +0200
Subject: [PATCH 078/180] hvf: Remove hvf-accel-ops.h

We can move the definition of hvf_vcpu_exec() into our internal
hvf header, obsoleting the need for hvf-accel-ops.h.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-11-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c |  2 --
 accel/hvf/hvf-accel-ops.h | 17 -----------------
 include/sysemu/hvf_int.h  |  1 +
 target/i386/hvf/hvf.c     |  2 --
 4 files changed, 1 insertion(+), 21 deletions(-)
 delete mode 100644 accel/hvf/hvf-accel-ops.h

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 69741ce7081d..14fc49791e34 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -58,8 +58,6 @@
 #include "sysemu/runstate.h"
 #include "qemu/guest-random.h"
 
-#include "hvf-accel-ops.h"
-
 HVFState *hvf_state;
 
 /* Memory slots */
diff --git a/accel/hvf/hvf-accel-ops.h b/accel/hvf/hvf-accel-ops.h
deleted file mode 100644
index 018a4e22f6dc..000000000000
--- a/accel/hvf/hvf-accel-ops.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * Accelerator CPUS Interface
- *
- * Copyright 2020 SUSE LLC
- *
- * This work is licensed under the terms of the GNU GPL, version 2 or later.
- * See the COPYING file in the top-level directory.
- */
-
-#ifndef HVF_CPUS_H
-#define HVF_CPUS_H
-
-#include "sysemu/cpus.h"
-
-int hvf_vcpu_exec(CPUState *);
-
-#endif /* HVF_CPUS_H */
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 80c1a8f94667..fd1dcaf26e08 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -46,6 +46,7 @@ extern HVFState *hvf_state;
 void assert_hvf_ok(hv_return_t ret);
 int hvf_arch_init_vcpu(CPUState *cpu);
 void hvf_arch_vcpu_destroy(CPUState *cpu);
+int hvf_vcpu_exec(CPUState *);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 int hvf_put_registers(CPUState *);
 int hvf_get_registers(CPUState *);
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index c7132ee370c9..02f7be6cfd6d 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -73,8 +73,6 @@
 #include "qemu/accel.h"
 #include "target/i386/cpu.h"
 
-#include "hvf-accel-ops.h"
-
 void vmx_update_tpr(CPUState *cpu)
 {
     /* TODO: need integrate APIC handling */

From 4c82b50085b221ba766704c8defadc13594e726b Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:45 +0200
Subject: [PATCH 079/180] hvf: Introduce hvf vcpu struct
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We will need more than a single field for hvf going forward. To keep
the global vcpu struct uncluttered, let's allocate a special hvf vcpu
struct, similar to how hax does it.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reviewed-by: Roman Bolshakov <r.bolshakov@yadro.com>
Tested-by: Roman Bolshakov <r.bolshakov@yadro.com>
Reviewed-by: Alex Bennée <alex.bennee@linaro.org>

Message-Id: <20210519202253.76782-12-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c   |   8 +-
 include/hw/core/cpu.h       |   3 +-
 include/sysemu/hvf_int.h    |   4 +
 target/i386/hvf/hvf.c       | 104 +++++++++---------
 target/i386/hvf/vmx.h       |  24 +++--
 target/i386/hvf/x86.c       |  28 ++---
 target/i386/hvf/x86_descr.c |  26 ++---
 target/i386/hvf/x86_emu.c   |  62 +++++------
 target/i386/hvf/x86_mmu.c   |   4 +-
 target/i386/hvf/x86_task.c  |  12 +--
 target/i386/hvf/x86hvf.c    | 210 ++++++++++++++++++------------------
 11 files changed, 248 insertions(+), 237 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 14fc49791e34..ded918c443d9 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -363,16 +363,20 @@ type_init(hvf_type_init);
 
 static void hvf_vcpu_destroy(CPUState *cpu)
 {
-    hv_return_t ret = hv_vcpu_destroy(cpu->hvf_fd);
+    hv_return_t ret = hv_vcpu_destroy(cpu->hvf->fd);
     assert_hvf_ok(ret);
 
     hvf_arch_vcpu_destroy(cpu);
+    g_free(cpu->hvf);
+    cpu->hvf = NULL;
 }
 
 static int hvf_init_vcpu(CPUState *cpu)
 {
     int r;
 
+    cpu->hvf = g_malloc0(sizeof(*cpu->hvf));
+
     /* init cpu signals */
     sigset_t set;
     struct sigaction sigact;
@@ -384,7 +388,7 @@ static int hvf_init_vcpu(CPUState *cpu)
     pthread_sigmask(SIG_BLOCK, NULL, &set);
     sigdelset(&set, SIG_IPI);
 
-    r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf_fd, HV_VCPU_DEFAULT);
+    r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf->fd, HV_VCPU_DEFAULT);
     cpu->vcpu_dirty = 1;
     assert_hvf_ok(r);
 
diff --git a/include/hw/core/cpu.h b/include/hw/core/cpu.h
index d45f78290e02..47d82a5aa9d1 100644
--- a/include/hw/core/cpu.h
+++ b/include/hw/core/cpu.h
@@ -251,6 +251,7 @@ struct KVMState;
 struct kvm_run;
 
 struct hax_vcpu_state;
+struct hvf_vcpu_state;
 
 #define TB_JMP_CACHE_BITS 12
 #define TB_JMP_CACHE_SIZE (1 << TB_JMP_CACHE_BITS)
@@ -436,7 +437,7 @@ struct CPUState {
 
     struct hax_vcpu_state *hax_vcpu;
 
-    int hvf_fd;
+    struct hvf_vcpu_state *hvf;
 
     /* track IOMMUs whose translations we've cached in the TCG TLB */
     GArray *iommu_notifiers;
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index fd1dcaf26e08..8b66a4e7d0dc 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -43,6 +43,10 @@ struct HVFState {
 };
 extern HVFState *hvf_state;
 
+struct hvf_vcpu_state {
+    int fd;
+};
+
 void assert_hvf_ok(hv_return_t ret);
 int hvf_arch_init_vcpu(CPUState *cpu);
 void hvf_arch_vcpu_destroy(CPUState *cpu);
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index 02f7be6cfd6d..346dbcc26f4a 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -80,11 +80,11 @@ void vmx_update_tpr(CPUState *cpu)
     int tpr = cpu_get_apic_tpr(x86_cpu->apic_state) << 4;
     int irr = apic_get_highest_priority_irr(x86_cpu->apic_state);
 
-    wreg(cpu->hvf_fd, HV_X86_TPR, tpr);
+    wreg(cpu->hvf->fd, HV_X86_TPR, tpr);
     if (irr == -1) {
-        wvmcs(cpu->hvf_fd, VMCS_TPR_THRESHOLD, 0);
+        wvmcs(cpu->hvf->fd, VMCS_TPR_THRESHOLD, 0);
     } else {
-        wvmcs(cpu->hvf_fd, VMCS_TPR_THRESHOLD, (irr > tpr) ? tpr >> 4 :
+        wvmcs(cpu->hvf->fd, VMCS_TPR_THRESHOLD, (irr > tpr) ? tpr >> 4 :
               irr >> 4);
     }
 }
@@ -92,7 +92,7 @@ void vmx_update_tpr(CPUState *cpu)
 static void update_apic_tpr(CPUState *cpu)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
-    int tpr = rreg(cpu->hvf_fd, HV_X86_TPR) >> 4;
+    int tpr = rreg(cpu->hvf->fd, HV_X86_TPR) >> 4;
     cpu_set_apic_tpr(x86_cpu->apic_state, tpr);
 }
 
@@ -244,43 +244,43 @@ int hvf_arch_init_vcpu(CPUState *cpu)
     }
 
     /* set VMCS control fields */
-    wvmcs(cpu->hvf_fd, VMCS_PIN_BASED_CTLS,
+    wvmcs(cpu->hvf->fd, VMCS_PIN_BASED_CTLS,
           cap2ctrl(hvf_state->hvf_caps->vmx_cap_pinbased,
           VMCS_PIN_BASED_CTLS_EXTINT |
           VMCS_PIN_BASED_CTLS_NMI |
           VMCS_PIN_BASED_CTLS_VNMI));
-    wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS,
+    wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS,
           cap2ctrl(hvf_state->hvf_caps->vmx_cap_procbased,
           VMCS_PRI_PROC_BASED_CTLS_HLT |
           VMCS_PRI_PROC_BASED_CTLS_MWAIT |
           VMCS_PRI_PROC_BASED_CTLS_TSC_OFFSET |
           VMCS_PRI_PROC_BASED_CTLS_TPR_SHADOW) |
           VMCS_PRI_PROC_BASED_CTLS_SEC_CONTROL);
-    wvmcs(cpu->hvf_fd, VMCS_SEC_PROC_BASED_CTLS,
+    wvmcs(cpu->hvf->fd, VMCS_SEC_PROC_BASED_CTLS,
           cap2ctrl(hvf_state->hvf_caps->vmx_cap_procbased2,
                    VMCS_PRI_PROC_BASED2_CTLS_APIC_ACCESSES));
 
-    wvmcs(cpu->hvf_fd, VMCS_ENTRY_CTLS, cap2ctrl(hvf_state->hvf_caps->vmx_cap_entry,
+    wvmcs(cpu->hvf->fd, VMCS_ENTRY_CTLS, cap2ctrl(hvf_state->hvf_caps->vmx_cap_entry,
           0));
-    wvmcs(cpu->hvf_fd, VMCS_EXCEPTION_BITMAP, 0); /* Double fault */
+    wvmcs(cpu->hvf->fd, VMCS_EXCEPTION_BITMAP, 0); /* Double fault */
 
-    wvmcs(cpu->hvf_fd, VMCS_TPR_THRESHOLD, 0);
+    wvmcs(cpu->hvf->fd, VMCS_TPR_THRESHOLD, 0);
 
     x86cpu = X86_CPU(cpu);
     x86cpu->env.xsave_buf = qemu_memalign(4096, 4096);
 
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_STAR, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_LSTAR, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_CSTAR, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_FMASK, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_FSBASE, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_GSBASE, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_KERNELGSBASE, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_TSC_AUX, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_IA32_TSC, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_IA32_SYSENTER_CS, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_IA32_SYSENTER_EIP, 1);
-    hv_vcpu_enable_native_msr(cpu->hvf_fd, MSR_IA32_SYSENTER_ESP, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_STAR, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_LSTAR, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_CSTAR, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_FMASK, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_FSBASE, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_GSBASE, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_KERNELGSBASE, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_TSC_AUX, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_IA32_TSC, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_IA32_SYSENTER_CS, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_IA32_SYSENTER_EIP, 1);
+    hv_vcpu_enable_native_msr(cpu->hvf->fd, MSR_IA32_SYSENTER_ESP, 1);
 
     return 0;
 }
@@ -321,16 +321,16 @@ static void hvf_store_events(CPUState *cpu, uint32_t ins_len, uint64_t idtvec_in
         }
         if (idtvec_info & VMCS_IDT_VEC_ERRCODE_VALID) {
             env->has_error_code = true;
-            env->error_code = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_ERROR);
+            env->error_code = rvmcs(cpu->hvf->fd, VMCS_IDT_VECTORING_ERROR);
         }
     }
-    if ((rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY) &
+    if ((rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY) &
         VMCS_INTERRUPTIBILITY_NMI_BLOCKING)) {
         env->hflags2 |= HF2_NMI_MASK;
     } else {
         env->hflags2 &= ~HF2_NMI_MASK;
     }
-    if (rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY) &
+    if (rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY) &
          (VMCS_INTERRUPTIBILITY_STI_BLOCKING |
          VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING)) {
         env->hflags |= HF_INHIBIT_IRQ_MASK;
@@ -409,20 +409,20 @@ int hvf_vcpu_exec(CPUState *cpu)
             return EXCP_HLT;
         }
 
-        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);
+        hv_return_t r  = hv_vcpu_run(cpu->hvf->fd);
         assert_hvf_ok(r);
 
         /* handle VMEXIT */
-        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);
-        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);
-        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,
+        uint64_t exit_reason = rvmcs(cpu->hvf->fd, VMCS_EXIT_REASON);
+        uint64_t exit_qual = rvmcs(cpu->hvf->fd, VMCS_EXIT_QUALIFICATION);
+        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf->fd,
                                            VMCS_EXIT_INSTRUCTION_LENGTH);
 
-        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);
+        uint64_t idtvec_info = rvmcs(cpu->hvf->fd, VMCS_IDT_VECTORING_INFO);
 
         hvf_store_events(cpu, ins_len, idtvec_info);
-        rip = rreg(cpu->hvf_fd, HV_X86_RIP);
-        env->eflags = rreg(cpu->hvf_fd, HV_X86_RFLAGS);
+        rip = rreg(cpu->hvf->fd, HV_X86_RIP);
+        env->eflags = rreg(cpu->hvf->fd, HV_X86_RFLAGS);
 
         qemu_mutex_lock_iothread();
 
@@ -452,7 +452,7 @@ int hvf_vcpu_exec(CPUState *cpu)
         case EXIT_REASON_EPT_FAULT:
         {
             hvf_slot *slot;
-            uint64_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);
+            uint64_t gpa = rvmcs(cpu->hvf->fd, VMCS_GUEST_PHYSICAL_ADDRESS);
 
             if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&
                 ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {
@@ -497,7 +497,7 @@ int hvf_vcpu_exec(CPUState *cpu)
                 store_regs(cpu);
                 break;
             } else if (!string && !in) {
-                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);
+                RAX(env) = rreg(cpu->hvf->fd, HV_X86_RAX);
                 hvf_handle_io(env, port, &RAX(env), 1, size, 1);
                 macvm_set_rip(cpu, rip + ins_len);
                 break;
@@ -513,21 +513,21 @@ int hvf_vcpu_exec(CPUState *cpu)
             break;
         }
         case EXIT_REASON_CPUID: {
-            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);
-            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);
-            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);
-            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);
+            uint32_t rax = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RAX);
+            uint32_t rbx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RBX);
+            uint32_t rcx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RCX);
+            uint32_t rdx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RDX);
 
             if (rax == 1) {
                 /* CPUID1.ecx.OSXSAVE needs to know CR4 */
-                env->cr[4] = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR4);
+                env->cr[4] = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR4);
             }
             hvf_cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);
 
-            wreg(cpu->hvf_fd, HV_X86_RAX, rax);
-            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);
-            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);
-            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);
+            wreg(cpu->hvf->fd, HV_X86_RAX, rax);
+            wreg(cpu->hvf->fd, HV_X86_RBX, rbx);
+            wreg(cpu->hvf->fd, HV_X86_RCX, rcx);
+            wreg(cpu->hvf->fd, HV_X86_RDX, rdx);
 
             macvm_set_rip(cpu, rip + ins_len);
             break;
@@ -535,16 +535,16 @@ int hvf_vcpu_exec(CPUState *cpu)
         case EXIT_REASON_XSETBV: {
             X86CPU *x86_cpu = X86_CPU(cpu);
             CPUX86State *env = &x86_cpu->env;
-            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);
-            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);
-            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);
+            uint32_t eax = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RAX);
+            uint32_t ecx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RCX);
+            uint32_t edx = (uint32_t)rreg(cpu->hvf->fd, HV_X86_RDX);
 
             if (ecx) {
                 macvm_set_rip(cpu, rip + ins_len);
                 break;
             }
             env->xcr0 = ((uint64_t)edx << 32) | eax;
-            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);
+            wreg(cpu->hvf->fd, HV_X86_XCR0, env->xcr0 | 1);
             macvm_set_rip(cpu, rip + ins_len);
             break;
         }
@@ -583,11 +583,11 @@ int hvf_vcpu_exec(CPUState *cpu)
 
             switch (cr) {
             case 0x0: {
-                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));
+                macvm_set_cr0(cpu->hvf->fd, RRX(env, reg));
                 break;
             }
             case 4: {
-                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));
+                macvm_set_cr4(cpu->hvf->fd, RRX(env, reg));
                 break;
             }
             case 8: {
@@ -623,7 +623,7 @@ int hvf_vcpu_exec(CPUState *cpu)
             break;
         }
         case EXIT_REASON_TASK_SWITCH: {
-            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);
+            uint64_t vinfo = rvmcs(cpu->hvf->fd, VMCS_IDT_VECTORING_INFO);
             x68_segment_selector sel = {.sel = exit_qual & 0xffff};
             vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,
              vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo
@@ -636,8 +636,8 @@ int hvf_vcpu_exec(CPUState *cpu)
             break;
         }
         case EXIT_REASON_RDPMC:
-            wreg(cpu->hvf_fd, HV_X86_RAX, 0);
-            wreg(cpu->hvf_fd, HV_X86_RDX, 0);
+            wreg(cpu->hvf->fd, HV_X86_RAX, 0);
+            wreg(cpu->hvf->fd, HV_X86_RDX, 0);
             macvm_set_rip(cpu, rip + ins_len);
             break;
         case VMX_REASON_VMCALL:
diff --git a/target/i386/hvf/vmx.h b/target/i386/hvf/vmx.h
index 24c4cdf0be0c..6df87116f62f 100644
--- a/target/i386/hvf/vmx.h
+++ b/target/i386/hvf/vmx.h
@@ -30,6 +30,8 @@
 #include "vmcs.h"
 #include "cpu.h"
 #include "x86.h"
+#include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
 
 #include "exec/address-spaces.h"
 
@@ -179,15 +181,15 @@ static inline void macvm_set_rip(CPUState *cpu, uint64_t rip)
     uint64_t val;
 
     /* BUG, should take considering overlap.. */
-    wreg(cpu->hvf_fd, HV_X86_RIP, rip);
+    wreg(cpu->hvf->fd, HV_X86_RIP, rip);
     env->eip = rip;
 
     /* after moving forward in rip, we need to clean INTERRUPTABILITY */
-   val = rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY);
+   val = rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY);
    if (val & (VMCS_INTERRUPTIBILITY_STI_BLOCKING |
                VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING)) {
         env->hflags &= ~HF_INHIBIT_IRQ_MASK;
-        wvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY,
+        wvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY,
                val & ~(VMCS_INTERRUPTIBILITY_STI_BLOCKING |
                VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING));
    }
@@ -199,9 +201,9 @@ static inline void vmx_clear_nmi_blocking(CPUState *cpu)
     CPUX86State *env = &x86_cpu->env;
 
     env->hflags2 &= ~HF2_NMI_MASK;
-    uint32_t gi = (uint32_t) rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY);
+    uint32_t gi = (uint32_t) rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY);
     gi &= ~VMCS_INTERRUPTIBILITY_NMI_BLOCKING;
-    wvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY, gi);
+    wvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY, gi);
 }
 
 static inline void vmx_set_nmi_blocking(CPUState *cpu)
@@ -210,16 +212,16 @@ static inline void vmx_set_nmi_blocking(CPUState *cpu)
     CPUX86State *env = &x86_cpu->env;
 
     env->hflags2 |= HF2_NMI_MASK;
-    uint32_t gi = (uint32_t)rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY);
+    uint32_t gi = (uint32_t)rvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY);
     gi |= VMCS_INTERRUPTIBILITY_NMI_BLOCKING;
-    wvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY, gi);
+    wvmcs(cpu->hvf->fd, VMCS_GUEST_INTERRUPTIBILITY, gi);
 }
 
 static inline void vmx_set_nmi_window_exiting(CPUState *cpu)
 {
     uint64_t val;
-    val = rvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS);
-    wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS, val |
+    val = rvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS);
+    wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS, val |
           VMCS_PRI_PROC_BASED_CTLS_NMI_WINDOW_EXITING);
 
 }
@@ -228,8 +230,8 @@ static inline void vmx_clear_nmi_window_exiting(CPUState *cpu)
 {
 
     uint64_t val;
-    val = rvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS);
-    wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS, val &
+    val = rvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS);
+    wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS, val &
           ~VMCS_PRI_PROC_BASED_CTLS_NMI_WINDOW_EXITING);
 }
 
diff --git a/target/i386/hvf/x86.c b/target/i386/hvf/x86.c
index cd045183a811..2898bb70a84e 100644
--- a/target/i386/hvf/x86.c
+++ b/target/i386/hvf/x86.c
@@ -62,11 +62,11 @@ bool x86_read_segment_descriptor(struct CPUState *cpu,
     }
 
     if (GDT_SEL == sel.ti) {
-        base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_GDTR_BASE);
-        limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_GDTR_LIMIT);
+        base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_GDTR_BASE);
+        limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_GDTR_LIMIT);
     } else {
-        base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_LDTR_BASE);
-        limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_LDTR_LIMIT);
+        base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_LDTR_BASE);
+        limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_LDTR_LIMIT);
     }
 
     if (sel.index * 8 >= limit) {
@@ -85,11 +85,11 @@ bool x86_write_segment_descriptor(struct CPUState *cpu,
     uint32_t limit;
     
     if (GDT_SEL == sel.ti) {
-        base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_GDTR_BASE);
-        limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_GDTR_LIMIT);
+        base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_GDTR_BASE);
+        limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_GDTR_LIMIT);
     } else {
-        base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_LDTR_BASE);
-        limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_LDTR_LIMIT);
+        base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_LDTR_BASE);
+        limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_LDTR_LIMIT);
     }
     
     if (sel.index * 8 >= limit) {
@@ -103,8 +103,8 @@ bool x86_write_segment_descriptor(struct CPUState *cpu,
 bool x86_read_call_gate(struct CPUState *cpu, struct x86_call_gate *idt_desc,
                         int gate)
 {
-    target_ulong base  = rvmcs(cpu->hvf_fd, VMCS_GUEST_IDTR_BASE);
-    uint32_t limit = rvmcs(cpu->hvf_fd, VMCS_GUEST_IDTR_LIMIT);
+    target_ulong base  = rvmcs(cpu->hvf->fd, VMCS_GUEST_IDTR_BASE);
+    uint32_t limit = rvmcs(cpu->hvf->fd, VMCS_GUEST_IDTR_LIMIT);
 
     memset(idt_desc, 0, sizeof(*idt_desc));
     if (gate * 8 >= limit) {
@@ -118,7 +118,7 @@ bool x86_read_call_gate(struct CPUState *cpu, struct x86_call_gate *idt_desc,
 
 bool x86_is_protected(struct CPUState *cpu)
 {
-    uint64_t cr0 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR0);
+    uint64_t cr0 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR0);
     return cr0 & CR0_PE;
 }
 
@@ -136,7 +136,7 @@ bool x86_is_v8086(struct CPUState *cpu)
 
 bool x86_is_long_mode(struct CPUState *cpu)
 {
-    return rvmcs(cpu->hvf_fd, VMCS_GUEST_IA32_EFER) & MSR_EFER_LMA;
+    return rvmcs(cpu->hvf->fd, VMCS_GUEST_IA32_EFER) & MSR_EFER_LMA;
 }
 
 bool x86_is_long64_mode(struct CPUState *cpu)
@@ -149,13 +149,13 @@ bool x86_is_long64_mode(struct CPUState *cpu)
 
 bool x86_is_paging_mode(struct CPUState *cpu)
 {
-    uint64_t cr0 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR0);
+    uint64_t cr0 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR0);
     return cr0 & CR0_PG;
 }
 
 bool x86_is_pae_enabled(struct CPUState *cpu)
 {
-    uint64_t cr4 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR4);
+    uint64_t cr4 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR4);
     return cr4 & CR4_PAE;
 }
 
diff --git a/target/i386/hvf/x86_descr.c b/target/i386/hvf/x86_descr.c
index 9f539e73f6dd..af15c06ac5db 100644
--- a/target/i386/hvf/x86_descr.c
+++ b/target/i386/hvf/x86_descr.c
@@ -48,47 +48,47 @@ static const struct vmx_segment_field {
 
 uint32_t vmx_read_segment_limit(CPUState *cpu, X86Seg seg)
 {
-    return (uint32_t)rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].limit);
+    return (uint32_t)rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].limit);
 }
 
 uint32_t vmx_read_segment_ar(CPUState *cpu, X86Seg seg)
 {
-    return (uint32_t)rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].ar_bytes);
+    return (uint32_t)rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].ar_bytes);
 }
 
 uint64_t vmx_read_segment_base(CPUState *cpu, X86Seg seg)
 {
-    return rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].base);
+    return rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].base);
 }
 
 x68_segment_selector vmx_read_segment_selector(CPUState *cpu, X86Seg seg)
 {
     x68_segment_selector sel;
-    sel.sel = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].selector);
+    sel.sel = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].selector);
     return sel;
 }
 
 void vmx_write_segment_selector(struct CPUState *cpu, x68_segment_selector selector, X86Seg seg)
 {
-    wvmcs(cpu->hvf_fd, vmx_segment_fields[seg].selector, selector.sel);
+    wvmcs(cpu->hvf->fd, vmx_segment_fields[seg].selector, selector.sel);
 }
 
 void vmx_read_segment_descriptor(struct CPUState *cpu, struct vmx_segment *desc, X86Seg seg)
 {
-    desc->sel = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].selector);
-    desc->base = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].base);
-    desc->limit = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].limit);
-    desc->ar = rvmcs(cpu->hvf_fd, vmx_segment_fields[seg].ar_bytes);
+    desc->sel = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].selector);
+    desc->base = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].base);
+    desc->limit = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].limit);
+    desc->ar = rvmcs(cpu->hvf->fd, vmx_segment_fields[seg].ar_bytes);
 }
 
 void vmx_write_segment_descriptor(CPUState *cpu, struct vmx_segment *desc, X86Seg seg)
 {
     const struct vmx_segment_field *sf = &vmx_segment_fields[seg];
 
-    wvmcs(cpu->hvf_fd, sf->base, desc->base);
-    wvmcs(cpu->hvf_fd, sf->limit, desc->limit);
-    wvmcs(cpu->hvf_fd, sf->selector, desc->sel);
-    wvmcs(cpu->hvf_fd, sf->ar_bytes, desc->ar);
+    wvmcs(cpu->hvf->fd, sf->base, desc->base);
+    wvmcs(cpu->hvf->fd, sf->limit, desc->limit);
+    wvmcs(cpu->hvf->fd, sf->selector, desc->sel);
+    wvmcs(cpu->hvf->fd, sf->ar_bytes, desc->ar);
 }
 
 void x86_segment_descriptor_to_vmx(struct CPUState *cpu, x68_segment_selector selector, struct x86_segment_descriptor *desc, struct vmx_segment *vmx_desc)
diff --git a/target/i386/hvf/x86_emu.c b/target/i386/hvf/x86_emu.c
index e52c39ddb1f0..7c8203b21fb9 100644
--- a/target/i386/hvf/x86_emu.c
+++ b/target/i386/hvf/x86_emu.c
@@ -674,7 +674,7 @@ void simulate_rdmsr(struct CPUState *cpu)
 
     switch (msr) {
     case MSR_IA32_TSC:
-        val = rdtscp() + rvmcs(cpu->hvf_fd, VMCS_TSC_OFFSET);
+        val = rdtscp() + rvmcs(cpu->hvf->fd, VMCS_TSC_OFFSET);
         break;
     case MSR_IA32_APICBASE:
         val = cpu_get_apic_base(X86_CPU(cpu)->apic_state);
@@ -683,16 +683,16 @@ void simulate_rdmsr(struct CPUState *cpu)
         val = x86_cpu->ucode_rev;
         break;
     case MSR_EFER:
-        val = rvmcs(cpu->hvf_fd, VMCS_GUEST_IA32_EFER);
+        val = rvmcs(cpu->hvf->fd, VMCS_GUEST_IA32_EFER);
         break;
     case MSR_FSBASE:
-        val = rvmcs(cpu->hvf_fd, VMCS_GUEST_FS_BASE);
+        val = rvmcs(cpu->hvf->fd, VMCS_GUEST_FS_BASE);
         break;
     case MSR_GSBASE:
-        val = rvmcs(cpu->hvf_fd, VMCS_GUEST_GS_BASE);
+        val = rvmcs(cpu->hvf->fd, VMCS_GUEST_GS_BASE);
         break;
     case MSR_KERNELGSBASE:
-        val = rvmcs(cpu->hvf_fd, VMCS_HOST_FS_BASE);
+        val = rvmcs(cpu->hvf->fd, VMCS_HOST_FS_BASE);
         break;
     case MSR_STAR:
         abort();
@@ -780,13 +780,13 @@ void simulate_wrmsr(struct CPUState *cpu)
         cpu_set_apic_base(X86_CPU(cpu)->apic_state, data);
         break;
     case MSR_FSBASE:
-        wvmcs(cpu->hvf_fd, VMCS_GUEST_FS_BASE, data);
+        wvmcs(cpu->hvf->fd, VMCS_GUEST_FS_BASE, data);
         break;
     case MSR_GSBASE:
-        wvmcs(cpu->hvf_fd, VMCS_GUEST_GS_BASE, data);
+        wvmcs(cpu->hvf->fd, VMCS_GUEST_GS_BASE, data);
         break;
     case MSR_KERNELGSBASE:
-        wvmcs(cpu->hvf_fd, VMCS_HOST_FS_BASE, data);
+        wvmcs(cpu->hvf->fd, VMCS_HOST_FS_BASE, data);
         break;
     case MSR_STAR:
         abort();
@@ -799,9 +799,9 @@ void simulate_wrmsr(struct CPUState *cpu)
         break;
     case MSR_EFER:
         /*printf("new efer %llx\n", EFER(cpu));*/
-        wvmcs(cpu->hvf_fd, VMCS_GUEST_IA32_EFER, data);
+        wvmcs(cpu->hvf->fd, VMCS_GUEST_IA32_EFER, data);
         if (data & MSR_EFER_NXE) {
-            hv_vcpu_invalidate_tlb(cpu->hvf_fd);
+            hv_vcpu_invalidate_tlb(cpu->hvf->fd);
         }
         break;
     case MSR_MTRRphysBase(0):
@@ -1425,21 +1425,21 @@ void load_regs(struct CPUState *cpu)
     CPUX86State *env = &x86_cpu->env;
 
     int i = 0;
-    RRX(env, R_EAX) = rreg(cpu->hvf_fd, HV_X86_RAX);
-    RRX(env, R_EBX) = rreg(cpu->hvf_fd, HV_X86_RBX);
-    RRX(env, R_ECX) = rreg(cpu->hvf_fd, HV_X86_RCX);
-    RRX(env, R_EDX) = rreg(cpu->hvf_fd, HV_X86_RDX);
-    RRX(env, R_ESI) = rreg(cpu->hvf_fd, HV_X86_RSI);
-    RRX(env, R_EDI) = rreg(cpu->hvf_fd, HV_X86_RDI);
-    RRX(env, R_ESP) = rreg(cpu->hvf_fd, HV_X86_RSP);
-    RRX(env, R_EBP) = rreg(cpu->hvf_fd, HV_X86_RBP);
+    RRX(env, R_EAX) = rreg(cpu->hvf->fd, HV_X86_RAX);
+    RRX(env, R_EBX) = rreg(cpu->hvf->fd, HV_X86_RBX);
+    RRX(env, R_ECX) = rreg(cpu->hvf->fd, HV_X86_RCX);
+    RRX(env, R_EDX) = rreg(cpu->hvf->fd, HV_X86_RDX);
+    RRX(env, R_ESI) = rreg(cpu->hvf->fd, HV_X86_RSI);
+    RRX(env, R_EDI) = rreg(cpu->hvf->fd, HV_X86_RDI);
+    RRX(env, R_ESP) = rreg(cpu->hvf->fd, HV_X86_RSP);
+    RRX(env, R_EBP) = rreg(cpu->hvf->fd, HV_X86_RBP);
     for (i = 8; i < 16; i++) {
-        RRX(env, i) = rreg(cpu->hvf_fd, HV_X86_RAX + i);
+        RRX(env, i) = rreg(cpu->hvf->fd, HV_X86_RAX + i);
     }
 
-    env->eflags = rreg(cpu->hvf_fd, HV_X86_RFLAGS);
+    env->eflags = rreg(cpu->hvf->fd, HV_X86_RFLAGS);
     rflags_to_lflags(env);
-    env->eip = rreg(cpu->hvf_fd, HV_X86_RIP);
+    env->eip = rreg(cpu->hvf->fd, HV_X86_RIP);
 }
 
 void store_regs(struct CPUState *cpu)
@@ -1448,20 +1448,20 @@ void store_regs(struct CPUState *cpu)
     CPUX86State *env = &x86_cpu->env;
 
     int i = 0;
-    wreg(cpu->hvf_fd, HV_X86_RAX, RAX(env));
-    wreg(cpu->hvf_fd, HV_X86_RBX, RBX(env));
-    wreg(cpu->hvf_fd, HV_X86_RCX, RCX(env));
-    wreg(cpu->hvf_fd, HV_X86_RDX, RDX(env));
-    wreg(cpu->hvf_fd, HV_X86_RSI, RSI(env));
-    wreg(cpu->hvf_fd, HV_X86_RDI, RDI(env));
-    wreg(cpu->hvf_fd, HV_X86_RBP, RBP(env));
-    wreg(cpu->hvf_fd, HV_X86_RSP, RSP(env));
+    wreg(cpu->hvf->fd, HV_X86_RAX, RAX(env));
+    wreg(cpu->hvf->fd, HV_X86_RBX, RBX(env));
+    wreg(cpu->hvf->fd, HV_X86_RCX, RCX(env));
+    wreg(cpu->hvf->fd, HV_X86_RDX, RDX(env));
+    wreg(cpu->hvf->fd, HV_X86_RSI, RSI(env));
+    wreg(cpu->hvf->fd, HV_X86_RDI, RDI(env));
+    wreg(cpu->hvf->fd, HV_X86_RBP, RBP(env));
+    wreg(cpu->hvf->fd, HV_X86_RSP, RSP(env));
     for (i = 8; i < 16; i++) {
-        wreg(cpu->hvf_fd, HV_X86_RAX + i, RRX(env, i));
+        wreg(cpu->hvf->fd, HV_X86_RAX + i, RRX(env, i));
     }
 
     lflags_to_rflags(env);
-    wreg(cpu->hvf_fd, HV_X86_RFLAGS, env->eflags);
+    wreg(cpu->hvf->fd, HV_X86_RFLAGS, env->eflags);
     macvm_set_rip(cpu, env->eip);
 }
 
diff --git a/target/i386/hvf/x86_mmu.c b/target/i386/hvf/x86_mmu.c
index 78fff0468455..e9ed0f5aa107 100644
--- a/target/i386/hvf/x86_mmu.c
+++ b/target/i386/hvf/x86_mmu.c
@@ -127,7 +127,7 @@ static bool test_pt_entry(struct CPUState *cpu, struct gpt_translation *pt,
         pt->err_code |= MMU_PAGE_PT;
     }
 
-    uint32_t cr0 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR0);
+    uint32_t cr0 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR0);
     /* check protection */
     if (cr0 & CR0_WP) {
         if (pt->write_access && !pte_write_access(pte)) {
@@ -172,7 +172,7 @@ static bool walk_gpt(struct CPUState *cpu, target_ulong addr, int err_code,
 {
     int top_level, level;
     bool is_large = false;
-    target_ulong cr3 = rvmcs(cpu->hvf_fd, VMCS_GUEST_CR3);
+    target_ulong cr3 = rvmcs(cpu->hvf->fd, VMCS_GUEST_CR3);
     uint64_t page_mask = pae ? PAE_PTE_PAGE_MASK : LEGACY_PTE_PAGE_MASK;
     
     memset(pt, 0, sizeof(*pt));
diff --git a/target/i386/hvf/x86_task.c b/target/i386/hvf/x86_task.c
index d66dfd766902..422156128b7a 100644
--- a/target/i386/hvf/x86_task.c
+++ b/target/i386/hvf/x86_task.c
@@ -62,7 +62,7 @@ static void load_state_from_tss32(CPUState *cpu, struct x86_tss_segment32 *tss)
     X86CPU *x86_cpu = X86_CPU(cpu);
     CPUX86State *env = &x86_cpu->env;
 
-    wvmcs(cpu->hvf_fd, VMCS_GUEST_CR3, tss->cr3);
+    wvmcs(cpu->hvf->fd, VMCS_GUEST_CR3, tss->cr3);
 
     env->eip = tss->eip;
     env->eflags = tss->eflags | 2;
@@ -111,11 +111,11 @@ static int task_switch_32(CPUState *cpu, x68_segment_selector tss_sel, x68_segme
 
 void vmx_handle_task_switch(CPUState *cpu, x68_segment_selector tss_sel, int reason, bool gate_valid, uint8_t gate, uint64_t gate_type)
 {
-    uint64_t rip = rreg(cpu->hvf_fd, HV_X86_RIP);
+    uint64_t rip = rreg(cpu->hvf->fd, HV_X86_RIP);
     if (!gate_valid || (gate_type != VMCS_INTR_T_HWEXCEPTION &&
                         gate_type != VMCS_INTR_T_HWINTR &&
                         gate_type != VMCS_INTR_T_NMI)) {
-        int ins_len = rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);
+        int ins_len = rvmcs(cpu->hvf->fd, VMCS_EXIT_INSTRUCTION_LENGTH);
         macvm_set_rip(cpu, rip + ins_len);
         return;
     }
@@ -174,12 +174,12 @@ void vmx_handle_task_switch(CPUState *cpu, x68_segment_selector tss_sel, int rea
         //ret = task_switch_16(cpu, tss_sel, old_tss_sel, old_tss_base, &next_tss_desc);
         VM_PANIC("task_switch_16");
 
-    macvm_set_cr0(cpu->hvf_fd, rvmcs(cpu->hvf_fd, VMCS_GUEST_CR0) | CR0_TS);
+    macvm_set_cr0(cpu->hvf->fd, rvmcs(cpu->hvf->fd, VMCS_GUEST_CR0) | CR0_TS);
     x86_segment_descriptor_to_vmx(cpu, tss_sel, &next_tss_desc, &vmx_seg);
     vmx_write_segment_descriptor(cpu, &vmx_seg, R_TR);
 
     store_regs(cpu);
 
-    hv_vcpu_invalidate_tlb(cpu->hvf_fd);
-    hv_vcpu_flush(cpu->hvf_fd);
+    hv_vcpu_invalidate_tlb(cpu->hvf->fd);
+    hv_vcpu_flush(cpu->hvf->fd);
 }
diff --git a/target/i386/hvf/x86hvf.c b/target/i386/hvf/x86hvf.c
index cc381307ab90..28cfee4f6087 100644
--- a/target/i386/hvf/x86hvf.c
+++ b/target/i386/hvf/x86hvf.c
@@ -80,7 +80,7 @@ void hvf_put_xsave(CPUState *cpu_state)
 
     x86_cpu_xsave_all_areas(X86_CPU(cpu_state), xsave);
 
-    if (hv_vcpu_write_fpstate(cpu_state->hvf_fd, (void*)xsave, 4096)) {
+    if (hv_vcpu_write_fpstate(cpu_state->hvf->fd, (void*)xsave, 4096)) {
         abort();
     }
 }
@@ -90,19 +90,19 @@ void hvf_put_segments(CPUState *cpu_state)
     CPUX86State *env = &X86_CPU(cpu_state)->env;
     struct vmx_segment seg;
     
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_IDTR_LIMIT, env->idt.limit);
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_IDTR_BASE, env->idt.base);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_IDTR_LIMIT, env->idt.limit);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_IDTR_BASE, env->idt.base);
 
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_GDTR_LIMIT, env->gdt.limit);
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_GDTR_BASE, env->gdt.base);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_GDTR_LIMIT, env->gdt.limit);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_GDTR_BASE, env->gdt.base);
 
-    /* wvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR2, env->cr[2]); */
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR3, env->cr[3]);
+    /* wvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR2, env->cr[2]); */
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR3, env->cr[3]);
     vmx_update_tpr(cpu_state);
-    wvmcs(cpu_state->hvf_fd, VMCS_GUEST_IA32_EFER, env->efer);
+    wvmcs(cpu_state->hvf->fd, VMCS_GUEST_IA32_EFER, env->efer);
 
-    macvm_set_cr4(cpu_state->hvf_fd, env->cr[4]);
-    macvm_set_cr0(cpu_state->hvf_fd, env->cr[0]);
+    macvm_set_cr4(cpu_state->hvf->fd, env->cr[4]);
+    macvm_set_cr0(cpu_state->hvf->fd, env->cr[0]);
 
     hvf_set_segment(cpu_state, &seg, &env->segs[R_CS], false);
     vmx_write_segment_descriptor(cpu_state, &seg, R_CS);
@@ -128,31 +128,31 @@ void hvf_put_segments(CPUState *cpu_state)
     hvf_set_segment(cpu_state, &seg, &env->ldt, false);
     vmx_write_segment_descriptor(cpu_state, &seg, R_LDTR);
     
-    hv_vcpu_flush(cpu_state->hvf_fd);
+    hv_vcpu_flush(cpu_state->hvf->fd);
 }
     
 void hvf_put_msrs(CPUState *cpu_state)
 {
     CPUX86State *env = &X86_CPU(cpu_state)->env;
 
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_CS,
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_CS,
                       env->sysenter_cs);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_ESP,
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_ESP,
                       env->sysenter_esp);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_EIP,
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_EIP,
                       env->sysenter_eip);
 
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_STAR, env->star);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_STAR, env->star);
 
 #ifdef TARGET_X86_64
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_CSTAR, env->cstar);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_KERNELGSBASE, env->kernelgsbase);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_FMASK, env->fmask);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_LSTAR, env->lstar);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_CSTAR, env->cstar);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_KERNELGSBASE, env->kernelgsbase);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_FMASK, env->fmask);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_LSTAR, env->lstar);
 #endif
 
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_GSBASE, env->segs[R_GS].base);
-    hv_vcpu_write_msr(cpu_state->hvf_fd, MSR_FSBASE, env->segs[R_FS].base);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_GSBASE, env->segs[R_GS].base);
+    hv_vcpu_write_msr(cpu_state->hvf->fd, MSR_FSBASE, env->segs[R_FS].base);
 }
 
 
@@ -162,7 +162,7 @@ void hvf_get_xsave(CPUState *cpu_state)
 
     xsave = X86_CPU(cpu_state)->env.xsave_buf;
 
-    if (hv_vcpu_read_fpstate(cpu_state->hvf_fd, (void*)xsave, 4096)) {
+    if (hv_vcpu_read_fpstate(cpu_state->hvf->fd, (void*)xsave, 4096)) {
         abort();
     }
 
@@ -201,17 +201,17 @@ void hvf_get_segments(CPUState *cpu_state)
     vmx_read_segment_descriptor(cpu_state, &seg, R_LDTR);
     hvf_get_segment(&env->ldt, &seg);
 
-    env->idt.limit = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_IDTR_LIMIT);
-    env->idt.base = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_IDTR_BASE);
-    env->gdt.limit = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_GDTR_LIMIT);
-    env->gdt.base = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_GDTR_BASE);
+    env->idt.limit = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_IDTR_LIMIT);
+    env->idt.base = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_IDTR_BASE);
+    env->gdt.limit = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_GDTR_LIMIT);
+    env->gdt.base = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_GDTR_BASE);
 
-    env->cr[0] = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR0);
+    env->cr[0] = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR0);
     env->cr[2] = 0;
-    env->cr[3] = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR3);
-    env->cr[4] = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_CR4);
+    env->cr[3] = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR3);
+    env->cr[4] = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_CR4);
     
-    env->efer = rvmcs(cpu_state->hvf_fd, VMCS_GUEST_IA32_EFER);
+    env->efer = rvmcs(cpu_state->hvf->fd, VMCS_GUEST_IA32_EFER);
 }
 
 void hvf_get_msrs(CPUState *cpu_state)
@@ -219,27 +219,27 @@ void hvf_get_msrs(CPUState *cpu_state)
     CPUX86State *env = &X86_CPU(cpu_state)->env;
     uint64_t tmp;
     
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_CS, &tmp);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_CS, &tmp);
     env->sysenter_cs = tmp;
     
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_ESP, &tmp);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_ESP, &tmp);
     env->sysenter_esp = tmp;
 
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_IA32_SYSENTER_EIP, &tmp);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_IA32_SYSENTER_EIP, &tmp);
     env->sysenter_eip = tmp;
 
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_STAR, &env->star);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_STAR, &env->star);
 
 #ifdef TARGET_X86_64
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_CSTAR, &env->cstar);
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_KERNELGSBASE, &env->kernelgsbase);
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_FMASK, &env->fmask);
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_LSTAR, &env->lstar);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_CSTAR, &env->cstar);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_KERNELGSBASE, &env->kernelgsbase);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_FMASK, &env->fmask);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_LSTAR, &env->lstar);
 #endif
 
-    hv_vcpu_read_msr(cpu_state->hvf_fd, MSR_IA32_APICBASE, &tmp);
+    hv_vcpu_read_msr(cpu_state->hvf->fd, MSR_IA32_APICBASE, &tmp);
     
-    env->tsc = rdtscp() + rvmcs(cpu_state->hvf_fd, VMCS_TSC_OFFSET);
+    env->tsc = rdtscp() + rvmcs(cpu_state->hvf->fd, VMCS_TSC_OFFSET);
 }
 
 int hvf_put_registers(CPUState *cpu_state)
@@ -247,26 +247,26 @@ int hvf_put_registers(CPUState *cpu_state)
     X86CPU *x86cpu = X86_CPU(cpu_state);
     CPUX86State *env = &x86cpu->env;
 
-    wreg(cpu_state->hvf_fd, HV_X86_RAX, env->regs[R_EAX]);
-    wreg(cpu_state->hvf_fd, HV_X86_RBX, env->regs[R_EBX]);
-    wreg(cpu_state->hvf_fd, HV_X86_RCX, env->regs[R_ECX]);
-    wreg(cpu_state->hvf_fd, HV_X86_RDX, env->regs[R_EDX]);
-    wreg(cpu_state->hvf_fd, HV_X86_RBP, env->regs[R_EBP]);
-    wreg(cpu_state->hvf_fd, HV_X86_RSP, env->regs[R_ESP]);
-    wreg(cpu_state->hvf_fd, HV_X86_RSI, env->regs[R_ESI]);
-    wreg(cpu_state->hvf_fd, HV_X86_RDI, env->regs[R_EDI]);
-    wreg(cpu_state->hvf_fd, HV_X86_R8, env->regs[8]);
-    wreg(cpu_state->hvf_fd, HV_X86_R9, env->regs[9]);
-    wreg(cpu_state->hvf_fd, HV_X86_R10, env->regs[10]);
-    wreg(cpu_state->hvf_fd, HV_X86_R11, env->regs[11]);
-    wreg(cpu_state->hvf_fd, HV_X86_R12, env->regs[12]);
-    wreg(cpu_state->hvf_fd, HV_X86_R13, env->regs[13]);
-    wreg(cpu_state->hvf_fd, HV_X86_R14, env->regs[14]);
-    wreg(cpu_state->hvf_fd, HV_X86_R15, env->regs[15]);
-    wreg(cpu_state->hvf_fd, HV_X86_RFLAGS, env->eflags);
-    wreg(cpu_state->hvf_fd, HV_X86_RIP, env->eip);
+    wreg(cpu_state->hvf->fd, HV_X86_RAX, env->regs[R_EAX]);
+    wreg(cpu_state->hvf->fd, HV_X86_RBX, env->regs[R_EBX]);
+    wreg(cpu_state->hvf->fd, HV_X86_RCX, env->regs[R_ECX]);
+    wreg(cpu_state->hvf->fd, HV_X86_RDX, env->regs[R_EDX]);
+    wreg(cpu_state->hvf->fd, HV_X86_RBP, env->regs[R_EBP]);
+    wreg(cpu_state->hvf->fd, HV_X86_RSP, env->regs[R_ESP]);
+    wreg(cpu_state->hvf->fd, HV_X86_RSI, env->regs[R_ESI]);
+    wreg(cpu_state->hvf->fd, HV_X86_RDI, env->regs[R_EDI]);
+    wreg(cpu_state->hvf->fd, HV_X86_R8, env->regs[8]);
+    wreg(cpu_state->hvf->fd, HV_X86_R9, env->regs[9]);
+    wreg(cpu_state->hvf->fd, HV_X86_R10, env->regs[10]);
+    wreg(cpu_state->hvf->fd, HV_X86_R11, env->regs[11]);
+    wreg(cpu_state->hvf->fd, HV_X86_R12, env->regs[12]);
+    wreg(cpu_state->hvf->fd, HV_X86_R13, env->regs[13]);
+    wreg(cpu_state->hvf->fd, HV_X86_R14, env->regs[14]);
+    wreg(cpu_state->hvf->fd, HV_X86_R15, env->regs[15]);
+    wreg(cpu_state->hvf->fd, HV_X86_RFLAGS, env->eflags);
+    wreg(cpu_state->hvf->fd, HV_X86_RIP, env->eip);
    
-    wreg(cpu_state->hvf_fd, HV_X86_XCR0, env->xcr0);
+    wreg(cpu_state->hvf->fd, HV_X86_XCR0, env->xcr0);
     
     hvf_put_xsave(cpu_state);
     
@@ -274,14 +274,14 @@ int hvf_put_registers(CPUState *cpu_state)
     
     hvf_put_msrs(cpu_state);
     
-    wreg(cpu_state->hvf_fd, HV_X86_DR0, env->dr[0]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR1, env->dr[1]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR2, env->dr[2]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR3, env->dr[3]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR4, env->dr[4]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR5, env->dr[5]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR6, env->dr[6]);
-    wreg(cpu_state->hvf_fd, HV_X86_DR7, env->dr[7]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR0, env->dr[0]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR1, env->dr[1]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR2, env->dr[2]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR3, env->dr[3]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR4, env->dr[4]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR5, env->dr[5]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR6, env->dr[6]);
+    wreg(cpu_state->hvf->fd, HV_X86_DR7, env->dr[7]);
     
     return 0;
 }
@@ -291,40 +291,40 @@ int hvf_get_registers(CPUState *cpu_state)
     X86CPU *x86cpu = X86_CPU(cpu_state);
     CPUX86State *env = &x86cpu->env;
 
-    env->regs[R_EAX] = rreg(cpu_state->hvf_fd, HV_X86_RAX);
-    env->regs[R_EBX] = rreg(cpu_state->hvf_fd, HV_X86_RBX);
-    env->regs[R_ECX] = rreg(cpu_state->hvf_fd, HV_X86_RCX);
-    env->regs[R_EDX] = rreg(cpu_state->hvf_fd, HV_X86_RDX);
-    env->regs[R_EBP] = rreg(cpu_state->hvf_fd, HV_X86_RBP);
-    env->regs[R_ESP] = rreg(cpu_state->hvf_fd, HV_X86_RSP);
-    env->regs[R_ESI] = rreg(cpu_state->hvf_fd, HV_X86_RSI);
-    env->regs[R_EDI] = rreg(cpu_state->hvf_fd, HV_X86_RDI);
-    env->regs[8] = rreg(cpu_state->hvf_fd, HV_X86_R8);
-    env->regs[9] = rreg(cpu_state->hvf_fd, HV_X86_R9);
-    env->regs[10] = rreg(cpu_state->hvf_fd, HV_X86_R10);
-    env->regs[11] = rreg(cpu_state->hvf_fd, HV_X86_R11);
-    env->regs[12] = rreg(cpu_state->hvf_fd, HV_X86_R12);
-    env->regs[13] = rreg(cpu_state->hvf_fd, HV_X86_R13);
-    env->regs[14] = rreg(cpu_state->hvf_fd, HV_X86_R14);
-    env->regs[15] = rreg(cpu_state->hvf_fd, HV_X86_R15);
+    env->regs[R_EAX] = rreg(cpu_state->hvf->fd, HV_X86_RAX);
+    env->regs[R_EBX] = rreg(cpu_state->hvf->fd, HV_X86_RBX);
+    env->regs[R_ECX] = rreg(cpu_state->hvf->fd, HV_X86_RCX);
+    env->regs[R_EDX] = rreg(cpu_state->hvf->fd, HV_X86_RDX);
+    env->regs[R_EBP] = rreg(cpu_state->hvf->fd, HV_X86_RBP);
+    env->regs[R_ESP] = rreg(cpu_state->hvf->fd, HV_X86_RSP);
+    env->regs[R_ESI] = rreg(cpu_state->hvf->fd, HV_X86_RSI);
+    env->regs[R_EDI] = rreg(cpu_state->hvf->fd, HV_X86_RDI);
+    env->regs[8] = rreg(cpu_state->hvf->fd, HV_X86_R8);
+    env->regs[9] = rreg(cpu_state->hvf->fd, HV_X86_R9);
+    env->regs[10] = rreg(cpu_state->hvf->fd, HV_X86_R10);
+    env->regs[11] = rreg(cpu_state->hvf->fd, HV_X86_R11);
+    env->regs[12] = rreg(cpu_state->hvf->fd, HV_X86_R12);
+    env->regs[13] = rreg(cpu_state->hvf->fd, HV_X86_R13);
+    env->regs[14] = rreg(cpu_state->hvf->fd, HV_X86_R14);
+    env->regs[15] = rreg(cpu_state->hvf->fd, HV_X86_R15);
     
-    env->eflags = rreg(cpu_state->hvf_fd, HV_X86_RFLAGS);
-    env->eip = rreg(cpu_state->hvf_fd, HV_X86_RIP);
+    env->eflags = rreg(cpu_state->hvf->fd, HV_X86_RFLAGS);
+    env->eip = rreg(cpu_state->hvf->fd, HV_X86_RIP);
    
     hvf_get_xsave(cpu_state);
-    env->xcr0 = rreg(cpu_state->hvf_fd, HV_X86_XCR0);
+    env->xcr0 = rreg(cpu_state->hvf->fd, HV_X86_XCR0);
     
     hvf_get_segments(cpu_state);
     hvf_get_msrs(cpu_state);
     
-    env->dr[0] = rreg(cpu_state->hvf_fd, HV_X86_DR0);
-    env->dr[1] = rreg(cpu_state->hvf_fd, HV_X86_DR1);
-    env->dr[2] = rreg(cpu_state->hvf_fd, HV_X86_DR2);
-    env->dr[3] = rreg(cpu_state->hvf_fd, HV_X86_DR3);
-    env->dr[4] = rreg(cpu_state->hvf_fd, HV_X86_DR4);
-    env->dr[5] = rreg(cpu_state->hvf_fd, HV_X86_DR5);
-    env->dr[6] = rreg(cpu_state->hvf_fd, HV_X86_DR6);
-    env->dr[7] = rreg(cpu_state->hvf_fd, HV_X86_DR7);
+    env->dr[0] = rreg(cpu_state->hvf->fd, HV_X86_DR0);
+    env->dr[1] = rreg(cpu_state->hvf->fd, HV_X86_DR1);
+    env->dr[2] = rreg(cpu_state->hvf->fd, HV_X86_DR2);
+    env->dr[3] = rreg(cpu_state->hvf->fd, HV_X86_DR3);
+    env->dr[4] = rreg(cpu_state->hvf->fd, HV_X86_DR4);
+    env->dr[5] = rreg(cpu_state->hvf->fd, HV_X86_DR5);
+    env->dr[6] = rreg(cpu_state->hvf->fd, HV_X86_DR6);
+    env->dr[7] = rreg(cpu_state->hvf->fd, HV_X86_DR7);
     
     x86_update_hflags(env);
     return 0;
@@ -333,16 +333,16 @@ int hvf_get_registers(CPUState *cpu_state)
 static void vmx_set_int_window_exiting(CPUState *cpu)
 {
      uint64_t val;
-     val = rvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS);
-     wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS, val |
+     val = rvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS);
+     wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS, val |
              VMCS_PRI_PROC_BASED_CTLS_INT_WINDOW_EXITING);
 }
 
 void vmx_clear_int_window_exiting(CPUState *cpu)
 {
      uint64_t val;
-     val = rvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS);
-     wvmcs(cpu->hvf_fd, VMCS_PRI_PROC_BASED_CTLS, val &
+     val = rvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS);
+     wvmcs(cpu->hvf->fd, VMCS_PRI_PROC_BASED_CTLS, val &
              ~VMCS_PRI_PROC_BASED_CTLS_INT_WINDOW_EXITING);
 }
 
@@ -378,7 +378,7 @@ bool hvf_inject_interrupts(CPUState *cpu_state)
     uint64_t info = 0;
     if (have_event) {
         info = vector | intr_type | VMCS_INTR_VALID;
-        uint64_t reason = rvmcs(cpu_state->hvf_fd, VMCS_EXIT_REASON);
+        uint64_t reason = rvmcs(cpu_state->hvf->fd, VMCS_EXIT_REASON);
         if (env->nmi_injected && reason != EXIT_REASON_TASK_SWITCH) {
             vmx_clear_nmi_blocking(cpu_state);
         }
@@ -387,17 +387,17 @@ bool hvf_inject_interrupts(CPUState *cpu_state)
             info &= ~(1 << 12); /* clear undefined bit */
             if (intr_type == VMCS_INTR_T_SWINTR ||
                 intr_type == VMCS_INTR_T_SWEXCEPTION) {
-                wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_INST_LENGTH, env->ins_len);
+                wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_INST_LENGTH, env->ins_len);
             }
             
             if (env->has_error_code) {
-                wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_EXCEPTION_ERROR,
+                wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_EXCEPTION_ERROR,
                       env->error_code);
                 /* Indicate that VMCS_ENTRY_EXCEPTION_ERROR is valid */
                 info |= VMCS_INTR_DEL_ERRCODE;
             }
             /*printf("reinject  %lx err %d\n", info, err);*/
-            wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_INTR_INFO, info);
+            wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_INTR_INFO, info);
         };
     }
 
@@ -405,7 +405,7 @@ bool hvf_inject_interrupts(CPUState *cpu_state)
         if (!(env->hflags2 & HF2_NMI_MASK) && !(info & VMCS_INTR_VALID)) {
             cpu_state->interrupt_request &= ~CPU_INTERRUPT_NMI;
             info = VMCS_INTR_VALID | VMCS_INTR_T_NMI | EXCP02_NMI;
-            wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_INTR_INFO, info);
+            wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_INTR_INFO, info);
         } else {
             vmx_set_nmi_window_exiting(cpu_state);
         }
@@ -417,7 +417,7 @@ bool hvf_inject_interrupts(CPUState *cpu_state)
         int line = cpu_get_pic_interrupt(&x86cpu->env);
         cpu_state->interrupt_request &= ~CPU_INTERRUPT_HARD;
         if (line >= 0) {
-            wvmcs(cpu_state->hvf_fd, VMCS_ENTRY_INTR_INFO, line |
+            wvmcs(cpu_state->hvf->fd, VMCS_ENTRY_INTR_INFO, line |
                   VMCS_INTR_VALID | VMCS_INTR_T_HWINTR);
         }
     }
@@ -433,7 +433,7 @@ int hvf_process_events(CPUState *cpu_state)
     X86CPU *cpu = X86_CPU(cpu_state);
     CPUX86State *env = &cpu->env;
 
-    env->eflags = rreg(cpu_state->hvf_fd, HV_X86_RFLAGS);
+    env->eflags = rreg(cpu_state->hvf->fd, HV_X86_RFLAGS);
 
     if (cpu_state->interrupt_request & CPU_INTERRUPT_INIT) {
         cpu_synchronize_state(cpu_state);

From 3bf12f1f4046f275e5cfaf6aefe83bd11de3a3c3 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:46 +0200
Subject: [PATCH 080/180] hvf: Simplify post reset/init/loadvm hooks

The hooks we have that call us after reset, init and loadvm really all
just want to say "The reference of all register state is in the QEMU
vcpu struct, please push it".

We already have a working pushing mechanism though called cpu->vcpu_dirty,
so we can just reuse that for all of the above, syncing state properly the
next time we actually execute a vCPU.

This fixes PSCI resets on ARM, as they modify CPU state even after the
post init call has completed, but before we execute the vCPU again.

To also make the scheme work for x86, we have to make sure we don't
move stale eflags into our env when the vcpu state is dirty.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reviewed-by: Roman Bolshakov <r.bolshakov@yadro.com>
Tested-by: Roman Bolshakov <r.bolshakov@yadro.com>
Message-Id: <20210519202253.76782-13-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c | 27 +++++++--------------------
 target/i386/hvf/x86hvf.c  |  5 ++++-
 2 files changed, 11 insertions(+), 21 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index ded918c443d9..d1691be9896e 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -205,39 +205,26 @@ static void hvf_cpu_synchronize_state(CPUState *cpu)
     }
 }
 
-static void do_hvf_cpu_synchronize_post_reset(CPUState *cpu,
-                                              run_on_cpu_data arg)
+static void do_hvf_cpu_synchronize_set_dirty(CPUState *cpu,
+                                             run_on_cpu_data arg)
 {
-    hvf_put_registers(cpu);
-    cpu->vcpu_dirty = false;
+    /* QEMU state is the reference, push it to HVF now and on next entry */
+    cpu->vcpu_dirty = true;
 }
 
 static void hvf_cpu_synchronize_post_reset(CPUState *cpu)
 {
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
-}
-
-static void do_hvf_cpu_synchronize_post_init(CPUState *cpu,
-                                             run_on_cpu_data arg)
-{
-    hvf_put_registers(cpu);
-    cpu->vcpu_dirty = false;
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_set_dirty, RUN_ON_CPU_NULL);
 }
 
 static void hvf_cpu_synchronize_post_init(CPUState *cpu)
 {
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
-}
-
-static void do_hvf_cpu_synchronize_pre_loadvm(CPUState *cpu,
-                                              run_on_cpu_data arg)
-{
-    cpu->vcpu_dirty = true;
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_set_dirty, RUN_ON_CPU_NULL);
 }
 
 static void hvf_cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
-    run_on_cpu(cpu, do_hvf_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
+    run_on_cpu(cpu, do_hvf_cpu_synchronize_set_dirty, RUN_ON_CPU_NULL);
 }
 
 static void hvf_set_dirty_tracking(MemoryRegionSection *section, bool on)
diff --git a/target/i386/hvf/x86hvf.c b/target/i386/hvf/x86hvf.c
index 28cfee4f6087..2ced2c24784e 100644
--- a/target/i386/hvf/x86hvf.c
+++ b/target/i386/hvf/x86hvf.c
@@ -433,7 +433,10 @@ int hvf_process_events(CPUState *cpu_state)
     X86CPU *cpu = X86_CPU(cpu_state);
     CPUX86State *env = &cpu->env;
 
-    env->eflags = rreg(cpu_state->hvf->fd, HV_X86_RFLAGS);
+    if (!cpu_state->vcpu_dirty) {
+        /* light weight sync for CPU_INTERRUPT_HARD and IF_MASK */
+        env->eflags = rreg(cpu_state->hvf->fd, HV_X86_RFLAGS);
+    }
 
     if (cpu_state->interrupt_request & CPU_INTERRUPT_INIT) {
         cpu_synchronize_state(cpu_state);

From 30adfa9b1d35b35e04185d8f900250524f9db672 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:47 +0200
Subject: [PATCH 081/180] hvf: Add Apple Silicon support

With Apple Silicon available to the masses, it's a good time to add support
for driving its virtualization extensions from QEMU.

This patch adds all necessary architecture specific code to get basic VMs
working. It's still pretty raw, but definitely functional.

Known limitations:

  - Vtimer acknowledgement is hacky
  - Should implement more sysregs and fault on invalid ones then
  - WFI handling is missing, need to marry it with vtimer

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reviewed-by: Roman Bolshakov <r.bolshakov@yadro.com>

Message-Id: <20210519202253.76782-14-agraf@csgraf.de>
---
 MAINTAINERS                 |   5 +
 accel/hvf/hvf-accel-ops.c   |  14 +
 include/sysemu/hvf_int.h    |   9 +-
 meson.build                 |   1 +
 target/arm/hvf/hvf.c        | 703 ++++++++++++++++++++++++++++++++++++
 target/arm/hvf/trace-events |  10 +
 6 files changed, 741 insertions(+), 1 deletion(-)
 create mode 100644 target/arm/hvf/hvf.c
 create mode 100644 target/arm/hvf/trace-events

diff --git a/MAINTAINERS b/MAINTAINERS
index 6c87b683924d..9612998dde74 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -431,6 +431,11 @@ F: accel/accel-*.c
 F: accel/Makefile.objs
 F: accel/stubs/Makefile.objs
 
+Apple Silicon HVF CPUs
+M: Alexander Graf <agraf@csgraf.de>
+S: Maintained
+F: target/arm/hvf/
+
 X86 HVF CPUs
 M: Cameron Esfahani <dirty@apple.com>
 M: Roman Bolshakov <r.bolshakov@yadro.com>
diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index d1691be9896e..48e402ef57bf 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -60,6 +60,10 @@
 
 HVFState *hvf_state;
 
+#ifdef __aarch64__
+#define HV_VM_DEFAULT NULL
+#endif
+
 /* Memory slots */
 
 hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
@@ -375,7 +379,11 @@ static int hvf_init_vcpu(CPUState *cpu)
     pthread_sigmask(SIG_BLOCK, NULL, &set);
     sigdelset(&set, SIG_IPI);
 
+#ifdef __aarch64__
+    r = hv_vcpu_create(&cpu->hvf->fd, (hv_vcpu_exit_t **)&cpu->hvf->exit, NULL);
+#else
     r = hv_vcpu_create((hv_vcpuid_t *)&cpu->hvf->fd, HV_VCPU_DEFAULT);
+#endif
     cpu->vcpu_dirty = 1;
     assert_hvf_ok(r);
 
@@ -446,11 +454,17 @@ static void hvf_start_vcpu_thread(CPUState *cpu)
                        cpu, QEMU_THREAD_JOINABLE);
 }
 
+__attribute__((weak)) void hvf_kick_vcpu_thread(CPUState *cpu)
+{
+    cpus_kick_thread(cpu);
+}
+
 static void hvf_accel_ops_class_init(ObjectClass *oc, void *data)
 {
     AccelOpsClass *ops = ACCEL_OPS_CLASS(oc);
 
     ops->create_vcpu_thread = hvf_start_vcpu_thread;
+    ops->kick_vcpu_thread = hvf_kick_vcpu_thread;
 
     ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
     ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 8b66a4e7d0dc..e52d67ed5c74 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -11,7 +11,11 @@
 #ifndef HVF_INT_H
 #define HVF_INT_H
 
+#ifdef __aarch64__
+#include <Hypervisor/Hypervisor.h>
+#else
 #include <Hypervisor/hv.h>
+#endif
 
 /* hvf_slot flags */
 #define HVF_SLOT_LOG (1 << 0)
@@ -44,7 +48,9 @@ struct HVFState {
 extern HVFState *hvf_state;
 
 struct hvf_vcpu_state {
-    int fd;
+    uint64_t fd;
+    void *exit;
+    bool vtimer_masked;
 };
 
 void assert_hvf_ok(hv_return_t ret);
@@ -54,5 +60,6 @@ int hvf_vcpu_exec(CPUState *);
 hvf_slot *hvf_find_overlap_slot(uint64_t, uint64_t);
 int hvf_put_registers(CPUState *);
 int hvf_get_registers(CPUState *);
+void hvf_kick_vcpu_thread(CPUState *cpu);
 
 #endif
diff --git a/meson.build b/meson.build
index 632b380738d3..9277a06bc601 100644
--- a/meson.build
+++ b/meson.build
@@ -1860,6 +1860,7 @@ if have_system or have_user
     'accel/tcg',
     'hw/core',
     'target/arm',
+    'target/arm/hvf',
     'target/hppa',
     'target/i386',
     'target/i386/kvm',
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
new file mode 100644
index 000000000000..3934c05979d5
--- /dev/null
+++ b/target/arm/hvf/hvf.c
@@ -0,0 +1,703 @@
+/*
+ * QEMU Hypervisor.framework support for Apple Silicon
+
+ * Copyright 2020 Alexander Graf <agraf@csgraf.de>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "qemu/error-report.h"
+
+#include "sysemu/runstate.h"
+#include "sysemu/hvf.h"
+#include "sysemu/hvf_int.h"
+#include "sysemu/hw_accel.h"
+
+#include "exec/address-spaces.h"
+#include "hw/irq.h"
+#include "qemu/main-loop.h"
+#include "sysemu/cpus.h"
+#include "target/arm/cpu.h"
+#include "target/arm/internals.h"
+#include "trace/trace-target_arm_hvf.h"
+
+#define HVF_SYSREG(crn, crm, op0, op1, op2) \
+        ENCODE_AA64_CP_REG(CP_REG_ARM64_SYSREG_CP, crn, crm, op0, op1, op2)
+#define PL1_WRITE_MASK 0x4
+
+#define SYSREG(op0, op1, crn, crm, op2) \
+    ((op0 << 20) | (op2 << 17) | (op1 << 14) | (crn << 10) | (crm << 1))
+#define SYSREG_MASK           SYSREG(0x3, 0x7, 0xf, 0xf, 0x7)
+#define SYSREG_CNTPCT_EL0     SYSREG(3, 3, 14, 0, 1)
+#define SYSREG_PMCCNTR_EL0    SYSREG(3, 3, 9, 13, 0)
+
+#define WFX_IS_WFE (1 << 0)
+
+#define TMR_CTL_ENABLE  (1 << 0)
+#define TMR_CTL_IMASK   (1 << 1)
+#define TMR_CTL_ISTATUS (1 << 2)
+
+struct hvf_reg_match {
+    int reg;
+    uint64_t offset;
+};
+
+static const struct hvf_reg_match hvf_reg_match[] = {
+    { HV_REG_X0,   offsetof(CPUARMState, xregs[0]) },
+    { HV_REG_X1,   offsetof(CPUARMState, xregs[1]) },
+    { HV_REG_X2,   offsetof(CPUARMState, xregs[2]) },
+    { HV_REG_X3,   offsetof(CPUARMState, xregs[3]) },
+    { HV_REG_X4,   offsetof(CPUARMState, xregs[4]) },
+    { HV_REG_X5,   offsetof(CPUARMState, xregs[5]) },
+    { HV_REG_X6,   offsetof(CPUARMState, xregs[6]) },
+    { HV_REG_X7,   offsetof(CPUARMState, xregs[7]) },
+    { HV_REG_X8,   offsetof(CPUARMState, xregs[8]) },
+    { HV_REG_X9,   offsetof(CPUARMState, xregs[9]) },
+    { HV_REG_X10,  offsetof(CPUARMState, xregs[10]) },
+    { HV_REG_X11,  offsetof(CPUARMState, xregs[11]) },
+    { HV_REG_X12,  offsetof(CPUARMState, xregs[12]) },
+    { HV_REG_X13,  offsetof(CPUARMState, xregs[13]) },
+    { HV_REG_X14,  offsetof(CPUARMState, xregs[14]) },
+    { HV_REG_X15,  offsetof(CPUARMState, xregs[15]) },
+    { HV_REG_X16,  offsetof(CPUARMState, xregs[16]) },
+    { HV_REG_X17,  offsetof(CPUARMState, xregs[17]) },
+    { HV_REG_X18,  offsetof(CPUARMState, xregs[18]) },
+    { HV_REG_X19,  offsetof(CPUARMState, xregs[19]) },
+    { HV_REG_X20,  offsetof(CPUARMState, xregs[20]) },
+    { HV_REG_X21,  offsetof(CPUARMState, xregs[21]) },
+    { HV_REG_X22,  offsetof(CPUARMState, xregs[22]) },
+    { HV_REG_X23,  offsetof(CPUARMState, xregs[23]) },
+    { HV_REG_X24,  offsetof(CPUARMState, xregs[24]) },
+    { HV_REG_X25,  offsetof(CPUARMState, xregs[25]) },
+    { HV_REG_X26,  offsetof(CPUARMState, xregs[26]) },
+    { HV_REG_X27,  offsetof(CPUARMState, xregs[27]) },
+    { HV_REG_X28,  offsetof(CPUARMState, xregs[28]) },
+    { HV_REG_X29,  offsetof(CPUARMState, xregs[29]) },
+    { HV_REG_X30,  offsetof(CPUARMState, xregs[30]) },
+    { HV_REG_PC,   offsetof(CPUARMState, pc) },
+};
+
+static const struct hvf_reg_match hvf_fpreg_match[] = {
+    { HV_SIMD_FP_REG_Q0,  offsetof(CPUARMState, vfp.zregs[0]) },
+    { HV_SIMD_FP_REG_Q1,  offsetof(CPUARMState, vfp.zregs[1]) },
+    { HV_SIMD_FP_REG_Q2,  offsetof(CPUARMState, vfp.zregs[2]) },
+    { HV_SIMD_FP_REG_Q3,  offsetof(CPUARMState, vfp.zregs[3]) },
+    { HV_SIMD_FP_REG_Q4,  offsetof(CPUARMState, vfp.zregs[4]) },
+    { HV_SIMD_FP_REG_Q5,  offsetof(CPUARMState, vfp.zregs[5]) },
+    { HV_SIMD_FP_REG_Q6,  offsetof(CPUARMState, vfp.zregs[6]) },
+    { HV_SIMD_FP_REG_Q7,  offsetof(CPUARMState, vfp.zregs[7]) },
+    { HV_SIMD_FP_REG_Q8,  offsetof(CPUARMState, vfp.zregs[8]) },
+    { HV_SIMD_FP_REG_Q9,  offsetof(CPUARMState, vfp.zregs[9]) },
+    { HV_SIMD_FP_REG_Q10, offsetof(CPUARMState, vfp.zregs[10]) },
+    { HV_SIMD_FP_REG_Q11, offsetof(CPUARMState, vfp.zregs[11]) },
+    { HV_SIMD_FP_REG_Q12, offsetof(CPUARMState, vfp.zregs[12]) },
+    { HV_SIMD_FP_REG_Q13, offsetof(CPUARMState, vfp.zregs[13]) },
+    { HV_SIMD_FP_REG_Q14, offsetof(CPUARMState, vfp.zregs[14]) },
+    { HV_SIMD_FP_REG_Q15, offsetof(CPUARMState, vfp.zregs[15]) },
+    { HV_SIMD_FP_REG_Q16, offsetof(CPUARMState, vfp.zregs[16]) },
+    { HV_SIMD_FP_REG_Q17, offsetof(CPUARMState, vfp.zregs[17]) },
+    { HV_SIMD_FP_REG_Q18, offsetof(CPUARMState, vfp.zregs[18]) },
+    { HV_SIMD_FP_REG_Q19, offsetof(CPUARMState, vfp.zregs[19]) },
+    { HV_SIMD_FP_REG_Q20, offsetof(CPUARMState, vfp.zregs[20]) },
+    { HV_SIMD_FP_REG_Q21, offsetof(CPUARMState, vfp.zregs[21]) },
+    { HV_SIMD_FP_REG_Q22, offsetof(CPUARMState, vfp.zregs[22]) },
+    { HV_SIMD_FP_REG_Q23, offsetof(CPUARMState, vfp.zregs[23]) },
+    { HV_SIMD_FP_REG_Q24, offsetof(CPUARMState, vfp.zregs[24]) },
+    { HV_SIMD_FP_REG_Q25, offsetof(CPUARMState, vfp.zregs[25]) },
+    { HV_SIMD_FP_REG_Q26, offsetof(CPUARMState, vfp.zregs[26]) },
+    { HV_SIMD_FP_REG_Q27, offsetof(CPUARMState, vfp.zregs[27]) },
+    { HV_SIMD_FP_REG_Q28, offsetof(CPUARMState, vfp.zregs[28]) },
+    { HV_SIMD_FP_REG_Q29, offsetof(CPUARMState, vfp.zregs[29]) },
+    { HV_SIMD_FP_REG_Q30, offsetof(CPUARMState, vfp.zregs[30]) },
+    { HV_SIMD_FP_REG_Q31, offsetof(CPUARMState, vfp.zregs[31]) },
+};
+
+struct hvf_sreg_match {
+    int reg;
+    uint32_t key;
+};
+
+static const struct hvf_sreg_match hvf_sreg_match[] = {
+    { HV_SYS_REG_DBGBVR0_EL1, HVF_SYSREG(0, 0, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR0_EL1, HVF_SYSREG(0, 0, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR0_EL1, HVF_SYSREG(0, 0, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR0_EL1, HVF_SYSREG(0, 0, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR1_EL1, HVF_SYSREG(0, 1, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR1_EL1, HVF_SYSREG(0, 1, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR1_EL1, HVF_SYSREG(0, 1, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR1_EL1, HVF_SYSREG(0, 1, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR2_EL1, HVF_SYSREG(0, 2, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR2_EL1, HVF_SYSREG(0, 2, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR2_EL1, HVF_SYSREG(0, 2, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR2_EL1, HVF_SYSREG(0, 2, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR3_EL1, HVF_SYSREG(0, 3, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR3_EL1, HVF_SYSREG(0, 3, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR3_EL1, HVF_SYSREG(0, 3, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR3_EL1, HVF_SYSREG(0, 3, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR4_EL1, HVF_SYSREG(0, 4, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR4_EL1, HVF_SYSREG(0, 4, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR4_EL1, HVF_SYSREG(0, 4, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR4_EL1, HVF_SYSREG(0, 4, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR5_EL1, HVF_SYSREG(0, 5, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR5_EL1, HVF_SYSREG(0, 5, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR5_EL1, HVF_SYSREG(0, 5, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR5_EL1, HVF_SYSREG(0, 5, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR6_EL1, HVF_SYSREG(0, 6, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR6_EL1, HVF_SYSREG(0, 6, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR6_EL1, HVF_SYSREG(0, 6, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR6_EL1, HVF_SYSREG(0, 6, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR7_EL1, HVF_SYSREG(0, 7, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR7_EL1, HVF_SYSREG(0, 7, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR7_EL1, HVF_SYSREG(0, 7, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR7_EL1, HVF_SYSREG(0, 7, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR8_EL1, HVF_SYSREG(0, 8, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR8_EL1, HVF_SYSREG(0, 8, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR8_EL1, HVF_SYSREG(0, 8, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR8_EL1, HVF_SYSREG(0, 8, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR9_EL1, HVF_SYSREG(0, 9, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR9_EL1, HVF_SYSREG(0, 9, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR9_EL1, HVF_SYSREG(0, 9, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR9_EL1, HVF_SYSREG(0, 9, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR10_EL1, HVF_SYSREG(0, 10, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR10_EL1, HVF_SYSREG(0, 10, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR10_EL1, HVF_SYSREG(0, 10, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR10_EL1, HVF_SYSREG(0, 10, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR11_EL1, HVF_SYSREG(0, 11, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR11_EL1, HVF_SYSREG(0, 11, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR11_EL1, HVF_SYSREG(0, 11, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR11_EL1, HVF_SYSREG(0, 11, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR12_EL1, HVF_SYSREG(0, 12, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR12_EL1, HVF_SYSREG(0, 12, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR12_EL1, HVF_SYSREG(0, 12, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR12_EL1, HVF_SYSREG(0, 12, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR13_EL1, HVF_SYSREG(0, 13, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR13_EL1, HVF_SYSREG(0, 13, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR13_EL1, HVF_SYSREG(0, 13, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR13_EL1, HVF_SYSREG(0, 13, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR14_EL1, HVF_SYSREG(0, 14, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR14_EL1, HVF_SYSREG(0, 14, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR14_EL1, HVF_SYSREG(0, 14, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR14_EL1, HVF_SYSREG(0, 14, 14, 0, 7) },
+
+    { HV_SYS_REG_DBGBVR15_EL1, HVF_SYSREG(0, 15, 14, 0, 4) },
+    { HV_SYS_REG_DBGBCR15_EL1, HVF_SYSREG(0, 15, 14, 0, 5) },
+    { HV_SYS_REG_DBGWVR15_EL1, HVF_SYSREG(0, 15, 14, 0, 6) },
+    { HV_SYS_REG_DBGWCR15_EL1, HVF_SYSREG(0, 15, 14, 0, 7) },
+
+#ifdef SYNC_NO_RAW_REGS
+    /*
+     * The registers below are manually synced on init because they are
+     * marked as NO_RAW. We still list them to make number space sync easier.
+     */
+    { HV_SYS_REG_MDCCINT_EL1, HVF_SYSREG(0, 2, 2, 0, 0) },
+    { HV_SYS_REG_MIDR_EL1, HVF_SYSREG(0, 0, 3, 0, 0) },
+    { HV_SYS_REG_MPIDR_EL1, HVF_SYSREG(0, 0, 3, 0, 5) },
+    { HV_SYS_REG_ID_AA64PFR0_EL1, HVF_SYSREG(0, 4, 3, 0, 0) },
+#endif
+    { HV_SYS_REG_ID_AA64PFR1_EL1, HVF_SYSREG(0, 4, 3, 0, 2) },
+    { HV_SYS_REG_ID_AA64DFR0_EL1, HVF_SYSREG(0, 5, 3, 0, 0) },
+    { HV_SYS_REG_ID_AA64DFR1_EL1, HVF_SYSREG(0, 5, 3, 0, 1) },
+    { HV_SYS_REG_ID_AA64ISAR0_EL1, HVF_SYSREG(0, 6, 3, 0, 0) },
+    { HV_SYS_REG_ID_AA64ISAR1_EL1, HVF_SYSREG(0, 6, 3, 0, 1) },
+#ifdef SYNC_NO_MMFR0
+    /* We keep the hardware MMFR0 around. HW limits are there anyway */
+    { HV_SYS_REG_ID_AA64MMFR0_EL1, HVF_SYSREG(0, 7, 3, 0, 0) },
+#endif
+    { HV_SYS_REG_ID_AA64MMFR1_EL1, HVF_SYSREG(0, 7, 3, 0, 1) },
+    { HV_SYS_REG_ID_AA64MMFR2_EL1, HVF_SYSREG(0, 7, 3, 0, 2) },
+
+    { HV_SYS_REG_MDSCR_EL1, HVF_SYSREG(0, 2, 2, 0, 2) },
+    { HV_SYS_REG_SCTLR_EL1, HVF_SYSREG(1, 0, 3, 0, 0) },
+    { HV_SYS_REG_CPACR_EL1, HVF_SYSREG(1, 0, 3, 0, 2) },
+    { HV_SYS_REG_TTBR0_EL1, HVF_SYSREG(2, 0, 3, 0, 0) },
+    { HV_SYS_REG_TTBR1_EL1, HVF_SYSREG(2, 0, 3, 0, 1) },
+    { HV_SYS_REG_TCR_EL1, HVF_SYSREG(2, 0, 3, 0, 2) },
+
+    { HV_SYS_REG_APIAKEYLO_EL1, HVF_SYSREG(2, 1, 3, 0, 0) },
+    { HV_SYS_REG_APIAKEYHI_EL1, HVF_SYSREG(2, 1, 3, 0, 1) },
+    { HV_SYS_REG_APIBKEYLO_EL1, HVF_SYSREG(2, 1, 3, 0, 2) },
+    { HV_SYS_REG_APIBKEYHI_EL1, HVF_SYSREG(2, 1, 3, 0, 3) },
+    { HV_SYS_REG_APDAKEYLO_EL1, HVF_SYSREG(2, 2, 3, 0, 0) },
+    { HV_SYS_REG_APDAKEYHI_EL1, HVF_SYSREG(2, 2, 3, 0, 1) },
+    { HV_SYS_REG_APDBKEYLO_EL1, HVF_SYSREG(2, 2, 3, 0, 2) },
+    { HV_SYS_REG_APDBKEYHI_EL1, HVF_SYSREG(2, 2, 3, 0, 3) },
+    { HV_SYS_REG_APGAKEYLO_EL1, HVF_SYSREG(2, 3, 3, 0, 0) },
+    { HV_SYS_REG_APGAKEYHI_EL1, HVF_SYSREG(2, 3, 3, 0, 1) },
+
+    { HV_SYS_REG_SPSR_EL1, HVF_SYSREG(4, 0, 3, 1, 0) },
+    { HV_SYS_REG_ELR_EL1, HVF_SYSREG(4, 0, 3, 0, 1) },
+    { HV_SYS_REG_SP_EL0, HVF_SYSREG(4, 1, 3, 0, 0) },
+    { HV_SYS_REG_AFSR0_EL1, HVF_SYSREG(5, 1, 3, 0, 0) },
+    { HV_SYS_REG_AFSR1_EL1, HVF_SYSREG(5, 1, 3, 0, 1) },
+    { HV_SYS_REG_ESR_EL1, HVF_SYSREG(5, 2, 3, 0, 0) },
+    { HV_SYS_REG_FAR_EL1, HVF_SYSREG(6, 0, 3, 0, 0) },
+    { HV_SYS_REG_PAR_EL1, HVF_SYSREG(7, 4, 3, 0, 0) },
+    { HV_SYS_REG_MAIR_EL1, HVF_SYSREG(10, 2, 3, 0, 0) },
+    { HV_SYS_REG_AMAIR_EL1, HVF_SYSREG(10, 3, 3, 0, 0) },
+    { HV_SYS_REG_VBAR_EL1, HVF_SYSREG(12, 0, 3, 0, 0) },
+    { HV_SYS_REG_CONTEXTIDR_EL1, HVF_SYSREG(13, 0, 3, 0, 1) },
+    { HV_SYS_REG_TPIDR_EL1, HVF_SYSREG(13, 0, 3, 0, 4) },
+    { HV_SYS_REG_CNTKCTL_EL1, HVF_SYSREG(14, 1, 3, 0, 0) },
+    { HV_SYS_REG_CSSELR_EL1, HVF_SYSREG(0, 0, 3, 2, 0) },
+    { HV_SYS_REG_TPIDR_EL0, HVF_SYSREG(13, 0, 3, 3, 2) },
+    { HV_SYS_REG_TPIDRRO_EL0, HVF_SYSREG(13, 0, 3, 3, 3) },
+    { HV_SYS_REG_CNTV_CTL_EL0, HVF_SYSREG(14, 3, 3, 3, 1) },
+    { HV_SYS_REG_CNTV_CVAL_EL0, HVF_SYSREG(14, 3, 3, 3, 2) },
+    { HV_SYS_REG_SP_EL1, HVF_SYSREG(4, 1, 3, 4, 0) },
+};
+
+int hvf_get_registers(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    hv_return_t ret;
+    uint64_t val;
+    hv_simd_fp_uchar16_t fpval;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(hvf_reg_match); i++) {
+        ret = hv_vcpu_get_reg(cpu->hvf->fd, hvf_reg_match[i].reg, &val);
+        *(uint64_t *)((void *)env + hvf_reg_match[i].offset) = val;
+        assert_hvf_ok(ret);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(hvf_fpreg_match); i++) {
+        ret = hv_vcpu_get_simd_fp_reg(cpu->hvf->fd, hvf_fpreg_match[i].reg,
+                                      &fpval);
+        memcpy((void *)env + hvf_fpreg_match[i].offset, &fpval, sizeof(fpval));
+        assert_hvf_ok(ret);
+    }
+
+    val = 0;
+    ret = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_FPCR, &val);
+    assert_hvf_ok(ret);
+    vfp_set_fpcr(env, val);
+
+    val = 0;
+    ret = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_FPSR, &val);
+    assert_hvf_ok(ret);
+    vfp_set_fpsr(env, val);
+
+    ret = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_CPSR, &val);
+    assert_hvf_ok(ret);
+    pstate_write(env, val);
+
+    for (i = 0; i < ARRAY_SIZE(hvf_sreg_match); i++) {
+        ret = hv_vcpu_get_sys_reg(cpu->hvf->fd, hvf_sreg_match[i].reg, &val);
+        assert_hvf_ok(ret);
+
+        arm_cpu->cpreg_values[i] = val;
+    }
+    write_list_to_cpustate(arm_cpu);
+
+    return 0;
+}
+
+int hvf_put_registers(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    hv_return_t ret;
+    uint64_t val;
+    hv_simd_fp_uchar16_t fpval;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(hvf_reg_match); i++) {
+        val = *(uint64_t *)((void *)env + hvf_reg_match[i].offset);
+        ret = hv_vcpu_set_reg(cpu->hvf->fd, hvf_reg_match[i].reg, val);
+        assert_hvf_ok(ret);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(hvf_fpreg_match); i++) {
+        memcpy(&fpval, (void *)env + hvf_fpreg_match[i].offset, sizeof(fpval));
+        ret = hv_vcpu_set_simd_fp_reg(cpu->hvf->fd, hvf_fpreg_match[i].reg,
+                                      fpval);
+        assert_hvf_ok(ret);
+    }
+
+    ret = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_FPCR, vfp_get_fpcr(env));
+    assert_hvf_ok(ret);
+
+    ret = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_FPSR, vfp_get_fpsr(env));
+    assert_hvf_ok(ret);
+
+    ret = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_CPSR, pstate_read(env));
+    assert_hvf_ok(ret);
+
+    write_cpustate_to_list(arm_cpu, false);
+    for (i = 0; i < ARRAY_SIZE(hvf_sreg_match); i++) {
+        val = arm_cpu->cpreg_values[i];
+        ret = hv_vcpu_set_sys_reg(cpu->hvf->fd, hvf_sreg_match[i].reg, val);
+        assert_hvf_ok(ret);
+    }
+
+    return 0;
+}
+
+static void flush_cpu_state(CPUState *cpu)
+{
+    if (cpu->vcpu_dirty) {
+        hvf_put_registers(cpu);
+        cpu->vcpu_dirty = false;
+    }
+}
+
+static void hvf_set_reg(CPUState *cpu, int rt, uint64_t val)
+{
+    hv_return_t r;
+
+    flush_cpu_state(cpu);
+
+    if (rt < 31) {
+        r = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_X0 + rt, val);
+        assert_hvf_ok(r);
+    }
+}
+
+static uint64_t hvf_get_reg(CPUState *cpu, int rt)
+{
+    uint64_t val = 0;
+    hv_return_t r;
+
+    flush_cpu_state(cpu);
+
+    if (rt < 31) {
+        r = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_X0 + rt, &val);
+        assert_hvf_ok(r);
+    }
+
+    return val;
+}
+
+void hvf_arch_vcpu_destroy(CPUState *cpu)
+{
+}
+
+int hvf_arch_init_vcpu(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    uint32_t sregs_match_len = ARRAY_SIZE(hvf_sreg_match);
+    uint64_t pfr;
+    hv_return_t ret;
+    int i;
+
+    env->aarch64 = 1;
+    asm volatile("mrs %0, cntfrq_el0" : "=r"(arm_cpu->gt_cntfrq_hz));
+
+    /* Allocate enough space for our sysreg sync */
+    arm_cpu->cpreg_indexes = g_renew(uint64_t, arm_cpu->cpreg_indexes,
+                                     sregs_match_len);
+    arm_cpu->cpreg_values = g_renew(uint64_t, arm_cpu->cpreg_values,
+                                    sregs_match_len);
+    arm_cpu->cpreg_vmstate_indexes = g_renew(uint64_t,
+                                             arm_cpu->cpreg_vmstate_indexes,
+                                             sregs_match_len);
+    arm_cpu->cpreg_vmstate_values = g_renew(uint64_t,
+                                            arm_cpu->cpreg_vmstate_values,
+                                            sregs_match_len);
+
+    memset(arm_cpu->cpreg_values, 0, sregs_match_len * sizeof(uint64_t));
+    arm_cpu->cpreg_array_len = sregs_match_len;
+    arm_cpu->cpreg_vmstate_array_len = sregs_match_len;
+
+    /* Populate cp list for all known sysregs */
+    for (i = 0; i < sregs_match_len; i++) {
+        const ARMCPRegInfo *ri;
+
+        arm_cpu->cpreg_indexes[i] = cpreg_to_kvm_id(hvf_sreg_match[i].key);
+
+        ri = get_arm_cp_reginfo(arm_cpu->cp_regs, hvf_sreg_match[i].key);
+        if (ri) {
+            assert(!(ri->type & ARM_CP_NO_RAW));
+        }
+    }
+    write_cpustate_to_list(arm_cpu, false);
+
+    /* Set CP_NO_RAW system registers on init */
+    ret = hv_vcpu_set_sys_reg(cpu->hvf->fd, HV_SYS_REG_MIDR_EL1,
+                              arm_cpu->midr);
+    assert_hvf_ok(ret);
+
+    ret = hv_vcpu_set_sys_reg(cpu->hvf->fd, HV_SYS_REG_MPIDR_EL1,
+                              arm_cpu->mp_affinity);
+    assert_hvf_ok(ret);
+
+    ret = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_ID_AA64PFR0_EL1, &pfr);
+    assert_hvf_ok(ret);
+    pfr |= env->gicv3state ? (1 << 24) : 0;
+    ret = hv_vcpu_set_sys_reg(cpu->hvf->fd, HV_SYS_REG_ID_AA64PFR0_EL1, pfr);
+    assert_hvf_ok(ret);
+
+    /* We're limited to underlying hardware caps, override internal versions */
+    ret = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_ID_AA64MMFR0_EL1,
+                              &arm_cpu->isar.id_aa64mmfr0);
+    assert_hvf_ok(ret);
+
+    return 0;
+}
+
+void hvf_kick_vcpu_thread(CPUState *cpu)
+{
+    hv_vcpus_exit(&cpu->hvf->fd, 1);
+}
+
+static void hvf_raise_exception(CPUARMState *env, uint32_t excp,
+                                uint32_t syndrome)
+{
+    unsigned int new_el = 1;
+    unsigned int old_mode = pstate_read(env);
+    unsigned int new_mode = aarch64_pstate_mode(new_el, true);
+    target_ulong addr = env->cp15.vbar_el[new_el];
+
+    env->cp15.esr_el[new_el] = syndrome;
+    aarch64_save_sp(env, arm_current_el(env));
+    env->elr_el[new_el] = env->pc;
+    env->banked_spsr[aarch64_banked_spsr_index(new_el)] = old_mode;
+    pstate_write(env, PSTATE_DAIF | new_mode);
+    aarch64_restore_sp(env, new_el);
+    env->pc = addr;
+}
+
+static uint64_t hvf_sysreg_read(CPUState *cpu, uint32_t reg)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    uint64_t val = 0;
+
+    switch (reg) {
+    case SYSREG_CNTPCT_EL0:
+        val = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) /
+              gt_cntfrq_period_ns(arm_cpu);
+        break;
+    case SYSREG_PMCCNTR_EL0:
+        val = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
+        break;
+    default:
+        trace_hvf_unhandled_sysreg_read(reg,
+                                        (reg >> 20) & 0x3,
+                                        (reg >> 14) & 0x7,
+                                        (reg >> 10) & 0xf,
+                                        (reg >> 1) & 0xf,
+                                        (reg >> 17) & 0x7);
+        break;
+    }
+
+    return val;
+}
+
+static void hvf_sysreg_write(CPUState *cpu, uint32_t reg, uint64_t val)
+{
+    switch (reg) {
+    case SYSREG_CNTPCT_EL0:
+        break;
+    default:
+        trace_hvf_unhandled_sysreg_write(reg,
+                                         (reg >> 20) & 0x3,
+                                         (reg >> 14) & 0x7,
+                                         (reg >> 10) & 0xf,
+                                         (reg >> 1) & 0xf,
+                                         (reg >> 17) & 0x7);
+        break;
+    }
+}
+
+static int hvf_inject_interrupts(CPUState *cpu)
+{
+    if (cpu->interrupt_request & CPU_INTERRUPT_FIQ) {
+        trace_hvf_inject_fiq();
+        hv_vcpu_set_pending_interrupt(cpu->hvf->fd, HV_INTERRUPT_TYPE_FIQ,
+                                      true);
+    }
+
+    if (cpu->interrupt_request & CPU_INTERRUPT_HARD) {
+        trace_hvf_inject_irq();
+        hv_vcpu_set_pending_interrupt(cpu->hvf->fd, HV_INTERRUPT_TYPE_IRQ,
+                                      true);
+    }
+
+    return 0;
+}
+
+static void hvf_sync_vtimer(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    hv_return_t r;
+    uint64_t ctl;
+    bool irq_state;
+
+    if (!cpu->hvf->vtimer_masked) {
+        /* We will get notified on vtimer changes by hvf, nothing to do */
+        return;
+    }
+
+    r = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_CNTV_CTL_EL0, &ctl);
+    assert_hvf_ok(r);
+
+    irq_state = (ctl & (TMR_CTL_ENABLE | TMR_CTL_IMASK | TMR_CTL_ISTATUS)) ==
+                (TMR_CTL_ENABLE | TMR_CTL_ISTATUS);
+    qemu_set_irq(arm_cpu->gt_timer_outputs[GTIMER_VIRT], irq_state);
+
+    if (!irq_state) {
+        /* Timer no longer asserting, we can unmask it */
+        hv_vcpu_set_vtimer_mask(cpu->hvf->fd, false);
+        cpu->hvf->vtimer_masked = false;
+    }
+}
+
+int hvf_vcpu_exec(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    hv_vcpu_exit_t *hvf_exit = cpu->hvf->exit;
+    hv_return_t r;
+    bool advance_pc = false;
+
+    flush_cpu_state(cpu);
+
+    hvf_sync_vtimer(cpu);
+
+    if (hvf_inject_interrupts(cpu)) {
+        return EXCP_INTERRUPT;
+    }
+
+    if (cpu->halted) {
+        return EXCP_HLT;
+    }
+
+    qemu_mutex_unlock_iothread();
+    assert_hvf_ok(hv_vcpu_run(cpu->hvf->fd));
+
+    /* handle VMEXIT */
+    uint64_t exit_reason = hvf_exit->reason;
+    uint64_t syndrome = hvf_exit->exception.syndrome;
+    uint32_t ec = syn_get_ec(syndrome);
+
+    qemu_mutex_lock_iothread();
+    switch (exit_reason) {
+    case HV_EXIT_REASON_EXCEPTION:
+        /* This is the main one, handle below. */
+        break;
+    case HV_EXIT_REASON_VTIMER_ACTIVATED:
+        qemu_set_irq(arm_cpu->gt_timer_outputs[GTIMER_VIRT], 1);
+        cpu->hvf->vtimer_masked = true;
+        return 0;
+    case HV_EXIT_REASON_CANCELED:
+        /* we got kicked, no exit to process */
+        return 0;
+    default:
+        assert(0);
+    }
+
+    switch (ec) {
+    case EC_DATAABORT: {
+        bool isv = syndrome & ARM_EL_ISV;
+        bool iswrite = (syndrome >> 6) & 1;
+        bool s1ptw = (syndrome >> 7) & 1;
+        uint32_t sas = (syndrome >> 22) & 3;
+        uint32_t len = 1 << sas;
+        uint32_t srt = (syndrome >> 16) & 0x1f;
+        uint64_t val = 0;
+
+        trace_hvf_data_abort(env->pc, hvf_exit->exception.virtual_address,
+                             hvf_exit->exception.physical_address, isv,
+                             iswrite, s1ptw, len, srt);
+
+        assert(isv);
+
+        if (iswrite) {
+            val = hvf_get_reg(cpu, srt);
+            address_space_write(&address_space_memory,
+                                hvf_exit->exception.physical_address,
+                                MEMTXATTRS_UNSPECIFIED, &val, len);
+        } else {
+            address_space_read(&address_space_memory,
+                               hvf_exit->exception.physical_address,
+                               MEMTXATTRS_UNSPECIFIED, &val, len);
+            hvf_set_reg(cpu, srt, val);
+        }
+
+        advance_pc = true;
+        break;
+    }
+    case EC_SYSTEMREGISTERTRAP: {
+        bool isread = (syndrome >> 0) & 1;
+        uint32_t rt = (syndrome >> 5) & 0x1f;
+        uint32_t reg = syndrome & SYSREG_MASK;
+        uint64_t val = 0;
+
+        if (isread) {
+            val = hvf_sysreg_read(cpu, reg);
+            trace_hvf_sysreg_read(reg,
+                                  (reg >> 20) & 0x3,
+                                  (reg >> 14) & 0x7,
+                                  (reg >> 10) & 0xf,
+                                  (reg >> 1) & 0xf,
+                                  (reg >> 17) & 0x7,
+                                  val);
+            hvf_set_reg(cpu, rt, val);
+        } else {
+            val = hvf_get_reg(cpu, rt);
+            trace_hvf_sysreg_write(reg,
+                                   (reg >> 20) & 0x3,
+                                   (reg >> 14) & 0x7,
+                                   (reg >> 10) & 0xf,
+                                   (reg >> 1) & 0xf,
+                                   (reg >> 17) & 0x7,
+                                   val);
+            hvf_sysreg_write(cpu, reg, val);
+        }
+
+        advance_pc = true;
+        break;
+    }
+    case EC_WFX_TRAP:
+        advance_pc = true;
+        break;
+    case EC_AA64_HVC:
+        cpu_synchronize_state(cpu);
+        trace_hvf_unknown_hvf(env->xregs[0]);
+        hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        break;
+    case EC_AA64_SMC:
+        cpu_synchronize_state(cpu);
+        trace_hvf_unknown_smc(env->xregs[0]);
+        hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        break;
+    default:
+        cpu_synchronize_state(cpu);
+        trace_hvf_exit(syndrome, ec, env->pc);
+        error_report("0x%llx: unhandled exit 0x%llx", env->pc, exit_reason);
+    }
+
+    if (advance_pc) {
+        uint64_t pc;
+
+        flush_cpu_state(cpu);
+
+        r = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_PC, &pc);
+        assert_hvf_ok(r);
+        pc += 4;
+        r = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_PC, pc);
+        assert_hvf_ok(r);
+    }
+
+    return 0;
+}
diff --git a/target/arm/hvf/trace-events b/target/arm/hvf/trace-events
new file mode 100644
index 000000000000..49a547dcf66e
--- /dev/null
+++ b/target/arm/hvf/trace-events
@@ -0,0 +1,10 @@
+hvf_unhandled_sysreg_read(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_t crm, uint32_t op2) "unhandled sysreg read 0x%08x (op0=%d op1=%d crn=%d crm=%d op2=%d)"
+hvf_unhandled_sysreg_write(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_t crm, uint32_t op2) "unhandled sysreg write 0x%08x (op0=%d op1=%d crn=%d crm=%d op2=%d)"
+hvf_inject_fiq(void) "injecting FIQ"
+hvf_inject_irq(void) "injecting IRQ"
+hvf_data_abort(uint64_t pc, uint64_t va, uint64_t pa, bool isv, bool iswrite, bool s1ptw, uint32_t len, uint32_t srt) "data abort: [pc=0x%"PRIx64" va=0x%016"PRIx64" pa=0x%016"PRIx64" isv=%d iswrite=%d s1ptw=%d len=%d srt=%d]"
+hvf_sysreg_read(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_t crm, uint32_t op2, uint64_t val) "sysreg read 0x%08x (op0=%d op1=%d crn=%d crm=%d op2=%d) = 0x%016"PRIx64
+hvf_sysreg_write(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_t crm, uint32_t op2, uint64_t val) "sysreg write 0x%08x (op0=%d op1=%d crn=%d crm=%d op2=%d, val=0x%016"PRIx64")"
+hvf_unknown_hvf(uint64_t x0) "unknown HVC! 0x%016"PRIx64
+hvf_unknown_smc(uint64_t x0) "unknown SMC! 0x%016"PRIx64
+hvf_exit(uint64_t syndrome, uint32_t ec, uint64_t pc) "exit: 0x%"PRIx64" [ec=0x%x pc=0x%"PRIx64"]"

From 66c71d88ed4e88b53667bdabf0400e309fba215c Mon Sep 17 00:00:00 2001
From: Peter Collingbourne <pcc@google.com>
Date: Wed, 19 May 2021 22:22:48 +0200
Subject: [PATCH 082/180] arm/hvf: Add a WFI handler

Sleep on WFI until the VTIMER is due but allow ourselves to be woken
up on IPI.

In this implementation IPI is blocked on the CPU thread at startup and
pselect() is used to atomically unblock the signal and begin sleeping.
The signal is sent unconditionally so there's no need to worry about
races between actually sleeping and the "we think we're sleeping"
state. It may lead to an extra wakeup but that's better than missing
it entirely.

Signed-off-by: Peter Collingbourne <pcc@google.com>
[agraf: Remove unused 'set' variable, always advance PC on WFX trap]
Signed-off-by: Alexander Graf <agraf@csgraf.de>
Acked-by: Roman Bolshakov <r.bolshakov@yadro.com>

Message-Id: <20210519202253.76782-15-agraf@csgraf.de>
---
 accel/hvf/hvf-accel-ops.c |  5 ++-
 include/sysemu/hvf_int.h  |  1 +
 target/arm/hvf/hvf.c      | 68 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 71 insertions(+), 3 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 48e402ef57bf..63ec8a6f2558 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -369,15 +369,14 @@ static int hvf_init_vcpu(CPUState *cpu)
     cpu->hvf = g_malloc0(sizeof(*cpu->hvf));
 
     /* init cpu signals */
-    sigset_t set;
     struct sigaction sigact;
 
     memset(&sigact, 0, sizeof(sigact));
     sigact.sa_handler = dummy_signal;
     sigaction(SIG_IPI, &sigact, NULL);
 
-    pthread_sigmask(SIG_BLOCK, NULL, &set);
-    sigdelset(&set, SIG_IPI);
+    pthread_sigmask(SIG_BLOCK, NULL, &cpu->hvf->unblock_ipi_mask);
+    sigdelset(&cpu->hvf->unblock_ipi_mask, SIG_IPI);
 
 #ifdef __aarch64__
     r = hv_vcpu_create(&cpu->hvf->fd, (hv_vcpu_exit_t **)&cpu->hvf->exit, NULL);
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index e52d67ed5c74..6d4eef806529 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -51,6 +51,7 @@ struct hvf_vcpu_state {
     uint64_t fd;
     void *exit;
     bool vtimer_masked;
+    sigset_t unblock_ipi_mask;
 };
 
 void assert_hvf_ok(hv_return_t ret);
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 3934c05979d5..67002efd3668 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -2,6 +2,7 @@
  * QEMU Hypervisor.framework support for Apple Silicon
 
  * Copyright 2020 Alexander Graf <agraf@csgraf.de>
+ * Copyright 2020 Google LLC
  *
  * This work is licensed under the terms of the GNU GPL, version 2 or later.
  * See the COPYING file in the top-level directory.
@@ -17,6 +18,8 @@
 #include "sysemu/hvf_int.h"
 #include "sysemu/hw_accel.h"
 
+#include <mach/mach_time.h>
+
 #include "exec/address-spaces.h"
 #include "hw/irq.h"
 #include "qemu/main-loop.h"
@@ -457,6 +460,7 @@ int hvf_arch_init_vcpu(CPUState *cpu)
 
 void hvf_kick_vcpu_thread(CPUState *cpu)
 {
+    cpus_kick_thread(cpu);
     hv_vcpus_exit(&cpu->hvf->fd, 1);
 }
 
@@ -536,6 +540,67 @@ static int hvf_inject_interrupts(CPUState *cpu)
     return 0;
 }
 
+static void hvf_wait_for_ipi(CPUState *cpu, struct timespec *ts)
+{
+    /*
+     * Use pselect to sleep so that other threads can IPI us while we're
+     * sleeping.
+     */
+    qatomic_mb_set(&cpu->thread_kicked, false);
+    qemu_mutex_unlock_iothread();
+    pselect(0, 0, 0, 0, ts, &cpu->hvf->unblock_ipi_mask);
+    qemu_mutex_lock_iothread();
+}
+
+static void hvf_wfi(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    hv_return_t r;
+    uint64_t ctl;
+
+    if (cpu->interrupt_request & (CPU_INTERRUPT_HARD | CPU_INTERRUPT_FIQ)) {
+        /* Interrupt pending, no need to wait */
+        return;
+    }
+
+    r = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_CNTV_CTL_EL0,
+                            &ctl);
+    assert_hvf_ok(r);
+
+    if (!(ctl & 1) || (ctl & 2)) {
+        /* Timer disabled or masked, just wait for an IPI. */
+        hvf_wait_for_ipi(cpu, NULL);
+        return;
+    }
+
+    uint64_t cval;
+    r = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_CNTV_CVAL_EL0,
+                            &cval);
+    assert_hvf_ok(r);
+
+    int64_t ticks_to_sleep = cval - mach_absolute_time();
+    if (ticks_to_sleep < 0) {
+        return;
+    }
+
+    uint64_t seconds = ticks_to_sleep / arm_cpu->gt_cntfrq_hz;
+    uint64_t nanos =
+        (ticks_to_sleep - arm_cpu->gt_cntfrq_hz * seconds) *
+        1000000000 / arm_cpu->gt_cntfrq_hz;
+
+    /*
+     * Don't sleep for less than the time a context switch would take,
+     * so that we can satisfy fast timer requests on the same CPU.
+     * Measurements on M1 show the sweet spot to be ~2ms.
+     */
+    if (!seconds && nanos < 2000000) {
+        return;
+    }
+
+    struct timespec ts = { seconds, nanos };
+    hvf_wait_for_ipi(cpu, &ts);
+}
+
 static void hvf_sync_vtimer(CPUState *cpu)
 {
     ARMCPU *arm_cpu = ARM_CPU(cpu);
@@ -670,6 +735,9 @@ int hvf_vcpu_exec(CPUState *cpu)
     }
     case EC_WFX_TRAP:
         advance_pc = true;
+        if (!(syndrome & WFX_IS_WFE)) {
+            hvf_wfi(cpu);
+        }
         break;
     case EC_AA64_HVC:
         cpu_synchronize_state(cpu);

From 17d38dc6d91367c87fb774e02cf879cd2002fcba Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:49 +0200
Subject: [PATCH 083/180] hvf: arm: Implement -cpu host

Now that we have working system register sync, we push more target CPU
properties into the virtual machine. That might be useful in some
situations, but is not the typical case that users want.

So let's add a -cpu host option that allows them to explicitly pass all
CPU capabilities of their host CPU into the guest.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Acked-by: Roman Bolshakov <r.bolshakov@yadro.com>

Message-Id: <20210519202253.76782-16-agraf@csgraf.de>
---
 target/arm/cpu.c     |  9 ++++--
 target/arm/cpu.h     |  2 ++
 target/arm/hvf/hvf.c | 72 ++++++++++++++++++++++++++++++++++++++++++++
 target/arm/hvf_arm.h | 19 ++++++++++++
 target/arm/kvm_arm.h |  2 --
 5 files changed, 100 insertions(+), 4 deletions(-)
 create mode 100644 target/arm/hvf_arm.h

diff --git a/target/arm/cpu.c b/target/arm/cpu.c
index 7aeb4b138162..69b96ba0c52e 100644
--- a/target/arm/cpu.c
+++ b/target/arm/cpu.c
@@ -39,6 +39,7 @@
 #include "sysemu/tcg.h"
 #include "sysemu/hw_accel.h"
 #include "kvm_arm.h"
+#include "hvf_arm.h"
 #include "disas/capstone.h"
 #include "fpu/softfloat.h"
 
@@ -2000,15 +2001,19 @@ static void arm_cpu_class_init(ObjectClass *oc, void *data)
 #endif /* CONFIG_TCG */
 }
 
-#ifdef CONFIG_KVM
+#if defined(CONFIG_KVM) || defined(CONFIG_HVF)
 static void arm_host_initfn(Object *obj)
 {
     ARMCPU *cpu = ARM_CPU(obj);
 
+#ifdef CONFIG_KVM
     kvm_arm_set_cpu_features_from_host(cpu);
     if (arm_feature(&cpu->env, ARM_FEATURE_AARCH64)) {
         aarch64_add_sve_properties(obj);
     }
+#else
+    hvf_arm_set_cpu_features_from_host(cpu);
+#endif
     arm_cpu_post_init(obj);
 }
 
@@ -2068,7 +2073,7 @@ static void arm_cpu_register_types(void)
 {
     type_register_static(&arm_cpu_type_info);
 
-#ifdef CONFIG_KVM
+#if defined(CONFIG_KVM) || defined(CONFIG_HVF)
     type_register_static(&host_arm_cpu_type_info);
 #endif
 }
diff --git a/target/arm/cpu.h b/target/arm/cpu.h
index 04f8be35bf09..ba5da3301dbe 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -2988,6 +2988,8 @@ bool write_cpustate_to_list(ARMCPU *cpu, bool kvm_sync);
 #define ARM_CPU_TYPE_NAME(name) (name ARM_CPU_TYPE_SUFFIX)
 #define CPU_RESOLVING_TYPE TYPE_ARM_CPU
 
+#define TYPE_ARM_HOST_CPU "host-" TYPE_ARM_CPU
+
 #define cpu_signal_handler cpu_arm_signal_handler
 #define cpu_list arm_cpu_list
 
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 67002efd3668..bce46f3ed811 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -17,6 +17,7 @@
 #include "sysemu/hvf.h"
 #include "sysemu/hvf_int.h"
 #include "sysemu/hw_accel.h"
+#include "hvf_arm.h"
 
 #include <mach/mach_time.h>
 
@@ -44,6 +45,16 @@
 #define TMR_CTL_IMASK   (1 << 1)
 #define TMR_CTL_ISTATUS (1 << 2)
 
+typedef struct ARMHostCPUFeatures {
+    ARMISARegisters isar;
+    uint64_t features;
+    uint64_t midr;
+    uint32_t reset_sctlr;
+    const char *dtb_compatible;
+} ARMHostCPUFeatures;
+
+static ARMHostCPUFeatures arm_host_cpu_features;
+
 struct hvf_reg_match {
     int reg;
     uint64_t offset;
@@ -390,6 +401,67 @@ static uint64_t hvf_get_reg(CPUState *cpu, int rt)
     return val;
 }
 
+static void hvf_arm_get_host_cpu_features(ARMHostCPUFeatures *ahcf)
+{
+    ARMISARegisters host_isar;
+    const struct isar_regs {
+        int reg;
+        uint64_t *val;
+    } regs[] = {
+        { HV_SYS_REG_ID_AA64PFR0_EL1, &host_isar.id_aa64pfr0 },
+        { HV_SYS_REG_ID_AA64PFR1_EL1, &host_isar.id_aa64pfr1 },
+        { HV_SYS_REG_ID_AA64DFR0_EL1, &host_isar.id_aa64dfr0 },
+        { HV_SYS_REG_ID_AA64DFR1_EL1, &host_isar.id_aa64dfr1 },
+        { HV_SYS_REG_ID_AA64ISAR0_EL1, &host_isar.id_aa64isar0 },
+        { HV_SYS_REG_ID_AA64ISAR1_EL1, &host_isar.id_aa64isar1 },
+        { HV_SYS_REG_ID_AA64MMFR0_EL1, &host_isar.id_aa64mmfr0 },
+        { HV_SYS_REG_ID_AA64MMFR1_EL1, &host_isar.id_aa64mmfr1 },
+        { HV_SYS_REG_ID_AA64MMFR2_EL1, &host_isar.id_aa64mmfr2 },
+    };
+    hv_vcpu_t fd;
+    hv_vcpu_exit_t *exit;
+    int i;
+
+    ahcf->dtb_compatible = "arm,arm-v8";
+    ahcf->features = (1ULL << ARM_FEATURE_V8) |
+                     (1ULL << ARM_FEATURE_NEON) |
+                     (1ULL << ARM_FEATURE_AARCH64) |
+                     (1ULL << ARM_FEATURE_PMU) |
+                     (1ULL << ARM_FEATURE_GENERIC_TIMER);
+
+    /* We set up a small vcpu to extract host registers */
+
+    assert_hvf_ok(hv_vcpu_create(&fd, &exit, NULL));
+    for (i = 0; i < ARRAY_SIZE(regs); i++) {
+        assert_hvf_ok(hv_vcpu_get_sys_reg(fd, regs[i].reg, regs[i].val));
+    }
+    assert_hvf_ok(hv_vcpu_get_sys_reg(fd, HV_SYS_REG_MIDR_EL1, &ahcf->midr));
+    assert_hvf_ok(hv_vcpu_destroy(fd));
+
+    ahcf->isar = host_isar;
+    ahcf->reset_sctlr = 0x00c50078;
+
+    /* Make sure we don't advertise AArch32 support for EL0/EL1 */
+    g_assert((host_isar.id_aa64pfr0 & 0xff) == 0x11);
+}
+
+void hvf_arm_set_cpu_features_from_host(ARMCPU *cpu)
+{
+    if (!arm_host_cpu_features.dtb_compatible) {
+        if (!hvf_enabled()) {
+            cpu->host_cpu_probe_failed = true;
+            return;
+        }
+        hvf_arm_get_host_cpu_features(&arm_host_cpu_features);
+    }
+
+    cpu->dtb_compatible = arm_host_cpu_features.dtb_compatible;
+    cpu->isar = arm_host_cpu_features.isar;
+    cpu->env.features = arm_host_cpu_features.features;
+    cpu->midr = arm_host_cpu_features.midr;
+    cpu->reset_sctlr = arm_host_cpu_features.reset_sctlr;
+}
+
 void hvf_arch_vcpu_destroy(CPUState *cpu)
 {
 }
diff --git a/target/arm/hvf_arm.h b/target/arm/hvf_arm.h
new file mode 100644
index 000000000000..603074a33132
--- /dev/null
+++ b/target/arm/hvf_arm.h
@@ -0,0 +1,19 @@
+/*
+ * QEMU Hypervisor.framework (HVF) support -- ARM specifics
+ *
+ * Copyright (c) 2021 Alexander Graf
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#ifndef QEMU_HVF_ARM_H
+#define QEMU_HVF_ARM_H
+
+#include "qemu/accel.h"
+#include "cpu.h"
+
+void hvf_arm_set_cpu_features_from_host(struct ARMCPU *cpu);
+
+#endif
diff --git a/target/arm/kvm_arm.h b/target/arm/kvm_arm.h
index 34f8daa37752..828dca4a4a9d 100644
--- a/target/arm/kvm_arm.h
+++ b/target/arm/kvm_arm.h
@@ -214,8 +214,6 @@ bool kvm_arm_create_scratch_host_vcpu(const uint32_t *cpus_to_try,
  */
 void kvm_arm_destroy_scratch_host_vcpu(int *fdarray);
 
-#define TYPE_ARM_HOST_CPU "host-" TYPE_ARM_CPU
-
 /**
  * ARMHostCPUFeatures: information about the host CPU (identified
  * by asking the host kernel)

From 3f09807e7fbcabb05d393e05234d662e6357f8fe Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:50 +0200
Subject: [PATCH 084/180] hvf: arm: Implement PSCI handling

We need to handle PSCI calls. Most of the TCG code works for us,
but we can simplify it to only handle aa64 mode and we need to
handle SUSPEND differently.

This patch takes the TCG code as template and duplicates it in HVF.

To tell the guest that we support PSCI 0.2 now, update the check in
arm_cpu_initfn() as well.

Signed-off-by: Alexander Graf <agraf@csgraf.de>

Message-Id: <20210519202253.76782-17-agraf@csgraf.de>
---
 target/arm/cpu.c            |   4 +-
 target/arm/hvf/hvf.c        | 123 ++++++++++++++++++++++++++++++++++--
 target/arm/hvf/trace-events |   1 +
 3 files changed, 122 insertions(+), 6 deletions(-)

diff --git a/target/arm/cpu.c b/target/arm/cpu.c
index 69b96ba0c52e..0924c1697add 100644
--- a/target/arm/cpu.c
+++ b/target/arm/cpu.c
@@ -1079,8 +1079,8 @@ static void arm_cpu_initfn(Object *obj)
     cpu->psci_version = 1; /* By default assume PSCI v0.1 */
     cpu->kvm_target = QEMU_KVM_ARM_TARGET_NONE;
 
-    if (tcg_enabled()) {
-        cpu->psci_version = 2; /* TCG implements PSCI 0.2 */
+    if (tcg_enabled() || hvf_enabled()) {
+        cpu->psci_version = 2; /* TCG and HVF implement PSCI 0.2 */
     }
 }
 
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index bce46f3ed811..65c33e2a1421 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -25,6 +25,7 @@
 #include "hw/irq.h"
 #include "qemu/main-loop.h"
 #include "sysemu/cpus.h"
+#include "arm-powerctl.h"
 #include "target/arm/cpu.h"
 #include "target/arm/internals.h"
 #include "trace/trace-target_arm_hvf.h"
@@ -45,6 +46,8 @@
 #define TMR_CTL_IMASK   (1 << 1)
 #define TMR_CTL_ISTATUS (1 << 2)
 
+static void hvf_wfi(CPUState *cpu);
+
 typedef struct ARMHostCPUFeatures {
     ARMISARegisters isar;
     uint64_t features;
@@ -553,6 +556,110 @@ static void hvf_raise_exception(CPUARMState *env, uint32_t excp,
     env->pc = addr;
 }
 
+static int hvf_psci_cpu_off(ARMCPU *arm_cpu)
+{
+    int32_t ret = 0;
+    ret = arm_set_cpu_off(arm_cpu->mp_affinity);
+    assert(ret == QEMU_ARM_POWERCTL_RET_SUCCESS);
+
+    return 0;
+}
+
+static int hvf_handle_psci_call(CPUState *cpu)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+    uint64_t param[4] = {
+        env->xregs[0],
+        env->xregs[1],
+        env->xregs[2],
+        env->xregs[3]
+    };
+    uint64_t context_id, mpidr;
+    bool target_aarch64 = true;
+    CPUState *target_cpu_state;
+    ARMCPU *target_cpu;
+    target_ulong entry;
+    int target_el = 1;
+    int32_t ret = 0;
+
+    trace_hvf_psci_call(param[0], param[1], param[2], param[3],
+                        arm_cpu->mp_affinity);
+
+    switch (param[0]) {
+    case QEMU_PSCI_0_2_FN_PSCI_VERSION:
+        ret = QEMU_PSCI_0_2_RET_VERSION_0_2;
+        break;
+    case QEMU_PSCI_0_2_FN_MIGRATE_INFO_TYPE:
+        ret = QEMU_PSCI_0_2_RET_TOS_MIGRATION_NOT_REQUIRED; /* No trusted OS */
+        break;
+    case QEMU_PSCI_0_2_FN_AFFINITY_INFO:
+    case QEMU_PSCI_0_2_FN64_AFFINITY_INFO:
+        mpidr = param[1];
+
+        switch (param[2]) {
+        case 0:
+            target_cpu_state = arm_get_cpu_by_id(mpidr);
+            if (!target_cpu_state) {
+                ret = QEMU_PSCI_RET_INVALID_PARAMS;
+                break;
+            }
+            target_cpu = ARM_CPU(target_cpu_state);
+
+            ret = target_cpu->power_state;
+            break;
+        default:
+            /* Everything above affinity level 0 is always on. */
+            ret = 0;
+        }
+        break;
+    case QEMU_PSCI_0_2_FN_SYSTEM_RESET:
+        qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);
+        /* QEMU reset and shutdown are async requests, but PSCI
+         * mandates that we never return from the reset/shutdown
+         * call, so power the CPU off now so it doesn't execute
+         * anything further.
+         */
+        return hvf_psci_cpu_off(arm_cpu);
+    case QEMU_PSCI_0_2_FN_SYSTEM_OFF:
+        qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);
+        return hvf_psci_cpu_off(arm_cpu);
+    case QEMU_PSCI_0_1_FN_CPU_ON:
+    case QEMU_PSCI_0_2_FN_CPU_ON:
+    case QEMU_PSCI_0_2_FN64_CPU_ON:
+        mpidr = param[1];
+        entry = param[2];
+        context_id = param[3];
+        ret = arm_set_cpu_on(mpidr, entry, context_id,
+                             target_el, target_aarch64);
+        break;
+    case QEMU_PSCI_0_1_FN_CPU_OFF:
+    case QEMU_PSCI_0_2_FN_CPU_OFF:
+        return hvf_psci_cpu_off(arm_cpu);
+    case QEMU_PSCI_0_1_FN_CPU_SUSPEND:
+    case QEMU_PSCI_0_2_FN_CPU_SUSPEND:
+    case QEMU_PSCI_0_2_FN64_CPU_SUSPEND:
+        /* Affinity levels are not supported in QEMU */
+        if (param[1] & 0xfffe0000) {
+            ret = QEMU_PSCI_RET_INVALID_PARAMS;
+            break;
+        }
+        /* Powerdown is not supported, we always go into WFI */
+        env->xregs[0] = 0;
+        hvf_wfi(cpu);
+        break;
+    case QEMU_PSCI_0_1_FN_MIGRATE:
+    case QEMU_PSCI_0_2_FN_MIGRATE:
+        ret = QEMU_PSCI_RET_NOT_SUPPORTED;
+        break;
+    default:
+        return 1;
+    }
+
+    env->xregs[0] = ret;
+    return 0;
+}
+
 static uint64_t hvf_sysreg_read(CPUState *cpu, uint32_t reg)
 {
     ARMCPU *arm_cpu = ARM_CPU(cpu);
@@ -716,6 +823,8 @@ int hvf_vcpu_exec(CPUState *cpu)
     }
 
     if (cpu->halted) {
+        /* On unhalt, we usually have CPU state changes. Prepare for them. */
+        cpu_synchronize_state(cpu);
         return EXCP_HLT;
     }
 
@@ -813,13 +922,19 @@ int hvf_vcpu_exec(CPUState *cpu)
         break;
     case EC_AA64_HVC:
         cpu_synchronize_state(cpu);
-        trace_hvf_unknown_hvf(env->xregs[0]);
-        hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        if (hvf_handle_psci_call(cpu)) {
+            trace_hvf_unknown_hvf(env->xregs[0]);
+            hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        }
         break;
     case EC_AA64_SMC:
         cpu_synchronize_state(cpu);
-        trace_hvf_unknown_smc(env->xregs[0]);
-        hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        if (!hvf_handle_psci_call(cpu)) {
+            advance_pc = true;
+        } else {
+            trace_hvf_unknown_smc(env->xregs[0]);
+            hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());
+        }
         break;
     default:
         cpu_synchronize_state(cpu);
diff --git a/target/arm/hvf/trace-events b/target/arm/hvf/trace-events
index 49a547dcf66e..278b88cc62a6 100644
--- a/target/arm/hvf/trace-events
+++ b/target/arm/hvf/trace-events
@@ -8,3 +8,4 @@ hvf_sysreg_write(uint32_t reg, uint32_t op0, uint32_t op1, uint32_t crn, uint32_
 hvf_unknown_hvf(uint64_t x0) "unknown HVC! 0x%016"PRIx64
 hvf_unknown_smc(uint64_t x0) "unknown SMC! 0x%016"PRIx64
 hvf_exit(uint64_t syndrome, uint32_t ec, uint64_t pc) "exit: 0x%"PRIx64" [ec=0x%x pc=0x%"PRIx64"]"
+hvf_psci_call(uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint32_t cpuid) "PSCI Call x0=0x%016"PRIx64" x1=0x%016"PRIx64" x2=0x%016"PRIx64" x3=0x%016"PRIx64" cpu=0x%x"

From 8137225fde2778ac315e96614e4b7ec0d1cc86de Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:51 +0200
Subject: [PATCH 085/180] arm: Add Hypervisor.framework build target

Now that we have all logic in place that we need to handle Hypervisor.framework
on Apple Silicon systems, let's add CONFIG_HVF for aarch64 as well so that we
can build it.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reviewed-by: Roman Bolshakov <r.bolshakov@yadro.com>
Tested-by: Roman Bolshakov <r.bolshakov@yadro.com> (x86 only)

Message-Id: <20210519202253.76782-18-agraf@csgraf.de>
---
 meson.build                | 7 +++++++
 target/arm/hvf/meson.build | 3 +++
 target/arm/meson.build     | 2 ++
 3 files changed, 12 insertions(+)
 create mode 100644 target/arm/hvf/meson.build

diff --git a/meson.build b/meson.build
index 9277a06bc601..f58efe4750d2 100644
--- a/meson.build
+++ b/meson.build
@@ -77,6 +77,13 @@ else
 endif
 
 accelerator_targets = { 'CONFIG_KVM': kvm_targets }
+
+if cpu in ['aarch64']
+  accelerator_targets += {
+    'CONFIG_HVF': ['aarch64-softmmu']
+  }
+endif
+
 if cpu in ['x86', 'x86_64', 'arm', 'aarch64']
   # i368 emulator provides xenpv machine type for multiple architectures
   accelerator_targets += {
diff --git a/target/arm/hvf/meson.build b/target/arm/hvf/meson.build
new file mode 100644
index 000000000000..855e6cce5ab6
--- /dev/null
+++ b/target/arm/hvf/meson.build
@@ -0,0 +1,3 @@
+arm_softmmu_ss.add(when: [hvf, 'CONFIG_HVF'], if_true: files(
+  'hvf.c',
+))
diff --git a/target/arm/meson.build b/target/arm/meson.build
index 5bfaf43b500e..48004bf0e66c 100644
--- a/target/arm/meson.build
+++ b/target/arm/meson.build
@@ -57,5 +57,7 @@ arm_softmmu_ss.add(files(
   'psci.c',
 ))
 
+subdir('hvf')
+
 target_arch += {'arm': arm_ss}
 target_softmmu_arch += {'arm': arm_softmmu_ss}

From 998320a3da86d1be7a258cb84f4a6efd258e7ad6 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:52 +0200
Subject: [PATCH 086/180] arm: Enable Windows 10 trusted SMCCC boot call

Windows 10 calls an SMCCC call via SMC unconditionally on boot. It lives
in the trusted application call number space, but its purpose is unknown.

In our current SMC implementation, we inject a UDEF for unknown SMC calls,
including this one. However, Windows breaks on boot when we do this. Instead,
let's return an error code.

With this and -M virt,virtualization=on I can successfully boot the current
Windows 10 Insider Preview in TCG.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Message-Id: <20210519202253.76782-19-agraf@csgraf.de>
---
 target/arm/kvm-consts.h | 2 ++
 target/arm/psci.c       | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/target/arm/kvm-consts.h b/target/arm/kvm-consts.h
index 580f1c1fee0c..4b64f98117c7 100644
--- a/target/arm/kvm-consts.h
+++ b/target/arm/kvm-consts.h
@@ -85,6 +85,8 @@ MISMATCH_CHECK(QEMU_PSCI_0_2_FN64_CPU_SUSPEND, PSCI_0_2_FN64_CPU_SUSPEND);
 MISMATCH_CHECK(QEMU_PSCI_0_2_FN64_CPU_ON, PSCI_0_2_FN64_CPU_ON);
 MISMATCH_CHECK(QEMU_PSCI_0_2_FN64_MIGRATE, PSCI_0_2_FN64_MIGRATE);
 
+#define QEMU_SMCCC_TC_WINDOWS10_BOOT 0xc3000001
+
 /* PSCI v0.2 return values used by TCG emulation of PSCI */
 
 /* No Trusted OS migration to worry about when offlining CPUs */
diff --git a/target/arm/psci.c b/target/arm/psci.c
index 6709e280133a..4d11dd59c498 100644
--- a/target/arm/psci.c
+++ b/target/arm/psci.c
@@ -69,6 +69,7 @@ bool arm_is_psci_call(ARMCPU *cpu, int excp_type)
     case QEMU_PSCI_0_2_FN64_CPU_SUSPEND:
     case QEMU_PSCI_0_1_FN_MIGRATE:
     case QEMU_PSCI_0_2_FN_MIGRATE:
+    case QEMU_SMCCC_TC_WINDOWS10_BOOT:
         return true;
     default:
         return false;
@@ -194,6 +195,7 @@ void arm_handle_psci_call(ARMCPU *cpu)
         break;
     case QEMU_PSCI_0_1_FN_MIGRATE:
     case QEMU_PSCI_0_2_FN_MIGRATE:
+    case QEMU_SMCCC_TC_WINDOWS10_BOOT:
         ret = QEMU_PSCI_RET_NOT_SUPPORTED;
         break;
     default:

From a0db5bfa90ac33acc1f5e86db9632dfcb0b45945 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Wed, 19 May 2021 22:22:53 +0200
Subject: [PATCH 087/180] hvf: arm: Handle Windows 10 SMC call

Windows 10 calls an SMCCC call via SMC unconditionally on boot. It lives
in the trusted application call number space, but its purpose is unknown.

In our current SMC implementation, we inject a UDEF for unknown SMC calls,
including this one. However, Windows breaks on boot when we do this. Instead,
let's return an error code.

With this patch applied I can successfully boot the current Windows 10
Insider Preview in HVF.

Signed-off-by: Alexander Graf <agraf@csgraf.de>

Message-Id: <20210519202253.76782-20-agraf@csgraf.de>
---
 target/arm/hvf/hvf.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 65c33e2a1421..be670af578a0 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -931,6 +931,10 @@ int hvf_vcpu_exec(CPUState *cpu)
         cpu_synchronize_state(cpu);
         if (!hvf_handle_psci_call(cpu)) {
             advance_pc = true;
+        } else if (env->xregs[0] == QEMU_SMCCC_TC_WINDOWS10_BOOT) {
+            /* This special SMC is called by Windows 10 on boot. Return error */
+            env->xregs[0] = -1;
+            advance_pc = true;
         } else {
             trace_hvf_unknown_smc(env->xregs[0]);
             hvf_raise_exception(env, EXCP_UDEF, syn_uncategorized());

From 2ee6330b9ead0b333a8ed6f7e7861dd7e6128133 Mon Sep 17 00:00:00 2001
From: Yasuo Kuwahara <kwhr00@gmail.com>
Date: Tue, 25 May 2021 18:46:19 +0900
Subject: [PATCH 088/180] tcg/aarch64: Fix tcg_out_rotl

The last argument of tcg_out_extr() must be in the range 0-31 if ext==0.
Before the fix, when m==0 it becomes 32 and it crashes with an Illegal
instruction on Apple Silicon.  After the fix, it will be 0.  If m is in
the range 1-31, it is the same as before.

Signed-off-by: Yasuo Kuwahara <kwhr00@gmail.com>
Message-Id: <CAHfJ0vSXnmnTLmT0kR=a8ACRdw_UsLYOhStzUzgVEHoH8U-7sA@mail.gmail.com>
Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
---
 tcg/aarch64/tcg-target.c.inc | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/tcg/aarch64/tcg-target.c.inc b/tcg/aarch64/tcg-target.c.inc
index f07ba98aa483..5bd366f2d4de 100644
--- a/tcg/aarch64/tcg-target.c.inc
+++ b/tcg/aarch64/tcg-target.c.inc
@@ -1291,9 +1291,8 @@ static inline void tcg_out_rotr(TCGContext *s, TCGType ext,
 static inline void tcg_out_rotl(TCGContext *s, TCGType ext,
                                 TCGReg rd, TCGReg rn, unsigned int m)
 {
-    int bits = ext ? 64 : 32;
-    int max = bits - 1;
-    tcg_out_extr(s, ext, rd, rn, rn, bits - (m & max));
+    int max = ext ? 63 : 31;
+    tcg_out_extr(s, ext, rd, rn, rn, -m & max);
 }
 
 static inline void tcg_out_dep(TCGContext *s, TCGType ext, TCGReg rd,

From 7292f1fc18b0e0b68ba8e4c73afe500e44f77271 Mon Sep 17 00:00:00 2001
From: Gustavo Noronha Silva <gustavo@noronha.dev.br>
Date: Tue, 13 Jul 2021 18:31:59 -0300
Subject: [PATCH 089/180] ui/cocoa: capture all keys and combos when mouse is
 grabbed

Applications such as Gnome may use Alt-Tab and Super-Tab for different
purposes, some use Ctrl-arrows so we want to allow qemu to handle
everything when it captures the mouse/keyboard.

However, Mac OS handles some combos like Command-Tab and Ctrl-arrows
at an earlier part of the event handling chain, not letting qemu see it.

We add a global Event Tap that allows qemu to see all events when the
mouse is grabbed. Note that this requires additional permissions.

See:

https://developer.apple.com/documentation/coregraphics/1454426-cgeventtapcreate?language=objc#discussion
https://support.apple.com/en-in/guide/mac-help/mh32356/mac

Acked-by: Markus Armbruster <armbru@redhat.com>
Reviewed-by: Akihiko Odaki <akihiko.odaki@gmail.com>
Signed-off-by: Gustavo Noronha Silva <gustavo@noronha.dev.br>
Message-Id: <20210713213200.2547-2-gustavo@noronha.dev.br>
---
 qapi/ui.json    | 16 ++++++++++++
 qemu-options.hx |  3 +++
 ui/cocoa.m      | 65 ++++++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 83 insertions(+), 1 deletion(-)

diff --git a/qapi/ui.json b/qapi/ui.json
index fd9677d48efb..b2d27ce1671b 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -1092,6 +1092,21 @@
 { 'struct'  : 'DisplayCurses',
   'data'    : { '*charset'       : 'str' } }
 
+##
+# @DisplayCocoa:
+#
+# Cocoa display options.
+#
+# @full-grab: Capture all key presses, including system combos. This
+#             requires accessibility permissions, since it performs
+#             a global grab on key events. (default: off)
+#             See https://support.apple.com/en-in/guide/mac-help/mh32356/mac
+#
+# Since: 6.1
+##
+{ 'struct'  : 'DisplayCocoa',
+  'data'    : { '*full-grab'     : 'bool' } }
+
 ##
 # @DisplayType:
 #
@@ -1165,6 +1180,7 @@
   'discriminator' : 'type',
   'data'    : {
       'gtk': { 'type': 'DisplayGTK', 'if': 'defined(CONFIG_GTK)' },
+      'cocoa': { 'type': 'DisplayCocoa', 'if': 'defined(CONFIG_COCOA)' },
       'curses': { 'type': 'DisplayCurses', 'if': 'defined(CONFIG_CURSES)' },
       'egl-headless': { 'type': 'DisplayEGLHeadless',
                         'if': 'defined(CONFIG_OPENGL) && defined(CONFIG_GBM)' }
diff --git a/qemu-options.hx b/qemu-options.hx
index 8965dabc83e3..8308d28d1f98 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -1796,6 +1796,9 @@ DEF("display", HAS_ARG, QEMU_OPTION_display,
 #if defined(CONFIG_CURSES)
     "-display curses[,charset=<encoding>]\n"
 #endif
+#if defined(CONFIG_COCOA)
+    "-display cocoa[,full_grab=on|off]\n"
+#endif
 #if defined(CONFIG_OPENGL)
     "-display egl-headless[,rendernode=<file>]\n"
 #endif
diff --git a/ui/cocoa.m b/ui/cocoa.m
index 9f72844b0793..d9d98aa9ded6 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -309,11 +309,13 @@ @interface QemuCocoaView : NSView
     BOOL isMouseGrabbed;
     BOOL isFullscreen;
     BOOL isAbsoluteEnabled;
+    CFMachPortRef eventsTap;
 }
 - (void) switchSurface:(pixman_image_t *)image;
 - (void) grabMouse;
 - (void) ungrabMouse;
 - (void) toggleFullScreen:(id)sender;
+- (void) setFullGrab:(id)sender;
 - (void) handleMonitorInput:(NSEvent *)event;
 - (bool) handleEvent:(NSEvent *)event;
 - (bool) handleEventLocked:(NSEvent *)event;
@@ -336,6 +338,19 @@ - (void) raiseAllKeys;
 
 QemuCocoaView *cocoaView;
 
+static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
+{
+    QemuCocoaView *cocoaView = (QemuCocoaView*) userInfo;
+    NSEvent* event = [NSEvent eventWithCGEvent:cgEvent];
+    if ([cocoaView isMouseGrabbed] && [cocoaView handleEvent:event]) {
+        COCOA_DEBUG("Global events tap: qemu handled the event, capturing!\n");
+        return NULL;
+    }
+    COCOA_DEBUG("Global events tap: qemu did not handle the event, letting it through...\n");
+
+    return cgEvent;
+}
+
 @implementation QemuCocoaView
 - (id)initWithFrame:(NSRect)frameRect
 {
@@ -361,6 +376,11 @@ - (void) dealloc
     }
 
     qkbd_state_free(kbd);
+
+    if (eventsTap) {
+        CFRelease(eventsTap);
+    }
+
     [super dealloc];
 }
 
@@ -635,6 +655,36 @@ - (void) toggleFullScreen:(id)sender
     }
 }
 
+- (void) setFullGrab:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaView: setFullGrab\n");
+
+    CGEventMask mask = CGEventMaskBit(kCGEventKeyDown) | CGEventMaskBit(kCGEventKeyUp) | CGEventMaskBit(kCGEventFlagsChanged);
+    eventsTap = CGEventTapCreate(kCGHIDEventTap, kCGHeadInsertEventTap, kCGEventTapOptionDefault,
+                                 mask, handleTapEvent, self);
+    if (!eventsTap) {
+        warn_report("Could not create event tap, system key combos will not be captured.\n");
+        return;
+    } else {
+        COCOA_DEBUG("Global events tap created! Will capture system key combos.\n");
+    }
+
+    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
+    if (!runLoop) {
+        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
+        return;
+    }
+
+    CFRunLoopSourceRef tapEventsSrc = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventsTap, 0);
+    if (!tapEventsSrc ) {
+        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
+        return;
+    }
+
+    CFRunLoopAddSource(runLoop, tapEventsSrc, kCFRunLoopDefaultMode);
+    CFRelease(tapEventsSrc);
+}
+
 - (void) toggleKey: (int)keycode {
     qkbd_state_key_event(kbd, keycode, !qkbd_state_key_get(kbd, keycode));
 }
@@ -1260,6 +1310,13 @@ - (void)toggleFullScreen:(id)sender
     [cocoaView toggleFullScreen:sender];
 }
 
+- (void) setFullGrab:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaAppController: setFullGrab\n");
+
+    [cocoaView setFullGrab:sender];
+}
+
 /* Tries to find then open the specified filename */
 - (void) openDocumentation: (NSString *) filename
 {
@@ -2031,11 +2088,17 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
     qemu_sem_wait(&app_started_sem);
     COCOA_DEBUG("cocoa_display_init: app start completed\n");
 
+    QemuCocoaAppController* controller = (QemuCocoaAppController*)[[NSApplication sharedApplication] delegate];
     /* if fullscreen mode is to be used */
     if (opts->has_full_screen && opts->full_screen) {
         dispatch_async(dispatch_get_main_queue(), ^{
             [NSApp activateIgnoringOtherApps: YES];
-            [(QemuCocoaAppController *)[[NSApplication sharedApplication] delegate] toggleFullScreen: nil];
+            [controller toggleFullScreen: nil];
+        });
+    }
+    if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            [controller setFullGrab: nil];
         });
     }
     if (opts->has_show_cursor && opts->show_cursor) {

From bc73e879972e3fe3b1a5c4d5c24e7c7b7e2dfa97 Mon Sep 17 00:00:00 2001
From: Gustavo Noronha Silva <gustavo@noronha.dev.br>
Date: Tue, 13 Jul 2021 18:32:00 -0300
Subject: [PATCH 090/180] ui/cocoa: add option to swap Option and Command

On Mac OS X the Option key maps to Alt and Command to Super/Meta. This change
swaps them around so that Alt is the key closer to the space bar and Meta/Super
is between Control and Alt, like on non-Mac keyboards.

It is a cocoa display option, disabled by default.

Acked-by: Markus Armbruster <armbru@redhat.com>
Reviewed-by: Akihiko Odaki <akihiko.odaki@gmail.com>
Signed-off-by: Gustavo Noronha Silva <gustavo@noronha.dev.br>
Message-Id: <20210713213200.2547-3-gustavo@noronha.dev.br>
---
 qapi/ui.json    |  8 ++++++-
 qemu-options.hx |  3 ++-
 ui/cocoa.m      | 64 ++++++++++++++++++++++++++++++++++++++++++-------
 3 files changed, 65 insertions(+), 10 deletions(-)

diff --git a/qapi/ui.json b/qapi/ui.json
index b2d27ce1671b..7d8d3b532e58 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -1102,10 +1102,16 @@
 #             a global grab on key events. (default: off)
 #             See https://support.apple.com/en-in/guide/mac-help/mh32356/mac
 #
+# @swap-option-command: Swap the Option and Command keys so that their key
+#                       codes match their position on non-Mac keyboards and
+#                       you can use Meta/Super and Alt where you expect them.
+#                       (default: off)
+#
 # Since: 6.1
 ##
 { 'struct'  : 'DisplayCocoa',
-  'data'    : { '*full-grab'     : 'bool' } }
+  'data'    : { '*full-grab'           : 'bool',
+                '*swap-option-command' : 'bool' } }
 
 ##
 # @DisplayType:
diff --git a/qemu-options.hx b/qemu-options.hx
index 8308d28d1f98..7cdacc83ae13 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -1797,7 +1797,8 @@ DEF("display", HAS_ARG, QEMU_OPTION_display,
     "-display curses[,charset=<encoding>]\n"
 #endif
 #if defined(CONFIG_COCOA)
-    "-display cocoa[,full_grab=on|off]\n"
+    "-display cocoa[,full-grab=on|off]\n"
+    "              [,swap-option-command=on|off]\n"
 #endif
 #if defined(CONFIG_OPENGL)
     "-display egl-headless[,rendernode=<file>]\n"
diff --git a/ui/cocoa.m b/ui/cocoa.m
index d9d98aa9ded6..e23060da538a 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -73,6 +73,7 @@
 typedef struct {
     int width;
     int height;
+    bool swap_option_command;
 } QEMUScreen;
 
 static void cocoa_update(DisplayChangeListener *dcl,
@@ -330,6 +331,7 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
  */
 - (BOOL) isMouseGrabbed;
 - (BOOL) isAbsoluteEnabled;
+- (BOOL) isSwapOptionCommandEnabled;
 - (float) cdx;
 - (float) cdy;
 - (QEMUScreen) gscreen;
@@ -685,6 +687,13 @@ - (void) setFullGrab:(id)sender
     CFRelease(tapEventsSrc);
 }
 
+- (void) setSwapOptionCommand:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaView: setSwapOptionCommand\n");
+
+    screen.swap_option_command = true;
+}
+
 - (void) toggleKey: (int)keycode {
     qkbd_state_key_event(kbd, keycode, !qkbd_state_key_get(kbd, keycode));
 }
@@ -834,12 +843,22 @@ - (bool) handleEventLocked:(NSEvent *)event
         qkbd_state_key_event(kbd, Q_KEY_CODE_CTRL_R, false);
     }
     if (!(modifiers & NSEventModifierFlagOption)) {
-        qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
-        qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
+        if ([self isSwapOptionCommandEnabled]) {
+            qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
+            qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
+        } else {
+            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
+            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
+        }
     }
     if (!(modifiers & NSEventModifierFlagCommand)) {
-        qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
-        qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
+        if ([self isSwapOptionCommandEnabled]) {
+            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
+            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
+        } else {
+            qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
+            qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
+        }
     }
 
     switch ([event type]) {
@@ -871,13 +890,21 @@ - (bool) handleEventLocked:(NSEvent *)event
 
                 case kVK_Option:
                     if (!!(modifiers & NSEventModifierFlagOption)) {
-                        [self toggleKey:Q_KEY_CODE_ALT];
+                        if ([self isSwapOptionCommandEnabled]) {
+                            [self toggleKey:Q_KEY_CODE_META_L];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_ALT];
+                        }
                     }
                     break;
 
                 case kVK_RightOption:
                     if (!!(modifiers & NSEventModifierFlagOption)) {
-                        [self toggleKey:Q_KEY_CODE_ALT_R];
+                        if ([self isSwapOptionCommandEnabled]) {
+                            [self toggleKey:Q_KEY_CODE_META_R];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_ALT_R];
+                        }
                     }
                     break;
 
@@ -885,14 +912,22 @@ - (bool) handleEventLocked:(NSEvent *)event
                 case kVK_Command:
                     if (isMouseGrabbed &&
                         !!(modifiers & NSEventModifierFlagCommand)) {
-                        [self toggleKey:Q_KEY_CODE_META_L];
+                        if ([self isSwapOptionCommandEnabled]) {
+                            [self toggleKey:Q_KEY_CODE_ALT];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_META_L];
+                        }
                     }
                     break;
 
                 case kVK_RightCommand:
                     if (isMouseGrabbed &&
                         !!(modifiers & NSEventModifierFlagCommand)) {
-                        [self toggleKey:Q_KEY_CODE_META_R];
+                        if ([self isSwapOptionCommandEnabled]) {
+                            [self toggleKey:Q_KEY_CODE_ALT_R];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_META_R];
+                        }
                     }
                     break;
             }
@@ -1121,6 +1156,7 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
 }
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
 - (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
+- (BOOL) isSwapOptionCommandEnabled {return screen.swap_option_command;}
 - (float) cdx {return cdx;}
 - (float) cdy {return cdy;}
 - (QEMUScreen) gscreen {return screen;}
@@ -1317,6 +1353,13 @@ - (void) setFullGrab:(id)sender
     [cocoaView setFullGrab:sender];
 }
 
+- (void) setSwapOptionCommand:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaAppController: setSwapOptionCommand\n");
+
+    [cocoaView setSwapOptionCommand:sender];
+}
+
 /* Tries to find then open the specified filename */
 - (void) openDocumentation: (NSString *) filename
 {
@@ -2101,6 +2144,11 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
             [controller setFullGrab: nil];
         });
     }
+    if (opts->u.cocoa.has_swap_option_command && opts->u.cocoa.swap_option_command) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            [controller setSwapOptionCommand: nil];
+        });
+    }
     if (opts->has_show_cursor && opts->show_cursor) {
         cursor_hide = 0;
     }

From 6a1e678f5bfed893bbbfbd550a036c7a675c5940 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 11 Feb 2021 16:02:52 +0900
Subject: [PATCH 091/180] ui/cocoa: Use NSWindow's ability to resize

This change brings two new features:
- The window will be resizable if "Zoom To Fit" is eanbled
- The window can be made full screen by clicking full screen button
  provided by the platform. (The left-top green button.)

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 542 ++++++++++++++++++++++++-----------------------------
 1 file changed, 249 insertions(+), 293 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index e23060da538a..68a6ae3df075 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -94,12 +94,10 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 static DisplayChangeListener dcl = {
     .ops = &dcl_ops,
 };
-static int last_buttons;
 static int cursor_hide = 1;
 
 static int gArgc;
 static char **gArgv;
-static bool stretch_video;
 static NSTextField *pauseLabel;
 static NSArray * supportedImageFileTypes;
 
@@ -302,20 +300,17 @@ static void handleAnyDeviceErrors(Error * err)
 */
 @interface QemuCocoaView : NSView
 {
+    NSTrackingArea *trackingArea;
     QEMUScreen screen;
-    NSWindow *fullScreenWindow;
-    float cx,cy,cw,ch,cdx,cdy;
     pixman_image_t *pixman_image;
     QKbdState *kbd;
     BOOL isMouseGrabbed;
-    BOOL isFullscreen;
     BOOL isAbsoluteEnabled;
     CFMachPortRef eventsTap;
 }
 - (void) switchSurface:(pixman_image_t *)image;
 - (void) grabMouse;
 - (void) ungrabMouse;
-- (void) toggleFullScreen:(id)sender;
 - (void) setFullGrab:(id)sender;
 - (void) handleMonitorInput:(NSEvent *)event;
 - (bool) handleEvent:(NSEvent *)event;
@@ -332,8 +327,6 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
 - (BOOL) isMouseGrabbed;
 - (BOOL) isAbsoluteEnabled;
 - (BOOL) isSwapOptionCommandEnabled;
-- (float) cdx;
-- (float) cdy;
 - (QEMUScreen) gscreen;
 - (void) raiseAllKeys;
 @end
@@ -391,46 +384,43 @@ - (BOOL) isOpaque
     return YES;
 }
 
-- (BOOL) screenContainsPoint:(NSPoint) p
+- (void) removeTrackingRect
 {
-    return (p.x > -1 && p.x < screen.width && p.y > -1 && p.y < screen.height);
+    if (trackingArea) {
+        [self removeTrackingArea:trackingArea];
+        [trackingArea release];
+        trackingArea = nil;
+    }
 }
 
-/* Get location of event and convert to virtual screen coordinate */
-- (CGPoint) screenLocationOfEvent:(NSEvent *)ev
+- (void) frameUpdated
 {
-    NSWindow *eventWindow = [ev window];
-    // XXX: Use CGRect and -convertRectFromScreen: to support macOS 10.10
-    CGRect r = CGRectZero;
-    r.origin = [ev locationInWindow];
-    if (!eventWindow) {
-        if (!isFullscreen) {
-            return [[self window] convertRectFromScreen:r].origin;
-        } else {
-            CGPoint locationInSelfWindow = [[self window] convertRectFromScreen:r].origin;
-            CGPoint loc = [self convertPoint:locationInSelfWindow fromView:nil];
-            if (stretch_video) {
-                loc.x /= cdx;
-                loc.y /= cdy;
-            }
-            return loc;
-        }
-    } else if ([[self window] isEqual:eventWindow]) {
-        if (!isFullscreen) {
-            return r.origin;
-        } else {
-            CGPoint loc = [self convertPoint:r.origin fromView:nil];
-            if (stretch_video) {
-                loc.x /= cdx;
-                loc.y /= cdy;
-            }
-            return loc;
-        }
-    } else {
-        return [[self window] convertRectFromScreen:[eventWindow convertRectToScreen:r]].origin;
+    [self removeTrackingRect];
+
+    if ([self window]) {
+        NSTrackingAreaOptions options = NSTrackingActiveInKeyWindow |
+                                        NSTrackingMouseEnteredAndExited |
+                                        NSTrackingMouseMoved;
+        trackingArea = [[NSTrackingArea alloc] initWithRect:[self frame]
+                                                    options:options
+                                                      owner:self
+                                                   userInfo:nil];
+        [self addTrackingArea:trackingArea];
+        [self updateUIInfo];
     }
 }
 
+- (void) viewDidMoveToWindow
+{
+    [self resizeWindow];
+    [self frameUpdated];
+}
+
+- (void) viewWillMoveToWindow:(NSWindow *)newWindow
+{
+    [self removeTrackingRect];
+}
+
 - (void) hideCursor
 {
     if (!cursor_hide) {
@@ -493,13 +483,14 @@ - (void) drawRect:(NSRect) rect
         int i;
         CGImageRef clipImageRef;
         CGRect clipRect;
+        CGFloat d = (CGFloat)h / [self frame].size.height;
 
         [self getRectsBeingDrawn:&rectList count:&rectCount];
         for (i = 0; i < rectCount; i++) {
-            clipRect.origin.x = rectList[i].origin.x / cdx;
-            clipRect.origin.y = (float)h - (rectList[i].origin.y + rectList[i].size.height) / cdy;
-            clipRect.size.width = rectList[i].size.width / cdx;
-            clipRect.size.height = rectList[i].size.height / cdy;
+            clipRect.origin.x = rectList[i].origin.x * d;
+            clipRect.origin.y = (float)h - (rectList[i].origin.y + rectList[i].size.height) * d;
+            clipRect.size.width = rectList[i].size.width * d;
+            clipRect.size.height = rectList[i].size.height * d;
             clipImageRef = CGImageCreateWithImageInRect(
                                                         imageRef,
                                                         clipRect
@@ -512,36 +503,34 @@ - (void) drawRect:(NSRect) rect
     }
 }
 
-- (void) setContentDimensions
+- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
 {
-    COCOA_DEBUG("QemuCocoaView: setContentDimensions\n");
+    NSSize size;
 
-    if (isFullscreen) {
-        cdx = [[NSScreen mainScreen] frame].size.width / (float)screen.width;
-        cdy = [[NSScreen mainScreen] frame].size.height / (float)screen.height;
+    size.width = (CGFloat)screen.width * proposedSize.height;
+    size.height = (CGFloat)screen.height * proposedSize.width;
 
-        /* stretches video, but keeps same aspect ratio */
-        if (stretch_video == true) {
-            /* use smallest stretch value - prevents clipping on sides */
-            if (MIN(cdx, cdy) == cdx) {
-                cdy = cdx;
-            } else {
-                cdx = cdy;
-            }
-        } else {  /* No stretching */
-            cdx = cdy = 1;
-        }
-        cw = screen.width * cdx;
-        ch = screen.height * cdy;
-        cx = ([[NSScreen mainScreen] frame].size.width - cw) / 2.0;
-        cy = ([[NSScreen mainScreen] frame].size.height - ch) / 2.0;
+    if (size.width < size.height) {
+        size.width /= screen.height;
+        size.height = proposedSize.height;
     } else {
-        cx = 0;
-        cy = 0;
-        cw = screen.width;
-        ch = screen.height;
-        cdx = 1.0;
-        cdy = 1.0;
+        size.width = proposedSize.width;
+        size.height /= screen.width;
+    }
+
+    return size;
+}
+
+- (void) resizeWindow
+{
+    [[self window] setContentAspectRatio:NSMakeSize(screen.width, screen.height)];
+
+    if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [[self window] setContentSize:NSMakeSize(screen.width, screen.height)];
+        [[self window] center];
+    } else if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
+        [[self window] setContentSize:[self fixZoomedFullScreenSize:[[[self window] screen] frame].size]];
+        [[self window] center];
     }
 }
 
@@ -560,7 +549,12 @@ - (void) updateUIInfo
         NSSize screenSize = [[[self window] screen] frame].size;
         CGSize screenPhysicalSize = CGDisplayScreenSize(display);
 
-        frameSize = isFullscreen ? screenSize : [self frame].size;
+        if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) == 0) {
+            frameSize = [self frame].size;
+        } else {
+            frameSize = screenSize;
+        }
+
         info.width_mm = frameSize.width / screenSize.width * screenPhysicalSize.width;
         info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
     } else {
@@ -577,31 +571,19 @@ - (void) updateUIInfo
     dpy_set_ui_info(dcl.con, &info);
 }
 
-- (void)viewDidMoveToWindow
-{
-    [self updateUIInfo];
-}
-
 - (void) switchSurface:(pixman_image_t *)image
 {
     COCOA_DEBUG("QemuCocoaView: switchSurface\n");
 
     int w = pixman_image_get_width(image);
     int h = pixman_image_get_height(image);
-    /* cdx == 0 means this is our very first surface, in which case we need
-     * to recalculate the content dimensions even if it happens to be the size
-     * of the initial empty window.
-     */
-    bool isResize = (w != screen.width || h != screen.height || cdx == 0.0);
 
-    int oldh = screen.height;
-    if (isResize) {
+    if (w != screen.width || h != screen.height) {
         // Resize before we trigger the redraw, or we'll redraw at the wrong size
         COCOA_DEBUG("switchSurface: new size %d x %d\n", w, h);
         screen.width = w;
         screen.height = h;
-        [self setContentDimensions];
-        [self setFrame:NSMakeRect(cx, cy, cw, ch)];
+        [self resizeWindow];
     }
 
     // update screenBuffer
@@ -610,51 +592,6 @@ - (void) switchSurface:(pixman_image_t *)image
     }
 
     pixman_image = image;
-
-    // update windows
-    if (isFullscreen) {
-        [[fullScreenWindow contentView] setFrame:[[NSScreen mainScreen] frame]];
-        [normalWindow setFrame:NSMakeRect([normalWindow frame].origin.x, [normalWindow frame].origin.y - h + oldh, w, h + [normalWindow frame].size.height - oldh) display:NO animate:NO];
-    } else {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
-        [normalWindow setFrame:NSMakeRect([normalWindow frame].origin.x, [normalWindow frame].origin.y - h + oldh, w, h + [normalWindow frame].size.height - oldh) display:YES animate:NO];
-    }
-
-    if (isResize) {
-        [normalWindow center];
-    }
-}
-
-- (void) toggleFullScreen:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaView: toggleFullScreen\n");
-
-    if (isFullscreen) { // switch from fullscreen to desktop
-        isFullscreen = FALSE;
-        [self ungrabMouse];
-        [self setContentDimensions];
-        [fullScreenWindow close];
-        [normalWindow setContentView: self];
-        [normalWindow makeKeyAndOrderFront: self];
-        [NSMenu setMenuBarVisible:YES];
-    } else { // switch from desktop to fullscreen
-        isFullscreen = TRUE;
-        [normalWindow orderOut: nil]; /* Hide the window */
-        [self grabMouse];
-        [self setContentDimensions];
-        [NSMenu setMenuBarVisible:NO];
-        fullScreenWindow = [[NSWindow alloc] initWithContentRect:[[NSScreen mainScreen] frame]
-            styleMask:NSWindowStyleMaskBorderless
-            backing:NSBackingStoreBuffered
-            defer:NO];
-        [fullScreenWindow setAcceptsMouseMovedEvents: YES];
-        [fullScreenWindow setHasShadow:NO];
-        [fullScreenWindow setBackgroundColor: [NSColor blackColor]];
-        [self setFrame:NSMakeRect(cx, cy, cw, ch)];
-        [[fullScreenWindow contentView] addSubview: self];
-        [fullScreenWindow makeKeyAndOrderFront:self];
-    }
 }
 
 - (void) setFullGrab:(id)sender
@@ -783,12 +720,7 @@ - (bool) handleEventLocked:(NSEvent *)event
 {
     /* Return true if we handled the event, false if it should be given to OSX */
     COCOA_DEBUG("QemuCocoaView: handleEvent\n");
-    int buttons = 0;
     int keycode = 0;
-    bool mouse_event = false;
-    static bool switched_to_fullscreen = false;
-    // Location of event in virtual screen coordinates
-    NSPoint p = [self screenLocationOfEvent:event];
     NSUInteger modifiers = [event modifierFlags];
 
     /*
@@ -868,25 +800,25 @@ - (bool) handleEventLocked:(NSEvent *)event
                     if (!!(modifiers & NSEventModifierFlagShift)) {
                         [self toggleKey:Q_KEY_CODE_SHIFT];
                     }
-                    break;
+                    return true;
 
                 case kVK_RightShift:
                     if (!!(modifiers & NSEventModifierFlagShift)) {
                         [self toggleKey:Q_KEY_CODE_SHIFT_R];
                     }
-                    break;
+                    return true;
 
                 case kVK_Control:
                     if (!!(modifiers & NSEventModifierFlagControl)) {
                         [self toggleKey:Q_KEY_CODE_CTRL];
                     }
-                    break;
+                    return true;
 
                 case kVK_RightControl:
                     if (!!(modifiers & NSEventModifierFlagControl)) {
                         [self toggleKey:Q_KEY_CODE_CTRL_R];
                     }
-                    break;
+                    return true;
 
                 case kVK_Option:
                     if (!!(modifiers & NSEventModifierFlagOption)) {
@@ -896,7 +828,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                             [self toggleKey:Q_KEY_CODE_ALT];
                         }
                     }
-                    break;
+                    return true;
 
                 case kVK_RightOption:
                     if (!!(modifiers & NSEventModifierFlagOption)) {
@@ -906,7 +838,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                             [self toggleKey:Q_KEY_CODE_ALT_R];
                         }
                     }
-                    break;
+                    return true;
 
                 /* Don't pass command key changes to guest unless mouse is grabbed */
                 case kVK_Command:
@@ -918,7 +850,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                             [self toggleKey:Q_KEY_CODE_META_L];
                         }
                     }
-                    break;
+                    return true;
 
                 case kVK_RightCommand:
                     if (isMouseGrabbed &&
@@ -929,21 +861,16 @@ - (bool) handleEventLocked:(NSEvent *)event
                             [self toggleKey:Q_KEY_CODE_META_R];
                         }
                     }
-                    break;
+                    return true;
+
+                default:
+                    return true;
             }
-            break;
         case NSEventTypeKeyDown:
             keycode = cocoa_keycode_to_qemu([event keyCode]);
 
             // forward command key combos to the host UI unless the mouse is grabbed
             if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
-                /*
-                 * Prevent the command key from being stuck down in the guest
-                 * when using Command-F to switch to full screen mode.
-                 */
-                if (keycode == Q_KEY_CODE_F) {
-                    switched_to_fullscreen = true;
-                }
                 return false;
             }
 
@@ -974,7 +901,7 @@ - (bool) handleEventLocked:(NSEvent *)event
             } else {
                 [self handleMonitorInput: event];
             }
-            break;
+            return true;
         case NSEventTypeKeyUp:
             keycode = cocoa_keycode_to_qemu([event keyCode]);
 
@@ -987,67 +914,7 @@ - (bool) handleEventLocked:(NSEvent *)event
             if (qemu_console_is_graphic(NULL)) {
                 qkbd_state_key_event(kbd, keycode, false);
             }
-            break;
-        case NSEventTypeMouseMoved:
-            if (isAbsoluteEnabled) {
-                // Cursor re-entered into a window might generate events bound to screen coordinates
-                // and `nil` window property, and in full screen mode, current window might not be
-                // key window, where event location alone should suffice.
-                if (![self screenContainsPoint:p] || !([[self window] isKeyWindow] || isFullscreen)) {
-                    if (isMouseGrabbed) {
-                        [self ungrabMouse];
-                    }
-                } else {
-                    if (!isMouseGrabbed) {
-                        [self grabMouse];
-                    }
-                }
-            }
-            mouse_event = true;
-            break;
-        case NSEventTypeLeftMouseDown:
-            buttons |= MOUSE_EVENT_LBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeRightMouseDown:
-            buttons |= MOUSE_EVENT_RBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeOtherMouseDown:
-            buttons |= MOUSE_EVENT_MBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeLeftMouseDragged:
-            buttons |= MOUSE_EVENT_LBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeRightMouseDragged:
-            buttons |= MOUSE_EVENT_RBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeOtherMouseDragged:
-            buttons |= MOUSE_EVENT_MBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeLeftMouseUp:
-            mouse_event = true;
-            if (!isMouseGrabbed && [self screenContainsPoint:p]) {
-                /*
-                 * In fullscreen mode, the window of cocoaView may not be the
-                 * key window, therefore the position relative to the virtual
-                 * screen alone will be sufficient.
-                 */
-                if(isFullscreen || [[self window] isKeyWindow]) {
-                    [self grabMouse];
-                }
-            }
-            break;
-        case NSEventTypeRightMouseUp:
-            mouse_event = true;
-            break;
-        case NSEventTypeOtherMouseUp:
-            mouse_event = true;
-            break;
+            return true;
         case NSEventTypeScrollWheel:
             /*
              * Send wheel events to the guest regardless of window focus.
@@ -1061,7 +928,7 @@ - (bool) handleEventLocked:(NSEvent *)event
              */
             if ([event deltaY] != 0) {
             /* Determine if this is a scroll up or scroll down event */
-                buttons = ([event deltaY] > 0) ?
+                int buttons = ([event deltaY] > 0) ?
                     INPUT_BUTTON_WHEEL_UP : INPUT_BUTTON_WHEEL_DOWN;
                 qemu_input_queue_btn(dcl.con, buttons, true);
                 qemu_input_event_sync();
@@ -1072,62 +939,124 @@ - (bool) handleEventLocked:(NSEvent *)event
              * Since deltaY also reports scroll wheel events we prevent mouse
              * movement code from executing.
              */
-            mouse_event = false;
-            break;
+            return true;
         default:
             return false;
     }
+}
 
-    if (mouse_event) {
-        /* Don't send button events to the guest unless we've got a
-         * mouse grab or window focus. If we have neither then this event
-         * is the user clicking on the background window to activate and
-         * bring us to the front, which will be done by the sendEvent
-         * call below. We definitely don't want to pass that click through
-         * to the guest.
-         */
-        if ((isMouseGrabbed || [[self window] isKeyWindow]) &&
-            (last_buttons != buttons)) {
-            static uint32_t bmap[INPUT_BUTTON__MAX] = {
-                [INPUT_BUTTON_LEFT]       = MOUSE_EVENT_LBUTTON,
-                [INPUT_BUTTON_MIDDLE]     = MOUSE_EVENT_MBUTTON,
-                [INPUT_BUTTON_RIGHT]      = MOUSE_EVENT_RBUTTON
-            };
-            qemu_input_update_buttons(dcl.con, bmap, last_buttons, buttons);
-            last_buttons = buttons;
-        }
-        if (isMouseGrabbed) {
-            if (isAbsoluteEnabled) {
-                /* Note that the origin for Cocoa mouse coords is bottom left, not top left.
-                 * The check on screenContainsPoint is to avoid sending out of range values for
-                 * clicks in the titlebar.
-                 */
-                if ([self screenContainsPoint:p]) {
-                    qemu_input_queue_abs(dcl.con, INPUT_AXIS_X, p.x, 0, screen.width);
-                    qemu_input_queue_abs(dcl.con, INPUT_AXIS_Y, screen.height - p.y, 0, screen.height);
-                }
-            } else {
-                qemu_input_queue_rel(dcl.con, INPUT_AXIS_X, (int)[event deltaX]);
-                qemu_input_queue_rel(dcl.con, INPUT_AXIS_Y, (int)[event deltaY]);
-            }
+- (void) handleMouseEvent:(NSEvent *)event
+{
+    if (!isMouseGrabbed) {
+        return;
+    }
+
+    with_iothread_lock(^{
+        if (isAbsoluteEnabled) {
+            CGFloat d = (CGFloat)screen.height / [self frame].size.height;
+            NSPoint p = [event locationInWindow];
+            // Note that the origin for Cocoa mouse coords is bottom left, not top left.
+            qemu_input_queue_abs(dcl.con, INPUT_AXIS_X, p.x * d, 0, screen.width);
+            qemu_input_queue_abs(dcl.con, INPUT_AXIS_Y, screen.height - p.y * d, 0, screen.height);
         } else {
-            return false;
+            CGFloat d = (CGFloat)screen.height / [self convertSizeToBacking:[self frame].size].height;
+            qemu_input_queue_rel(dcl.con, INPUT_AXIS_X, [event deltaX] * d);
+            qemu_input_queue_rel(dcl.con, INPUT_AXIS_Y, [event deltaY] * d);
         }
+
         qemu_input_event_sync();
+    });
+}
+
+- (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool)down
+{
+    if (!isMouseGrabbed) {
+        return;
     }
-    return true;
+
+    with_iothread_lock(^{
+        qemu_input_queue_btn(dcl.con, button, down);
+    });
+
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseExited:(NSEvent *)event
+{
+    if (isAbsoluteEnabled && isMouseGrabbed) {
+        [self ungrabMouse];
+    }
+}
+
+- (void) mouseEntered:(NSEvent *)event
+{
+    if (isAbsoluteEnabled && !isMouseGrabbed) {
+        [self grabMouse];
+    }
+}
+
+- (void) mouseMoved:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:true];
+}
+
+- (void) rightMouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:true];
+}
+
+- (void) otherMouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:true];
+}
+
+- (void) mouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) rightMouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) otherMouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseUp:(NSEvent *)event
+{
+    if (!isMouseGrabbed) {
+        [self grabMouse];
+    }
+
+    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:false];
+}
+
+- (void) rightMouseUp:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:false];
+}
+
+- (void) otherMouseUp:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:false];
 }
 
 - (void) grabMouse
 {
     COCOA_DEBUG("QemuCocoaView: grabMouse\n");
 
-    if (!isFullscreen) {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
-        else
-            [normalWindow setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
-    }
+    if (qemu_name)
+        [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
+    else
+        [normalWindow setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
     [self hideCursor];
     CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
     isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
@@ -1137,15 +1066,14 @@ - (void) ungrabMouse
 {
     COCOA_DEBUG("QemuCocoaView: ungrabMouse\n");
 
-    if (!isFullscreen) {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
-        else
-            [normalWindow setTitle:@"QEMU"];
-    }
+    if (qemu_name)
+        [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
+    else
+        [normalWindow setTitle:@"QEMU"];
     [self unhideCursor];
     CGAssociateMouseAndMouseCursorPosition(TRUE);
     isMouseGrabbed = FALSE;
+    [self raiseAllButtons];
 }
 
 - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
@@ -1157,8 +1085,6 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
 - (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
 - (BOOL) isSwapOptionCommandEnabled {return screen.swap_option_command;}
-- (float) cdx {return cdx;}
-- (float) cdy {return cdy;}
 - (QEMUScreen) gscreen {return screen;}
 
 /*
@@ -1172,6 +1098,15 @@ - (void) raiseAllKeys
         qkbd_state_lift_all_keys(kbd);
     });
 }
+
+- (void) raiseAllButtons
+{
+    with_iothread_lock(^{
+        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_LEFT, false);
+        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_RIGHT, false);
+        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_MIDDLE, false);
+    });
+}
 @end
 
 
@@ -1186,7 +1121,6 @@ @interface QemuCocoaAppController : NSObject
 {
 }
 - (void)doToggleFullScreen:(id)sender;
-- (void)toggleFullScreen:(id)sender;
 - (void)showQEMUDoc:(id)sender;
 - (void)zoomToFit:(id) sender;
 - (void)displayConsole:(id)sender;
@@ -1229,12 +1163,12 @@ - (id) init
             exit(1);
         }
         [normalWindow setAcceptsMouseMovedEvents:YES];
-        [normalWindow setTitle:@"QEMU"];
+        [normalWindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
+        [normalWindow setTitle:qemu_name ? [NSString stringWithFormat:@"QEMU %s", qemu_name] : @"QEMU"];
         [normalWindow setContentView:cocoaView];
         [normalWindow makeKeyAndOrderFront:self];
         [normalWindow center];
         [normalWindow setDelegate: self];
-        stretch_video = false;
 
         /* Used for displaying pause on the screen */
         pauseLabel = [NSTextField new];
@@ -1305,9 +1239,20 @@ - (void)windowDidChangeScreen:(NSNotification *)notification
     [cocoaView updateUIInfo];
 }
 
+- (void)windowDidEnterFullScreen:(NSNotification *)notification
+{
+    [cocoaView grabMouse];
+}
+
+- (void)windowDidExitFullScreen:(NSNotification *)notification
+{
+    [cocoaView resizeWindow];
+    [cocoaView ungrabMouse];
+}
+
 - (void)windowDidResize:(NSNotification *)notification
 {
-    [cocoaView updateUIInfo];
+    [cocoaView frameUpdated];
 }
 
 /* Called when the user clicks on a window's close button */
@@ -1323,6 +1268,23 @@ - (BOOL)windowShouldClose:(id)sender
     return NO;
 }
 
+- (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
+{
+    if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
+        return NSMakeSize([cocoaView gscreen].width, [cocoaView gscreen].height);
+    }
+
+    return [cocoaView fixZoomedFullScreenSize:proposedSize];
+}
+
+- (NSApplicationPresentationOptions) window:(NSWindow *)window
+                                     willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions;
+
+{
+    return (proposedOptions & ~(NSApplicationPresentationAutoHideDock | NSApplicationPresentationAutoHideMenuBar)) |
+           NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar;
+}
+
 /* Called when QEMU goes into the background */
 - (void) applicationWillResignActive: (NSNotification *)aNotification
 {
@@ -1336,14 +1298,7 @@ - (void) applicationWillResignActive: (NSNotification *)aNotification
  */
 - (void) doToggleFullScreen:(id)sender
 {
-    [self toggleFullScreen:(id)sender];
-}
-
-- (void)toggleFullScreen:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: toggleFullScreen\n");
-
-    [cocoaView toggleFullScreen:sender];
+    [normalWindow toggleFullScreen:sender];
 }
 
 - (void) setFullGrab:(id)sender
@@ -1394,13 +1349,15 @@ - (void)showQEMUDoc:(id)sender
     [self openDocumentation: @"index.html"];
 }
 
-/* Stretches video to fit host monitor size */
+/* Toggles the flag which stretches video to fit host window size */
 - (void)zoomToFit:(id) sender
 {
-    stretch_video = !stretch_video;
-    if (stretch_video == true) {
+    if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [normalWindow setStyleMask:[normalWindow styleMask] | NSWindowStyleMaskResizable];
         [sender setState: NSControlStateValueOn];
     } else {
+        [normalWindow setStyleMask:[normalWindow styleMask] & ~NSWindowStyleMaskResizable];
+        [cocoaView resizeWindow];
         [sender setState: NSControlStateValueOff];
     }
 }
@@ -1408,7 +1365,9 @@ - (void)zoomToFit:(id) sender
 /* Displays the console on the screen */
 - (void)displayConsole:(id)sender
 {
-    console_select([sender tag]);
+    with_iothread_lock(^{
+        console_select([sender tag]);
+    });
 }
 
 /* Pause the guest */
@@ -2052,16 +2011,14 @@ static void cocoa_update(DisplayChangeListener *dcl,
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        NSRect rect;
-        if ([cocoaView cdx] == 1.0) {
-            rect = NSMakeRect(x, [cocoaView gscreen].height - y - h, w, h);
-        } else {
-            rect = NSMakeRect(
-                x * [cocoaView cdx],
-                ([cocoaView gscreen].height - y - h) * [cocoaView cdy],
-                w * [cocoaView cdx],
-                h * [cocoaView cdy]);
-        }
+        CGFloat d = [cocoaView frame].size.height / (CGFloat)[cocoaView gscreen].height;
+
+        NSRect rect = NSMakeRect(
+                x * d,
+                ([cocoaView gscreen].height - y - h) * d,
+                w * d,
+                h * d);
+
         [cocoaView setNeedsDisplayInRect:rect];
     });
 
@@ -2135,8 +2092,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
     /* if fullscreen mode is to be used */
     if (opts->has_full_screen && opts->full_screen) {
         dispatch_async(dispatch_get_main_queue(), ^{
-            [NSApp activateIgnoringOtherApps: YES];
-            [controller toggleFullScreen: nil];
+            [normalWindow toggleFullScreen: nil];
         });
     }
     if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {

From 9ea8f7a8047ffc6fd69bdb61ccd3a89fd53de0e8 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 8 Jul 2021 13:28:14 +0900
Subject: [PATCH 092/180] ui/cocoa: Do not perform unsafe cast of argv

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 68a6ae3df075..45d821ab8784 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -1947,12 +1947,12 @@ static void cocoa_clipboard_request(QemuClipboardInfo *info,
     exit(status);
 }
 
-int main (int argc, const char * argv[]) {
+int main (int argc, char **argv) {
     QemuThread thread;
 
     COCOA_DEBUG("Entered main()\n");
     gArgc = argc;
-    gArgv = (char **)argv;
+    gArgv = argv;
 
     qemu_sem_init(&display_init_sem, 0);
     qemu_sem_init(&app_started_sem, 0);

From b2708c468427afc232c0e7f2e4602841574529c1 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 8 Jul 2021 13:25:35 +0900
Subject: [PATCH 093/180] ui/cocoa: Use the standard about panel

This provides standard look and feel for the about panel and reduces
code.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 113 ++++++++++++-----------------------------------------
 1 file changed, 24 insertions(+), 89 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 45d821ab8784..c06e44b93ab9 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -84,7 +84,7 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 
 static void cocoa_refresh(DisplayChangeListener *dcl);
 
-static NSWindow *normalWindow, *about_window;
+static NSWindow *normalWindow;
 static const DisplayChangeListenerOps dcl_ops = {
     .dpy_name          = "cocoa",
     .dpy_gfx_update = cocoa_update,
@@ -1135,7 +1135,6 @@ - (void)changeDeviceMedia:(id)sender;
 - (BOOL)verifyQuit;
 - (void)openDocumentation:(NSString *)filename;
 - (IBAction) do_about_menu_item: (id) sender;
-- (void)make_about_window;
 - (void)adjustSpeed:(id)sender;
 @end
 
@@ -1186,7 +1185,6 @@ - (id) init
         supportedImageFileTypes = [NSArray arrayWithObjects: @"img", @"iso", @"dmg",
                                  @"qcow", @"qcow2", @"cloop", @"vmdk", @"cdr",
                                   @"toast", nil];
-        [self make_about_window];
     }
     return self;
 }
@@ -1510,92 +1508,29 @@ - (BOOL)verifyQuit
 /* The action method for the About menu item */
 - (IBAction) do_about_menu_item: (id) sender
 {
-    [about_window makeKeyAndOrderFront: nil];
-}
-
-/* Create and display the about dialog */
-- (void)make_about_window
-{
-    /* Make the window */
-    int x = 0, y = 0, about_width = 400, about_height = 200;
-    NSRect window_rect = NSMakeRect(x, y, about_width, about_height);
-    about_window = [[NSWindow alloc] initWithContentRect:window_rect
-                    styleMask:NSWindowStyleMaskTitled | NSWindowStyleMaskClosable |
-                    NSWindowStyleMaskMiniaturizable
-                    backing:NSBackingStoreBuffered
-                    defer:NO];
-    [about_window setTitle: @"About"];
-    [about_window setReleasedWhenClosed: NO];
-    [about_window center];
-    NSView *superView = [about_window contentView];
-
-    /* Create the dimensions of the picture */
-    int picture_width = 80, picture_height = 80;
-    x = (about_width - picture_width)/2;
-    y = about_height - picture_height - 10;
-    NSRect picture_rect = NSMakeRect(x, y, picture_width, picture_height);
-
-    /* Make the picture of QEMU */
-    NSImageView *picture_view = [[NSImageView alloc] initWithFrame:
-                                                     picture_rect];
-    char *qemu_image_path_c = get_relocated_path(CONFIG_QEMU_ICONDIR "/hicolor/512x512/apps/qemu.png");
-    NSString *qemu_image_path = [NSString stringWithUTF8String:qemu_image_path_c];
-    g_free(qemu_image_path_c);
-    NSImage *qemu_image = [[NSImage alloc] initWithContentsOfFile:qemu_image_path];
-    [picture_view setImage: qemu_image];
-    [picture_view setImageScaling: NSImageScaleProportionallyUpOrDown];
-    [superView addSubview: picture_view];
-
-    /* Make the name label */
-    NSBundle *bundle = [NSBundle mainBundle];
-    if (bundle) {
-        x = 0;
-        y = y - 25;
-        int name_width = about_width, name_height = 20;
-        NSRect name_rect = NSMakeRect(x, y, name_width, name_height);
-        NSTextField *name_label = [[NSTextField alloc] initWithFrame: name_rect];
-        [name_label setEditable: NO];
-        [name_label setBezeled: NO];
-        [name_label setDrawsBackground: NO];
-        [name_label setAlignment: NSTextAlignmentCenter];
-        NSString *qemu_name = [[bundle executablePath] lastPathComponent];
-        [name_label setStringValue: qemu_name];
-        [superView addSubview: name_label];
-    }
-
-    /* Set the version label's attributes */
-    x = 0;
-    y = 50;
-    int version_width = about_width, version_height = 20;
-    NSRect version_rect = NSMakeRect(x, y, version_width, version_height);
-    NSTextField *version_label = [[NSTextField alloc] initWithFrame:
-                                                      version_rect];
-    [version_label setEditable: NO];
-    [version_label setBezeled: NO];
-    [version_label setAlignment: NSTextAlignmentCenter];
-    [version_label setDrawsBackground: NO];
-
-    /* Create the version string*/
-    NSString *version_string;
-    version_string = [[NSString alloc] initWithFormat:
-    @"QEMU emulator version %s", QEMU_FULL_VERSION];
-    [version_label setStringValue: version_string];
-    [superView addSubview: version_label];
-
-    /* Make copyright label */
-    x = 0;
-    y = 35;
-    int copyright_width = about_width, copyright_height = 20;
-    NSRect copyright_rect = NSMakeRect(x, y, copyright_width, copyright_height);
-    NSTextField *copyright_label = [[NSTextField alloc] initWithFrame:
-                                                        copyright_rect];
-    [copyright_label setEditable: NO];
-    [copyright_label setBezeled: NO];
-    [copyright_label setDrawsBackground: NO];
-    [copyright_label setAlignment: NSTextAlignmentCenter];
-    [copyright_label setStringValue: [NSString stringWithFormat: @"%s",
-                                     QEMU_COPYRIGHT]];
-    [superView addSubview: copyright_label];
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    char *icon_path_c = get_relocated_path(CONFIG_QEMU_ICONDIR "/hicolor/512x512/apps/qemu.png");
+    NSString *icon_path = [NSString stringWithUTF8String:icon_path_c];
+    g_free(icon_path_c);
+    NSImage *icon = [[NSImage alloc] initWithContentsOfFile:icon_path];
+    NSString *version = @"QEMU emulator version " QEMU_FULL_VERSION;
+    NSString *copyright = @QEMU_COPYRIGHT;
+    NSDictionary *options;
+    if (icon) {
+        options = @{
+            NSAboutPanelOptionApplicationIcon : icon,
+            NSAboutPanelOptionApplicationVersion : version,
+            @"Copyright" : copyright,
+        };
+        [icon release];
+    } else {
+        options = @{
+            NSAboutPanelOptionApplicationVersion : version,
+            @"Copyright" : copyright,
+        };
+    }
+    [NSApp orderFrontStandardAboutPanelWithOptions:options];
+    [pool release];
 }
 
 /* Used by the Speed menu items */

From db430377c0ccff16807131e4437095f9c0c4dfa9 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 11 Feb 2021 18:30:49 +0900
Subject: [PATCH 094/180] ui/cocoa: Do not scale UI without "Zoom To Fit"

Cocoa scales UI for high-resolution display like Retina, but we do not
need it since we now have our own "Zoom To Fit" work well also for
windows, and the guest is aware of the resolution thanks to UI
information. This change reverts the scaling.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index c06e44b93ab9..71496588bfdc 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -503,6 +503,14 @@ - (void) drawRect:(NSRect) rect
     }
 }
 
+- (NSSize) computeUnzoomedSize
+{
+    CGFloat width = screen.width / [[self window] backingScaleFactor];
+    CGFloat height = screen.height / [[self window] backingScaleFactor];
+
+    return NSMakeSize(width, height);
+}
+
 - (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
 {
     NSSize size;
@@ -526,7 +534,7 @@ - (void) resizeWindow
     [[self window] setContentAspectRatio:NSMakeSize(screen.width, screen.height)];
 
     if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
-        [[self window] setContentSize:NSMakeSize(screen.width, screen.height)];
+        [[self window] setContentSize:[self computeUnzoomedSize]];
         [[self window] center];
     } else if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
         [[self window] setContentSize:[self fixZoomedFullScreenSize:[[[self window] screen] frame].size]];
@@ -563,10 +571,12 @@ - (void) updateUIInfo
         info.height_mm = 0;
     }
 
+    NSSize frameBackingSize = [self convertSizeToBacking:frameSize];
+
     info.xoff = 0;
     info.yoff = 0;
-    info.width = frameSize.width;
-    info.height = frameSize.height;
+    info.width = frameBackingSize.width;
+    info.height = frameBackingSize.height;
 
     dpy_set_ui_info(dcl.con, &info);
 }
@@ -1269,7 +1279,7 @@ - (BOOL)windowShouldClose:(id)sender
 - (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
 {
     if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
-        return NSMakeSize([cocoaView gscreen].width, [cocoaView gscreen].height);
+        return [cocoaView computeUnzoomedSize];
     }
 
     return [cocoaView fixZoomedFullScreenSize:proposedSize];

From 8c2f5eff66a42f00dfee5bc9748d1826b6db0708 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 18 Feb 2021 12:53:25 +0900
Subject: [PATCH 095/180] virtio-gpu: Respect UI refresh rate for EDID

This change adds a new member, refresh_rate to QemuUIInfo in
include/ui/console.h. It represents the refresh rate of the
physical display backend, and it is more appropriate than
GUI update interval as the refresh rate which the emulated device
reports:
- sdl may set GUI update interval shorter than the refresh rate
  of the physical display to respond to user-generated events.
- sdl and vnc aggressively changes GUI update interval, but
  a guests is typically not designed to respond to frequent
  refresh rate changes, or frequent "display mode" changes in
  general. The frequency of refresh rate changes of the physical
  display backend matches better to the guest's expectation.

QemuUIInfo also has other members representing "display mode",
which makes it suitable for refresh rate representation. It has
a throttling of update notifications, and prevents frequent changes
of the display mode.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 hw/display/virtio-gpu-base.c   |  1 +
 hw/display/virtio-gpu.c        |  1 +
 hw/display/xenfb.c             | 14 ++++++++---
 include/hw/virtio/virtio-gpu.h |  1 +
 include/ui/console.h           |  2 +-
 include/ui/gtk.h               |  2 +-
 ui/console.c                   |  6 -----
 ui/gtk-egl.c                   |  4 +--
 ui/gtk.c                       | 45 ++++++++++++++++++++--------------
 9 files changed, 44 insertions(+), 32 deletions(-)

diff --git a/hw/display/virtio-gpu-base.c b/hw/display/virtio-gpu-base.c
index c8da4806e0bb..765eb08921bf 100644
--- a/hw/display/virtio-gpu-base.c
+++ b/hw/display/virtio-gpu-base.c
@@ -79,6 +79,7 @@ static int virtio_gpu_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)
 
     g->req_state[idx].x = info->xoff;
     g->req_state[idx].y = info->yoff;
+    g->req_state[idx].refresh_rate = info->refresh_rate;
     g->req_state[idx].width = info->width;
     g->req_state[idx].height = info->height;
     g->req_state[idx].width_mm = info->width_mm;
diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
index 6b7f643951fe..cc3f828f95a7 100644
--- a/hw/display/virtio-gpu.c
+++ b/hw/display/virtio-gpu.c
@@ -217,6 +217,7 @@ virtio_gpu_generate_edid(VirtIOGPU *g, int scanout,
         .height_mm = b->req_state[scanout].height_mm,
         .prefx = b->req_state[scanout].width,
         .prefy = b->req_state[scanout].height,
+        .refresh_rate = b->req_state[scanout].refresh_rate,
     };
 
     edid->size = cpu_to_le32(sizeof(edid->edid));
diff --git a/hw/display/xenfb.c b/hw/display/xenfb.c
index 838260b6ad14..a53341ef673a 100644
--- a/hw/display/xenfb.c
+++ b/hw/display/xenfb.c
@@ -777,16 +777,24 @@ static void xenfb_update(void *opaque)
     xenfb->up_fullscreen = 0;
 }
 
-static void xenfb_update_interval(void *opaque, uint64_t interval)
+static void xenfb_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)
 {
     struct XenFB *xenfb = opaque;
+    uint32_t refresh_rate;
 
     if (xenfb->feature_update) {
 #ifdef XENFB_TYPE_REFRESH_PERIOD
         if (xenfb_queue_full(xenfb)) {
             return;
         }
-        xenfb_send_refresh_period(xenfb, interval);
+
+        refresh_rate = info->refresh_rate;
+        if (!refresh_rate) {
+            refresh_rate = 75;
+        }
+
+        /* T = 1 / f = 1 [s*Hz] / f = 1000*1000 [ms*mHz] / f */
+        xenfb_send_refresh_period(xenfb, 1000 * 1000 / refresh_rate);
 #endif
     }
 }
@@ -983,5 +991,5 @@ struct XenDevOps xen_framebuffer_ops = {
 static const GraphicHwOps xenfb_ops = {
     .invalidate  = xenfb_invalidate,
     .gfx_update  = xenfb_update,
-    .update_interval = xenfb_update_interval,
+    .ui_info     = xenfb_ui_info,
 };
diff --git a/include/hw/virtio/virtio-gpu.h b/include/hw/virtio/virtio-gpu.h
index bcf54d970f24..d5a1c69f9941 100644
--- a/include/hw/virtio/virtio-gpu.h
+++ b/include/hw/virtio/virtio-gpu.h
@@ -81,6 +81,7 @@ struct virtio_gpu_scanout {
 struct virtio_gpu_requested_state {
     uint16_t width_mm, height_mm;
     uint32_t width, height;
+    uint32_t refresh_rate;
     int x, y;
 };
 
diff --git a/include/ui/console.h b/include/ui/console.h
index b30b63976a5a..91516e3550d9 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -128,6 +128,7 @@ typedef struct QemuUIInfo {
     int       yoff;
     uint32_t  width;
     uint32_t  height;
+    uint32_t  refresh_rate;
 } QemuUIInfo;
 
 /* cursor data format is 32bit RGBA */
@@ -380,7 +381,6 @@ typedef struct GraphicHwOps {
     void (*gfx_update)(void *opaque);
     bool gfx_update_async; /* if true, calls graphic_hw_update_done() */
     void (*text_update)(void *opaque, console_ch_t *text);
-    void (*update_interval)(void *opaque, uint64_t interval);
     int (*ui_info)(void *opaque, uint32_t head, QemuUIInfo *info);
     void (*gl_block)(void *opaque, bool block);
     void (*gl_flushed)(void *opaque);
diff --git a/include/ui/gtk.h b/include/ui/gtk.h
index 9516670ebc87..4b052f204cce 100644
--- a/include/ui/gtk.h
+++ b/include/ui/gtk.h
@@ -151,7 +151,7 @@ extern bool gtk_use_gl_area;
 
 /* ui/gtk.c */
 void gd_update_windowsize(VirtualConsole *vc);
-int gd_monitor_update_interval(GtkWidget *widget);
+void gd_update_monitor_refresh_rate(VirtualConsole *vc, GtkWidget *widget);
 
 /* ui/gtk-egl.c */
 void gd_egl_init(VirtualConsole *vc);
diff --git a/ui/console.c b/ui/console.c
index 1103b6531470..63cc8f038d03 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -203,7 +203,6 @@ static void gui_update(void *opaque)
     uint64_t dcl_interval;
     DisplayState *ds = opaque;
     DisplayChangeListener *dcl;
-    QemuConsole *con;
 
     ds->refreshing = true;
     dpy_refresh(ds);
@@ -218,11 +217,6 @@ static void gui_update(void *opaque)
     }
     if (ds->update_interval != interval) {
         ds->update_interval = interval;
-        QTAILQ_FOREACH(con, &consoles, next) {
-            if (con->hw_ops->update_interval) {
-                con->hw_ops->update_interval(con->hw, interval);
-            }
-        }
         trace_console_refresh(interval);
     }
     ds->last_update = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
index 2a2e6d3a17d4..d9d3bba43168 100644
--- a/ui/gtk-egl.c
+++ b/ui/gtk-egl.c
@@ -116,8 +116,8 @@ void gd_egl_refresh(DisplayChangeListener *dcl)
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
 
-    vc->gfx.dcl.update_interval = gd_monitor_update_interval(
-            vc->window ? vc->window : vc->gfx.drawing_area);
+    gd_update_monitor_refresh_rate(
+            vc, vc->window ? vc->window : vc->gfx.drawing_area);
 
     if (!vc->gfx.esurface) {
         gd_egl_init(vc);
diff --git a/ui/gtk.c b/ui/gtk.c
index 376b4d528daa..f8f09b068c4a 100644
--- a/ui/gtk.c
+++ b/ui/gtk.c
@@ -669,11 +669,20 @@ static gboolean gd_window_close(GtkWidget *widget, GdkEvent *event,
     return TRUE;
 }
 
-static void gd_set_ui_info(VirtualConsole *vc, gint width, gint height)
+static void gd_set_ui_refresh_rate(VirtualConsole *vc, int refresh_rate)
 {
     QemuUIInfo info;
 
-    memset(&info, 0, sizeof(info));
+    info = *dpy_get_ui_info(vc->gfx.dcl.con);
+    info.refresh_rate = refresh_rate;
+    dpy_set_ui_info(vc->gfx.dcl.con, &info);
+}
+
+static void gd_set_ui_size(VirtualConsole *vc, gint width, gint height)
+{
+    QemuUIInfo info;
+
+    info = *dpy_get_ui_info(vc->gfx.dcl.con);
     info.width = width;
     info.height = height;
     dpy_set_ui_info(vc->gfx.dcl.con, &info);
@@ -697,33 +706,32 @@ static void gd_resize_event(GtkGLArea *area,
 {
     VirtualConsole *vc = (void *)opaque;
 
-    gd_set_ui_info(vc, width, height);
+    gd_set_ui_size(vc, width, height);
 }
 
 #endif
 
-/*
- * If available, return the update interval of the monitor in ms,
- * else return 0 (the default update interval).
- */
-int gd_monitor_update_interval(GtkWidget *widget)
+void gd_update_monitor_refresh_rate(VirtualConsole *vc, GtkWidget *widget)
 {
 #ifdef GDK_VERSION_3_22
     GdkWindow *win = gtk_widget_get_window(widget);
+    int refresh_rate;
 
     if (win) {
         GdkDisplay *dpy = gtk_widget_get_display(widget);
         GdkMonitor *monitor = gdk_display_get_monitor_at_window(dpy, win);
-        int refresh_rate = gdk_monitor_get_refresh_rate(monitor); /* [mHz] */
-
-        if (refresh_rate) {
-            /* T = 1 / f = 1 [s*Hz] / f = 1000*1000 [ms*mHz] / f */
-            return MIN(1000 * 1000 / refresh_rate,
-                       GUI_REFRESH_INTERVAL_DEFAULT);
-        }
+        refresh_rate = gdk_monitor_get_refresh_rate(monitor); /* [mHz] */
+    } else {
+        refresh_rate = 0;
     }
+
+    gd_set_ui_refresh_rate(vc, refresh_rate);
+
+    /* T = 1 / f = 1 [s*Hz] / f = 1000*1000 [ms*mHz] / f */
+    vc->gfx.dcl.update_interval = refresh_rate ?
+        MIN(1000 * 1000 / refresh_rate, GUI_REFRESH_INTERVAL_DEFAULT) :
+        GUI_REFRESH_INTERVAL_DEFAULT;
 #endif
-    return 0;
 }
 
 static gboolean gd_draw_event(GtkWidget *widget, cairo_t *cr, void *opaque)
@@ -757,8 +765,7 @@ static gboolean gd_draw_event(GtkWidget *widget, cairo_t *cr, void *opaque)
         return FALSE;
     }
 
-    vc->gfx.dcl.update_interval =
-        gd_monitor_update_interval(vc->window ? vc->window : s->window);
+    gd_update_monitor_refresh_rate(vc, vc->window ? vc->window : s->window);
 
     fbw = surface_width(vc->gfx.ds);
     fbh = surface_height(vc->gfx.ds);
@@ -1602,7 +1609,7 @@ static gboolean gd_configure(GtkWidget *widget,
 {
     VirtualConsole *vc = opaque;
 
-    gd_set_ui_info(vc, cfg->width, cfg->height);
+    gd_set_ui_size(vc, cfg->width, cfg->height);
     return FALSE;
 }
 

From 2565eea22b64947d0375683cc8710b4d0c1bef26 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 14 Jul 2021 12:27:47 +0900
Subject: [PATCH 096/180] ui/egl-headless: Remove a check for CONFIG_OPENGL

ui/egl-headless is only built when CONFIG_OPENGL is defined because it
depends on CONFIG_OPENGL without condition. Remove a redundant
conditonal in ui/egl-headless.c

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/egl-headless.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/ui/egl-headless.c b/ui/egl-headless.c
index 75404e0e8700..a26a2520c496 100644
--- a/ui/egl-headless.c
+++ b/ui/egl-headless.c
@@ -214,6 +214,4 @@ static void register_egl(void)
 
 type_init(register_egl);
 
-#ifdef CONFIG_OPENGL
 module_dep("ui-opengl");
-#endif

From 110dbe7e89ea7a7fcfb2e1682f51ce65a0096a97 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 14 Jul 2021 12:35:13 +0900
Subject: [PATCH 097/180] ui/spice: Use HAVE_SPICE_GL for OpenGL checks

Some code in ui/spice used CONFIG_OPENGL for OpenGL conditionals, but
SPICE also depends on CONFIG_GBM and SPICE server whose version is
0.13.1 or later for OpenGL. Always use HAVE_SPICE_GL, which defines the
precise condition.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/spice-app.c  | 3 ++-
 ui/spice-core.c | 2 +-
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/ui/spice-app.c b/ui/spice-app.c
index 641f4a9d53e3..7e71e18da9ad 100644
--- a/ui/spice-app.c
+++ b/ui/spice-app.c
@@ -27,6 +27,7 @@
 #include <gio/gio.h>
 
 #include "ui/console.h"
+#include "ui/spice-display.h"
 #include "qemu/config-file.h"
 #include "qemu/option.h"
 #include "qemu/cutils.h"
@@ -175,7 +176,7 @@ static void spice_app_display_early_init(DisplayOptions *opts)
     qemu_opt_set(qopts, "addr", sock_path, &error_abort);
     qemu_opt_set(qopts, "image-compression", "off", &error_abort);
     qemu_opt_set(qopts, "streaming-video", "off", &error_abort);
-#ifdef CONFIG_OPENGL
+#ifdef HAVE_SPICE_GL
     qemu_opt_set(qopts, "gl", opts->has_gl ? "on" : "off", &error_abort);
     display_opengl = opts->has_gl;
 #endif
diff --git a/ui/spice-core.c b/ui/spice-core.c
index 86d43783acac..0371055e6c17 100644
--- a/ui/spice-core.c
+++ b/ui/spice-core.c
@@ -1039,6 +1039,6 @@ static void spice_register_config(void)
 opts_init(spice_register_config);
 module_opts("spice");
 
-#ifdef CONFIG_OPENGL
+#ifdef HAVE_SPICE_GL
 module_dep("ui-opengl");
 #endif

From 3184f37bbe6bfbe90124bab0dab8ea8088b2aa0f Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Tue, 23 Feb 2021 15:12:22 +0900
Subject: [PATCH 098/180] Support Virgil 3D renderer on macOS

Virgil 3D renderer will be available with ui/cocoa on macOS.

The OpenGL backend is NSOpenGLContext for core profile, and
EGL (in particular, ANGLE) for ES profile.

As a notable change, CONFIG_OPENGL_DMABUF is replaced with the
combination of CONFIG_EGL and CONFIG_GBM. In fact, the old
detection of DMA-BUF in configure script was not working
because EGL_MESA_image_dma_buf_export is always defined in
<epoxy/egl.h>. Therefore, the new combination should
behave in the same way.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 configure                        |  25 +-
 hw/display/vhost-user-gpu.c      |   2 +-
 hw/display/virtio-gpu.c          |   6 +-
 include/ui/console.h             |  66 +++--
 include/ui/egl-context.h         |   8 +-
 include/ui/egl-helpers.h         |   4 +-
 include/ui/gtk.h                 |  43 ++-
 include/ui/sdl2.h                |  17 +-
 include/ui/spice-display.h       |   2 +-
 qemu-options.hx                  |   2 +-
 ui/cocoa.m                       | 462 ++++++++++++++++++++++++++-----
 ui/console.c                     | 134 +++++----
 ui/egl-context.c                 |   8 +-
 ui/egl-headless.c                |  63 +++--
 ui/egl-helpers.c                 | 136 ++++-----
 ui/gtk-egl.c                     |  44 +--
 ui/gtk-gl-area.c                 |  32 +--
 ui/gtk.c                         |  62 +++--
 ui/meson.build                   |  14 +-
 ui/sdl2-gl.c                     |  25 +-
 ui/sdl2.c                        |  33 ++-
 ui/shader.c                      |  14 +-
 ui/shader/texture-blit-flip.vert |   3 -
 ui/shader/texture-blit.frag      |   3 -
 ui/shader/texture-blit.vert      |   3 -
 ui/spice-display.c               |  36 +--
 26 files changed, 827 insertions(+), 420 deletions(-)

diff --git a/configure b/configure
index 4d0a2bfdd873..f711778086e9 100755
--- a/configure
+++ b/configure
@@ -377,6 +377,7 @@ u2f="auto"
 libusb="auto"
 usb_redir="auto"
 opengl="$default_feature"
+egl="no"
 cpuid_h="no"
 avx2_opt="$default_feature"
 capstone="auto"
@@ -3380,18 +3381,7 @@ if $pkg_config gbm; then
 fi
 
 if test "$opengl" != "no" ; then
-  epoxy=no
   if $pkg_config epoxy; then
-    cat > $TMPC << EOF
-#include <epoxy/egl.h>
-int main(void) { return 0; }
-EOF
-    if compile_prog "" "" ; then
-      epoxy=yes
-    fi
-  fi
-
-  if test "$epoxy" = "yes" ; then
     opengl_cflags="$($pkg_config --cflags epoxy)"
     opengl_libs="$($pkg_config --libs epoxy)"
     opengl=yes
@@ -3405,6 +3395,16 @@ EOF
   fi
 fi
 
+if test "$opengl" = "yes"; then
+  cat > $TMPC << EOF
+#include <epoxy/egl.h>
+int main(void) { return 0; }
+EOF
+  if compile_prog "" "" ; then
+    egl=yes
+  fi
+fi
+
 ##########################################
 # libnuma probe
 
@@ -4658,6 +4658,9 @@ if test "$opengl" = "yes" ; then
   echo "CONFIG_OPENGL=y" >> $config_host_mak
   echo "OPENGL_CFLAGS=$opengl_cflags" >> $config_host_mak
   echo "OPENGL_LIBS=$opengl_libs" >> $config_host_mak
+  if test "$egl" = "yes" ; then
+    echo "CONFIG_EGL=y" >> $config_host_mak
+  fi
 fi
 
 if test "$gbm" = "yes" ; then
diff --git a/hw/display/vhost-user-gpu.c b/hw/display/vhost-user-gpu.c
index 49df56cd14e9..f88d548164c1 100644
--- a/hw/display/vhost-user-gpu.c
+++ b/hw/display/vhost-user-gpu.c
@@ -249,7 +249,7 @@ vhost_user_gpu_handle_display(VhostUserGPU *g, VhostUserGpuMsg *msg)
         }
 
         con = g->parent_obj.scanout[m->scanout_id].con;
-        if (!console_has_gl(con)) {
+        if (!console_has_gl()) {
             error_report("console doesn't support GL!");
             vhost_user_gpu_unblock(g);
             break;
diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
index cc3f828f95a7..274cd46f89c2 100644
--- a/hw/display/virtio-gpu.c
+++ b/hw/display/virtio-gpu.c
@@ -521,7 +521,7 @@ static void virtio_gpu_resource_flush(VirtIOGPU *g,
         for (i = 0; i < g->parent_obj.conf.max_outputs; i++) {
             scanout = &g->parent_obj.scanout[i];
             if (scanout->resource_id == res->resource_id &&
-                console_has_gl(scanout->con)) {
+                console_has_gl()) {
                 dpy_gl_update(scanout->con, 0, 0, scanout->width,
                               scanout->height);
                 return;
@@ -633,7 +633,7 @@ static void virtio_gpu_do_set_scanout(VirtIOGPU *g,
     g->parent_obj.enable = 1;
 
     if (res->blob) {
-        if (console_has_gl(scanout->con)) {
+        if (console_has_gl()) {
             if (!virtio_gpu_update_dmabuf(g, scanout_id, res, fb)) {
                 virtio_gpu_update_scanout(g, scanout_id, res, r);
                 return;
@@ -646,7 +646,7 @@ static void virtio_gpu_do_set_scanout(VirtIOGPU *g,
     }
 
     /* create a surface for this scanout */
-    if ((res->blob && !console_has_gl(scanout->con)) ||
+    if ((res->blob && !console_has_gl()) ||
         !scanout->ds ||
         surface_data(scanout->ds) != data + fb->offset ||
         scanout->width != r->width ||
diff --git a/include/ui/console.h b/include/ui/console.h
index 91516e3550d9..5e38906f0747 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -207,54 +207,48 @@ typedef struct DisplayChangeListenerOps {
                               QEMUCursor *cursor);
 
     /* required if GL */
-    QEMUGLContext (*dpy_gl_ctx_create)(DisplayChangeListener *dcl,
-                                       QEMUGLParams *params);
-    /* required if GL */
-    void (*dpy_gl_ctx_destroy)(DisplayChangeListener *dcl,
-                               QEMUGLContext ctx);
-    /* required if GL */
-    int (*dpy_gl_ctx_make_current)(DisplayChangeListener *dcl,
-                                   QEMUGLContext ctx);
+    void (*dpy_gl_update)(DisplayChangeListener *dcl,
+                          uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 
-    /* required if GL */
-    void (*dpy_gl_scanout_disable)(DisplayChangeListener *dcl);
-    /* required if GL */
-    void (*dpy_gl_scanout_texture)(DisplayChangeListener *dcl,
+} DisplayChangeListenerOps;
+
+struct DisplayChangeListener {
+    uint64_t update_interval;
+    const DisplayChangeListenerOps *ops;
+    DisplayState *ds;
+    QemuConsole *con;
+
+    QLIST_ENTRY(DisplayChangeListener) next;
+};
+
+typedef struct DisplayGLOps {
+    QEMUGLContext (*dpy_gl_ctx_create)(void *dg, QEMUGLParams *params);
+    void (*dpy_gl_ctx_destroy)(void *dg, QEMUGLContext ctx);
+    int (*dpy_gl_ctx_make_current)(void *dg, QEMUGLContext ctx);
+
+    bool (*dpy_gl_scanout_get_enabled)(void *dg);
+    void (*dpy_gl_scanout_disable)(void *dg);
+    void (*dpy_gl_scanout_texture)(void *dg,
                                    uint32_t backing_id,
                                    bool backing_y_0_top,
                                    uint32_t backing_width,
                                    uint32_t backing_height,
                                    uint32_t x, uint32_t y,
                                    uint32_t w, uint32_t h);
+
     /* optional (default to true if has dpy_gl_scanout_dmabuf) */
-    bool (*dpy_has_dmabuf)(DisplayChangeListener *dcl);
+    bool (*dpy_has_dmabuf)(void *dg);
     /* optional */
-    void (*dpy_gl_scanout_dmabuf)(DisplayChangeListener *dcl,
-                                  QemuDmaBuf *dmabuf);
+    void (*dpy_gl_scanout_dmabuf)(void *dg, QemuDmaBuf *dmabuf);
     /* optional */
-    void (*dpy_gl_cursor_dmabuf)(DisplayChangeListener *dcl,
+    void (*dpy_gl_cursor_dmabuf)(void *dg,
                                  QemuDmaBuf *dmabuf, bool have_hot,
                                  uint32_t hot_x, uint32_t hot_y);
     /* optional */
-    void (*dpy_gl_cursor_position)(DisplayChangeListener *dcl,
-                                   uint32_t pos_x, uint32_t pos_y);
+    void (*dpy_gl_cursor_position)(void *dg, uint32_t pos_x, uint32_t pos_y);
     /* optional */
-    void (*dpy_gl_release_dmabuf)(DisplayChangeListener *dcl,
-                                  QemuDmaBuf *dmabuf);
-    /* required if GL */
-    void (*dpy_gl_update)(DisplayChangeListener *dcl,
-                          uint32_t x, uint32_t y, uint32_t w, uint32_t h);
-
-} DisplayChangeListenerOps;
-
-struct DisplayChangeListener {
-    uint64_t update_interval;
-    const DisplayChangeListenerOps *ops;
-    DisplayState *ds;
-    QemuConsole *con;
-
-    QLIST_ENTRY(DisplayChangeListener) next;
-};
+    void (*dpy_gl_release_dmabuf)(void *dg, QemuDmaBuf *dmabuf);
+} DisplayGLOps;
 
 DisplayState *init_displaystate(void);
 DisplaySurface *qemu_create_displaysurface_from(int width, int height,
@@ -278,6 +272,7 @@ static inline int is_placeholder(DisplaySurface *surface)
     return surface->flags & QEMU_PLACEHOLDER_FLAG;
 }
 
+void register_displayglops(const DisplayGLOps *dg_ops);
 void register_displaychangelistener(DisplayChangeListener *dcl);
 void update_displaychangelistener(DisplayChangeListener *dcl,
                                   uint64_t interval);
@@ -321,7 +316,8 @@ QEMUGLContext dpy_gl_ctx_create(QemuConsole *con,
 void dpy_gl_ctx_destroy(QemuConsole *con, QEMUGLContext ctx);
 int dpy_gl_ctx_make_current(QemuConsole *con, QEMUGLContext ctx);
 
-bool console_has_gl(QemuConsole *con);
+void console_set_displayglcontext(QemuConsole *con, void *dg);
+bool console_has_gl(void);
 
 static inline int surface_stride(DisplaySurface *s)
 {
diff --git a/include/ui/egl-context.h b/include/ui/egl-context.h
index 9374fe41e32b..450ac78ad38b 100644
--- a/include/ui/egl-context.h
+++ b/include/ui/egl-context.h
@@ -4,10 +4,8 @@
 #include "ui/console.h"
 #include "ui/egl-helpers.h"
 
-QEMUGLContext qemu_egl_create_context(DisplayChangeListener *dcl,
-                                      QEMUGLParams *params);
-void qemu_egl_destroy_context(DisplayChangeListener *dcl, QEMUGLContext ctx);
-int qemu_egl_make_context_current(DisplayChangeListener *dcl,
-                                  QEMUGLContext ctx);
+QEMUGLContext qemu_egl_create_context(void *dg, QEMUGLParams *params);
+void qemu_egl_destroy_context(void *dg, QEMUGLContext ctx);
+int qemu_egl_make_context_current(void *dg, QEMUGLContext ctx);
 
 #endif /* EGL_CONTEXT_H */
diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
index f1bf8f97fc33..e36cc0060553 100644
--- a/include/ui/egl-helpers.h
+++ b/include/ui/egl-helpers.h
@@ -48,7 +48,9 @@ void egl_dmabuf_release_texture(QemuDmaBuf *dmabuf);
 
 #endif
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win);
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win);
+
+int qemu_egl_init_dpy_cocoa(DisplayGLMode mode);
 
 #if defined(CONFIG_X11) || defined(CONFIG_GBM)
 
diff --git a/include/ui/gtk.h b/include/ui/gtk.h
index 4b052f204cce..104d342f7e17 100644
--- a/include/ui/gtk.h
+++ b/include/ui/gtk.h
@@ -21,7 +21,7 @@
 #include "ui/clipboard.h"
 #include "ui/console.h"
 #include "ui/kbd-state.h"
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 #include "ui/egl-helpers.h"
 #include "ui/egl-context.h"
 #endif
@@ -39,7 +39,7 @@ typedef struct VirtualGfxConsole {
     cairo_surface_t *surface;
     double scale_x;
     double scale_y;
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     QemuGLShader *gls;
     EGLContext ectx;
     EGLSurface esurface;
@@ -161,30 +161,26 @@ void gd_egl_update(DisplayChangeListener *dcl,
 void gd_egl_refresh(DisplayChangeListener *dcl);
 void gd_egl_switch(DisplayChangeListener *dcl,
                    DisplaySurface *surface);
-QEMUGLContext gd_egl_create_context(DisplayChangeListener *dcl,
-                                    QEMUGLParams *params);
-void gd_egl_scanout_disable(DisplayChangeListener *dcl);
-void gd_egl_scanout_texture(DisplayChangeListener *dcl,
+QEMUGLContext gd_egl_create_context(void *dg, QEMUGLParams *params);
+bool gd_egl_scanout_get_enabled(void *dg);
+void gd_egl_scanout_disable(void *dg);
+void gd_egl_scanout_texture(void *dg,
                             uint32_t backing_id,
                             bool backing_y_0_top,
                             uint32_t backing_width,
                             uint32_t backing_height,
                             uint32_t x, uint32_t y,
                             uint32_t w, uint32_t h);
-void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                           QemuDmaBuf *dmabuf);
-void gd_egl_cursor_dmabuf(DisplayChangeListener *dcl,
+void gd_egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf);
+void gd_egl_cursor_dmabuf(void *dg,
                           QemuDmaBuf *dmabuf, bool have_hot,
                           uint32_t hot_x, uint32_t hot_y);
-void gd_egl_cursor_position(DisplayChangeListener *dcl,
-                            uint32_t pos_x, uint32_t pos_y);
-void gd_egl_release_dmabuf(DisplayChangeListener *dcl,
-                           QemuDmaBuf *dmabuf);
+void gd_egl_cursor_position(void *dg, uint32_t pos_x, uint32_t pos_y);
+void gd_egl_release_dmabuf(void *dg, QemuDmaBuf *dmabuf);
 void gd_egl_scanout_flush(DisplayChangeListener *dcl,
                           uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 void gtk_egl_init(DisplayGLMode mode);
-int gd_egl_make_current(DisplayChangeListener *dcl,
-                        QEMUGLContext ctx);
+int gd_egl_make_current(void *dg, QEMUGLContext ctx);
 
 /* ui/gtk-gl-area.c */
 void gd_gl_area_init(VirtualConsole *vc);
@@ -194,25 +190,22 @@ void gd_gl_area_update(DisplayChangeListener *dcl,
 void gd_gl_area_refresh(DisplayChangeListener *dcl);
 void gd_gl_area_switch(DisplayChangeListener *dcl,
                        DisplaySurface *surface);
-QEMUGLContext gd_gl_area_create_context(DisplayChangeListener *dcl,
-                                        QEMUGLParams *params);
-void gd_gl_area_destroy_context(DisplayChangeListener *dcl,
-                                QEMUGLContext ctx);
-void gd_gl_area_scanout_dmabuf(DisplayChangeListener *dcl,
-                               QemuDmaBuf *dmabuf);
-void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
+QEMUGLContext gd_gl_area_create_context(void *dg, QEMUGLParams *params);
+void gd_gl_area_destroy_context(void *dg, QEMUGLContext ctx);
+bool gd_gl_area_scanout_get_enabled(void *dg);
+void gd_gl_area_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf);
+void gd_gl_area_scanout_texture(void *dg,
                                 uint32_t backing_id,
                                 bool backing_y_0_top,
                                 uint32_t backing_width,
                                 uint32_t backing_height,
                                 uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h);
-void gd_gl_area_scanout_disable(DisplayChangeListener *dcl);
+void gd_gl_area_scanout_disable(void *dg);
 void gd_gl_area_scanout_flush(DisplayChangeListener *dcl,
                               uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 void gtk_gl_area_init(void);
-int gd_gl_area_make_current(DisplayChangeListener *dcl,
-                            QEMUGLContext ctx);
+int gd_gl_area_make_current(void *dg, QEMUGLContext ctx);
 
 /* gtk-clipboard.c */
 void gd_clipboard_init(GtkDisplayState *gd);
diff --git a/include/ui/sdl2.h b/include/ui/sdl2.h
index f85c117a78f2..41082ec660be 100644
--- a/include/ui/sdl2.h
+++ b/include/ui/sdl2.h
@@ -11,7 +11,7 @@
 #endif
 
 #include "ui/kbd-state.h"
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 # include "ui/egl-helpers.h"
 #endif
 
@@ -32,7 +32,7 @@ struct sdl2_console {
     int ignore_hotkeys;
     SDL_GLContext winctx;
     QKbdState *kbd;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     QemuGLShader *gls;
     egl_fb guest_fb;
     egl_fb win_fb;
@@ -65,14 +65,13 @@ void sdl2_gl_switch(DisplayChangeListener *dcl,
 void sdl2_gl_refresh(DisplayChangeListener *dcl);
 void sdl2_gl_redraw(struct sdl2_console *scon);
 
-QEMUGLContext sdl2_gl_create_context(DisplayChangeListener *dcl,
-                                     QEMUGLParams *params);
-void sdl2_gl_destroy_context(DisplayChangeListener *dcl, QEMUGLContext ctx);
-int sdl2_gl_make_context_current(DisplayChangeListener *dcl,
-                                 QEMUGLContext ctx);
+QEMUGLContext sdl2_gl_create_context(void *dg, QEMUGLParams *params);
+void sdl2_gl_destroy_context(void *dg, QEMUGLContext ctx);
+int sdl2_gl_make_context_current(void *dg, QEMUGLContext ctx);
 
-void sdl2_gl_scanout_disable(DisplayChangeListener *dcl);
-void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
+bool sdl2_gl_scanout_get_enabled(void *dg);
+void sdl2_gl_scanout_disable(void *dg);
+void sdl2_gl_scanout_texture(void *dg,
                              uint32_t backing_id,
                              bool backing_y_0_top,
                              uint32_t backing_width,
diff --git a/include/ui/spice-display.h b/include/ui/spice-display.h
index ed298d58f06c..894234e87462 100644
--- a/include/ui/spice-display.h
+++ b/include/ui/spice-display.h
@@ -27,7 +27,7 @@
 #include "ui/qemu-pixman.h"
 #include "ui/console.h"
 
-#if defined(CONFIG_OPENGL) && defined(CONFIG_GBM)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL) && defined(CONFIG_GBM)
 # if SPICE_SERVER_VERSION >= 0x000d01 /* release 0.13.1 */
 #  define HAVE_SPICE_GL 1
 #  include "ui/egl-helpers.h"
diff --git a/qemu-options.hx b/qemu-options.hx
index 7cdacc83ae13..f72107794097 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -1800,7 +1800,7 @@ DEF("display", HAS_ARG, QEMU_OPTION_display,
     "-display cocoa[,full-grab=on|off]\n"
     "              [,swap-option-command=on|off]\n"
 #endif
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     "-display egl-headless[,rendernode=<file>]\n"
 #endif
     "-display none\n"
diff --git a/ui/cocoa.m b/ui/cocoa.m
index 71496588bfdc..432b7aebf0cd 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -47,6 +47,10 @@
 #include <Carbon/Carbon.h>
 #include "hw/core/cpu.h"
 
+#ifdef CONFIG_EGL
+#include "ui/egl-context.h"
+#endif
+
 #ifndef MAC_OS_X_VERSION_10_13
 #define MAC_OS_X_VERSION_10_13 101300
 #endif
@@ -76,24 +80,10 @@
     bool swap_option_command;
 } QEMUScreen;
 
-static void cocoa_update(DisplayChangeListener *dcl,
-                         int x, int y, int w, int h);
-
-static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *surface);
-
-static void cocoa_refresh(DisplayChangeListener *dcl);
-
 static NSWindow *normalWindow;
-static const DisplayChangeListenerOps dcl_ops = {
-    .dpy_name          = "cocoa",
-    .dpy_gfx_update = cocoa_update,
-    .dpy_gfx_switch = cocoa_switch,
-    .dpy_refresh = cocoa_refresh,
-};
-static DisplayChangeListener dcl = {
-    .ops = &dcl_ops,
-};
+static DisplayChangeListener dcl;
+static DisplaySurface *surface;
+static QemuMutex surface_mutex;
 static int cursor_hide = 1;
 
 static int gArgc;
@@ -109,6 +99,26 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 static QemuClipboardInfo *cbinfo;
 static QemuEvent cbevent;
 
+#ifdef CONFIG_OPENGL
+
+typedef struct {
+    uint32_t scanout_id;
+    bool scanout_y0_top;
+    bool surface_dirty;
+} DisplayGL;
+
+static DisplayGL *dgs;
+static QEMUGLContext view_ctx;
+static QemuGLShader *gls;
+
+#ifdef CONFIG_EGL
+static EGLSurface egl_surface;
+#endif
+
+static void cocoa_gl_destroy_context(void *dg, QEMUGLContext ctx);
+
+#endif
+
 // Utility functions to run specified code block with iothread lock held
 typedef void (^CodeBlock)(void);
 typedef bool (^BoolCodeBlock)(void);
@@ -302,13 +312,11 @@ @interface QemuCocoaView : NSView
 {
     NSTrackingArea *trackingArea;
     QEMUScreen screen;
-    pixman_image_t *pixman_image;
     QKbdState *kbd;
     BOOL isMouseGrabbed;
     BOOL isAbsoluteEnabled;
     CFMachPortRef eventsTap;
 }
-- (void) switchSurface:(pixman_image_t *)image;
 - (void) grabMouse;
 - (void) ungrabMouse;
 - (void) setFullGrab:(id)sender;
@@ -327,7 +335,6 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
 - (BOOL) isMouseGrabbed;
 - (BOOL) isAbsoluteEnabled;
 - (BOOL) isSwapOptionCommandEnabled;
-- (QEMUScreen) gscreen;
 - (void) raiseAllKeys;
 @end
 
@@ -366,10 +373,6 @@ - (void) dealloc
 {
     COCOA_DEBUG("QemuCocoaView: dealloc\n");
 
-    if (pixman_image) {
-        pixman_image_unref(pixman_image);
-    }
-
     qkbd_state_free(kbd);
 
     if (eventsTap) {
@@ -441,29 +444,39 @@ - (void) drawRect:(NSRect) rect
 {
     COCOA_DEBUG("QemuCocoaView: drawRect\n");
 
+#ifdef CONFIG_OPENGL
+    if (display_opengl) {
+        return;
+    }
+#endif
+
     // get CoreGraphic context
     CGContextRef viewContextRef = [[NSGraphicsContext currentContext] CGContext];
 
     CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
     CGContextSetShouldAntialias (viewContextRef, NO);
 
+    qemu_mutex_lock(&surface_mutex);
+
     // draw screen bitmap directly to Core Graphics context
-    if (!pixman_image) {
+    if (!surface) {
         // Draw request before any guest device has set up a framebuffer:
         // just draw an opaque black rectangle
         CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
         CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
     } else {
-        int w = pixman_image_get_width(pixman_image);
-        int h = pixman_image_get_height(pixman_image);
-        int bitsPerPixel = PIXMAN_FORMAT_BPP(pixman_image_get_format(pixman_image));
-        int stride = pixman_image_get_stride(pixman_image);
+        int w = surface_width(surface);
+        int h = surface_height(surface);
+        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(surface));
+        int stride = surface_stride(surface);
+
         CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
             NULL,
-            pixman_image_get_data(pixman_image),
+            surface_data(surface),
             stride * h,
             NULL
         );
+
         CGImageRef imageRef = CGImageCreate(
             w, //width
             h, //height
@@ -501,6 +514,8 @@ - (void) drawRect:(NSRect) rect
         CGImageRelease (imageRef);
         CGDataProviderRelease(dataProviderRef);
     }
+
+    qemu_mutex_unlock(&surface_mutex);
 }
 
 - (NSSize) computeUnzoomedSize
@@ -581,27 +596,16 @@ - (void) updateUIInfo
     dpy_set_ui_info(dcl.con, &info);
 }
 
-- (void) switchSurface:(pixman_image_t *)image
+- (void) updateScreenWidth:(int)w height:(int)h
 {
-    COCOA_DEBUG("QemuCocoaView: switchSurface\n");
-
-    int w = pixman_image_get_width(image);
-    int h = pixman_image_get_height(image);
+    COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
 
     if (w != screen.width || h != screen.height) {
-        // Resize before we trigger the redraw, or we'll redraw at the wrong size
-        COCOA_DEBUG("switchSurface: new size %d x %d\n", w, h);
+        COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
         screen.width = w;
         screen.height = h;
         [self resizeWindow];
     }
-
-    // update screenBuffer
-    if (pixman_image) {
-        pixman_image_unref(pixman_image);
-    }
-
-    pixman_image = image;
 }
 
 - (void) setFullGrab:(id)sender
@@ -711,7 +715,7 @@ - (void) handleMonitorInput:(NSEvent *)event
 
 - (bool) handleEvent:(NSEvent *)event
 {
-    if(!allow_events) {
+    if(!qatomic_read(&allow_events)) {
         /*
          * Just let OSX have all events that arrive before
          * applicationDidFinishLaunching.
@@ -1095,7 +1099,6 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
 - (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
 - (BOOL) isSwapOptionCommandEnabled {return screen.swap_option_command;}
-- (QEMUScreen) gscreen {return screen;}
 
 /*
  * Makes the target think all down keys are being released.
@@ -1211,7 +1214,6 @@ - (void) dealloc
 - (void)applicationDidFinishLaunching: (NSNotification *) note
 {
     COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
-    allow_events = true;
     /* Tell cocoa_display_init to proceed */
     qemu_sem_post(&app_started_sem);
 }
@@ -1889,6 +1891,13 @@ static void cocoa_clipboard_request(QemuClipboardInfo *info,
     status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
     COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
     [cbowner release];
+#ifdef CONFIG_OPENGL
+    g_free(dgs);
+    qemu_gl_fini_shader(gls);
+    if (view_ctx) {
+        cocoa_gl_destroy_context(NULL, view_ctx);
+    }
+#endif
     exit(status);
 }
 
@@ -1905,6 +1914,8 @@ int main (int argc, char **argv) {
     qemu_thread_create(&thread, "qemu_main", call_qemu_main,
                        NULL, QEMU_THREAD_DETACHED);
 
+    qemu_mutex_init(&surface_mutex);
+
     COCOA_DEBUG("Main thread: waiting for display_init_sem\n");
     qemu_sem_wait(&display_init_sem);
     COCOA_DEBUG("Main thread: initializing app\n");
@@ -1952,18 +1963,21 @@ static void cocoa_update(DisplayChangeListener *dcl,
                          int x, int y, int w, int h)
 {
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    DisplaySurface *updated = surface;
 
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        CGFloat d = [cocoaView frame].size.height / (CGFloat)[cocoaView gscreen].height;
-
-        NSRect rect = NSMakeRect(
-                x * d,
-                ([cocoaView gscreen].height - y - h) * d,
-                w * d,
-                h * d);
+        qemu_mutex_lock(&surface_mutex);
+        if (updated != surface) {
+            qemu_mutex_unlock(&surface_mutex);
+            return;
+        }
+        int full_height = surface_height(surface);
+        qemu_mutex_unlock(&surface_mutex);
 
+        CGFloat d = [cocoaView frame].size.height / full_height;
+        NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
         [cocoaView setNeedsDisplayInRect:rect];
     });
 
@@ -1971,24 +1985,31 @@ static void cocoa_update(DisplayChangeListener *dcl,
 }
 
 static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *surface)
+                         DisplaySurface *new_surface)
 {
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-    pixman_image_t *image = surface->image;
+    static bool updating_screen;
 
     COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
 
     [cocoaView updateUIInfo];
 
-    // The DisplaySurface will be freed as soon as this callback returns.
-    // We take a reference to the underlying pixman image here so it does
-    // not disappear from under our feet; the switchSurface method will
-    // deref the old image when it is done with it.
-    pixman_image_ref(image);
+    qemu_mutex_lock(&surface_mutex);
+    surface = new_surface;
+    if (!updating_screen) {
+        updating_screen = true;
 
-    dispatch_async(dispatch_get_main_queue(), ^{
-        [cocoaView switchSurface:image];
-    });
+        dispatch_async(dispatch_get_main_queue(), ^{
+            qemu_mutex_lock(&surface_mutex);
+            updating_screen = false;
+            int w = surface_width(surface);
+            int h = surface_height(surface);
+            qemu_mutex_unlock(&surface_mutex);
+
+            [cocoaView updateScreenWidth:w height:h];
+        });
+    }
+    qemu_mutex_unlock(&surface_mutex);
     [pool release];
 }
 
@@ -2024,6 +2045,263 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
     [pool release];
 }
 
+static const DisplayChangeListenerOps dcl_ops = {
+    .dpy_name          = "cocoa",
+    .dpy_gfx_update = cocoa_update,
+    .dpy_gfx_switch = cocoa_switch,
+    .dpy_refresh = cocoa_refresh,
+};
+
+#ifdef CONFIG_OPENGL
+
+static void with_view_ctx(CodeBlock block)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
+        block();
+        return;
+    }
+#endif
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    [(NSOpenGLContext *)view_ctx lock];
+    [(NSOpenGLContext *)view_ctx makeCurrentContext];
+    block();
+    [(NSOpenGLContext *)view_ctx unlock];
+#pragma clang diagnostic pop
+}
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+static NSOpenGLContext *cocoa_gl_create_context_ns(NSOpenGLContext *share_context,
+                                                   int bpp)
+{
+    NSOpenGLPixelFormatAttribute attributes[] = {
+        NSOpenGLPFAOpenGLProfile,
+        NSOpenGLProfileVersion4_1Core,
+        NSOpenGLPFAColorSize,
+        bpp,
+        NSOpenGLPFADoubleBuffer,
+        0,
+    };
+    NSOpenGLPixelFormat *format;
+    NSOpenGLContext *ctx;
+
+    format = [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
+    ctx = [[NSOpenGLContext alloc] initWithFormat:format shareContext:share_context];
+    [format release];
+
+    [ctx retain];
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [ctx setView:cocoaView];
+        [ctx release];
+    });
+
+    return (QEMUGLContext)ctx;
+}
+#pragma clang diagnostic pop
+
+static int cocoa_gl_make_context_current(void *dg, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        EGLSurface surface = ctx == EGL_NO_CONTEXT ? EGL_NO_SURFACE : egl_surface;
+        return eglMakeCurrent(qemu_egl_display, surface, surface, ctx);
+    }
+#endif
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    if (ctx) {
+        [(NSOpenGLContext *)ctx makeCurrentContext];
+    } else {
+        [NSOpenGLContext clearCurrentContext];
+    }
+#pragma clang diagnostic pop
+
+    return 0;
+}
+
+static QEMUGLContext cocoa_gl_create_context(void *dg, QEMUGLParams *params)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
+        return qemu_egl_create_context(dg, params);
+    }
+#endif
+
+    int bpp = PIXMAN_FORMAT_BPP(surface_format(surface));
+    return cocoa_gl_create_context_ns(view_ctx, bpp);
+}
+
+static void cocoa_gl_destroy_context(void *dg, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglDestroyContext(qemu_egl_display, ctx);
+        return;
+    }
+#endif
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    [(NSOpenGLContext *)ctx release];
+#pragma clang diagnostic pop
+}
+
+static void cocoa_gl_flush()
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglSwapBuffers(qemu_egl_display, egl_surface);
+        return;
+    }
+#endif
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    [[NSOpenGLContext currentContext] flushBuffer];
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [(NSOpenGLContext *)view_ctx update];
+    });
+#pragma clang diagnostic pop
+}
+
+static void cocoa_scanout_disable(DisplayGL *dg)
+{
+    if (!dg->scanout_id) {
+        return;
+    }
+
+    dg->scanout_id = 0;
+
+    if (surface) {
+        surface_gl_destroy_texture(gls, surface);
+        surface_gl_create_texture(gls, surface);
+    }
+}
+
+static void cocoa_gl_render_surface(DisplayGL *dg)
+{
+    cocoa_scanout_disable(dg);
+
+    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+
+    surface_gl_setup_viewport(gls, surface, size.width, size.height);
+    surface_gl_render_texture(gls, surface);
+    cocoa_gl_flush();
+}
+
+static void cocoa_gl_update(DisplayChangeListener *dcl,
+                            int x, int y, int w, int h)
+{
+    with_view_ctx(^{
+        surface_gl_update_texture(gls, surface, x, y, w, h);
+        dgs[qemu_console_get_index(dcl->con)].surface_dirty = true;
+    });
+}
+
+static void cocoa_gl_switch(DisplayChangeListener *dcl,
+                            DisplaySurface *new_surface)
+{
+    cocoa_switch(dcl, new_surface);
+
+    with_view_ctx(^{
+        surface_gl_create_texture(gls, new_surface);
+    });
+}
+
+static void cocoa_gl_refresh(DisplayChangeListener *dcl)
+{
+    cocoa_refresh(dcl);
+
+    with_view_ctx(^{
+        DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
+
+        if (dg->surface_dirty && surface) {
+            dg->surface_dirty = false;
+            cocoa_gl_render_surface(dg);
+        }
+    });
+}
+
+static bool cocoa_gl_scanout_get_enabled(void *dg)
+{
+    return ((DisplayGL *)dg)->scanout_id != 0;
+}
+
+static void cocoa_gl_scanout_disable(void *dg)
+{
+    with_view_ctx(^{
+        cocoa_scanout_disable((DisplayGL *)dg);
+    });
+}
+
+static void cocoa_gl_scanout_texture(void *dg,
+                                     uint32_t backing_id,
+                                     bool backing_y_0_top,
+                                     uint32_t backing_width,
+                                     uint32_t backing_height,
+                                     uint32_t x, uint32_t y,
+                                     uint32_t w, uint32_t h)
+{
+    ((DisplayGL *)dg)->scanout_id = backing_id;
+    ((DisplayGL *)dg)->scanout_y0_top = backing_y_0_top;
+}
+
+static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
+                                   uint32_t x, uint32_t y, uint32_t w, uint32_t h)
+{
+    DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
+
+    if (!dg->scanout_id) {
+        return;
+    }
+
+    with_view_ctx(^{
+        NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+
+        glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+        glViewport(0, 0, size.width, size.height);
+        glBindTexture(GL_TEXTURE_2D, dg->scanout_id);
+        qemu_gl_run_texture_blit(gls, dg->scanout_y0_top);
+        cocoa_gl_flush();
+    });
+}
+
+static const DisplayGLOps dg_ops = {
+    .dpy_gl_ctx_create           = cocoa_gl_create_context,
+    .dpy_gl_ctx_destroy          = cocoa_gl_destroy_context,
+    .dpy_gl_ctx_make_current     = cocoa_gl_make_context_current,
+    .dpy_gl_scanout_get_enabled  = cocoa_gl_scanout_get_enabled,
+    .dpy_gl_scanout_disable      = cocoa_gl_scanout_disable,
+    .dpy_gl_scanout_texture      = cocoa_gl_scanout_texture,
+};
+
+static const DisplayChangeListenerOps dcl_gl_ops = {
+    .dpy_name                = "cocoa-gl",
+    .dpy_gfx_update          = cocoa_gl_update,
+    .dpy_gfx_switch          = cocoa_gl_switch,
+    .dpy_gfx_check_format    = console_gl_check_format,
+    .dpy_refresh             = cocoa_gl_refresh,
+
+    .dpy_gl_update           = cocoa_gl_scanout_flush,
+};
+
+#endif
+
+static void cocoa_display_early_init(DisplayOptions *o)
+{
+    assert(o->type == DISPLAY_TYPE_COCOA);
+    if (o->has_gl && o->gl) {
+        display_opengl = 1;
+    }
+}
+
 static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 {
     COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
@@ -2054,9 +2332,58 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
         cursor_hide = 0;
     }
 
-    // register vga output callbacks
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        unsigned int console_count = 0;
+        while (qemu_console_lookup_by_index(console_count)) {
+            console_count++;
+        }
+
+        dgs = g_new0(DisplayGL, console_count);
+
+        for (unsigned int index = 0; index < console_count; index++) {
+            QemuConsole *con = qemu_console_lookup_by_index(index);
+            console_set_displayglcontext(con, dgs + index);
+        }
+
+        if (opts->gl == DISPLAYGL_MODE_ES) {
+#ifdef CONFIG_EGL
+            qemu_egl_init_dpy_cocoa(DISPLAYGL_MODE_ES);
+            view_ctx = qemu_egl_init_ctx();
+            dispatch_sync(dispatch_get_main_queue(), ^{
+                egl_surface = qemu_egl_init_surface(view_ctx, [cocoaView layer]);
+            });
+#else
+            error_report("OpenGLES without EGL is not supported - exiting");
+            exit(1);
+#endif
+        } else {
+            view_ctx = cocoa_gl_create_context_ns(nil, 32);
+#ifdef CONFIG_EGL
+            egl_surface = EGL_NO_SURFACE;
+#endif
+            cocoa_gl_make_context_current(NULL, view_ctx);
+        }
+
+        gls = qemu_gl_init_shader();
+
+        // register vga output callbacks
+        dcl.ops = &dcl_gl_ops;
+
+        register_displayglops(&dg_ops);
+#else
+        error_report("OpenGL is not enabled - exiting");
+        exit(1);
+#endif
+    } else {
+        // register vga output callbacks
+        dcl.ops = &dcl_ops;
+    }
+
     register_displaychangelistener(&dcl);
 
+    qatomic_set(&allow_events, true);
+
     qemu_event_init(&cbevent, false);
     cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
     qemu_clipboard_peer_register(&cbpeer);
@@ -2064,6 +2391,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 
 static QemuDisplay qemu_display_cocoa = {
     .type       = DISPLAY_TYPE_COCOA,
+    .early_init = cocoa_display_early_init,
     .init       = cocoa_display_init,
 };
 
@@ -2073,3 +2401,7 @@ static void register_cocoa(void)
 }
 
 type_init(register_cocoa);
+
+#ifdef CONFIG_OPENGL
+module_dep("ui-opengl");
+#endif
diff --git a/ui/console.c b/ui/console.c
index 63cc8f038d03..ac3086f676e9 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -127,7 +127,7 @@ struct QemuConsole {
     DisplayState *ds;
     DisplaySurface *surface;
     int dcls;
-    DisplayChangeListener *gl;
+    void *dg;
     bool gl_block;
     int window_id;
 
@@ -184,6 +184,7 @@ struct DisplayState {
     QLIST_HEAD(, DisplayChangeListener) listeners;
 };
 
+static const DisplayGLOps *display_gl_ops;
 static DisplayState *display_state;
 static QemuConsole *active_console;
 static QTAILQ_HEAD(, QemuConsole) consoles =
@@ -1103,8 +1104,14 @@ void console_select(unsigned int index)
                 }
             }
             if (s->surface) {
-                dpy_gfx_update(s, 0, 0, surface_width(s->surface),
-                               surface_height(s->surface));
+                int width = surface_width(s->surface);
+                int height = surface_height(s->surface);
+                if (display_gl_ops &&
+                    display_gl_ops->dpy_gl_scanout_get_enabled(s->dg)) {
+                    dpy_gl_update(s, 0, 0, width, height);
+                } else {
+                    dpy_gfx_update(s, 0, 0, width, height);
+                }
             }
         }
         if (ds->have_text) {
@@ -1454,26 +1461,30 @@ void qemu_free_displaysurface(DisplaySurface *surface)
     g_free(surface);
 }
 
-bool console_has_gl(QemuConsole *con)
+bool console_has_gl(void)
+{
+    return display_gl_ops != NULL;
+}
+
+void console_set_displayglcontext(QemuConsole *con, void *dg)
 {
-    return con->gl != NULL;
+    con->dg = dg;
 }
 
-static bool displaychangelistener_has_dmabuf(DisplayChangeListener *dcl)
+static bool console_has_dmabuf(QemuConsole *con)
 {
-    if (dcl->ops->dpy_has_dmabuf) {
-        return dcl->ops->dpy_has_dmabuf(dcl);
+    if (display_gl_ops->dpy_has_dmabuf) {
+        return display_gl_ops->dpy_has_dmabuf(con->dg);
     }
 
-    if (dcl->ops->dpy_gl_scanout_dmabuf) {
+    if (display_gl_ops->dpy_gl_scanout_dmabuf) {
         return true;
     }
 
     return false;
 }
 
-static bool dpy_compatible_with(QemuConsole *con,
-                                DisplayChangeListener *dcl, Error **errp)
+static bool dpy_compatible_with(QemuConsole *con, Error **errp)
 {
     ERRP_GUARD();
     int flags;
@@ -1481,14 +1492,13 @@ static bool dpy_compatible_with(QemuConsole *con,
     flags = con->hw_ops->get_flags ? con->hw_ops->get_flags(con->hw) : 0;
 
     if (flags & GRAPHIC_FLAGS_GL &&
-        !console_has_gl(con)) {
+        !console_has_gl()) {
         error_setg(errp, "The console requires a GL context.");
         return false;
-
     }
 
     if (flags & GRAPHIC_FLAGS_DMABUF &&
-        !displaychangelistener_has_dmabuf(dcl)) {
+        !console_has_dmabuf(con)) {
         error_setg(errp, "The console requires display DMABUF support.");
         return false;
     }
@@ -1496,6 +1506,16 @@ static bool dpy_compatible_with(QemuConsole *con,
     return true;
 }
 
+void register_displayglops(const DisplayGLOps *dg_ops)
+{
+    if (display_gl_ops) {
+        error_report("can't register two opengl operators");
+        exit(1);
+    }
+
+    display_gl_ops = dg_ops;
+}
+
 void register_displaychangelistener(DisplayChangeListener *dcl)
 {
     static const char nodev[] =
@@ -1506,20 +1526,18 @@ void register_displaychangelistener(DisplayChangeListener *dcl)
 
     assert(!dcl->ds);
 
-    if (dcl->ops->dpy_gl_ctx_create) {
-        /* display has opengl support */
-        assert(dcl->con);
-        if (dcl->con->gl) {
-            fprintf(stderr, "can't register two opengl displays (%s, %s)\n",
-                    dcl->ops->dpy_name, dcl->con->gl->ops->dpy_name);
+    if (dcl->con) {
+        if (!dpy_compatible_with(dcl->con, &err)) {
+            error_report_err(err);
             exit(1);
         }
-        dcl->con->gl = dcl;
-    }
-
-    if (dcl->con && !dpy_compatible_with(dcl->con, dcl, &err)) {
-        error_report_err(err);
-        exit(1);
+    } else {
+        QTAILQ_FOREACH(con, &consoles, next) {
+            if (!dpy_compatible_with(con, &err)) {
+                error_report_err(err);
+                exit(1);
+            }
+        }
     }
 
     trace_displaychangelistener_register(dcl, dcl->ops->dpy_name);
@@ -1836,26 +1854,26 @@ bool dpy_cursor_define_supported(QemuConsole *con)
 QEMUGLContext dpy_gl_ctx_create(QemuConsole *con,
                                 struct QEMUGLParams *qparams)
 {
-    assert(con->gl);
-    return con->gl->ops->dpy_gl_ctx_create(con->gl, qparams);
+    assert(display_gl_ops);
+    return display_gl_ops->dpy_gl_ctx_create(con->dg, qparams);
 }
 
 void dpy_gl_ctx_destroy(QemuConsole *con, QEMUGLContext ctx)
 {
-    assert(con->gl);
-    con->gl->ops->dpy_gl_ctx_destroy(con->gl, ctx);
+    assert(display_gl_ops);
+    display_gl_ops->dpy_gl_ctx_destroy(con->dg, ctx);
 }
 
 int dpy_gl_ctx_make_current(QemuConsole *con, QEMUGLContext ctx)
 {
-    assert(con->gl);
-    return con->gl->ops->dpy_gl_ctx_make_current(con->gl, ctx);
+    assert(display_gl_ops);
+    return display_gl_ops->dpy_gl_ctx_make_current(con->dg, ctx);
 }
 
 void dpy_gl_scanout_disable(QemuConsole *con)
 {
-    assert(con->gl);
-    con->gl->ops->dpy_gl_scanout_disable(con->gl);
+    assert(display_gl_ops);
+    display_gl_ops->dpy_gl_scanout_disable(con->dg);
 }
 
 void dpy_gl_scanout_texture(QemuConsole *con,
@@ -1866,56 +1884,64 @@ void dpy_gl_scanout_texture(QemuConsole *con,
                             uint32_t x, uint32_t y,
                             uint32_t width, uint32_t height)
 {
-    assert(con->gl);
-    con->gl->ops->dpy_gl_scanout_texture(con->gl, backing_id,
-                                         backing_y_0_top,
-                                         backing_width, backing_height,
-                                         x, y, width, height);
+    assert(display_gl_ops);
+    display_gl_ops->dpy_gl_scanout_texture(con->dg, backing_id,
+                                           backing_y_0_top,
+                                           backing_width, backing_height,
+                                           x, y, width, height);
 }
 
 void dpy_gl_scanout_dmabuf(QemuConsole *con,
                            QemuDmaBuf *dmabuf)
 {
-    assert(con->gl);
-    con->gl->ops->dpy_gl_scanout_dmabuf(con->gl, dmabuf);
+    assert(display_gl_ops);
+    display_gl_ops->dpy_gl_scanout_dmabuf(con->dg, dmabuf);
 }
 
 void dpy_gl_cursor_dmabuf(QemuConsole *con, QemuDmaBuf *dmabuf,
                           bool have_hot, uint32_t hot_x, uint32_t hot_y)
 {
-    assert(con->gl);
+    assert(display_gl_ops);
 
-    if (con->gl->ops->dpy_gl_cursor_dmabuf) {
-        con->gl->ops->dpy_gl_cursor_dmabuf(con->gl, dmabuf,
-                                           have_hot, hot_x, hot_y);
+    if (display_gl_ops->dpy_gl_cursor_dmabuf) {
+        display_gl_ops->dpy_gl_cursor_dmabuf(con->dg, dmabuf,
+                                             have_hot, hot_x, hot_y);
     }
 }
 
 void dpy_gl_cursor_position(QemuConsole *con,
                             uint32_t pos_x, uint32_t pos_y)
 {
-    assert(con->gl);
+    assert(display_gl_ops);
 
-    if (con->gl->ops->dpy_gl_cursor_position) {
-        con->gl->ops->dpy_gl_cursor_position(con->gl, pos_x, pos_y);
+    if (display_gl_ops->dpy_gl_cursor_position) {
+        display_gl_ops->dpy_gl_cursor_position(con->dg, pos_x, pos_y);
     }
 }
 
 void dpy_gl_release_dmabuf(QemuConsole *con,
                           QemuDmaBuf *dmabuf)
 {
-    assert(con->gl);
+    assert(display_gl_ops);
 
-    if (con->gl->ops->dpy_gl_release_dmabuf) {
-        con->gl->ops->dpy_gl_release_dmabuf(con->gl, dmabuf);
+    if (display_gl_ops->dpy_gl_release_dmabuf) {
+        display_gl_ops->dpy_gl_release_dmabuf(con->dg, dmabuf);
     }
 }
 
 void dpy_gl_update(QemuConsole *con,
                    uint32_t x, uint32_t y, uint32_t w, uint32_t h)
 {
-    assert(con->gl);
-    con->gl->ops->dpy_gl_update(con->gl, x, y, w, h);
+    DisplayChangeListener *dcl;
+
+    QLIST_FOREACH(dcl, &con->ds->listeners, next) {
+        if (con != (dcl->con ? dcl->con : active_console)) {
+            continue;
+        }
+        if (dcl->ops->dpy_gl_update) {
+        dcl->ops->dpy_gl_update(dcl, x, y, w, h);
+    }
+}
 }
 
 /***********************************************************/
@@ -2026,7 +2052,7 @@ void graphic_console_close(QemuConsole *con)
     object_property_set_link(OBJECT(con), "device", NULL, &error_abort);
     graphic_console_set_hwops(con, &unused_ops, NULL);
 
-    if (con->gl) {
+    if (display_gl_ops) {
         dpy_gl_scanout_disable(con);
     }
     surface = qemu_create_placeholder_surface(width, height, unplugged);
diff --git a/ui/egl-context.c b/ui/egl-context.c
index 368ffa49d82f..07c4c34ec465 100644
--- a/ui/egl-context.c
+++ b/ui/egl-context.c
@@ -1,8 +1,7 @@
 #include "qemu/osdep.h"
 #include "ui/egl-context.h"
 
-QEMUGLContext qemu_egl_create_context(DisplayChangeListener *dcl,
-                                      QEMUGLParams *params)
+QEMUGLContext qemu_egl_create_context(void *dg, QEMUGLParams *params)
 {
    EGLContext ctx;
    EGLint ctx_att_core[] = {
@@ -24,13 +23,12 @@ QEMUGLContext qemu_egl_create_context(DisplayChangeListener *dcl,
    return ctx;
 }
 
-void qemu_egl_destroy_context(DisplayChangeListener *dcl, QEMUGLContext ctx)
+void qemu_egl_destroy_context(void *dg, QEMUGLContext ctx)
 {
     eglDestroyContext(qemu_egl_display, ctx);
 }
 
-int qemu_egl_make_context_current(DisplayChangeListener *dcl,
-                                  QEMUGLContext ctx)
+int qemu_egl_make_context_current(void *dg, QEMUGLContext ctx)
 {
    return eglMakeCurrent(qemu_egl_display,
                          EGL_NO_SURFACE, EGL_NO_SURFACE, ctx);
diff --git a/ui/egl-headless.c b/ui/egl-headless.c
index a26a2520c496..ea4a88f536f1 100644
--- a/ui/egl-headless.c
+++ b/ui/egl-headless.c
@@ -38,23 +38,27 @@ static void egl_gfx_switch(DisplayChangeListener *dcl,
     edpy->ds = new_surface;
 }
 
-static QEMUGLContext egl_create_context(DisplayChangeListener *dcl,
+static QEMUGLContext egl_create_context(void *dg,
                                         QEMUGLParams *params)
 {
     eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                    qemu_egl_rn_ctx);
-    return qemu_egl_create_context(dcl, params);
+    return qemu_egl_create_context(dg, params);
 }
 
-static void egl_scanout_disable(DisplayChangeListener *dcl)
+static bool egl_scanout_get_enabled(void *dg)
 {
-    egl_dpy *edpy = container_of(dcl, egl_dpy, dcl);
+    return ((egl_dpy *)dg)->guest_fb.texture != 0;
+}
 
+static void egl_scanout_disable(void *dg)
+{
+    egl_dpy *edpy = dg;
     egl_fb_destroy(&edpy->guest_fb);
     egl_fb_destroy(&edpy->blit_fb);
 }
 
-static void egl_scanout_texture(DisplayChangeListener *dcl,
+static void egl_scanout_texture(void *dg,
                                 uint32_t backing_id,
                                 bool backing_y_0_top,
                                 uint32_t backing_width,
@@ -62,7 +66,7 @@ static void egl_scanout_texture(DisplayChangeListener *dcl,
                                 uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h)
 {
-    egl_dpy *edpy = container_of(dcl, egl_dpy, dcl);
+    egl_dpy *edpy = dg;
 
     edpy->y_0_top = backing_y_0_top;
 
@@ -78,24 +82,23 @@ static void egl_scanout_texture(DisplayChangeListener *dcl,
     }
 }
 
-static void egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                               QemuDmaBuf *dmabuf)
+static void egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
     egl_dmabuf_import_texture(dmabuf);
     if (!dmabuf->texture) {
         return;
     }
 
-    egl_scanout_texture(dcl, dmabuf->texture,
+    egl_scanout_texture(dg, dmabuf->texture,
                         false, dmabuf->width, dmabuf->height,
                         0, 0, dmabuf->width, dmabuf->height);
 }
 
-static void egl_cursor_dmabuf(DisplayChangeListener *dcl,
+static void egl_cursor_dmabuf(void *dg,
                               QemuDmaBuf *dmabuf, bool have_hot,
                               uint32_t hot_x, uint32_t hot_y)
 {
-    egl_dpy *edpy = container_of(dcl, egl_dpy, dcl);
+    egl_dpy *edpy = dg;
 
     if (dmabuf) {
         egl_dmabuf_import_texture(dmabuf);
@@ -109,17 +112,16 @@ static void egl_cursor_dmabuf(DisplayChangeListener *dcl,
     }
 }
 
-static void egl_cursor_position(DisplayChangeListener *dcl,
+static void egl_cursor_position(void *dg,
                                 uint32_t pos_x, uint32_t pos_y)
 {
-    egl_dpy *edpy = container_of(dcl, egl_dpy, dcl);
+    egl_dpy *edpy = dg;
 
     edpy->pos_x = pos_x;
     edpy->pos_y = pos_y;
 }
 
-static void egl_release_dmabuf(DisplayChangeListener *dcl,
-                               QemuDmaBuf *dmabuf)
+static void egl_release_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
     egl_dmabuf_release_texture(dmabuf);
 }
@@ -151,22 +153,26 @@ static void egl_scanout_flush(DisplayChangeListener *dcl,
     dpy_gfx_update(edpy->dcl.con, x, y, w, h);
 }
 
-static const DisplayChangeListenerOps egl_ops = {
+static const DisplayGLOps dg_egl_ops = {
+    .dpy_gl_ctx_create       = egl_create_context,
+    .dpy_gl_ctx_destroy      = qemu_egl_destroy_context,
+    .dpy_gl_ctx_make_current = qemu_egl_make_context_current,
+
+    .dpy_gl_scanout_get_enabled = egl_scanout_get_enabled,
+    .dpy_gl_scanout_disable     = egl_scanout_disable,
+    .dpy_gl_scanout_texture     = egl_scanout_texture,
+    .dpy_gl_scanout_dmabuf      = egl_scanout_dmabuf,
+    .dpy_gl_cursor_dmabuf       = egl_cursor_dmabuf,
+    .dpy_gl_cursor_position     = egl_cursor_position,
+    .dpy_gl_release_dmabuf      = egl_release_dmabuf,
+};
+
+static const DisplayChangeListenerOps dcl_egl_ops = {
     .dpy_name                = "egl-headless",
     .dpy_refresh             = egl_refresh,
     .dpy_gfx_update          = egl_gfx_update,
     .dpy_gfx_switch          = egl_gfx_switch,
 
-    .dpy_gl_ctx_create       = egl_create_context,
-    .dpy_gl_ctx_destroy      = qemu_egl_destroy_context,
-    .dpy_gl_ctx_make_current = qemu_egl_make_context_current,
-
-    .dpy_gl_scanout_disable  = egl_scanout_disable,
-    .dpy_gl_scanout_texture  = egl_scanout_texture,
-    .dpy_gl_scanout_dmabuf   = egl_scanout_dmabuf,
-    .dpy_gl_cursor_dmabuf    = egl_cursor_dmabuf,
-    .dpy_gl_cursor_position  = egl_cursor_position,
-    .dpy_gl_release_dmabuf   = egl_release_dmabuf,
     .dpy_gl_update           = egl_scanout_flush,
 };
 
@@ -187,6 +193,8 @@ static void egl_headless_init(DisplayState *ds, DisplayOptions *opts)
         exit(1);
     }
 
+    register_displayglops(&dg_egl_ops);
+
     for (idx = 0;; idx++) {
         con = qemu_console_lookup_by_index(idx);
         if (!con || !qemu_console_is_graphic(con)) {
@@ -195,8 +203,9 @@ static void egl_headless_init(DisplayState *ds, DisplayOptions *opts)
 
         edpy = g_new0(egl_dpy, 1);
         edpy->dcl.con = con;
-        edpy->dcl.ops = &egl_ops;
+        edpy->dcl.ops = &dcl_egl_ops;
         edpy->gls = qemu_gl_init_shader();
+        console_set_displayglcontext(con, edpy);
         register_displaychangelistener(&edpy->dcl);
     }
 }
diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index 6d0cb2b5cb93..ac30d990eca0 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -291,7 +291,7 @@ void egl_dmabuf_release_texture(QemuDmaBuf *dmabuf)
 
 /* ---------------------------------------------------------------------- */
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win)
 {
     EGLSurface esurface;
     EGLBoolean b;
@@ -315,6 +315,70 @@ EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
 
 /* ---------------------------------------------------------------------- */
 
+static int qemu_egl_init_dpy(EGLDisplay dpy, DisplayGLMode mode)
+{
+    static const EGLint conf_att_core[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
+        EGL_RED_SIZE,   5,
+        EGL_GREEN_SIZE, 5,
+        EGL_BLUE_SIZE,  5,
+        EGL_ALPHA_SIZE, 0,
+        EGL_NONE,
+    };
+    static const EGLint conf_att_gles[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_RED_SIZE,   5,
+        EGL_GREEN_SIZE, 5,
+        EGL_BLUE_SIZE,  5,
+        EGL_ALPHA_SIZE, 0,
+        EGL_NONE,
+    };
+    EGLint major, minor;
+    EGLBoolean b;
+    EGLint n;
+    bool gles = (mode == DISPLAYGL_MODE_ES);
+
+    qemu_egl_display = dpy;
+
+    b = eglInitialize(qemu_egl_display, &major, &minor);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglInitialize failed");
+        return -1;
+    }
+
+    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglBindAPI failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    b = eglChooseConfig(qemu_egl_display,
+                        gles ? conf_att_gles : conf_att_core,
+                        &qemu_egl_config, 1, &n);
+    if (b == EGL_FALSE || n != 1) {
+        error_report("egl: eglChooseConfig failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    qemu_egl_mode = gles ? DISPLAYGL_MODE_ES : DISPLAYGL_MODE_CORE;
+    return 0;
+}
+
+int qemu_egl_init_dpy_cocoa(DisplayGLMode mode)
+{
+    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (dpy == EGL_NO_DISPLAY) {
+        error_report("egl: eglGetDisplay failed");
+        return -1;
+    }
+
+    return qemu_egl_init_dpy(dpy, mode);
+}
+
 #if defined(CONFIG_X11) || defined(CONFIG_GBM)
 
 /*
@@ -345,8 +409,9 @@ EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
  * platform extensions (EGL_KHR_platform_gbm and friends) yet it doesn't seem
  * like mesa will be able to advertise these (even though it can do EGL 1.5).
  */
-static EGLDisplay qemu_egl_get_display(EGLNativeDisplayType native,
-                                       EGLenum platform)
+static int qemu_egl_init_dpy_platform(EGLNativeDisplayType native,
+                                      EGLenum platform,
+                                      DisplayGLMode mode)
 {
     EGLDisplay dpy = EGL_NO_DISPLAY;
 
@@ -363,83 +428,30 @@ static EGLDisplay qemu_egl_get_display(EGLNativeDisplayType native,
         /* fallback */
         dpy = eglGetDisplay(native);
     }
-    return dpy;
-}
 
-static int qemu_egl_init_dpy(EGLNativeDisplayType dpy,
-                             EGLenum platform,
-                             DisplayGLMode mode)
-{
-    static const EGLint conf_att_core[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
-        EGL_RED_SIZE,   5,
-        EGL_GREEN_SIZE, 5,
-        EGL_BLUE_SIZE,  5,
-        EGL_ALPHA_SIZE, 0,
-        EGL_NONE,
-    };
-    static const EGLint conf_att_gles[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE,   5,
-        EGL_GREEN_SIZE, 5,
-        EGL_BLUE_SIZE,  5,
-        EGL_ALPHA_SIZE, 0,
-        EGL_NONE,
-    };
-    EGLint major, minor;
-    EGLBoolean b;
-    EGLint n;
-    bool gles = (mode == DISPLAYGL_MODE_ES);
-
-    qemu_egl_display = qemu_egl_get_display(dpy, platform);
-    if (qemu_egl_display == EGL_NO_DISPLAY) {
+    if (dpy == EGL_NO_DISPLAY) {
         error_report("egl: eglGetDisplay failed");
         return -1;
     }
 
-    b = eglInitialize(qemu_egl_display, &major, &minor);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglInitialize failed");
-        return -1;
-    }
-
-    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglBindAPI failed (%s mode)",
-                     gles ? "gles" : "core");
-        return -1;
-    }
-
-    b = eglChooseConfig(qemu_egl_display,
-                        gles ? conf_att_gles : conf_att_core,
-                        &qemu_egl_config, 1, &n);
-    if (b == EGL_FALSE || n != 1) {
-        error_report("egl: eglChooseConfig failed (%s mode)",
-                     gles ? "gles" : "core");
-        return -1;
-    }
-
-    qemu_egl_mode = gles ? DISPLAYGL_MODE_ES : DISPLAYGL_MODE_CORE;
-    return 0;
+    return qemu_egl_init_dpy(dpy, mode);
 }
 
 int qemu_egl_init_dpy_x11(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_KHR_platform_x11
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_X11_KHR, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_X11_KHR, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 
 int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_MESA_platform_gbm
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_GBM_MESA, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_GBM_MESA, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 
diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
index d9d3bba43168..f6c1339dc2b5 100644
--- a/ui/gtk-egl.c
+++ b/ui/gtk-egl.c
@@ -53,7 +53,7 @@ void gd_egl_init(VirtualConsole *vc)
     }
 
     vc->gfx.ectx = qemu_egl_init_ctx();
-    vc->gfx.esurface = qemu_egl_init_surface_x11
+    vc->gfx.esurface = qemu_egl_init_surface
         (vc->gfx.ectx, (EGLNativeWindowType)x11_window);
 
     assert(vc->gfx.esurface);
@@ -164,32 +164,36 @@ void gd_egl_switch(DisplayChangeListener *dcl,
     }
 }
 
-QEMUGLContext gd_egl_create_context(DisplayChangeListener *dcl,
-                                    QEMUGLParams *params)
+QEMUGLContext gd_egl_create_context(void *dg, QEMUGLParams *params)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
 
     eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,
                    vc->gfx.esurface, vc->gfx.ectx);
-    return qemu_egl_create_context(dcl, params);
+    return qemu_egl_create_context(dg, params);
 }
 
-void gd_egl_scanout_disable(DisplayChangeListener *dcl)
+bool gd_egl_scanout_get_enabled(void *dg)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    return ((VirtualConsole *)dg)->gfx.scanout_mode;
+}
+
+void gd_egl_scanout_disable(void *dg)
+{
+    VirtualConsole *vc = dg;
 
     vc->gfx.w = 0;
     vc->gfx.h = 0;
     gtk_egl_set_scanout_mode(vc, false);
 }
 
-void gd_egl_scanout_texture(DisplayChangeListener *dcl,
+void gd_egl_scanout_texture(void *dg,
                             uint32_t backing_id, bool backing_y_0_top,
                             uint32_t backing_width, uint32_t backing_height,
                             uint32_t x, uint32_t y,
                             uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
 
     vc->gfx.x = x;
     vc->gfx.y = y;
@@ -205,8 +209,7 @@ void gd_egl_scanout_texture(DisplayChangeListener *dcl,
                          backing_id, false);
 }
 
-void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                           QemuDmaBuf *dmabuf)
+void gd_egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
 #ifdef CONFIG_GBM
     egl_dmabuf_import_texture(dmabuf);
@@ -214,18 +217,18 @@ void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
         return;
     }
 
-    gd_egl_scanout_texture(dcl, dmabuf->texture,
+    gd_egl_scanout_texture(dg, dmabuf->texture,
                            false, dmabuf->width, dmabuf->height,
                            0, 0, dmabuf->width, dmabuf->height);
 #endif
 }
 
-void gd_egl_cursor_dmabuf(DisplayChangeListener *dcl,
+void gd_egl_cursor_dmabuf(void *dg,
                           QemuDmaBuf *dmabuf, bool have_hot,
                           uint32_t hot_x, uint32_t hot_y)
 {
 #ifdef CONFIG_GBM
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
 
     if (dmabuf) {
         egl_dmabuf_import_texture(dmabuf);
@@ -240,17 +243,15 @@ void gd_egl_cursor_dmabuf(DisplayChangeListener *dcl,
 #endif
 }
 
-void gd_egl_cursor_position(DisplayChangeListener *dcl,
-                            uint32_t pos_x, uint32_t pos_y)
+void gd_egl_cursor_position(void *dg, uint32_t pos_x, uint32_t pos_y)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
 
     vc->gfx.cursor_x = pos_x * vc->gfx.scale_x;
     vc->gfx.cursor_y = pos_y * vc->gfx.scale_y;
 }
 
-void gd_egl_release_dmabuf(DisplayChangeListener *dcl,
-                           QemuDmaBuf *dmabuf)
+void gd_egl_release_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
 #ifdef CONFIG_GBM
     egl_dmabuf_release_texture(dmabuf);
@@ -304,10 +305,9 @@ void gtk_egl_init(DisplayGLMode mode)
     display_opengl = 1;
 }
 
-int gd_egl_make_current(DisplayChangeListener *dcl,
-                        QEMUGLContext ctx)
+int gd_egl_make_current(void *dg, QEMUGLContext ctx)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
 
     return eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,
                           vc->gfx.esurface, ctx);
diff --git a/ui/gtk-gl-area.c b/ui/gtk-gl-area.c
index dd5783fec784..0e76d48e4bbb 100644
--- a/ui/gtk-gl-area.c
+++ b/ui/gtk-gl-area.c
@@ -139,10 +139,9 @@ void gd_gl_area_switch(DisplayChangeListener *dcl,
     }
 }
 
-QEMUGLContext gd_gl_area_create_context(DisplayChangeListener *dcl,
-                                        QEMUGLParams *params)
+QEMUGLContext gd_gl_area_create_context(void *dg, QEMUGLParams *params)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
     GdkWindow *window;
     GdkGLContext *ctx;
     GError *err = NULL;
@@ -168,12 +167,17 @@ QEMUGLContext gd_gl_area_create_context(DisplayChangeListener *dcl,
     return ctx;
 }
 
-void gd_gl_area_destroy_context(DisplayChangeListener *dcl, QEMUGLContext ctx)
+void gd_gl_area_destroy_context(void *dg, QEMUGLContext ctx)
 {
     /* FIXME */
 }
 
-void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
+bool gd_gl_area_scanout_get_enabled(void *dg)
+{
+    return ((VirtualConsole *)dg)->gfx.scanout_mode;
+}
+
+void gd_gl_area_scanout_texture(void *dg,
                                 uint32_t backing_id,
                                 bool backing_y_0_top,
                                 uint32_t backing_width,
@@ -181,7 +185,7 @@ void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
                                 uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
 
     vc->gfx.x = x;
     vc->gfx.y = y;
@@ -201,11 +205,9 @@ void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
                          backing_id, false);
 }
 
-void gd_gl_area_scanout_disable(DisplayChangeListener *dcl)
+void gd_gl_area_scanout_disable(void *dg)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-
-    gtk_gl_area_set_scanout_mode(vc, false);
+    gtk_gl_area_set_scanout_mode(dg, false);
 }
 
 void gd_gl_area_scanout_flush(DisplayChangeListener *dcl,
@@ -216,11 +218,10 @@ void gd_gl_area_scanout_flush(DisplayChangeListener *dcl,
     gtk_gl_area_queue_render(GTK_GL_AREA(vc->gfx.drawing_area));
 }
 
-void gd_gl_area_scanout_dmabuf(DisplayChangeListener *dcl,
-                               QemuDmaBuf *dmabuf)
+void gd_gl_area_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
 #ifdef CONFIG_GBM
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
 
     gtk_gl_area_make_current(GTK_GL_AREA(vc->gfx.drawing_area));
     egl_dmabuf_import_texture(dmabuf);
@@ -228,7 +229,7 @@ void gd_gl_area_scanout_dmabuf(DisplayChangeListener *dcl,
         return;
     }
 
-    gd_gl_area_scanout_texture(dcl, dmabuf->texture,
+    gd_gl_area_scanout_texture(dg, dmabuf->texture,
                                false, dmabuf->width, dmabuf->height,
                                0, 0, dmabuf->width, dmabuf->height);
 #endif
@@ -239,8 +240,7 @@ void gtk_gl_area_init(void)
     display_opengl = 1;
 }
 
-int gd_gl_area_make_current(DisplayChangeListener *dcl,
-                            QEMUGLContext ctx)
+int gd_gl_area_make_current(void *dg, QEMUGLContext ctx)
 {
     gdk_gl_context_make_current(ctx);
     return 0;
diff --git a/ui/gtk.c b/ui/gtk.c
index f8f09b068c4a..bb246dd74db8 100644
--- a/ui/gtk.c
+++ b/ui/gtk.c
@@ -341,7 +341,7 @@ static void gd_update_full_redraw(VirtualConsole *vc)
     int ww, wh;
     ww = gdk_window_get_width(gtk_widget_get_window(area));
     wh = gdk_window_get_height(gtk_widget_get_window(area));
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.gls && gtk_use_gl_area) {
         gtk_gl_area_queue_render(GTK_GL_AREA(vc->gfx.drawing_area));
         return;
@@ -560,11 +560,11 @@ static const DisplayChangeListenerOps dcl_ops = {
 };
 
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 
-static bool gd_has_dmabuf(DisplayChangeListener *dcl)
+static bool gd_has_dmabuf(void *dg)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    VirtualConsole *vc = dg;
 
     if (gtk_use_gl_area && !gtk_widget_get_realized(vc->gfx.drawing_area)) {
         /* FIXME: Assume it will work, actual check done after realize */
@@ -577,6 +577,17 @@ static bool gd_has_dmabuf(DisplayChangeListener *dcl)
 
 /** DisplayState Callbacks (opengl version) **/
 
+static const DisplayGLOps dg_gl_area_ops = {
+    .dpy_gl_ctx_create          = gd_gl_area_create_context,
+    .dpy_gl_ctx_destroy         = gd_gl_area_destroy_context,
+    .dpy_gl_ctx_make_current    = gd_gl_area_make_current,
+    .dpy_gl_scanout_get_enabled = gd_gl_area_scanout_get_enabled,
+    .dpy_gl_scanout_texture     = gd_gl_area_scanout_texture,
+    .dpy_gl_scanout_disable     = gd_gl_area_scanout_disable,
+    .dpy_gl_scanout_dmabuf      = gd_gl_area_scanout_dmabuf,
+    .dpy_has_dmabuf             = gd_has_dmabuf,
+};
+
 static const DisplayChangeListenerOps dcl_gl_area_ops = {
     .dpy_name             = "gtk-egl",
     .dpy_gfx_update       = gd_gl_area_update,
@@ -586,14 +597,7 @@ static const DisplayChangeListenerOps dcl_gl_area_ops = {
     .dpy_mouse_set        = gd_mouse_set,
     .dpy_cursor_define    = gd_cursor_define,
 
-    .dpy_gl_ctx_create       = gd_gl_area_create_context,
-    .dpy_gl_ctx_destroy      = gd_gl_area_destroy_context,
-    .dpy_gl_ctx_make_current = gd_gl_area_make_current,
-    .dpy_gl_scanout_texture  = gd_gl_area_scanout_texture,
-    .dpy_gl_scanout_disable  = gd_gl_area_scanout_disable,
-    .dpy_gl_update           = gd_gl_area_scanout_flush,
-    .dpy_gl_scanout_dmabuf   = gd_gl_area_scanout_dmabuf,
-    .dpy_has_dmabuf          = gd_has_dmabuf,
+    .dpy_gl_update        = gd_gl_area_scanout_flush,
 };
 
 #ifdef CONFIG_X11
@@ -607,6 +611,10 @@ static const DisplayChangeListenerOps dcl_egl_ops = {
     .dpy_mouse_set        = gd_mouse_set,
     .dpy_cursor_define    = gd_cursor_define,
 
+    .dpy_gl_update        = gd_egl_scanout_flush,
+};
+
+static const DisplayGLOps dg_egl_ops = {
     .dpy_gl_ctx_create       = gd_egl_create_context,
     .dpy_gl_ctx_destroy      = qemu_egl_destroy_context,
     .dpy_gl_ctx_make_current = gd_egl_make_current,
@@ -616,13 +624,12 @@ static const DisplayChangeListenerOps dcl_egl_ops = {
     .dpy_gl_cursor_dmabuf    = gd_egl_cursor_dmabuf,
     .dpy_gl_cursor_position  = gd_egl_cursor_position,
     .dpy_gl_release_dmabuf   = gd_egl_release_dmabuf,
-    .dpy_gl_update           = gd_egl_scanout_flush,
     .dpy_has_dmabuf          = gd_has_dmabuf,
 };
 
 #endif
 
-#endif /* CONFIG_OPENGL */
+#endif /* defined(CONFIG_OPENGL) && defined(CONFIG_EGL) */
 
 /** QEMU Events **/
 
@@ -688,7 +695,7 @@ static void gd_set_ui_size(VirtualConsole *vc, gint width, gint height)
     dpy_set_ui_info(vc->gfx.dcl.con, &info);
 }
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 
 static gboolean gd_render_event(GtkGLArea *area, GdkGLContext *context,
                                 void *opaque)
@@ -742,7 +749,7 @@ static gboolean gd_draw_event(GtkWidget *widget, cairo_t *cr, void *opaque)
     int ww, wh;
     int fbw, fbh;
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.gls) {
         if (gtk_use_gl_area) {
             /* invoke render callback please */
@@ -1840,7 +1847,7 @@ static void gd_connect_vc_gfx_signals(VirtualConsole *vc)
 {
     g_signal_connect(vc->gfx.drawing_area, "draw",
                      G_CALLBACK(gd_draw_event), vc);
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (gtk_use_gl_area) {
         /* wire up GtkGlArea events */
         g_signal_connect(vc->gfx.drawing_area, "render",
@@ -1954,7 +1961,7 @@ static GtkWidget *gd_create_menu_machine(GtkDisplayState *s)
     return machine_menu;
 }
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 static void gl_area_realize(GtkGLArea *area, VirtualConsole *vc)
 {
     gtk_gl_area_make_current(area);
@@ -1977,7 +1984,7 @@ static GSList *gd_vc_gfx_init(GtkDisplayState *s, VirtualConsole *vc,
     vc->gfx.scale_x = 1.0;
     vc->gfx.scale_y = 1.0;
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (display_opengl) {
         if (gtk_use_gl_area) {
             vc->gfx.drawing_area = gtk_gl_area_new();
@@ -2032,6 +2039,7 @@ static GSList *gd_vc_gfx_init(GtkDisplayState *s, VirtualConsole *vc,
     vc->gfx.kbd = qkbd_state_init(con);
     vc->gfx.dcl.con = con;
 
+    console_set_displayglcontext(con, vc);
     register_displaychangelistener(&vc->gfx.dcl);
 
     gd_connect_vc_gfx_signals(vc);
@@ -2121,6 +2129,18 @@ static GtkWidget *gd_create_menu_view(GtkDisplayState *s)
     separator = gtk_separator_menu_item_new();
     gtk_menu_shell_append(GTK_MENU_SHELL(view_menu), separator);
 
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
+    if (display_opengl) {
+        if (gtk_use_gl_area) {
+            register_displayglops(&dg_gl_area_ops);
+        } else {
+#ifdef CONFIG_X11
+            register_displayglops(&dg_egl_ops);
+#endif
+        }
+    }
+#endif
+
     /* gfx */
     for (vc = 0;; vc++) {
         con = qemu_console_lookup_by_index(vc);
@@ -2305,7 +2325,7 @@ static void early_gtk_display_init(DisplayOptions *opts)
 
     assert(opts->type == DISPLAY_TYPE_GTK);
     if (opts->has_gl && opts->gl != DISPLAYGL_MODE_OFF) {
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 #if defined(GDK_WINDOWING_WAYLAND)
         if (GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
             gtk_use_gl_area = true;
@@ -2341,6 +2361,6 @@ static void register_gtk(void)
 
 type_init(register_gtk);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 module_dep("ui-opengl");
 #endif
diff --git a/ui/meson.build b/ui/meson.build
index a3a187d633ab..846251159e3f 100644
--- a/ui/meson.build
+++ b/ui/meson.build
@@ -51,13 +51,15 @@ if config_host.has_key('CONFIG_OPENGL')
   opengl_ss = ss.source_set()
   opengl_ss.add(gbm)
   opengl_ss.add(when: [opengl, pixman, 'CONFIG_OPENGL'],
-               if_true: files('shader.c', 'console-gl.c', 'egl-helpers.c', 'egl-context.c'))
+               if_true: files('shader.c', 'console-gl.c'))
+  opengl_ss.add(when: [opengl, pixman, 'CONFIG_OPENGL', 'CONFIG_EGL'],
+               if_true: files('egl-helpers.c', 'egl-context.c'))
   ui_modules += {'opengl' : opengl_ss}
 endif
 
 if config_host.has_key('CONFIG_OPENGL') and gbm.found()
   egl_headless_ss = ss.source_set()
-  egl_headless_ss.add(when: [opengl, gbm, pixman, 'CONFIG_OPENGL'],
+  egl_headless_ss.add(when: [opengl, gbm, pixman, 'CONFIG_OPENGL', 'CONFIG_EGL'],
                       if_true: files('egl-headless.c'))
   ui_modules += {'egl-headless' : egl_headless_ss}
 endif
@@ -68,8 +70,10 @@ if gtk.found()
   gtk_ss = ss.source_set()
   gtk_ss.add(gtk, vte, pixman, files('gtk.c', 'gtk-clipboard.c'))
   gtk_ss.add(when: x11, if_true: files('x_keymap.c'))
-  gtk_ss.add(when: [opengl, 'CONFIG_OPENGL'], if_true: files('gtk-gl-area.c'))
-  gtk_ss.add(when: [x11, opengl, 'CONFIG_OPENGL'], if_true: files('gtk-egl.c'))
+  gtk_ss.add(when: [opengl, 'CONFIG_OPENGL', 'CONFIG_EGL'],
+             if_true: files('gtk-gl-area.c'))
+  gtk_ss.add(when: [x11, opengl, 'CONFIG_OPENGL', 'CONFIG_EGL'],
+             if_true: files('gtk-egl.c'))
   ui_modules += {'gtk' : gtk_ss}
 endif
 
@@ -82,7 +86,7 @@ if sdl.found()
     'sdl2-input.c',
     'sdl2.c',
   ))
-  sdl_ss.add(when: [opengl, 'CONFIG_OPENGL'], if_true: files('sdl2-gl.c'))
+  sdl_ss.add(when: [opengl, 'CONFIG_OPENGL', 'CONFIG_EGL'], if_true: files('sdl2-gl.c'))
   sdl_ss.add(when: x11, if_true: files('x_keymap.c'))
   ui_modules += {'sdl' : sdl_ss}
 endif
diff --git a/ui/sdl2-gl.c b/ui/sdl2-gl.c
index a21d2deed916..7f9d79852987 100644
--- a/ui/sdl2-gl.c
+++ b/ui/sdl2-gl.c
@@ -133,10 +133,9 @@ void sdl2_gl_redraw(struct sdl2_console *scon)
     }
 }
 
-QEMUGLContext sdl2_gl_create_context(DisplayChangeListener *dcl,
-                                     QEMUGLParams *params)
+QEMUGLContext sdl2_gl_create_context(void *dg, QEMUGLParams *params)
 {
-    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
+    struct sdl2_console *scon = dg;
     SDL_GLContext ctx;
 
     assert(scon->opengl);
@@ -168,17 +167,16 @@ QEMUGLContext sdl2_gl_create_context(DisplayChangeListener *dcl,
     return (QEMUGLContext)ctx;
 }
 
-void sdl2_gl_destroy_context(DisplayChangeListener *dcl, QEMUGLContext ctx)
+void sdl2_gl_destroy_context(void *dg, QEMUGLContext ctx)
 {
     SDL_GLContext sdlctx = (SDL_GLContext)ctx;
 
     SDL_GL_DeleteContext(sdlctx);
 }
 
-int sdl2_gl_make_context_current(DisplayChangeListener *dcl,
-                                 QEMUGLContext ctx)
+int sdl2_gl_make_context_current(void *dg, QEMUGLContext ctx)
 {
-    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
+    struct sdl2_console *scon = dg;
     SDL_GLContext sdlctx = (SDL_GLContext)ctx;
 
     assert(scon->opengl);
@@ -186,9 +184,9 @@ int sdl2_gl_make_context_current(DisplayChangeListener *dcl,
     return SDL_GL_MakeCurrent(scon->real_window, sdlctx);
 }
 
-void sdl2_gl_scanout_disable(DisplayChangeListener *dcl)
+void sdl2_gl_scanout_disable(void *dg)
 {
-    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
+    struct sdl2_console *scon = dg;
 
     assert(scon->opengl);
     scon->w = 0;
@@ -196,7 +194,12 @@ void sdl2_gl_scanout_disable(DisplayChangeListener *dcl)
     sdl2_set_scanout_mode(scon, false);
 }
 
-void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
+bool sdl2_gl_scanout_get_enabled(void *dg)
+{
+    return ((struct sdl2_console *)dg)->scanout_mode;
+}
+
+void sdl2_gl_scanout_texture(void *dg,
                              uint32_t backing_id,
                              bool backing_y_0_top,
                              uint32_t backing_width,
@@ -204,7 +207,7 @@ void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
                              uint32_t x, uint32_t y,
                              uint32_t w, uint32_t h)
 {
-    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
+    struct sdl2_console *scon = dg;
 
     assert(scon->opengl);
     scon->x = x;
diff --git a/ui/sdl2.c b/ui/sdl2.c
index 36d9010cb6c1..5a81e181701b 100644
--- a/ui/sdl2.c
+++ b/ui/sdl2.c
@@ -85,7 +85,7 @@ void sdl2_window_create(struct sdl2_console *scon)
     if (scon->hidden) {
         flags |= SDL_WINDOW_HIDDEN;
     }
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (scon->opengl) {
         flags |= SDL_WINDOW_OPENGL;
     }
@@ -129,7 +129,7 @@ void sdl2_window_resize(struct sdl2_console *scon)
 static void sdl2_redraw(struct sdl2_console *scon)
 {
     if (scon->opengl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         sdl2_gl_redraw(scon);
 #endif
     } else {
@@ -768,7 +768,16 @@ static const DisplayChangeListenerOps dcl_2d_ops = {
     .dpy_cursor_define    = sdl_mouse_define,
 };
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
+static const DisplayGLOps dg_gl_ops = {
+    .dpy_gl_ctx_create          = sdl2_gl_create_context,
+    .dpy_gl_ctx_destroy         = sdl2_gl_destroy_context,
+    .dpy_gl_ctx_make_current    = sdl2_gl_make_context_current,
+    .dpy_gl_scanout_get_enabled = sdl2_gl_scanout_get_enabled,
+    .dpy_gl_scanout_disable     = sdl2_gl_scanout_disable,
+    .dpy_gl_scanout_texture     = sdl2_gl_scanout_texture,
+};
+
 static const DisplayChangeListenerOps dcl_gl_ops = {
     .dpy_name                = "sdl2-gl",
     .dpy_gfx_update          = sdl2_gl_update,
@@ -778,11 +787,6 @@ static const DisplayChangeListenerOps dcl_gl_ops = {
     .dpy_mouse_set           = sdl_mouse_warp,
     .dpy_cursor_define       = sdl_mouse_define,
 
-    .dpy_gl_ctx_create       = sdl2_gl_create_context,
-    .dpy_gl_ctx_destroy      = sdl2_gl_destroy_context,
-    .dpy_gl_ctx_make_current = sdl2_gl_make_context_current,
-    .dpy_gl_scanout_disable  = sdl2_gl_scanout_disable,
-    .dpy_gl_scanout_texture  = sdl2_gl_scanout_texture,
     .dpy_gl_update           = sdl2_gl_scanout_flush,
 };
 #endif
@@ -791,7 +795,7 @@ static void sdl2_display_early_init(DisplayOptions *o)
 {
     assert(o->type == DISPLAY_TYPE_SDL);
     if (o->has_gl && o->gl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         display_opengl = 1;
 #endif
     }
@@ -834,6 +838,12 @@ static void sdl2_display_init(DisplayState *ds, DisplayOptions *o)
 
     gui_fullscreen = o->has_full_screen && o->full_screen;
 
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
+    if (display_opengl) {
+        register_displayglops(&dg_gl_ops);
+    }
+#endif
+
     for (i = 0;; i++) {
         QemuConsole *con = qemu_console_lookup_by_index(i);
         if (!con) {
@@ -854,7 +864,7 @@ static void sdl2_display_init(DisplayState *ds, DisplayOptions *o)
         }
         sdl2_console[i].idx = i;
         sdl2_console[i].opts = o;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         sdl2_console[i].opengl = display_opengl;
         sdl2_console[i].dcl.ops = display_opengl ? &dcl_gl_ops : &dcl_2d_ops;
 #else
@@ -863,6 +873,7 @@ static void sdl2_display_init(DisplayState *ds, DisplayOptions *o)
 #endif
         sdl2_console[i].dcl.con = con;
         sdl2_console[i].kbd = qkbd_state_init(con);
+        console_set_displayglcontext(con, sdl2_console + i);
         register_displaychangelistener(&sdl2_console[i].dcl);
 
 #if defined(SDL_VIDEO_DRIVER_WINDOWS) || defined(SDL_VIDEO_DRIVER_X11)
@@ -919,6 +930,6 @@ static void register_sdl1(void)
 
 type_init(register_sdl1);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 module_dep("ui-opengl");
 #endif
diff --git a/ui/shader.c b/ui/shader.c
index e8b8d321b7c7..ae1784e7c4e1 100644
--- a/ui/shader.c
+++ b/ui/shader.c
@@ -150,11 +150,19 @@ static GLuint qemu_gl_create_compile_link_program(const GLchar *vert_src,
 QemuGLShader *qemu_gl_init_shader(void)
 {
     QemuGLShader *gls = g_new0(QemuGLShader, 1);
-
+    const char *header = epoxy_is_desktop_gl() ? "#version 140\n" : "#version 300 es\n";
+    char vert_src[256];
+    char frag_src[256];
+    char *vert_src_body = stpcpy(vert_src, header);
+    char *frag_src_body = stpcpy(frag_src, header);
+
+    strcpy(vert_src_body, texture_blit_vert_src);
+    strcpy(frag_src_body, texture_blit_frag_src);
     gls->texture_blit_prog = qemu_gl_create_compile_link_program
-        (texture_blit_vert_src, texture_blit_frag_src);
+        (vert_src, frag_src);
+    strcpy(vert_src_body, texture_blit_flip_vert_src);
     gls->texture_blit_flip_prog = qemu_gl_create_compile_link_program
-        (texture_blit_flip_vert_src, texture_blit_frag_src);
+        (vert_src, frag_src);
     if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog) {
         exit(1);
     }
diff --git a/ui/shader/texture-blit-flip.vert b/ui/shader/texture-blit-flip.vert
index ba081fa5a6c3..1e4ac4c94747 100644
--- a/ui/shader/texture-blit-flip.vert
+++ b/ui/shader/texture-blit-flip.vert
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 in vec2  in_position;
 out vec2 ex_tex_coord;
 
diff --git a/ui/shader/texture-blit.frag b/ui/shader/texture-blit.frag
index bfa202c22b01..bd296a2ffbf5 100644
--- a/ui/shader/texture-blit.frag
+++ b/ui/shader/texture-blit.frag
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 uniform sampler2D image;
 in  mediump vec2 ex_tex_coord;
 out mediump vec4 out_frag_color;
diff --git a/ui/shader/texture-blit.vert b/ui/shader/texture-blit.vert
index 6fe2744d6849..ae205f637782 100644
--- a/ui/shader/texture-blit.vert
+++ b/ui/shader/texture-blit.vert
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 in vec2  in_position;
 out vec2 ex_tex_coord;
 
diff --git a/ui/spice-display.c b/ui/spice-display.c
index f59c69882d91..ac5902be1df8 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -909,17 +909,17 @@ static void spice_gl_switch(DisplayChangeListener *dcl,
     }
 }
 
-static QEMUGLContext qemu_spice_gl_create_context(DisplayChangeListener *dcl,
+static QEMUGLContext qemu_spice_gl_create_context(void *dg,
                                                   QEMUGLParams *params)
 {
     eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                    qemu_egl_rn_ctx);
-    return qemu_egl_create_context(dcl, params);
+    return qemu_egl_create_context(dg, params);
 }
 
-static void qemu_spice_gl_scanout_disable(DisplayChangeListener *dcl)
+static void qemu_spice_gl_scanout_disable(void *dg)
 {
-    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
+    SimpleSpiceDisplay *ssd = dg;
 
     trace_qemu_spice_gl_scanout_disable(ssd->qxl.id);
     spice_qxl_gl_scanout(&ssd->qxl, -1, 0, 0, 0, 0, false);
@@ -928,7 +928,7 @@ static void qemu_spice_gl_scanout_disable(DisplayChangeListener *dcl)
     ssd->have_scanout = false;
 }
 
-static void qemu_spice_gl_scanout_texture(DisplayChangeListener *dcl,
+static void qemu_spice_gl_scanout_texture(void *dg,
                                           uint32_t tex_id,
                                           bool y_0_top,
                                           uint32_t backing_width,
@@ -936,7 +936,7 @@ static void qemu_spice_gl_scanout_texture(DisplayChangeListener *dcl,
                                           uint32_t x, uint32_t y,
                                           uint32_t w, uint32_t h)
 {
-    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
+    SimpleSpiceDisplay *ssd = dg;
     EGLint stride = 0, fourcc = 0;
     int fd = -1;
 
@@ -956,10 +956,9 @@ static void qemu_spice_gl_scanout_texture(DisplayChangeListener *dcl,
     ssd->have_scanout = true;
 }
 
-static void qemu_spice_gl_scanout_dmabuf(DisplayChangeListener *dcl,
-                                         QemuDmaBuf *dmabuf)
+static void qemu_spice_gl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
-    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
+    SimpleSpiceDisplay *ssd = dg;
 
     ssd->guest_dmabuf = dmabuf;
     ssd->guest_dmabuf_refresh = true;
@@ -968,11 +967,11 @@ static void qemu_spice_gl_scanout_dmabuf(DisplayChangeListener *dcl,
     ssd->have_scanout = true;
 }
 
-static void qemu_spice_gl_cursor_dmabuf(DisplayChangeListener *dcl,
+static void qemu_spice_gl_cursor_dmabuf(void *dg,
                                         QemuDmaBuf *dmabuf, bool have_hot,
                                         uint32_t hot_x, uint32_t hot_y)
 {
-    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
+    SimpleSpiceDisplay *ssd = dg;
 
     ssd->have_hot = have_hot;
     ssd->hot_x = hot_x;
@@ -991,10 +990,10 @@ static void qemu_spice_gl_cursor_dmabuf(DisplayChangeListener *dcl,
     }
 }
 
-static void qemu_spice_gl_cursor_position(DisplayChangeListener *dcl,
+static void qemu_spice_gl_cursor_position(void *dg,
                                           uint32_t pos_x, uint32_t pos_y)
 {
-    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
+    SimpleSpiceDisplay *ssd = dg;
 
     qemu_mutex_lock(&ssd->lock);
     ssd->ptr_x = pos_x;
@@ -1002,10 +1001,9 @@ static void qemu_spice_gl_cursor_position(DisplayChangeListener *dcl,
     qemu_mutex_unlock(&ssd->lock);
 }
 
-static void qemu_spice_gl_release_dmabuf(DisplayChangeListener *dcl,
-                                         QemuDmaBuf *dmabuf)
+static void qemu_spice_gl_release_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
-    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
+    SimpleSpiceDisplay *ssd = dg;
 
     if (ssd->guest_dmabuf == dmabuf) {
         ssd->guest_dmabuf = NULL;
@@ -1105,7 +1103,10 @@ static const DisplayChangeListenerOps display_listener_gl_ops = {
     .dpy_refresh             = spice_gl_refresh,
     .dpy_mouse_set           = display_mouse_set,
     .dpy_cursor_define       = display_mouse_define,
+    .dpy_gl_update           = qemu_spice_gl_update,
+};
 
+static const DisplayGLOps display_gl_ops = {
     .dpy_gl_ctx_create       = qemu_spice_gl_create_context,
     .dpy_gl_ctx_destroy      = qemu_egl_destroy_context,
     .dpy_gl_ctx_make_current = qemu_egl_make_context_current,
@@ -1116,7 +1117,6 @@ static const DisplayChangeListenerOps display_listener_gl_ops = {
     .dpy_gl_cursor_dmabuf    = qemu_spice_gl_cursor_dmabuf,
     .dpy_gl_cursor_position  = qemu_spice_gl_cursor_position,
     .dpy_gl_release_dmabuf   = qemu_spice_gl_release_dmabuf,
-    .dpy_gl_update           = qemu_spice_gl_update,
 };
 
 #endif /* HAVE_SPICE_GL */
@@ -1137,6 +1137,8 @@ static void qemu_spice_display_init_one(QemuConsole *con)
         ssd->gls = qemu_gl_init_shader();
         ssd->have_surface = false;
         ssd->have_scanout = false;
+        console_set_displayglcontext(con, ssd);
+        register_displayglops(&display_gl_ops);
     }
 #endif
     ssd->dcl.con = con;

From 51f8c2e5b8f4457dbea86f9eb79f5922f3003583 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 18 Feb 2021 12:57:48 +0900
Subject: [PATCH 099/180] ui/cocoa: Take refresh rate into account

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 meson.build |  3 ++-
 ui/cocoa.m  | 24 +++++++++++++++---------
 2 files changed, 17 insertions(+), 10 deletions(-)

diff --git a/meson.build b/meson.build
index 449f70610081..ed1bfee6e13f 100644
--- a/meson.build
+++ b/meson.build
@@ -384,7 +384,8 @@ if not get_option('attr').disabled()
   endif
 endif
 
-cocoa = dependency('appleframeworks', modules: 'Cocoa', required: get_option('cocoa'))
+cocoa = dependency('appleframeworks', modules: ['Cocoa', 'CoreVideo'],
+                   required: get_option('cocoa'))
 if cocoa.found() and get_option('sdl').enabled()
   error('Cocoa and SDL cannot be enabled at the same time')
 endif
diff --git a/ui/cocoa.m b/ui/cocoa.m
index 432b7aebf0cd..a1a8a8b7dc58 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -93,7 +93,7 @@
 
 static QemuSemaphore display_init_sem;
 static QemuSemaphore app_started_sem;
-static bool allow_events;
+static bool inited;
 
 static NSInteger cbchangecount = -1;
 static QemuClipboardInfo *cbinfo;
@@ -560,9 +560,9 @@ - (void) resizeWindow
 - (void) updateUIInfo
 {
     NSSize frameSize;
-    QemuUIInfo info;
+    QemuUIInfo info = {};
 
-    if (!qemu_console_is_graphic(dcl.con)) {
+    if (!qatomic_load_acquire(&inited)) {
         return;
     }
 
@@ -571,6 +571,7 @@ - (void) updateUIInfo
         CGDirectDisplayID display = [[description objectForKey:@"NSScreenNumber"] unsignedIntValue];
         NSSize screenSize = [[[self window] screen] frame].size;
         CGSize screenPhysicalSize = CGDisplayScreenSize(display);
+        CVDisplayLinkRef displayLink;
 
         if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) == 0) {
             frameSize = [self frame].size;
@@ -578,18 +579,23 @@ - (void) updateUIInfo
             frameSize = screenSize;
         }
 
+        if (!CVDisplayLinkCreateWithCGDisplay(display, &displayLink)) {
+            CVTime period = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink);
+            CVDisplayLinkRelease(displayLink);
+            if (!(period.flags & kCVTimeIsIndefinite)) {
+                update_displaychangelistener(&dcl, 1000 * period.timeValue / period.timeScale);
+                info.refresh_rate = (int64_t)1000 * period.timeScale / period.timeValue;
+            }
+        }
+
         info.width_mm = frameSize.width / screenSize.width * screenPhysicalSize.width;
         info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
     } else {
         frameSize = [self frame].size;
-        info.width_mm = 0;
-        info.height_mm = 0;
     }
 
     NSSize frameBackingSize = [self convertSizeToBacking:frameSize];
 
-    info.xoff = 0;
-    info.yoff = 0;
     info.width = frameBackingSize.width;
     info.height = frameBackingSize.height;
 
@@ -715,7 +721,7 @@ - (void) handleMonitorInput:(NSEvent *)event
 
 - (bool) handleEvent:(NSEvent *)event
 {
-    if(!qatomic_read(&allow_events)) {
+    if(!qatomic_read(&inited)) {
         /*
          * Just let OSX have all events that arrive before
          * applicationDidFinishLaunching.
@@ -2382,7 +2388,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 
     register_displaychangelistener(&dcl);
 
-    qatomic_set(&allow_events, true);
+    qatomic_store_release(&inited, true);
 
     qemu_event_init(&cbevent, false);
     cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];

From 5ba17fba6e8c713a4ec77895d480e8190fbf6858 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 18 Feb 2021 18:37:15 +0900
Subject: [PATCH 100/180] ui/cocoa: Update cursor

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 256 ++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 245 insertions(+), 11 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index a1a8a8b7dc58..c940e342da85 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -83,7 +83,11 @@
 static NSWindow *normalWindow;
 static DisplayChangeListener dcl;
 static DisplaySurface *surface;
-static QemuMutex surface_mutex;
+static QemuMutex draw_mutex;
+static int mouse_x;
+static int mouse_y;
+static int mouse_on;
+static CGImageRef cursor_cgimage;
 static int cursor_hide = 1;
 
 static int gArgc;
@@ -110,6 +114,9 @@
 static DisplayGL *dgs;
 static QEMUGLContext view_ctx;
 static QemuGLShader *gls;
+static GLuint cursor_texture;
+static int cursor_texture_width;
+static int cursor_texture_height;
 
 #ifdef CONFIG_EGL
 static EGLSurface egl_surface;
@@ -303,6 +310,20 @@ static void handleAnyDeviceErrors(Error * err)
     }
 }
 
+static CGRect compute_cursor_clip_rect(int screen_height,
+                                       int given_mouse_x, int given_mouse_y,
+                                       int cursor_width, int cursor_height)
+{
+    CGRect rect;
+
+    rect.origin.x = MAX(0, -given_mouse_x);
+    rect.origin.y = 0;
+    rect.size.width = MIN(cursor_width, cursor_width + given_mouse_x);
+    rect.size.height = cursor_height - rect.origin.x;
+
+    return rect;
+}
+
 /*
  ------------------------------------------------------
     QemuCocoaView
@@ -440,6 +461,21 @@ - (void) unhideCursor
     [NSCursor unhide];
 }
 
+- (CGRect) convertCursorClipRectToDraw:(CGRect)rect
+                          screenHeight:(int)screen_height
+                                mouseX:(int)given_mouse_x
+                                mouseY:(int)given_mouse_y
+{
+    CGFloat d = [self frame].size.height / (CGFloat)screen_height;
+
+    rect.origin.x = (rect.origin.x + given_mouse_x) * d;
+    rect.origin.y = (screen_height - rect.origin.y - given_mouse_y - rect.size.height) * d;
+    rect.size.width *= d;
+    rect.size.height *= d;
+
+    return rect;
+}
+
 - (void) drawRect:(NSRect) rect
 {
     COCOA_DEBUG("QemuCocoaView: drawRect\n");
@@ -456,7 +492,7 @@ - (void) drawRect:(NSRect) rect
     CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
     CGContextSetShouldAntialias (viewContextRef, NO);
 
-    qemu_mutex_lock(&surface_mutex);
+    qemu_mutex_lock(&draw_mutex);
 
     // draw screen bitmap directly to Core Graphics context
     if (!surface) {
@@ -513,9 +549,27 @@ - (void) drawRect:(NSRect) rect
         }
         CGImageRelease (imageRef);
         CGDataProviderRelease(dataProviderRef);
+
+        if (mouse_on) {
+            size_t cursor_width = CGImageGetWidth(cursor_cgimage);
+            size_t cursor_height = CGImageGetHeight(cursor_cgimage);
+            clipRect = compute_cursor_clip_rect(h, mouse_x, mouse_y,
+                                                cursor_width,
+                                                cursor_height);
+            CGRect drawRect = [self convertCursorClipRectToDraw:clipRect
+                                                   screenHeight:h
+                                                         mouseX:mouse_x
+                                                         mouseY:mouse_y];
+            clipImageRef = CGImageCreateWithImageInRect(
+                                                        cursor_cgimage,
+                                                        clipRect
+                                                        );
+            CGContextDrawImage(viewContextRef, drawRect, clipImageRef);
+            CGImageRelease (clipImageRef);
+        }
     }
 
-    qemu_mutex_unlock(&surface_mutex);
+    qemu_mutex_unlock(&draw_mutex);
 }
 
 - (NSSize) computeUnzoomedSize
@@ -1897,6 +1951,7 @@ static void cocoa_clipboard_request(QemuClipboardInfo *info,
     status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
     COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
     [cbowner release];
+    CGImageRelease(cursor_cgimage);
 #ifdef CONFIG_OPENGL
     g_free(dgs);
     qemu_gl_fini_shader(gls);
@@ -1920,7 +1975,7 @@ int main (int argc, char **argv) {
     qemu_thread_create(&thread, "qemu_main", call_qemu_main,
                        NULL, QEMU_THREAD_DETACHED);
 
-    qemu_mutex_init(&surface_mutex);
+    qemu_mutex_init(&draw_mutex);
 
     COCOA_DEBUG("Main thread: waiting for display_init_sem\n");
     qemu_sem_wait(&display_init_sem);
@@ -1974,13 +2029,13 @@ static void cocoa_update(DisplayChangeListener *dcl,
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&surface_mutex);
+        qemu_mutex_lock(&draw_mutex);
         if (updated != surface) {
-            qemu_mutex_unlock(&surface_mutex);
+            qemu_mutex_unlock(&draw_mutex);
             return;
         }
         int full_height = surface_height(surface);
-        qemu_mutex_unlock(&surface_mutex);
+        qemu_mutex_unlock(&draw_mutex);
 
         CGFloat d = [cocoaView frame].size.height / full_height;
         NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
@@ -2000,22 +2055,22 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 
     [cocoaView updateUIInfo];
 
-    qemu_mutex_lock(&surface_mutex);
+    qemu_mutex_lock(&draw_mutex);
     surface = new_surface;
     if (!updating_screen) {
         updating_screen = true;
 
         dispatch_async(dispatch_get_main_queue(), ^{
-            qemu_mutex_lock(&surface_mutex);
+            qemu_mutex_lock(&draw_mutex);
             updating_screen = false;
             int w = surface_width(surface);
             int h = surface_height(surface);
-            qemu_mutex_unlock(&surface_mutex);
+            qemu_mutex_unlock(&draw_mutex);
 
             [cocoaView updateScreenWidth:w height:h];
         });
     }
-    qemu_mutex_unlock(&surface_mutex);
+    qemu_mutex_unlock(&draw_mutex);
     [pool release];
 }
 
@@ -2051,11 +2106,121 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
     [pool release];
 }
 
+static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
+{
+    qemu_mutex_lock(&draw_mutex);
+    int full_height = surface_height(surface);
+    size_t cursor_width = CGImageGetWidth(cursor_cgimage);
+    size_t cursor_height = CGImageGetHeight(cursor_cgimage);
+    int old_x = mouse_x;
+    int old_y = mouse_y;
+    int old_on = mouse_on;
+    mouse_x = x;
+    mouse_y = y;
+    mouse_on = on;
+    qemu_mutex_unlock(&draw_mutex);
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        if (old_on) {
+            CGRect clip_rect = compute_cursor_clip_rect(full_height,
+                                                        old_x, old_y,
+                                                        cursor_width,
+                                                        cursor_height);
+            CGRect draw_rect =
+                [cocoaView convertCursorClipRectToDraw:clip_rect
+                                          screenHeight:full_height
+                                                mouseX:old_x
+                                                mouseY:old_y];
+            [cocoaView setNeedsDisplayInRect:draw_rect];
+        }
+
+        if (on) {
+            CGRect clip_rect = compute_cursor_clip_rect(full_height, x, y,
+                                                        cursor_width,
+                                                        cursor_height);
+            CGRect draw_rect =
+                [cocoaView convertCursorClipRectToDraw:clip_rect
+                                          screenHeight:full_height
+                                                mouseX:x
+                                                mouseY:y];
+            [cocoaView setNeedsDisplayInRect:draw_rect];
+        }
+    });
+}
+
+static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
+{
+    int width = cursor->width;
+    int height = cursor->height;
+
+    CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
+        NULL,
+        cursor->data,
+        width * height * 4,
+        NULL
+    );
+
+    CGImageRef imageRef = CGImageCreate(
+        width, //width
+        height, //height
+        8, //bitsPerComponent
+        32, //bitsPerPixel
+        width * 4, //bytesPerRow
+        CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
+        kCGBitmapByteOrder32Little | kCGImageAlphaFirst, //bitmapInfo
+        dataProviderRef, //provider
+        NULL, //decode
+        0, //interpolate
+        kCGRenderingIntentDefault //intent
+    );
+
+    qemu_mutex_lock(&draw_mutex);
+    int full_height = surface_height(surface);
+    int x = mouse_x;
+    int y = mouse_y;
+    int on = mouse_on;
+    size_t old_width;
+    size_t old_height;
+    if (cursor_cgimage) {
+        old_width = CGImageGetWidth(cursor_cgimage);
+        old_height = CGImageGetHeight(cursor_cgimage);
+    } else {
+        old_width = 0;
+        old_height = 0;
+    }
+    cursor_cgimage = CGImageCreateCopy(imageRef);
+    qemu_mutex_unlock(&draw_mutex);
+
+    CGImageRelease(imageRef);
+    CGDataProviderRelease(dataProviderRef);
+
+    if (on) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            CGFloat d = [cocoaView frame].size.height / full_height;
+            NSRect rect;
+
+            rect.origin.x = d * x;
+            rect.origin.y = d * (full_height - y - old_height);
+            rect.size.width = d * old_width;
+            rect.size.height = d * old_height;
+            [cocoaView setNeedsDisplayInRect:rect];
+
+            rect.origin.x = d * x;
+            rect.origin.y = d * (full_height - y - height);
+            rect.size.width = d * width;
+            rect.size.height = d * height;
+            [cocoaView setNeedsDisplayInRect:rect];
+       });
+    }
+}
+
 static const DisplayChangeListenerOps dcl_ops = {
     .dpy_name          = "cocoa",
     .dpy_gfx_update = cocoa_update,
     .dpy_gfx_switch = cocoa_switch,
     .dpy_refresh = cocoa_refresh,
+    .dpy_mouse_set = cocoa_mouse_set,
+    .dpy_cursor_define = cocoa_cursor_define,
 };
 
 #ifdef CONFIG_OPENGL
@@ -2191,6 +2356,29 @@ static void cocoa_scanout_disable(DisplayGL *dg)
     }
 }
 
+static void cocoa_gl_render_cursor()
+{
+    if (!mouse_on) {
+        return;
+    }
+
+    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+    int full_height = surface_height(surface);
+    CGFloat d = size.height / full_height;
+
+    glViewport(
+        d * mouse_x,
+        d * (full_height - mouse_y - cursor_texture_height),
+        d * cursor_texture_width,
+        d * cursor_texture_height
+    );
+    glBindTexture(GL_TEXTURE_2D, cursor_texture);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    qemu_gl_run_texture_blit(gls, false);
+    glDisable(GL_BLEND);
+}
+
 static void cocoa_gl_render_surface(DisplayGL *dg)
 {
     cocoa_scanout_disable(dg);
@@ -2198,7 +2386,11 @@ static void cocoa_gl_render_surface(DisplayGL *dg)
     NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
 
     surface_gl_setup_viewport(gls, surface, size.width, size.height);
+    glBindTexture(GL_TEXTURE_2D, surface->texture);
     surface_gl_render_texture(gls, surface);
+
+    cocoa_gl_render_cursor();
+
     cocoa_gl_flush();
 }
 
@@ -2275,10 +2467,49 @@ static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
         glViewport(0, 0, size.width, size.height);
         glBindTexture(GL_TEXTURE_2D, dg->scanout_id);
         qemu_gl_run_texture_blit(gls, dg->scanout_y0_top);
+
+        cocoa_gl_render_cursor();
+
         cocoa_gl_flush();
     });
 }
 
+static void cocoa_gl_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
+{
+    mouse_x = x;
+    mouse_y = y;
+    mouse_on = on;
+
+    DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
+
+    if (dg->scanout_id) {
+        cocoa_gl_scanout_flush(dcl, 0, 0, 0, 0);
+    } else {
+        with_view_ctx(^{
+            cocoa_gl_render_surface(dg);
+        });
+    }
+}
+
+static void cocoa_gl_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
+{
+    cursor_texture_width = cursor->width;
+    cursor_texture_height = cursor->height;
+
+    with_view_ctx(^{
+        glBindTexture(GL_TEXTURE_2D, cursor_texture);
+        glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, cursor->width);
+        glTexImage2D(GL_TEXTURE_2D, 0,
+                     epoxy_is_desktop_gl() ? GL_RGBA : GL_BGRA,
+                     cursor->width,
+                     cursor->height,
+                     0, GL_BGRA, GL_UNSIGNED_BYTE,
+                     cursor->data);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    });
+}
+
 static const DisplayGLOps dg_ops = {
     .dpy_gl_ctx_create           = cocoa_gl_create_context,
     .dpy_gl_ctx_destroy          = cocoa_gl_destroy_context,
@@ -2294,6 +2525,8 @@ static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
     .dpy_gfx_switch          = cocoa_gl_switch,
     .dpy_gfx_check_format    = console_gl_check_format,
     .dpy_refresh             = cocoa_gl_refresh,
+    .dpy_mouse_set           = cocoa_gl_mouse_set,
+    .dpy_cursor_define       = cocoa_gl_cursor_define,
 
     .dpy_gl_update           = cocoa_gl_scanout_flush,
 };
@@ -2372,6 +2605,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
         }
 
         gls = qemu_gl_init_shader();
+        glGenTextures(1, &cursor_texture);
 
         // register vga output callbacks
         dcl.ops = &dcl_gl_ops;

From 920d2875a088b42461067910033940a3bd8332e3 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 18 Feb 2021 13:06:30 +0900
Subject: [PATCH 101/180] Use virgl_renderer_borrow_texture_for_scanout

virgl_renderer_borrow_texture_for_scanout is a replacement of
virgl_renderer_resource_get_info and performs configurations such as
swizzle and sRGB decode.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 contrib/vhost-user-gpu/virgl.c |  4 +--
 hw/display/virtio-gpu-virgl.c  | 46 +++++++++++++++++++++++-----------
 include/ui/console.h           | 12 ++++-----
 include/ui/gtk.h               |  8 ++----
 include/ui/sdl2.h              |  4 +--
 ui/cocoa.m                     | 18 +++++++------
 ui/console.c                   |  8 ++----
 ui/egl-headless.c              | 37 +++++++++++++++++++--------
 ui/gtk-egl.c                   | 38 ++++++++++++++++++++--------
 ui/gtk-gl-area.c               | 42 ++++++++++++++++++++++---------
 ui/sdl2-gl.c                   | 16 +++++++++---
 ui/spice-display.c             | 16 ++++++++----
 12 files changed, 162 insertions(+), 87 deletions(-)

diff --git a/contrib/vhost-user-gpu/virgl.c b/contrib/vhost-user-gpu/virgl.c
index 3e45e1bd3360..33930b18473f 100644
--- a/contrib/vhost-user-gpu/virgl.c
+++ b/contrib/vhost-user-gpu/virgl.c
@@ -323,7 +323,7 @@ virgl_cmd_set_scanout(VuGpu *g,
                       struct virtio_gpu_ctrl_command *cmd)
 {
     struct virtio_gpu_set_scanout ss;
-    struct virgl_renderer_resource_info info;
+    struct virgl_renderer_texture_info info;
     int ret;
 
     VUGPU_FILL_CMD(ss);
@@ -338,7 +338,7 @@ virgl_cmd_set_scanout(VuGpu *g,
     memset(&info, 0, sizeof(info));
 
     if (ss.resource_id && ss.r.width && ss.r.height) {
-        ret = virgl_renderer_resource_get_info(ss.resource_id, &info);
+        ret = virgl_renderer_borrow_texture_for_scanout(ss.resource_id, &info);
         if (ret == -1) {
             g_critical("%s: illegal resource specified %d\n",
                        __func__, ss.resource_id);
diff --git a/hw/display/virtio-gpu-virgl.c b/hw/display/virtio-gpu-virgl.c
index 092c6dc380d9..99a93720b033 100644
--- a/hw/display/virtio-gpu-virgl.c
+++ b/hw/display/virtio-gpu-virgl.c
@@ -140,12 +140,39 @@ static void virgl_cmd_resource_flush(VirtIOGPU *g,
     }
 }
 
+static GLuint virgl_borrow_texture_for_scanout(uint32_t id, bool *y_0_top,
+                                               uint32_t *width,
+                                               uint32_t *height)
+{
+    struct virgl_renderer_texture_info info;
+    int ret;
+
+    memset(&info, 0, sizeof(info));
+
+    ret = virgl_renderer_borrow_texture_for_scanout(id, &info);
+    if (ret == -1) {
+        return 0;
+    }
+
+    if (y_0_top) {
+        *y_0_top = info.flags & 1 /* FIXME: Y_0_TOP */;
+    }
+
+    if (width) {
+        *width = info.width;
+    }
+
+    if (height) {
+        *height = info.height;
+    }
+
+    return info.tex_id;
+}
+
 static void virgl_cmd_set_scanout(VirtIOGPU *g,
                                   struct virtio_gpu_ctrl_command *cmd)
 {
     struct virtio_gpu_set_scanout ss;
-    struct virgl_renderer_resource_info info;
-    int ret;
 
     VIRTIO_GPU_FILL_CMD(ss);
     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,
@@ -159,24 +186,13 @@ static void virgl_cmd_set_scanout(VirtIOGPU *g,
     }
     g->parent_obj.enable = 1;
 
-    memset(&info, 0, sizeof(info));
-
     if (ss.resource_id && ss.r.width && ss.r.height) {
-        ret = virgl_renderer_resource_get_info(ss.resource_id, &info);
-        if (ret == -1) {
-            qemu_log_mask(LOG_GUEST_ERROR,
-                          "%s: illegal resource specified %d\n",
-                          __func__, ss.resource_id);
-            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-            return;
-        }
         qemu_console_resize(g->parent_obj.scanout[ss.scanout_id].con,
                             ss.r.width, ss.r.height);
         virgl_renderer_force_ctx_0();
         dpy_gl_scanout_texture(
-            g->parent_obj.scanout[ss.scanout_id].con, info.tex_id,
-            info.flags & 1 /* FIXME: Y_0_TOP */,
-            info.width, info.height,
+            g->parent_obj.scanout[ss.scanout_id].con, ss.resource_id,
+            virgl_borrow_texture_for_scanout,
             ss.r.x, ss.r.y, ss.r.width, ss.r.height);
     } else {
         dpy_gfx_replace_surface(
diff --git a/include/ui/console.h b/include/ui/console.h
index 5e38906f0747..d8d7649b1478 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -221,6 +221,9 @@ struct DisplayChangeListener {
     QLIST_ENTRY(DisplayChangeListener) next;
 };
 
+typedef uint32_t (* DisplayGLTextureBorrower)(uint32_t id, bool *y_0_top,
+                                              uint32_t *width, uint32_t *height);
+
 typedef struct DisplayGLOps {
     QEMUGLContext (*dpy_gl_ctx_create)(void *dg, QEMUGLParams *params);
     void (*dpy_gl_ctx_destroy)(void *dg, QEMUGLContext ctx);
@@ -230,9 +233,7 @@ typedef struct DisplayGLOps {
     void (*dpy_gl_scanout_disable)(void *dg);
     void (*dpy_gl_scanout_texture)(void *dg,
                                    uint32_t backing_id,
-                                   bool backing_y_0_top,
-                                   uint32_t backing_width,
-                                   uint32_t backing_height,
+                                   DisplayGLTextureBorrower backing_borrow,
                                    uint32_t x, uint32_t y,
                                    uint32_t w, uint32_t h);
 
@@ -296,9 +297,8 @@ bool dpy_gfx_check_format(QemuConsole *con,
                           pixman_format_code_t format);
 
 void dpy_gl_scanout_disable(QemuConsole *con);
-void dpy_gl_scanout_texture(QemuConsole *con,
-                            uint32_t backing_id, bool backing_y_0_top,
-                            uint32_t backing_width, uint32_t backing_height,
+void dpy_gl_scanout_texture(QemuConsole *con, uint32_t backing_id,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 void dpy_gl_scanout_dmabuf(QemuConsole *con,
                            QemuDmaBuf *dmabuf);
diff --git a/include/ui/gtk.h b/include/ui/gtk.h
index 104d342f7e17..6bb5c494270a 100644
--- a/include/ui/gtk.h
+++ b/include/ui/gtk.h
@@ -166,9 +166,7 @@ bool gd_egl_scanout_get_enabled(void *dg);
 void gd_egl_scanout_disable(void *dg);
 void gd_egl_scanout_texture(void *dg,
                             uint32_t backing_id,
-                            bool backing_y_0_top,
-                            uint32_t backing_width,
-                            uint32_t backing_height,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y,
                             uint32_t w, uint32_t h);
 void gd_egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf);
@@ -196,9 +194,7 @@ bool gd_gl_area_scanout_get_enabled(void *dg);
 void gd_gl_area_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf);
 void gd_gl_area_scanout_texture(void *dg,
                                 uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
+                                DisplayGLTextureBorrower backing_borrow,
                                 uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h);
 void gd_gl_area_scanout_disable(void *dg);
diff --git a/include/ui/sdl2.h b/include/ui/sdl2.h
index 41082ec660be..3001916bbc32 100644
--- a/include/ui/sdl2.h
+++ b/include/ui/sdl2.h
@@ -73,9 +73,7 @@ bool sdl2_gl_scanout_get_enabled(void *dg);
 void sdl2_gl_scanout_disable(void *dg);
 void sdl2_gl_scanout_texture(void *dg,
                              uint32_t backing_id,
-                             bool backing_y_0_top,
-                             uint32_t backing_width,
-                             uint32_t backing_height,
+                             DisplayGLTextureBorrower backing_borrow,
                              uint32_t x, uint32_t y,
                              uint32_t w, uint32_t h);
 void sdl2_gl_scanout_flush(DisplayChangeListener *dcl,
diff --git a/ui/cocoa.m b/ui/cocoa.m
index c940e342da85..e3772d9a4aa9 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -107,7 +107,7 @@
 
 typedef struct {
     uint32_t scanout_id;
-    bool scanout_y0_top;
+    DisplayGLTextureBorrower scanout_borrow;
     bool surface_dirty;
 } DisplayGL;
 
@@ -2441,32 +2441,36 @@ static void cocoa_gl_scanout_disable(void *dg)
 
 static void cocoa_gl_scanout_texture(void *dg,
                                      uint32_t backing_id,
-                                     bool backing_y_0_top,
-                                     uint32_t backing_width,
-                                     uint32_t backing_height,
+                                     DisplayGLTextureBorrower backing_borrow,
                                      uint32_t x, uint32_t y,
                                      uint32_t w, uint32_t h)
 {
     ((DisplayGL *)dg)->scanout_id = backing_id;
-    ((DisplayGL *)dg)->scanout_y0_top = backing_y_0_top;
+    ((DisplayGL *)dg)->scanout_borrow = backing_borrow;
 }
 
 static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
                                    uint32_t x, uint32_t y, uint32_t w, uint32_t h)
 {
     DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
+    bool y0_top;
 
     if (!dg->scanout_id) {
         return;
     }
 
+    GLint texture = dg->scanout_borrow(dg->scanout_id, &y0_top, NULL, NULL);
+    if (!texture) {
+        return;
+    }
+
     with_view_ctx(^{
         NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
 
         glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
         glViewport(0, 0, size.width, size.height);
-        glBindTexture(GL_TEXTURE_2D, dg->scanout_id);
-        qemu_gl_run_texture_blit(gls, dg->scanout_y0_top);
+        glBindTexture(GL_TEXTURE_2D, texture);
+        qemu_gl_run_texture_blit(gls, y0_top);
 
         cocoa_gl_render_cursor();
 
diff --git a/ui/console.c b/ui/console.c
index ac3086f676e9..7a66ece151ee 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -1878,16 +1878,12 @@ void dpy_gl_scanout_disable(QemuConsole *con)
 
 void dpy_gl_scanout_texture(QemuConsole *con,
                             uint32_t backing_id,
-                            bool backing_y_0_top,
-                            uint32_t backing_width,
-                            uint32_t backing_height,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y,
                             uint32_t width, uint32_t height)
 {
     assert(display_gl_ops);
-    display_gl_ops->dpy_gl_scanout_texture(con->dg, backing_id,
-                                           backing_y_0_top,
-                                           backing_width, backing_height,
+    display_gl_ops->dpy_gl_scanout_texture(con->dg, backing_id, backing_borrow,
                                            x, y, width, height);
 }
 
diff --git a/ui/egl-headless.c b/ui/egl-headless.c
index ea4a88f536f1..183e98a36563 100644
--- a/ui/egl-headless.c
+++ b/ui/egl-headless.c
@@ -58,13 +58,11 @@ static void egl_scanout_disable(void *dg)
     egl_fb_destroy(&edpy->blit_fb);
 }
 
-static void egl_scanout_texture(void *dg,
-                                uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
-                                uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h)
+static void egl_scanout_imported_texture(void *dg,
+                                         uint32_t backing_texture,
+                                         bool backing_y_0_top,
+                                         uint32_t backing_width,
+                                         uint32_t backing_height)
 {
     egl_dpy *edpy = dg;
 
@@ -72,7 +70,7 @@ static void egl_scanout_texture(void *dg,
 
     /* source framebuffer */
     egl_fb_setup_for_tex(&edpy->guest_fb,
-                         backing_width, backing_height, backing_id, false);
+                         backing_width, backing_height, backing_texture, false);
 
     /* dest framebuffer */
     if (edpy->blit_fb.width  != backing_width ||
@@ -82,6 +80,24 @@ static void egl_scanout_texture(void *dg,
     }
 }
 
+static void egl_scanout_texture(void *dg,
+                                uint32_t backing_id,
+                                DisplayGLTextureBorrower backing_borrower,
+                                uint32_t x, uint32_t y,
+                                uint32_t w, uint32_t h)
+{
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrower(backing_id, &backing_y_0_top,
+                                              &backing_width, &backing_height);
+    if (backing_texture) {
+        egl_scanout_imported_texture(dg, backing_texture, backing_y_0_top,
+                                     backing_width, backing_height);
+    }
+}
+
 static void egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
     egl_dmabuf_import_texture(dmabuf);
@@ -89,9 +105,8 @@ static void egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
         return;
     }
 
-    egl_scanout_texture(dg, dmabuf->texture,
-                        false, dmabuf->width, dmabuf->height,
-                        0, 0, dmabuf->width, dmabuf->height);
+    egl_scanout_imported_texture(dg, dmabuf->texture,
+                                 false, dmabuf->width, dmabuf->height);
 }
 
 static void egl_cursor_dmabuf(void *dg,
diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
index f6c1339dc2b5..43be2a36108b 100644
--- a/ui/gtk-egl.c
+++ b/ui/gtk-egl.c
@@ -187,14 +187,14 @@ void gd_egl_scanout_disable(void *dg)
     gtk_egl_set_scanout_mode(vc, false);
 }
 
-void gd_egl_scanout_texture(void *dg,
-                            uint32_t backing_id, bool backing_y_0_top,
-                            uint32_t backing_width, uint32_t backing_height,
-                            uint32_t x, uint32_t y,
-                            uint32_t w, uint32_t h)
+static void gd_egl_scanout_borrowed_texture(VirtualConsole *vc,
+                                            uint32_t backing_id,
+                                            bool backing_y_0_top,
+                                            uint32_t backing_width,
+                                            uint32_t backing_height,
+                                            uint32_t x, uint32_t y,
+                                            uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = dg;
-
     vc->gfx.x = x;
     vc->gfx.y = y;
     vc->gfx.w = w;
@@ -209,6 +209,24 @@ void gd_egl_scanout_texture(void *dg,
                          backing_id, false);
 }
 
+void gd_egl_scanout_texture(void *dg, uint32_t backing_id,
+                            DisplayGLTextureBorrower backing_borrow,
+                            uint32_t x, uint32_t y,
+                            uint32_t w, uint32_t h)
+{
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    if (backing_texture) {
+        gd_egl_scanout_borrowed_texture(dg, backing_texture, backing_y_0_top,
+                                        backing_width, backing_height,
+                                        x, y, w, h);
+    }
+}
+
 void gd_egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
 #ifdef CONFIG_GBM
@@ -217,9 +235,9 @@ void gd_egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
         return;
     }
 
-    gd_egl_scanout_texture(dg, dmabuf->texture,
-                           false, dmabuf->width, dmabuf->height,
-                           0, 0, dmabuf->width, dmabuf->height);
+    gd_egl_scanout_borrowed_texture(dg, dmabuf->texture,
+                                    false, dmabuf->width, dmabuf->height,
+                                    0, 0, dmabuf->width, dmabuf->height);
 #endif
 }
 
diff --git a/ui/gtk-gl-area.c b/ui/gtk-gl-area.c
index 0e76d48e4bbb..e5b198ac5337 100644
--- a/ui/gtk-gl-area.c
+++ b/ui/gtk-gl-area.c
@@ -177,16 +177,14 @@ bool gd_gl_area_scanout_get_enabled(void *dg)
     return ((VirtualConsole *)dg)->gfx.scanout_mode;
 }
 
-void gd_gl_area_scanout_texture(void *dg,
-                                uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
-                                uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h)
+static void gd_gl_area_scanout_borrowed_texture(VirtualConsole *vc,
+                                                uint32_t backing_id,
+                                                bool backing_y_0_top,
+                                                uint32_t backing_width,
+                                                uint32_t backing_height,
+                                                uint32_t x, uint32_t y,
+                                                uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = dg;
-
     vc->gfx.x = x;
     vc->gfx.y = y;
     vc->gfx.w = w;
@@ -205,6 +203,26 @@ void gd_gl_area_scanout_texture(void *dg,
                          backing_id, false);
 }
 
+void gd_gl_area_scanout_texture(void *dg,
+                                uint32_t backing_id,
+                                DisplayGLTextureBorrower backing_borrow,
+                                uint32_t x, uint32_t y,
+                                uint32_t w, uint32_t h)
+{
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    if (backing_texture) {
+        gd_gl_area_scanout_borrowed_texture(dg, backing_texture,
+                                            backing_y_0_top,
+                                            backing_width, backing_height,
+                                            x, y, w, h);
+    }
+}
+
 void gd_gl_area_scanout_disable(void *dg)
 {
     gtk_gl_area_set_scanout_mode(dg, false);
@@ -229,9 +247,9 @@ void gd_gl_area_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
         return;
     }
 
-    gd_gl_area_scanout_texture(dg, dmabuf->texture,
-                               false, dmabuf->width, dmabuf->height,
-                               0, 0, dmabuf->width, dmabuf->height);
+    gd_gl_area_scanout_borrowed_texture(dg, dmabuf->texture,
+                                        false, dmabuf->width, dmabuf->height,
+                                        0, 0, dmabuf->width, dmabuf->height);
 #endif
 }
 
diff --git a/ui/sdl2-gl.c b/ui/sdl2-gl.c
index 7f9d79852987..3e32a1d184b4 100644
--- a/ui/sdl2-gl.c
+++ b/ui/sdl2-gl.c
@@ -201,15 +201,23 @@ bool sdl2_gl_scanout_get_enabled(void *dg)
 
 void sdl2_gl_scanout_texture(void *dg,
                              uint32_t backing_id,
-                             bool backing_y_0_top,
-                             uint32_t backing_width,
-                             uint32_t backing_height,
+                             DisplayGLTextureBorrower backing_borrow,
                              uint32_t x, uint32_t y,
                              uint32_t w, uint32_t h)
 {
     struct sdl2_console *scon = dg;
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
 
     assert(scon->opengl);
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    if (!backing_texture) {
+        return;
+    }
+
     scon->x = x;
     scon->y = y;
     scon->w = w;
@@ -220,7 +228,7 @@ void sdl2_gl_scanout_texture(void *dg,
 
     sdl2_set_scanout_mode(scon, true);
     egl_fb_setup_for_tex(&scon->guest_fb, backing_width, backing_height,
-                         backing_id, false);
+                         backing_texture, false);
 }
 
 void sdl2_gl_scanout_flush(DisplayChangeListener *dcl,
diff --git a/ui/spice-display.c b/ui/spice-display.c
index ac5902be1df8..94efe07c9061 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -929,18 +929,24 @@ static void qemu_spice_gl_scanout_disable(void *dg)
 }
 
 static void qemu_spice_gl_scanout_texture(void *dg,
-                                          uint32_t tex_id,
-                                          bool y_0_top,
-                                          uint32_t backing_width,
-                                          uint32_t backing_height,
+                                          uint32_t backing_id,
+                                          DisplayGLTextureBorrower backing_borrow,
                                           uint32_t x, uint32_t y,
                                           uint32_t w, uint32_t h)
 {
     SimpleSpiceDisplay *ssd = dg;
     EGLint stride = 0, fourcc = 0;
     int fd = -1;
+    bool y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint tex_id = backing_borrow(backing_id, &y_0_top,
+                                   &backing_width, &backing_height);
+    if (!tex_id) {
+        return;
+    }
 
-    assert(tex_id);
     fd = egl_get_fd_for_texture(tex_id, &stride, &fourcc, NULL);
     if (fd < 0) {
         fprintf(stderr, "%s: failed to get fd for texture\n", __func__);

From d0c0d66796e9a4171b62cf772ac5e846907a6b9b Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sun, 14 Mar 2021 14:22:01 +0900
Subject: [PATCH 102/180] ui/cocoa: Do not raise keys before QEMU resigns
 active

ui/cocoa used to raise all keys before it resigns active to prevent a
stuck key problem caused by key up events it does not see while it is
inactive. The problem is solved by checking -[NSEvent modifierFlags] in
commit 6d73bb643aa725348aabe6a885ac5fb0b7f70252, which is better
because it handles the case that key *down* events are missed while it
is inactive.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 20 --------------------
 1 file changed, 20 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index e3772d9a4aa9..867922689ab6 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -356,7 +356,6 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
 - (BOOL) isMouseGrabbed;
 - (BOOL) isAbsoluteEnabled;
 - (BOOL) isSwapOptionCommandEnabled;
-- (void) raiseAllKeys;
 @end
 
 QemuCocoaView *cocoaView;
@@ -1160,18 +1159,6 @@ - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
 - (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
 - (BOOL) isSwapOptionCommandEnabled {return screen.swap_option_command;}
 
-/*
- * Makes the target think all down keys are being released.
- * This prevents a stuck key problem, since we will not see
- * key up events for those keys after we have lost focus.
- */
-- (void) raiseAllKeys
-{
-    with_iothread_lock(^{
-        qkbd_state_lift_all_keys(kbd);
-    });
-}
-
 - (void) raiseAllButtons
 {
     with_iothread_lock(^{
@@ -1355,13 +1342,6 @@ - (NSApplicationPresentationOptions) window:(NSWindow *)window
            NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar;
 }
 
-/* Called when QEMU goes into the background */
-- (void) applicationWillResignActive: (NSNotification *)aNotification
-{
-    COCOA_DEBUG("QemuCocoaAppController: applicationWillResignActive\n");
-    [cocoaView raiseAllKeys];
-}
-
 /* We abstract the method called by the Enter Fullscreen menu item
  * because Mac OS 10.7 and higher disables it. This is because of the
  * menu item's old selector's name toggleFullScreen:

From a1cbf10708017c5db7e1296fc502c99e37201704 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Tue, 15 Jun 2021 17:30:34 +0900
Subject: [PATCH 103/180] ui/cocoa: Use qemu_input_map_osx_to_qcode

ui/cocoa used to have a conversion table from macOS keycode to QKeyCode.
It is an unnecessary redundancy as ui/input-keymap.c already has such a
table. Worse, I added an incorrect mapping of kVK_JIS_Eisu and
kVK_JIS_Kana with commit 708b72557ff510493ab3653c7a1ebfe983009469.
According to the following documentations, the definitions in
ui/keycodemapdb/keymaps.csv, which ui/input-keymap.c uses, are correct:
https://developer.apple.com/documentation/uikit/uikeyboardhidusage/uikeyboardhidusagekeyboardlang1?language=objc
https://developer.apple.com/documentation/uikit/uikeyboardhidusage/uikeyboardhidusagekeyboardlang2?language=objc
https://docs.microsoft.com/en-us/windows-hardware/design/component-guidelines/keyboard-japan-ime

Use qemu_input_map_osx_to_qcode to eliminate the redundancy and
incorrect mappings.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 129 +----------------------------------------------------
 1 file changed, 2 insertions(+), 127 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 867922689ab6..81dbc8be4b0f 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -157,138 +157,13 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
     return val;
 }
 
-// Mac to QKeyCode conversion
-static const int mac_to_qkeycode_map[] = {
-    [kVK_ANSI_A] = Q_KEY_CODE_A,
-    [kVK_ANSI_B] = Q_KEY_CODE_B,
-    [kVK_ANSI_C] = Q_KEY_CODE_C,
-    [kVK_ANSI_D] = Q_KEY_CODE_D,
-    [kVK_ANSI_E] = Q_KEY_CODE_E,
-    [kVK_ANSI_F] = Q_KEY_CODE_F,
-    [kVK_ANSI_G] = Q_KEY_CODE_G,
-    [kVK_ANSI_H] = Q_KEY_CODE_H,
-    [kVK_ANSI_I] = Q_KEY_CODE_I,
-    [kVK_ANSI_J] = Q_KEY_CODE_J,
-    [kVK_ANSI_K] = Q_KEY_CODE_K,
-    [kVK_ANSI_L] = Q_KEY_CODE_L,
-    [kVK_ANSI_M] = Q_KEY_CODE_M,
-    [kVK_ANSI_N] = Q_KEY_CODE_N,
-    [kVK_ANSI_O] = Q_KEY_CODE_O,
-    [kVK_ANSI_P] = Q_KEY_CODE_P,
-    [kVK_ANSI_Q] = Q_KEY_CODE_Q,
-    [kVK_ANSI_R] = Q_KEY_CODE_R,
-    [kVK_ANSI_S] = Q_KEY_CODE_S,
-    [kVK_ANSI_T] = Q_KEY_CODE_T,
-    [kVK_ANSI_U] = Q_KEY_CODE_U,
-    [kVK_ANSI_V] = Q_KEY_CODE_V,
-    [kVK_ANSI_W] = Q_KEY_CODE_W,
-    [kVK_ANSI_X] = Q_KEY_CODE_X,
-    [kVK_ANSI_Y] = Q_KEY_CODE_Y,
-    [kVK_ANSI_Z] = Q_KEY_CODE_Z,
-
-    [kVK_ANSI_0] = Q_KEY_CODE_0,
-    [kVK_ANSI_1] = Q_KEY_CODE_1,
-    [kVK_ANSI_2] = Q_KEY_CODE_2,
-    [kVK_ANSI_3] = Q_KEY_CODE_3,
-    [kVK_ANSI_4] = Q_KEY_CODE_4,
-    [kVK_ANSI_5] = Q_KEY_CODE_5,
-    [kVK_ANSI_6] = Q_KEY_CODE_6,
-    [kVK_ANSI_7] = Q_KEY_CODE_7,
-    [kVK_ANSI_8] = Q_KEY_CODE_8,
-    [kVK_ANSI_9] = Q_KEY_CODE_9,
-
-    [kVK_ANSI_Grave] = Q_KEY_CODE_GRAVE_ACCENT,
-    [kVK_ANSI_Minus] = Q_KEY_CODE_MINUS,
-    [kVK_ANSI_Equal] = Q_KEY_CODE_EQUAL,
-    [kVK_Delete] = Q_KEY_CODE_BACKSPACE,
-    [kVK_CapsLock] = Q_KEY_CODE_CAPS_LOCK,
-    [kVK_Tab] = Q_KEY_CODE_TAB,
-    [kVK_Return] = Q_KEY_CODE_RET,
-    [kVK_ANSI_LeftBracket] = Q_KEY_CODE_BRACKET_LEFT,
-    [kVK_ANSI_RightBracket] = Q_KEY_CODE_BRACKET_RIGHT,
-    [kVK_ANSI_Backslash] = Q_KEY_CODE_BACKSLASH,
-    [kVK_ANSI_Semicolon] = Q_KEY_CODE_SEMICOLON,
-    [kVK_ANSI_Quote] = Q_KEY_CODE_APOSTROPHE,
-    [kVK_ANSI_Comma] = Q_KEY_CODE_COMMA,
-    [kVK_ANSI_Period] = Q_KEY_CODE_DOT,
-    [kVK_ANSI_Slash] = Q_KEY_CODE_SLASH,
-    [kVK_Space] = Q_KEY_CODE_SPC,
-
-    [kVK_ANSI_Keypad0] = Q_KEY_CODE_KP_0,
-    [kVK_ANSI_Keypad1] = Q_KEY_CODE_KP_1,
-    [kVK_ANSI_Keypad2] = Q_KEY_CODE_KP_2,
-    [kVK_ANSI_Keypad3] = Q_KEY_CODE_KP_3,
-    [kVK_ANSI_Keypad4] = Q_KEY_CODE_KP_4,
-    [kVK_ANSI_Keypad5] = Q_KEY_CODE_KP_5,
-    [kVK_ANSI_Keypad6] = Q_KEY_CODE_KP_6,
-    [kVK_ANSI_Keypad7] = Q_KEY_CODE_KP_7,
-    [kVK_ANSI_Keypad8] = Q_KEY_CODE_KP_8,
-    [kVK_ANSI_Keypad9] = Q_KEY_CODE_KP_9,
-    [kVK_ANSI_KeypadDecimal] = Q_KEY_CODE_KP_DECIMAL,
-    [kVK_ANSI_KeypadEnter] = Q_KEY_CODE_KP_ENTER,
-    [kVK_ANSI_KeypadPlus] = Q_KEY_CODE_KP_ADD,
-    [kVK_ANSI_KeypadMinus] = Q_KEY_CODE_KP_SUBTRACT,
-    [kVK_ANSI_KeypadMultiply] = Q_KEY_CODE_KP_MULTIPLY,
-    [kVK_ANSI_KeypadDivide] = Q_KEY_CODE_KP_DIVIDE,
-    [kVK_ANSI_KeypadEquals] = Q_KEY_CODE_KP_EQUALS,
-    [kVK_ANSI_KeypadClear] = Q_KEY_CODE_NUM_LOCK,
-
-    [kVK_UpArrow] = Q_KEY_CODE_UP,
-    [kVK_DownArrow] = Q_KEY_CODE_DOWN,
-    [kVK_LeftArrow] = Q_KEY_CODE_LEFT,
-    [kVK_RightArrow] = Q_KEY_CODE_RIGHT,
-
-    [kVK_Help] = Q_KEY_CODE_INSERT,
-    [kVK_Home] = Q_KEY_CODE_HOME,
-    [kVK_PageUp] = Q_KEY_CODE_PGUP,
-    [kVK_PageDown] = Q_KEY_CODE_PGDN,
-    [kVK_End] = Q_KEY_CODE_END,
-    [kVK_ForwardDelete] = Q_KEY_CODE_DELETE,
-
-    [kVK_Escape] = Q_KEY_CODE_ESC,
-
-    /* The Power key can't be used directly because the operating system uses
-     * it. This key can be emulated by using it in place of another key such as
-     * F1. Don't forget to disable the real key binding.
-     */
-    /* [kVK_F1] = Q_KEY_CODE_POWER, */
-
-    [kVK_F1] = Q_KEY_CODE_F1,
-    [kVK_F2] = Q_KEY_CODE_F2,
-    [kVK_F3] = Q_KEY_CODE_F3,
-    [kVK_F4] = Q_KEY_CODE_F4,
-    [kVK_F5] = Q_KEY_CODE_F5,
-    [kVK_F6] = Q_KEY_CODE_F6,
-    [kVK_F7] = Q_KEY_CODE_F7,
-    [kVK_F8] = Q_KEY_CODE_F8,
-    [kVK_F9] = Q_KEY_CODE_F9,
-    [kVK_F10] = Q_KEY_CODE_F10,
-    [kVK_F11] = Q_KEY_CODE_F11,
-    [kVK_F12] = Q_KEY_CODE_F12,
-    [kVK_F13] = Q_KEY_CODE_PRINT,
-    [kVK_F14] = Q_KEY_CODE_SCROLL_LOCK,
-    [kVK_F15] = Q_KEY_CODE_PAUSE,
-
-    // JIS keyboards only
-    [kVK_JIS_Yen] = Q_KEY_CODE_YEN,
-    [kVK_JIS_Underscore] = Q_KEY_CODE_RO,
-    [kVK_JIS_KeypadComma] = Q_KEY_CODE_KP_COMMA,
-    [kVK_JIS_Eisu] = Q_KEY_CODE_MUHENKAN,
-    [kVK_JIS_Kana] = Q_KEY_CODE_HENKAN,
-
-    /*
-     * The eject and volume keys can't be used here because they are handled at
-     * a lower level than what an Application can see.
-     */
-};
-
 static int cocoa_keycode_to_qemu(int keycode)
 {
-    if (ARRAY_SIZE(mac_to_qkeycode_map) <= keycode) {
+    if (qemu_input_map_osx_to_qcode_len <= keycode) {
         error_report("(cocoa) warning unknown keycode 0x%x", keycode);
         return 0;
     }
-    return mac_to_qkeycode_map[keycode];
+    return qemu_input_map_osx_to_qcode[keycode];
 }
 
 /* Displays an alert dialog box with the specified message */

From adaef950b58fdc34e5de2f7477be0976c502d85a Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sun, 14 Mar 2021 13:51:55 +0900
Subject: [PATCH 104/180] ui/cocoa: Define types early

---
 ui/cocoa.m | 124 ++++++++++++++++++++++++-----------------------------
 1 file changed, 57 insertions(+), 67 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 81dbc8be4b0f..961c076d861f 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -72,6 +72,63 @@
 #define COCOA_DEBUG(...)  ((void) 0)
 #endif
 
+typedef void (^CodeBlock)(void);
+typedef bool (^BoolCodeBlock)(void);
+
+@interface QemuCocoaView : NSView
+{
+    NSTrackingArea *trackingArea;
+    QEMUScreen screen;
+    QKbdState *kbd;
+    BOOL isMouseGrabbed;
+    BOOL isAbsoluteEnabled;
+    CFMachPortRef eventsTap;
+}
+- (void) grabMouse;
+- (void) ungrabMouse;
+- (void) setFullGrab:(id)sender;
+- (void) handleMonitorInput:(NSEvent *)event;
+- (bool) handleEvent:(NSEvent *)event;
+- (bool) handleEventLocked:(NSEvent *)event;
+- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
+/* The state surrounding mouse grabbing is potentially confusing.
+ * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
+ *   pointing device an absolute-position one?"], but is only updated on
+ *   next refresh.
+ * isMouseGrabbed tracks whether GUI events are directed to the guest;
+ *   it controls whether special keys like Cmd get sent to the guest,
+ *   and whether we capture the mouse when in non-absolute mode.
+ */
+- (BOOL) isMouseGrabbed;
+- (BOOL) isAbsoluteEnabled;
+- (BOOL) isSwapOptionCommandEnabled;
+@end
+
+@interface QemuCocoaAppController : NSObject
+                                       <NSWindowDelegate, NSApplicationDelegate>
+{
+}
+- (void)doToggleFullScreen:(id)sender;
+- (void)showQEMUDoc:(id)sender;
+- (void)zoomToFit:(id) sender;
+- (void)displayConsole:(id)sender;
+- (void)pauseQEMU:(id)sender;
+- (void)resumeQEMU:(id)sender;
+- (void)displayPause;
+- (void)removePause;
+- (void)restartQEMU:(id)sender;
+- (void)powerDownQEMU:(id)sender;
+- (void)ejectDeviceMedia:(id)sender;
+- (void)changeDeviceMedia:(id)sender;
+- (BOOL)verifyQuit;
+- (void)openDocumentation:(NSString *)filename;
+- (IBAction) do_about_menu_item: (id) sender;
+- (void)adjustSpeed:(id)sender;
+@end
+
+@interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
+@end
+
 #define cgrect(nsrect) (*(CGRect *)&(nsrect))
 
 typedef struct {
@@ -127,9 +184,6 @@
 #endif
 
 // Utility functions to run specified code block with iothread lock held
-typedef void (^CodeBlock)(void);
-typedef bool (^BoolCodeBlock)(void);
-
 static void with_iothread_lock(CodeBlock block)
 {
     bool locked = qemu_mutex_iothread_locked();
@@ -199,40 +253,6 @@ static CGRect compute_cursor_clip_rect(int screen_height,
     return rect;
 }
 
-/*
- ------------------------------------------------------
-    QemuCocoaView
- ------------------------------------------------------
-*/
-@interface QemuCocoaView : NSView
-{
-    NSTrackingArea *trackingArea;
-    QEMUScreen screen;
-    QKbdState *kbd;
-    BOOL isMouseGrabbed;
-    BOOL isAbsoluteEnabled;
-    CFMachPortRef eventsTap;
-}
-- (void) grabMouse;
-- (void) ungrabMouse;
-- (void) setFullGrab:(id)sender;
-- (void) handleMonitorInput:(NSEvent *)event;
-- (bool) handleEvent:(NSEvent *)event;
-- (bool) handleEventLocked:(NSEvent *)event;
-- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
-/* The state surrounding mouse grabbing is potentially confusing.
- * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
- *   pointing device an absolute-position one?"], but is only updated on
- *   next refresh.
- * isMouseGrabbed tracks whether GUI events are directed to the guest;
- *   it controls whether special keys like Cmd get sent to the guest,
- *   and whether we capture the mouse when in non-absolute mode.
- */
-- (BOOL) isMouseGrabbed;
-- (BOOL) isAbsoluteEnabled;
-- (BOOL) isSwapOptionCommandEnabled;
-@end
-
 QemuCocoaView *cocoaView;
 
 static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
@@ -1046,33 +1066,6 @@ - (void) raiseAllButtons
 
 
 
-/*
- ------------------------------------------------------
-    QemuCocoaAppController
- ------------------------------------------------------
-*/
-@interface QemuCocoaAppController : NSObject
-                                       <NSWindowDelegate, NSApplicationDelegate>
-{
-}
-- (void)doToggleFullScreen:(id)sender;
-- (void)showQEMUDoc:(id)sender;
-- (void)zoomToFit:(id) sender;
-- (void)displayConsole:(id)sender;
-- (void)pauseQEMU:(id)sender;
-- (void)resumeQEMU:(id)sender;
-- (void)displayPause;
-- (void)removePause;
-- (void)restartQEMU:(id)sender;
-- (void)powerDownQEMU:(id)sender;
-- (void)ejectDeviceMedia:(id)sender;
-- (void)changeDeviceMedia:(id)sender;
-- (BOOL)verifyQuit;
-- (void)openDocumentation:(NSString *)filename;
-- (IBAction) do_about_menu_item: (id) sender;
-- (void)adjustSpeed:(id)sender;
-@end
-
 @implementation QemuCocoaAppController
 - (id) init
 {
@@ -1684,9 +1677,6 @@ static void addRemovableDevicesMenuItems(void)
     qapi_free_BlockInfoList(pointerToFree);
 }
 
-@interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
-@end
-
 @implementation QemuCocoaPasteboardTypeOwner
 
 - (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type

From 8681835e666f7dec7cb29bdb9d82688e8b1df99c Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 25 Feb 2021 17:01:14 +0900
Subject: [PATCH 105/180] ui/cocoa: Isolate fragments with preprocessor

---
 ui/cocoa.m => include/ui/cocoa.h | 1115 ++++++++++++++++--------------
 ui/cocoa/app_controller.m        |   26 +
 ui/cocoa/main.m                  |   26 +
 ui/cocoa/pasteboard_type_owner.m |   26 +
 ui/cocoa/view.m                  |   27 +
 ui/meson.build                   |    4 +-
 6 files changed, 701 insertions(+), 523 deletions(-)
 rename ui/cocoa.m => include/ui/cocoa.h (80%)
 create mode 100644 ui/cocoa/app_controller.m
 create mode 100644 ui/cocoa/main.m
 create mode 100644 ui/cocoa/pasteboard_type_owner.m
 create mode 100644 ui/cocoa/view.m

diff --git a/ui/cocoa.m b/include/ui/cocoa.h
similarity index 80%
rename from ui/cocoa.m
rename to include/ui/cocoa.h
index 961c076d861f..7d5f084a2908 100644
--- a/ui/cocoa.m
+++ b/include/ui/cocoa.h
@@ -22,17 +22,31 @@
  * THE SOFTWARE.
  */
 
+#ifndef UI_COCOA_H
+#define UI_COCOA_H
+
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_PASTEBOARD_TYPE_OWNER) || defined(UI_COCOA_VIEW)
 #include "qemu/osdep.h"
+#endif
 
 #import <Cocoa/Cocoa.h>
+#ifdef UI_COCOA_MAIN
 #include <crt_externs.h>
+#endif
 
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER)
 #include "qemu-common.h"
+#endif
 #include "ui/clipboard.h"
 #include "ui/console.h"
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_VIEW)
 #include "ui/input.h"
+#endif
 #include "ui/kbd-state.h"
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_VIEW)
 #include "sysemu/sysemu.h"
+#endif
+#ifdef UI_COCOA_APP_CONTROLLER
 #include "sysemu/runstate.h"
 #include "sysemu/cpu-throttle.h"
 #include "qapi/error.h"
@@ -42,15 +56,29 @@
 #include "sysemu/blockdev.h"
 #include "qemu-version.h"
 #include "qemu/cutils.h"
+#endif
+#if defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_PASTEBOARD_TYPE_OWNER) || defined(UI_COCOA_VIEW)
 #include "qemu/main-loop.h"
+#endif
+#ifdef UI_COCOA_APP_CONTROLLER
 #include "qemu/module.h"
+#endif
+#ifdef UI_COCOA_VIEW
+#include "qemu/error-report.h"
 #include <Carbon/Carbon.h>
+#endif
+#include "qemu/thread.h"
+#ifdef UI_COCOA_APP_CONTROLLER
 #include "hw/core/cpu.h"
+#endif
 
+#ifdef UI_COCOA_MAIN
 #ifdef CONFIG_EGL
 #include "ui/egl-context.h"
 #endif
+#endif
 
+#ifdef UI_COCOA_APP_CONTROLLER
 #ifndef MAC_OS_X_VERSION_10_13
 #define MAC_OS_X_VERSION_10_13 101300
 #endif
@@ -63,6 +91,7 @@
 #define NSControlStateValueOn NSOnState
 #define NSControlStateValueOff NSOffState
 #endif
+#endif
 
 //#define DEBUG
 
@@ -75,21 +104,48 @@
 typedef void (^CodeBlock)(void);
 typedef bool (^BoolCodeBlock)(void);
 
+typedef struct {
+    DisplayChangeListener dcl;
+    DisplaySurface *surface;
+    QemuMutex draw_mutex;
+    int mouse_x;
+    int mouse_y;
+    int mouse_on;
+    CGImageRef cursor_cgimage;
+    int cursor_show;
+    bool swap_option_command;
+    bool inited;
+} QEMUScreen;
+
+typedef struct {
+    QemuClipboardInfo *info;
+    QemuEvent event;
+} QemuCocoaClipboard;
+
 @interface QemuCocoaView : NSView
 {
+    NSTextField *pauseLabel;
     NSTrackingArea *trackingArea;
-    QEMUScreen screen;
+    QEMUScreen *screen;
+    int screen_width;
+    int screen_height;
     QKbdState *kbd;
     BOOL isMouseGrabbed;
     BOOL isAbsoluteEnabled;
     CFMachPortRef eventsTap;
 }
+- (id)initWithFrame:(NSRect)frameRect
+             screen:(QEMUScreen *)given_screen;
+- (void) frameUpdated;
+- (NSSize) computeUnzoomedSize;
+- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize;
+- (void) resizeWindow;
+- (void) updateUIInfo;
+- (void) updateScreenWidth:(int)w height:(int)h;
 - (void) grabMouse;
 - (void) ungrabMouse;
 - (void) setFullGrab:(id)sender;
-- (void) handleMonitorInput:(NSEvent *)event;
 - (bool) handleEvent:(NSEvent *)event;
-- (bool) handleEventLocked:(NSEvent *)event;
 - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
 /* The state surrounding mouse grabbing is potentially confusing.
  * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
@@ -101,64 +157,51 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
  */
 - (BOOL) isMouseGrabbed;
 - (BOOL) isAbsoluteEnabled;
-- (BOOL) isSwapOptionCommandEnabled;
+- (void) setNeedsDisplayForCursorX:(int)x
+                                 y:(int)y
+                             width:(int)width
+                            height:(int)height
+                      screenHeight:(int)screen_height;
+- (void)displayPause;
+- (void)removePause;
 @end
 
 @interface QemuCocoaAppController : NSObject
                                        <NSWindowDelegate, NSApplicationDelegate>
 {
+    QemuSemaphore *started_sem;
+    NSArray * supportedImageFileTypes;
+    QemuCocoaView *cocoaView;
 }
-- (void)doToggleFullScreen:(id)sender;
-- (void)showQEMUDoc:(id)sender;
-- (void)zoomToFit:(id) sender;
-- (void)displayConsole:(id)sender;
-- (void)pauseQEMU:(id)sender;
-- (void)resumeQEMU:(id)sender;
-- (void)displayPause;
-- (void)removePause;
-- (void)restartQEMU:(id)sender;
-- (void)powerDownQEMU:(id)sender;
-- (void)ejectDeviceMedia:(id)sender;
-- (void)changeDeviceMedia:(id)sender;
-- (BOOL)verifyQuit;
-- (void)openDocumentation:(NSString *)filename;
-- (IBAction) do_about_menu_item: (id) sender;
-- (void)adjustSpeed:(id)sender;
+- (id) initWithStartedSem:(QemuSemaphore *)given_started_sem
+                   screen:(QEMUScreen *)screen;
+- (QemuCocoaView *)cocoaView;
 @end
 
 @interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
+{
+    QemuCocoaClipboard *cb;
+}
+- (id) initWith:(QemuCocoaClipboard *)aCb;
 @end
 
+#ifdef UI_COCOA_VIEW
 #define cgrect(nsrect) (*(CGRect *)&(nsrect))
+#endif
 
-typedef struct {
-    int width;
-    int height;
-    bool swap_option_command;
-} QEMUScreen;
-
-static NSWindow *normalWindow;
-static DisplayChangeListener dcl;
-static DisplaySurface *surface;
-static QemuMutex draw_mutex;
-static int mouse_x;
-static int mouse_y;
-static int mouse_on;
-static CGImageRef cursor_cgimage;
-static int cursor_hide = 1;
+#ifdef UI_COCOA_MAIN
+static QEMUScreen screen;
+static QemuCocoaAppController *appController;
 
 static int gArgc;
 static char **gArgv;
-static NSTextField *pauseLabel;
-static NSArray * supportedImageFileTypes;
 
 static QemuSemaphore display_init_sem;
 static QemuSemaphore app_started_sem;
-static bool inited;
 
 static NSInteger cbchangecount = -1;
-static QemuClipboardInfo *cbinfo;
-static QemuEvent cbevent;
+static QemuCocoaClipboard qemucb;
+static QemuCocoaPasteboardTypeOwner *cbowner;
 
 #ifdef CONFIG_OPENGL
 
@@ -181,9 +224,11 @@ @interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
 
 static void cocoa_gl_destroy_context(void *dg, QEMUGLContext ctx);
 
+#endif
 #endif
 
-// Utility functions to run specified code block with iothread lock held
+#ifdef UI_COCOA_APP_CONTROLLER
+// Utility function to run specified code block with iothread lock held
 static void with_iothread_lock(CodeBlock block)
 {
     bool locked = qemu_mutex_iothread_locked();
@@ -195,22 +240,9 @@ static void with_iothread_lock(CodeBlock block)
         qemu_mutex_unlock_iothread();
     }
 }
+#endif
 
-static bool bool_with_iothread_lock(BoolCodeBlock block)
-{
-    bool locked = qemu_mutex_iothread_locked();
-    bool val;
-
-    if (!locked) {
-        qemu_mutex_lock_iothread();
-    }
-    val = block();
-    if (!locked) {
-        qemu_mutex_unlock_iothread();
-    }
-    return val;
-}
-
+#ifdef UI_COCOA_VIEW
 static int cocoa_keycode_to_qemu(int keycode)
 {
     if (qemu_input_map_osx_to_qcode_len <= keycode) {
@@ -219,7 +251,9 @@ static int cocoa_keycode_to_qemu(int keycode)
     }
     return qemu_input_map_osx_to_qcode[keycode];
 }
+#endif
 
+#ifdef UI_COCOA_APP_CONTROLLER
 /* Displays an alert dialog box with the specified message */
 static void QEMU_Alert(NSString *message)
 {
@@ -238,7 +272,9 @@ static void handleAnyDeviceErrors(Error * err)
         error_free(err);
     }
 }
+#endif
 
+#ifdef UI_COCOA_VIEW
 static CGRect compute_cursor_clip_rect(int screen_height,
                                        int given_mouse_x, int given_mouse_y,
                                        int cursor_width, int cursor_height)
@@ -253,8 +289,6 @@ static CGRect compute_cursor_clip_rect(int screen_height,
     return rect;
 }
 
-QemuCocoaView *cocoaView;
-
 static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
 {
     QemuCocoaView *cocoaView = (QemuCocoaView*) userInfo;
@@ -270,15 +304,29 @@ static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEven
 
 @implementation QemuCocoaView
 - (id)initWithFrame:(NSRect)frameRect
+             screen:(QEMUScreen *)given_screen
 {
     COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
 
     self = [super initWithFrame:frameRect];
     if (self) {
 
-        screen.width = frameRect.size.width;
-        screen.height = frameRect.size.height;
-        kbd = qkbd_state_init(dcl.con);
+        screen = given_screen;
+        screen_width = frameRect.size.width;
+        screen_height = frameRect.size.height;
+        kbd = qkbd_state_init(screen->dcl.con);
+
+        /* Used for displaying pause on the screen */
+        pauseLabel = [NSTextField new];
+        [pauseLabel setBezeled:YES];
+        [pauseLabel setDrawsBackground:YES];
+        [pauseLabel setBackgroundColor: [NSColor whiteColor]];
+        [pauseLabel setEditable:NO];
+        [pauseLabel setSelectable:NO];
+        [pauseLabel setStringValue: @"Paused"];
+        [pauseLabel setFont: [NSFont fontWithName: @"Helvetica" size: 90]];
+        [pauseLabel setTextColor: [NSColor blackColor]];
+        [pauseLabel sizeToFit];
 
     }
     return self;
@@ -288,6 +336,10 @@ - (void) dealloc
 {
     COCOA_DEBUG("QemuCocoaView: dealloc\n");
 
+    if (pauseLabel) {
+        [pauseLabel release];
+    }
+
     qkbd_state_free(kbd);
 
     if (eventsTap) {
@@ -341,7 +393,7 @@ - (void) viewWillMoveToWindow:(NSWindow *)newWindow
 
 - (void) hideCursor
 {
-    if (!cursor_hide) {
+    if (screen->cursor_show) {
         return;
     }
     [NSCursor hide];
@@ -349,21 +401,21 @@ - (void) hideCursor
 
 - (void) unhideCursor
 {
-    if (!cursor_hide) {
+    if (screen->cursor_show) {
         return;
     }
     [NSCursor unhide];
 }
 
 - (CGRect) convertCursorClipRectToDraw:(CGRect)rect
-                          screenHeight:(int)screen_height
-                                mouseX:(int)given_mouse_x
-                                mouseY:(int)given_mouse_y
+                          screenHeight:(int)given_screen_height
+                                mouseX:(int)mouse_x
+                                mouseY:(int)mouse_y
 {
-    CGFloat d = [self frame].size.height / (CGFloat)screen_height;
+    CGFloat d = [self frame].size.height / (CGFloat)given_screen_height;
 
-    rect.origin.x = (rect.origin.x + given_mouse_x) * d;
-    rect.origin.y = (screen_height - rect.origin.y - given_mouse_y - rect.size.height) * d;
+    rect.origin.x = (rect.origin.x + mouse_x) * d;
+    rect.origin.y = (given_screen_height - rect.origin.y - mouse_y - rect.size.height) * d;
     rect.size.width *= d;
     rect.size.height *= d;
 
@@ -386,23 +438,23 @@ - (void) drawRect:(NSRect) rect
     CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
     CGContextSetShouldAntialias (viewContextRef, NO);
 
-    qemu_mutex_lock(&draw_mutex);
+    qemu_mutex_lock(&screen->draw_mutex);
 
     // draw screen bitmap directly to Core Graphics context
-    if (!surface) {
+    if (!screen->surface) {
         // Draw request before any guest device has set up a framebuffer:
         // just draw an opaque black rectangle
         CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
         CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
     } else {
-        int w = surface_width(surface);
-        int h = surface_height(surface);
-        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(surface));
-        int stride = surface_stride(surface);
+        int w = surface_width(screen->surface);
+        int h = surface_height(screen->surface);
+        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(screen->surface));
+        int stride = surface_stride(screen->surface);
 
         CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
             NULL,
-            surface_data(surface),
+            surface_data(screen->surface),
             stride * h,
             NULL
         );
@@ -444,18 +496,18 @@ - (void) drawRect:(NSRect) rect
         CGImageRelease (imageRef);
         CGDataProviderRelease(dataProviderRef);
 
-        if (mouse_on) {
-            size_t cursor_width = CGImageGetWidth(cursor_cgimage);
-            size_t cursor_height = CGImageGetHeight(cursor_cgimage);
-            clipRect = compute_cursor_clip_rect(h, mouse_x, mouse_y,
+        if (screen->mouse_on) {
+            size_t cursor_width = CGImageGetWidth(screen->cursor_cgimage);
+            size_t cursor_height = CGImageGetHeight(screen->cursor_cgimage);
+            clipRect = compute_cursor_clip_rect(h, screen->mouse_x, screen->mouse_y,
                                                 cursor_width,
                                                 cursor_height);
             CGRect drawRect = [self convertCursorClipRectToDraw:clipRect
                                                    screenHeight:h
-                                                         mouseX:mouse_x
-                                                         mouseY:mouse_y];
+                                                         mouseX:screen->mouse_x
+                                                         mouseY:screen->mouse_y];
             clipImageRef = CGImageCreateWithImageInRect(
-                                                        cursor_cgimage,
+                                                        screen->cursor_cgimage,
                                                         clipRect
                                                         );
             CGContextDrawImage(viewContextRef, drawRect, clipImageRef);
@@ -463,13 +515,13 @@ - (void) drawRect:(NSRect) rect
         }
     }
 
-    qemu_mutex_unlock(&draw_mutex);
+    qemu_mutex_unlock(&screen->draw_mutex);
 }
 
 - (NSSize) computeUnzoomedSize
 {
-    CGFloat width = screen.width / [[self window] backingScaleFactor];
-    CGFloat height = screen.height / [[self window] backingScaleFactor];
+    CGFloat width = screen_width / [[self window] backingScaleFactor];
+    CGFloat height = screen_height / [[self window] backingScaleFactor];
 
     return NSMakeSize(width, height);
 }
@@ -478,15 +530,15 @@ - (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
 {
     NSSize size;
 
-    size.width = (CGFloat)screen.width * proposedSize.height;
-    size.height = (CGFloat)screen.height * proposedSize.width;
+    size.width = (CGFloat)screen_width * proposedSize.height;
+    size.height = (CGFloat)screen_height * proposedSize.width;
 
     if (size.width < size.height) {
-        size.width /= screen.height;
+        size.width /= screen_height;
         size.height = proposedSize.height;
     } else {
         size.width = proposedSize.width;
-        size.height /= screen.width;
+        size.height /= screen_width;
     }
 
     return size;
@@ -494,7 +546,7 @@ - (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
 
 - (void) resizeWindow
 {
-    [[self window] setContentAspectRatio:NSMakeSize(screen.width, screen.height)];
+    [[self window] setContentAspectRatio:NSMakeSize(screen_width, screen_height)];
 
     if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
         [[self window] setContentSize:[self computeUnzoomedSize]];
@@ -510,7 +562,7 @@ - (void) updateUIInfo
     NSSize frameSize;
     QemuUIInfo info = {};
 
-    if (!qatomic_load_acquire(&inited)) {
+    if (!qatomic_load_acquire(&screen->inited)) {
         return;
     }
 
@@ -531,7 +583,8 @@ - (void) updateUIInfo
             CVTime period = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink);
             CVDisplayLinkRelease(displayLink);
             if (!(period.flags & kCVTimeIsIndefinite)) {
-                update_displaychangelistener(&dcl, 1000 * period.timeValue / period.timeScale);
+                update_displaychangelistener(&screen->dcl,
+                                             1000 * period.timeValue / period.timeScale);
                 info.refresh_rate = (int64_t)1000 * period.timeScale / period.timeValue;
             }
         }
@@ -547,17 +600,17 @@ - (void) updateUIInfo
     info.width = frameBackingSize.width;
     info.height = frameBackingSize.height;
 
-    dpy_set_ui_info(dcl.con, &info);
+    dpy_set_ui_info(screen->dcl.con, &info);
 }
 
 - (void) updateScreenWidth:(int)w height:(int)h
 {
     COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
 
-    if (w != screen.width || h != screen.height) {
+    if (w != screen_width || h != screen_height) {
         COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
-        screen.width = w;
-        screen.height = h;
+        screen_width = w;
+        screen_height = h;
         [self resizeWindow];
     }
 }
@@ -592,13 +645,6 @@ - (void) setFullGrab:(id)sender
     CFRelease(tapEventsSrc);
 }
 
-- (void) setSwapOptionCommand:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaView: setSwapOptionCommand\n");
-
-    screen.swap_option_command = true;
-}
-
 - (void) toggleKey: (int)keycode {
     qkbd_state_key_event(kbd, keycode, !qkbd_state_key_get(kbd, keycode));
 }
@@ -669,7 +715,7 @@ - (void) handleMonitorInput:(NSEvent *)event
 
 - (bool) handleEvent:(NSEvent *)event
 {
-    if(!qatomic_read(&inited)) {
+    if(!qatomic_read(&screen->inited)) {
         /*
          * Just let OSX have all events that arrive before
          * applicationDidFinishLaunching.
@@ -679,9 +725,11 @@ - (bool) handleEvent:(NSEvent *)event
          */
         return false;
     }
-    return bool_with_iothread_lock(^{
-        return [self handleEventLocked:event];
-    });
+
+    qemu_mutex_lock_iothread();
+    bool handled = [self handleEventLocked:event];
+    qemu_mutex_unlock_iothread();
+    return handled;
 }
 
 - (bool) handleEventLocked:(NSEvent *)event
@@ -858,7 +906,7 @@ - (bool) handleEventLocked:(NSEvent *)event
 
                         // release the mouse grab
                         case 'g':
-                            [self ungrabMouse];
+                            [self ungrabMouseLocked];
                             return true;
                     }
                 }
@@ -898,9 +946,9 @@ - (bool) handleEventLocked:(NSEvent *)event
             /* Determine if this is a scroll up or scroll down event */
                 int buttons = ([event deltaY] > 0) ?
                     INPUT_BUTTON_WHEEL_UP : INPUT_BUTTON_WHEEL_DOWN;
-                qemu_input_queue_btn(dcl.con, buttons, true);
+                qemu_input_queue_btn(screen->dcl.con, buttons, true);
                 qemu_input_event_sync();
-                qemu_input_queue_btn(dcl.con, buttons, false);
+                qemu_input_queue_btn(screen->dcl.con, buttons, false);
                 qemu_input_event_sync();
             }
             /*
@@ -919,21 +967,23 @@ - (void) handleMouseEvent:(NSEvent *)event
         return;
     }
 
-    with_iothread_lock(^{
-        if (isAbsoluteEnabled) {
-            CGFloat d = (CGFloat)screen.height / [self frame].size.height;
-            NSPoint p = [event locationInWindow];
-            // Note that the origin for Cocoa mouse coords is bottom left, not top left.
-            qemu_input_queue_abs(dcl.con, INPUT_AXIS_X, p.x * d, 0, screen.width);
-            qemu_input_queue_abs(dcl.con, INPUT_AXIS_Y, screen.height - p.y * d, 0, screen.height);
-        } else {
-            CGFloat d = (CGFloat)screen.height / [self convertSizeToBacking:[self frame].size].height;
-            qemu_input_queue_rel(dcl.con, INPUT_AXIS_X, [event deltaX] * d);
-            qemu_input_queue_rel(dcl.con, INPUT_AXIS_Y, [event deltaY] * d);
-        }
+    qemu_mutex_lock_iothread();
 
-        qemu_input_event_sync();
-    });
+    if (isAbsoluteEnabled) {
+        CGFloat d = (CGFloat)screen_height / [self frame].size.height;
+        NSPoint p = [event locationInWindow];
+        // Note that the origin for Cocoa mouse coords is bottom left, not top left.
+        qemu_input_queue_abs(screen->dcl.con, INPUT_AXIS_X, p.x * d, 0, screen_width);
+        qemu_input_queue_abs(screen->dcl.con, INPUT_AXIS_Y, screen_height - p.y * d, 0, screen_height);
+    } else {
+        CGFloat d = (CGFloat)screen_height / [self convertSizeToBacking:[self frame].size].height;
+        qemu_input_queue_rel(screen->dcl.con, INPUT_AXIS_X, [event deltaX] * d);
+        qemu_input_queue_rel(screen->dcl.con, INPUT_AXIS_Y, [event deltaY] * d);
+    }
+
+    qemu_input_event_sync();
+
+    qemu_mutex_unlock_iothread();
 }
 
 - (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool)down
@@ -942,9 +992,9 @@ - (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool
         return;
     }
 
-    with_iothread_lock(^{
-        qemu_input_queue_btn(dcl.con, button, down);
-    });
+    qemu_mutex_lock_iothread();
+    qemu_input_queue_btn(screen->dcl.con, button, down);
+    qemu_mutex_unlock_iothread();
 
     [self handleMouseEvent:event];
 }
@@ -1022,9 +1072,9 @@ - (void) grabMouse
     COCOA_DEBUG("QemuCocoaView: grabMouse\n");
 
     if (qemu_name)
-        [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
+        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
     else
-        [normalWindow setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
+        [[self window] setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
     [self hideCursor];
     CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
     isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
@@ -1032,16 +1082,23 @@ - (void) grabMouse
 
 - (void) ungrabMouse
 {
-    COCOA_DEBUG("QemuCocoaView: ungrabMouse\n");
+    qemu_mutex_lock_iothread();
+    [self ungrabMouseLocked];
+    qemu_mutex_unlock_iothread();
+}
+
+- (void) ungrabMouseLocked
+{
+    COCOA_DEBUG("QemuCocoaView: ungrabMouseLocked\n");
 
     if (qemu_name)
-        [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
+        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
     else
-        [normalWindow setTitle:@"QEMU"];
+        [[self window] setTitle:@"QEMU"];
     [self unhideCursor];
     CGAssociateMouseAndMouseCursorPosition(TRUE);
     isMouseGrabbed = FALSE;
-    [self raiseAllButtons];
+    [self raiseAllButtonsLocked];
 }
 
 - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
@@ -1052,37 +1109,264 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
 }
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
 - (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
-- (BOOL) isSwapOptionCommandEnabled {return screen.swap_option_command;}
+- (BOOL) isSwapOptionCommandEnabled {return screen->swap_option_command;}
 
-- (void) raiseAllButtons
+- (void) raiseAllButtonsLocked
 {
-    with_iothread_lock(^{
-        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_LEFT, false);
-        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_RIGHT, false);
-        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_MIDDLE, false);
-    });
+    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_LEFT, false);
+    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_RIGHT, false);
+    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_MIDDLE, false);
+}
+
+- (void) setNeedsDisplayForCursorX:(int)x
+                                 y:(int)y
+                             width:(int)width
+                            height:(int)height
+                      screenHeight:(int)given_screen_height
+{
+    CGRect clip_rect = compute_cursor_clip_rect(given_screen_height, x, y,
+                                                width, height);
+    CGRect draw_rect = [self convertCursorClipRectToDraw:clip_rect
+                                            screenHeight:given_screen_height
+                                                  mouseX:x
+                                                  mouseY:y];
+    [self setNeedsDisplayInRect:draw_rect];
+}
+
+/* Displays the word pause on the screen */
+- (void)displayPause
+{
+    /* Coordinates have to be calculated each time because the window can change its size */
+    int xCoord, yCoord, width, height;
+    xCoord = ([[self window] frame].size.width - [pauseLabel frame].size.width)/2;
+    yCoord = [[self window] frame].size.height - [pauseLabel frame].size.height - ([pauseLabel frame].size.height * .5);
+    width = [pauseLabel frame].size.width;
+    height = [pauseLabel frame].size.height;
+    [pauseLabel setFrame: NSMakeRect(xCoord, yCoord, width, height)];
+    [self addSubview: pauseLabel];
+}
+
+/* Removes the word pause from the screen */
+- (void)removePause
+{
+    [pauseLabel removeFromSuperview];
+}
+@end
+#endif
+
+#ifdef UI_COCOA_APP_CONTROLLER
+static void create_initial_menus(void)
+{
+    // Add menus
+    NSMenu      *menu;
+    NSMenuItem  *menuItem;
+
+    [NSApp setMainMenu:[[NSMenu alloc] init]];
+
+    // Application menu
+    menu = [[NSMenu alloc] initWithTitle:@""];
+    [menu addItemWithTitle:@"About QEMU" action:@selector(do_about_menu_item:) keyEquivalent:@""]; // About QEMU
+    [menu addItem:[NSMenuItem separatorItem]]; //Separator
+    [menu addItemWithTitle:@"Hide QEMU" action:@selector(hide:) keyEquivalent:@"h"]; //Hide QEMU
+    menuItem = (NSMenuItem *)[menu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"]; // Hide Others
+    [menuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];
+    [menu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""]; // Show All
+    [menu addItem:[NSMenuItem separatorItem]]; //Separator
+    [menu addItemWithTitle:@"Quit QEMU" action:@selector(terminate:) keyEquivalent:@"q"];
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Apple" action:nil keyEquivalent:@""];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+    [NSApp performSelector:@selector(setAppleMenu:) withObject:menu]; // Workaround (this method is private since 10.4+)
+
+    // Machine menu
+    menu = [[NSMenu alloc] initWithTitle: @"Machine"];
+    [menu setAutoenablesItems: NO];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Pause" action: @selector(pauseQEMU:) keyEquivalent: @""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Resume" action: @selector(resumeQEMU:) keyEquivalent: @""] autorelease];
+    [menu addItem: menuItem];
+    [menuItem setEnabled: NO];
+    [menu addItem: [NSMenuItem separatorItem]];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Reset" action: @selector(restartQEMU:) keyEquivalent: @""] autorelease]];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Power Down" action: @selector(powerDownQEMU:) keyEquivalent: @""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Machine" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // View menu
+    menu = [[NSMenu alloc] initWithTitle:@"View"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Enter Fullscreen" action:@selector(doToggleFullScreen:) keyEquivalent:@"f"] autorelease]]; // Fullscreen
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Zoom To Fit" action:@selector(zoomToFit:) keyEquivalent:@""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"View" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // Speed menu
+    menu = [[NSMenu alloc] initWithTitle:@"Speed"];
+
+    // Add the rest of the Speed menu items
+    int p, percentage, throttle_pct;
+    for (p = 10; p >= 0; p--)
+    {
+        percentage = p * 10 > 1 ? p * 10 : 1; // prevent a 0% menu item
+
+        menuItem = [[[NSMenuItem alloc]
+                   initWithTitle: [NSString stringWithFormat: @"%d%%", percentage] action:@selector(adjustSpeed:) keyEquivalent:@""] autorelease];
+
+        if (percentage == 100) {
+            [menuItem setState: NSControlStateValueOn];
+        }
+
+        /* Calculate the throttle percentage */
+        throttle_pct = -1 * percentage + 100;
+
+        [menuItem setTag: throttle_pct];
+        [menu addItem: menuItem];
+    }
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Speed" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // Window menu
+    menu = [[NSMenu alloc] initWithTitle:@"Window"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"] autorelease]]; // Miniaturize
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+    [NSApp setWindowsMenu:menu];
+
+    // Help menu
+    menu = [[NSMenu alloc] initWithTitle:@"Help"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"QEMU Documentation" action:@selector(showQEMUDoc:) keyEquivalent:@"?"] autorelease]]; // QEMU Help
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+}
+
+/* Returns a name for a given console */
+static NSString * getConsoleName(QemuConsole * console)
+{
+    return [NSString stringWithFormat: @"%s", qemu_console_get_label(console)];
+}
+
+/* Add an entry to the View menu for each console */
+static void add_console_menu_entries(void)
+{
+    NSMenu *menu;
+    NSMenuItem *menuItem;
+    int index = 0;
+
+    menu = [[[NSApp mainMenu] itemWithTitle:@"View"] submenu];
+
+    [menu addItem:[NSMenuItem separatorItem]];
+
+    while (qemu_console_lookup_by_index(index) != NULL) {
+        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(qemu_console_lookup_by_index(index))
+                                               action: @selector(displayConsole:) keyEquivalent: @""] autorelease];
+        [menuItem setTag: index];
+        [menu addItem: menuItem];
+        index++;
+    }
+}
+
+/* Make menu items for all removable devices.
+ * Each device is given an 'Eject' and 'Change' menu item.
+ */
+static void addRemovableDevicesMenuItems(void)
+{
+    NSMenu *menu;
+    NSMenuItem *menuItem;
+    BlockInfoList *currentDevice, *pointerToFree;
+    NSString *deviceName;
+
+    currentDevice = qmp_query_block(NULL);
+    pointerToFree = currentDevice;
+    if(currentDevice == NULL) {
+        NSBeep();
+        QEMU_Alert(@"Failed to query for block devices!");
+        return;
+    }
+
+    menu = [[[NSApp mainMenu] itemWithTitle:@"Machine"] submenu];
+
+    // Add a separator between related groups of menu items
+    [menu addItem:[NSMenuItem separatorItem]];
+
+    // Set the attributes to the "Removable Media" menu item
+    NSString *titleString = @"Removable Media";
+    NSMutableAttributedString *attString=[[NSMutableAttributedString alloc] initWithString:titleString];
+    NSColor *newColor = [NSColor blackColor];
+    NSFontManager *fontManager = [NSFontManager sharedFontManager];
+    NSFont *font = [fontManager fontWithFamily:@"Helvetica"
+                                          traits:NSBoldFontMask|NSItalicFontMask
+                                          weight:0
+                                            size:14];
+    [attString addAttribute:NSFontAttributeName value:font range:NSMakeRange(0, [titleString length])];
+    [attString addAttribute:NSForegroundColorAttributeName value:newColor range:NSMakeRange(0, [titleString length])];
+    [attString addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInt: 1] range:NSMakeRange(0, [titleString length])];
+
+    // Add the "Removable Media" menu item
+    menuItem = [NSMenuItem new];
+    [menuItem setAttributedTitle: attString];
+    [menuItem setEnabled: NO];
+    [menu addItem: menuItem];
+
+    /* Loop through all the block devices in the emulator */
+    while (currentDevice) {
+        deviceName = [[NSString stringWithFormat: @"%s", currentDevice->value->device] retain];
+
+        if(currentDevice->value->removable) {
+            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Change %s...", currentDevice->value->device]
+                                                  action: @selector(changeDeviceMedia:)
+                                           keyEquivalent: @""];
+            [menu addItem: menuItem];
+            [menuItem setRepresentedObject: deviceName];
+            [menuItem autorelease];
+
+            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Eject %s", currentDevice->value->device]
+                                                  action: @selector(ejectDeviceMedia:)
+                                           keyEquivalent: @""];
+            [menu addItem: menuItem];
+            [menuItem setRepresentedObject: deviceName];
+            [menuItem autorelease];
+        }
+        currentDevice = currentDevice->next;
+    }
+    qapi_free_BlockInfoList(pointerToFree);
 }
-@end
-
-
 
 @implementation QemuCocoaAppController
-- (id) init
+- (id) initWithStartedSem:(QemuSemaphore *)given_started_sem
+                   screen:(QEMUScreen *)screen
 {
-    COCOA_DEBUG("QemuCocoaAppController: init\n");
+    COCOA_DEBUG("%s\n", __func__);
 
     self = [super init];
     if (self) {
 
+        started_sem = given_started_sem;
+
+        create_initial_menus();
+
+        /*
+         * Create the menu entries which depend on QEMU state (for consoles
+         * and removeable devices). These make calls back into QEMU functions,
+         * which is OK because at this point we know that the second thread
+         * holds the iothread lock and is synchronously waiting for us to
+         * finish.
+         */
+        add_console_menu_entries();
+        addRemovableDevicesMenuItems();
+
         // create a view and add it to the window
-        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)];
+        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)
+                                                  screen:screen];
         if(!cocoaView) {
             error_report("(cocoa) can't create a view");
             exit(1);
         }
 
         // create a window
-        normalWindow = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
+        NSWindow *normalWindow = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
             styleMask:NSWindowStyleMaskTitled|NSWindowStyleMaskMiniaturizable|NSWindowStyleMaskClosable
             backing:NSBackingStoreBuffered defer:NO];
         if(!normalWindow) {
@@ -1096,18 +1380,7 @@ - (id) init
         [normalWindow makeKeyAndOrderFront:self];
         [normalWindow center];
         [normalWindow setDelegate: self];
-
-        /* Used for displaying pause on the screen */
-        pauseLabel = [NSTextField new];
-        [pauseLabel setBezeled:YES];
-        [pauseLabel setDrawsBackground:YES];
-        [pauseLabel setBackgroundColor: [NSColor whiteColor]];
-        [pauseLabel setEditable:NO];
-        [pauseLabel setSelectable:NO];
-        [pauseLabel setStringValue: @"Paused"];
-        [pauseLabel setFont: [NSFont fontWithName: @"Helvetica" size: 90]];
-        [pauseLabel setTextColor: [NSColor blackColor]];
-        [pauseLabel sizeToFit];
+        [normalWindow release];
 
         // set the supported image file types that can be opened
         supportedImageFileTypes = [NSArray arrayWithObjects: @"img", @"iso", @"dmg",
@@ -1130,7 +1403,7 @@ - (void)applicationDidFinishLaunching: (NSNotification *) note
 {
     COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
     /* Tell cocoa_display_init to proceed */
-    qemu_sem_post(&app_started_sem);
+    qemu_sem_post(started_sem);
 }
 
 - (void)applicationWillTerminate:(NSNotification *)aNotification
@@ -1195,7 +1468,7 @@ - (BOOL)windowShouldClose:(id)sender
 
 - (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
 {
-    if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
         return [cocoaView computeUnzoomedSize];
     }
 
@@ -1216,21 +1489,7 @@ - (NSApplicationPresentationOptions) window:(NSWindow *)window
  */
 - (void) doToggleFullScreen:(id)sender
 {
-    [normalWindow toggleFullScreen:sender];
-}
-
-- (void) setFullGrab:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: setFullGrab\n");
-
-    [cocoaView setFullGrab:sender];
-}
-
-- (void) setSwapOptionCommand:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: setSwapOptionCommand\n");
-
-    [cocoaView setSwapOptionCommand:sender];
+    [[cocoaView window] toggleFullScreen:sender];
 }
 
 /* Tries to find then open the specified filename */
@@ -1270,11 +1529,11 @@ - (void)showQEMUDoc:(id)sender
 /* Toggles the flag which stretches video to fit host window size */
 - (void)zoomToFit:(id) sender
 {
-    if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
-        [normalWindow setStyleMask:[normalWindow styleMask] | NSWindowStyleMaskResizable];
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] | NSWindowStyleMaskResizable];
         [sender setState: NSControlStateValueOn];
     } else {
-        [normalWindow setStyleMask:[normalWindow styleMask] & ~NSWindowStyleMaskResizable];
+        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] & ~NSWindowStyleMaskResizable];
         [cocoaView resizeWindow];
         [sender setState: NSControlStateValueOff];
     }
@@ -1296,7 +1555,7 @@ - (void)pauseQEMU:(id)sender
     });
     [sender setEnabled: NO];
     [[[sender menu] itemWithTitle: @"Resume"] setEnabled: YES];
-    [self displayPause];
+    [cocoaView displayPause];
 }
 
 /* Resume running the guest operating system */
@@ -1307,26 +1566,7 @@ - (void)resumeQEMU:(id) sender
     });
     [sender setEnabled: NO];
     [[[sender menu] itemWithTitle: @"Pause"] setEnabled: YES];
-    [self removePause];
-}
-
-/* Displays the word pause on the screen */
-- (void)displayPause
-{
-    /* Coordinates have to be calculated each time because the window can change its size */
-    int xCoord, yCoord, width, height;
-    xCoord = ([normalWindow frame].size.width - [pauseLabel frame].size.width)/2;
-    yCoord = [normalWindow frame].size.height - [pauseLabel frame].size.height - ([pauseLabel frame].size.height * .5);
-    width = [pauseLabel frame].size.width;
-    height = [pauseLabel frame].size.height;
-    [pauseLabel setFrame: NSMakeRect(xCoord, yCoord, width, height)];
-    [cocoaView addSubview: pauseLabel];
-}
-
-/* Removes the word pause from the screen */
-- (void)removePause
-{
-    [pauseLabel removeFromSuperview];
+    [cocoaView removePause];
 }
 
 /* Restarts QEMU */
@@ -1483,8 +1723,15 @@ - (void)adjustSpeed:(id)sender
     COCOA_DEBUG("cpu throttling at %d%c\n", cpu_throttle_get_percentage(), '%');
 }
 
+- (QemuCocoaView *)cocoaView
+{
+    return cocoaView;
+}
+
 @end
+#endif
 
+#ifdef UI_COCOA_MAIN
 @interface QemuApplication : NSApplication
 @end
 
@@ -1492,227 +1739,63 @@ @implementation QemuApplication
 - (void)sendEvent:(NSEvent *)event
 {
     COCOA_DEBUG("QemuApplication: sendEvent\n");
-    if (![cocoaView handleEvent:event]) {
+    if (![[appController cocoaView] handleEvent:event]) {
         [super sendEvent: event];
     }
 }
 @end
+#endif
 
-static void create_initial_menus(void)
-{
-    // Add menus
-    NSMenu      *menu;
-    NSMenuItem  *menuItem;
-
-    [NSApp setMainMenu:[[NSMenu alloc] init]];
-
-    // Application menu
-    menu = [[NSMenu alloc] initWithTitle:@""];
-    [menu addItemWithTitle:@"About QEMU" action:@selector(do_about_menu_item:) keyEquivalent:@""]; // About QEMU
-    [menu addItem:[NSMenuItem separatorItem]]; //Separator
-    [menu addItemWithTitle:@"Hide QEMU" action:@selector(hide:) keyEquivalent:@"h"]; //Hide QEMU
-    menuItem = (NSMenuItem *)[menu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"]; // Hide Others
-    [menuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];
-    [menu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""]; // Show All
-    [menu addItem:[NSMenuItem separatorItem]]; //Separator
-    [menu addItemWithTitle:@"Quit QEMU" action:@selector(terminate:) keyEquivalent:@"q"];
-    menuItem = [[NSMenuItem alloc] initWithTitle:@"Apple" action:nil keyEquivalent:@""];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-    [NSApp performSelector:@selector(setAppleMenu:) withObject:menu]; // Workaround (this method is private since 10.4+)
-
-    // Machine menu
-    menu = [[NSMenu alloc] initWithTitle: @"Machine"];
-    [menu setAutoenablesItems: NO];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Pause" action: @selector(pauseQEMU:) keyEquivalent: @""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Resume" action: @selector(resumeQEMU:) keyEquivalent: @""] autorelease];
-    [menu addItem: menuItem];
-    [menuItem setEnabled: NO];
-    [menu addItem: [NSMenuItem separatorItem]];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Reset" action: @selector(restartQEMU:) keyEquivalent: @""] autorelease]];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Power Down" action: @selector(powerDownQEMU:) keyEquivalent: @""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Machine" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // View menu
-    menu = [[NSMenu alloc] initWithTitle:@"View"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Enter Fullscreen" action:@selector(doToggleFullScreen:) keyEquivalent:@"f"] autorelease]]; // Fullscreen
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Zoom To Fit" action:@selector(zoomToFit:) keyEquivalent:@""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"View" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // Speed menu
-    menu = [[NSMenu alloc] initWithTitle:@"Speed"];
-
-    // Add the rest of the Speed menu items
-    int p, percentage, throttle_pct;
-    for (p = 10; p >= 0; p--)
-    {
-        percentage = p * 10 > 1 ? p * 10 : 1; // prevent a 0% menu item
-
-        menuItem = [[[NSMenuItem alloc]
-                   initWithTitle: [NSString stringWithFormat: @"%d%%", percentage] action:@selector(adjustSpeed:) keyEquivalent:@""] autorelease];
-
-        if (percentage == 100) {
-            [menuItem setState: NSControlStateValueOn];
-        }
-
-        /* Calculate the throttle percentage */
-        throttle_pct = -1 * percentage + 100;
-
-        [menuItem setTag: throttle_pct];
-        [menu addItem: menuItem];
-    }
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Speed" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // Window menu
-    menu = [[NSMenu alloc] initWithTitle:@"Window"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"] autorelease]]; // Miniaturize
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-    [NSApp setWindowsMenu:menu];
-
-    // Help menu
-    menu = [[NSMenu alloc] initWithTitle:@"Help"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"QEMU Documentation" action:@selector(showQEMUDoc:) keyEquivalent:@"?"] autorelease]]; // QEMU Help
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-}
-
-/* Returns a name for a given console */
-static NSString * getConsoleName(QemuConsole * console)
-{
-    return [NSString stringWithFormat: @"%s", qemu_console_get_label(console)];
-}
+#ifdef UI_COCOA_PASTEBOARD_TYPE_OWNER
+@implementation QemuCocoaPasteboardTypeOwner
 
-/* Add an entry to the View menu for each console */
-static void add_console_menu_entries(void)
+- (id)initWith:(QemuCocoaClipboard *)aCb
 {
-    NSMenu *menu;
-    NSMenuItem *menuItem;
-    int index = 0;
-
-    menu = [[[NSApp mainMenu] itemWithTitle:@"View"] submenu];
-
-    [menu addItem:[NSMenuItem separatorItem]];
+    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
 
-    while (qemu_console_lookup_by_index(index) != NULL) {
-        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(qemu_console_lookup_by_index(index))
-                                               action: @selector(displayConsole:) keyEquivalent: @""] autorelease];
-        [menuItem setTag: index];
-        [menu addItem: menuItem];
-        index++;
+    self = [super init];
+    if (self) {
+        cb = aCb;
     }
+    return self;
 }
 
-/* Make menu items for all removable devices.
- * Each device is given an 'Eject' and 'Change' menu item.
- */
-static void addRemovableDevicesMenuItems(void)
+- (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
 {
-    NSMenu *menu;
-    NSMenuItem *menuItem;
-    BlockInfoList *currentDevice, *pointerToFree;
-    NSString *deviceName;
-
-    currentDevice = qmp_query_block(NULL);
-    pointerToFree = currentDevice;
-    if(currentDevice == NULL) {
-        NSBeep();
-        QEMU_Alert(@"Failed to query for block devices!");
+    if (type != NSPasteboardTypeString) {
         return;
     }
 
-    menu = [[[NSApp mainMenu] itemWithTitle:@"Machine"] submenu];
-
-    // Add a separator between related groups of menu items
-    [menu addItem:[NSMenuItem separatorItem]];
-
-    // Set the attributes to the "Removable Media" menu item
-    NSString *titleString = @"Removable Media";
-    NSMutableAttributedString *attString=[[NSMutableAttributedString alloc] initWithString:titleString];
-    NSColor *newColor = [NSColor blackColor];
-    NSFontManager *fontManager = [NSFontManager sharedFontManager];
-    NSFont *font = [fontManager fontWithFamily:@"Helvetica"
-                                          traits:NSBoldFontMask|NSItalicFontMask
-                                          weight:0
-                                            size:14];
-    [attString addAttribute:NSFontAttributeName value:font range:NSMakeRange(0, [titleString length])];
-    [attString addAttribute:NSForegroundColorAttributeName value:newColor range:NSMakeRange(0, [titleString length])];
-    [attString addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInt: 1] range:NSMakeRange(0, [titleString length])];
-
-    // Add the "Removable Media" menu item
-    menuItem = [NSMenuItem new];
-    [menuItem setAttributedTitle: attString];
-    [menuItem setEnabled: NO];
-    [menu addItem: menuItem];
-
-    /* Loop through all the block devices in the emulator */
-    while (currentDevice) {
-        deviceName = [[NSString stringWithFormat: @"%s", currentDevice->value->device] retain];
+    qemu_mutex_lock_iothread();
 
-        if(currentDevice->value->removable) {
-            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Change %s...", currentDevice->value->device]
-                                                  action: @selector(changeDeviceMedia:)
-                                           keyEquivalent: @""];
-            [menu addItem: menuItem];
-            [menuItem setRepresentedObject: deviceName];
-            [menuItem autorelease];
+    QemuClipboardInfo *info = qemu_clipboard_info_ref(cb->info);
+    qemu_event_reset(&cb->event);
+    qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
 
-            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Eject %s", currentDevice->value->device]
-                                                  action: @selector(ejectDeviceMedia:)
-                                           keyEquivalent: @""];
-            [menu addItem: menuItem];
-            [menuItem setRepresentedObject: deviceName];
-            [menuItem autorelease];
-        }
-        currentDevice = currentDevice->next;
+    while (info == cb->info &&
+           info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
+           info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
+        qemu_mutex_unlock_iothread();
+        qemu_event_wait(&cb->event);
+        qemu_mutex_lock_iothread();
     }
-    qapi_free_BlockInfoList(pointerToFree);
-}
-
-@implementation QemuCocoaPasteboardTypeOwner
 
-- (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
-{
-    if (type != NSPasteboardTypeString) {
-        return;
+    if (info == cb->info) {
+        NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
+                                       length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
+        [sender setData:data forType:NSPasteboardTypeString];
+        [data release];
     }
 
-    with_iothread_lock(^{
-        QemuClipboardInfo *info = qemu_clipboard_info_ref(cbinfo);
-        qemu_event_reset(&cbevent);
-        qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
-
-        while (info == cbinfo &&
-               info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
-               info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
-            qemu_mutex_unlock_iothread();
-            qemu_event_wait(&cbevent);
-            qemu_mutex_lock_iothread();
-        }
-
-        if (info == cbinfo) {
-            NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
-                                           length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
-            [sender setData:data forType:NSPasteboardTypeString];
-            [data release];
-        }
+    qemu_clipboard_info_unref(info);
 
-        qemu_clipboard_info_unref(info);
-    });
+    qemu_mutex_unlock_iothread();
 }
 
 @end
+#endif
 
-static QemuCocoaPasteboardTypeOwner *cbowner;
-
+#ifdef UI_COCOA_MAIN
 static void cocoa_clipboard_notify(Notifier *notifier, void *data);
 static void cocoa_clipboard_request(QemuClipboardInfo *info,
                                     QemuClipboardType type);
@@ -1731,15 +1814,15 @@ static void cocoa_clipboard_notify(Notifier *notifier, void *data)
         return;
     }
 
-    if (info != cbinfo) {
+    if (info != qemucb.info) {
         NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-        qemu_clipboard_info_unref(cbinfo);
-        cbinfo = qemu_clipboard_info_ref(info);
+        qemu_clipboard_info_unref(qemucb.info);
+        qemucb.info = qemu_clipboard_info_ref(info);
         cbchangecount = [[NSPasteboard generalPasteboard] declareTypes:@[NSPasteboardTypeString] owner:cbowner];
         [pool release];
     }
 
-    qemu_event_set(&cbevent);
+    qemu_event_set(&qemucb.event);
 }
 
 static void cocoa_clipboard_request(QemuClipboardInfo *info,
@@ -1796,13 +1879,16 @@ static void cocoa_clipboard_request(QemuClipboardInfo *info,
     status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
     COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
     [cbowner release];
-    CGImageRelease(cursor_cgimage);
+    CGImageRelease(screen.cursor_cgimage);
 #ifdef CONFIG_OPENGL
     g_free(dgs);
     qemu_gl_fini_shader(gls);
     if (view_ctx) {
         cocoa_gl_destroy_context(NULL, view_ctx);
     }
+    if (appController) {
+        [appController release];
+    }
 #endif
     exit(status);
 }
@@ -1820,7 +1906,7 @@ int main (int argc, char **argv) {
     qemu_thread_create(&thread, "qemu_main", call_qemu_main,
                        NULL, QEMU_THREAD_DETACHED);
 
-    qemu_mutex_init(&draw_mutex);
+    qemu_mutex_init(&screen.draw_mutex);
 
     COCOA_DEBUG("Main thread: waiting for display_init_sem\n");
     qemu_sem_wait(&display_init_sem);
@@ -1835,20 +1921,9 @@ int main (int argc, char **argv) {
 
     [QemuApplication sharedApplication];
 
-    create_initial_menus();
-
-    /*
-     * Create the menu entries which depend on QEMU state (for consoles
-     * and removeable devices). These make calls back into QEMU functions,
-     * which is OK because at this point we know that the second thread
-     * holds the iothread lock and is synchronously waiting for us to
-     * finish.
-     */
-    add_console_menu_entries();
-    addRemovableDevicesMenuItems();
-
     // Create an Application controller
-    QemuCocoaAppController *appController = [[QemuCocoaAppController alloc] init];
+    appController = [[QemuCocoaAppController alloc] initWithStartedSem:&app_started_sem
+                                                                screen:&screen];
     [NSApp setDelegate:appController];
 
     // Start the main event loop
@@ -1856,7 +1931,6 @@ int main (int argc, char **argv) {
     [NSApp run];
     COCOA_DEBUG("Main thread: left OSX run loop, exiting\n");
 
-    [appController release];
     [pool release];
 
     return 0;
@@ -1869,22 +1943,22 @@ static void cocoa_update(DisplayChangeListener *dcl,
                          int x, int y, int w, int h)
 {
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-    DisplaySurface *updated = surface;
+    DisplaySurface *updated = screen.surface;
 
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&draw_mutex);
-        if (updated != surface) {
-            qemu_mutex_unlock(&draw_mutex);
+        qemu_mutex_lock(&screen.draw_mutex);
+        if (updated != screen.surface) {
+            qemu_mutex_unlock(&screen.draw_mutex);
             return;
         }
-        int full_height = surface_height(surface);
-        qemu_mutex_unlock(&draw_mutex);
+        int full_height = surface_height(screen.surface);
+        qemu_mutex_unlock(&screen.draw_mutex);
 
-        CGFloat d = [cocoaView frame].size.height / full_height;
+        CGFloat d = [[appController cocoaView] frame].size.height / full_height;
         NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
-        [cocoaView setNeedsDisplayInRect:rect];
+        [[appController cocoaView] setNeedsDisplayInRect:rect];
     });
 
     [pool release];
@@ -1898,24 +1972,24 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 
     COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
 
-    [cocoaView updateUIInfo];
+    [[appController cocoaView] updateUIInfo];
 
-    qemu_mutex_lock(&draw_mutex);
-    surface = new_surface;
+    qemu_mutex_lock(&screen.draw_mutex);
+    screen.surface = new_surface;
     if (!updating_screen) {
         updating_screen = true;
 
         dispatch_async(dispatch_get_main_queue(), ^{
-            qemu_mutex_lock(&draw_mutex);
+            qemu_mutex_lock(&screen.draw_mutex);
             updating_screen = false;
-            int w = surface_width(surface);
-            int h = surface_height(surface);
-            qemu_mutex_unlock(&draw_mutex);
+            int w = surface_width(screen.surface);
+            int h = surface_height(screen.surface);
+            qemu_mutex_unlock(&screen.draw_mutex);
 
-            [cocoaView updateScreenWidth:w height:h];
+            [[appController cocoaView] updateScreenWidth:w height:h];
         });
     }
-    qemu_mutex_unlock(&draw_mutex);
+    qemu_mutex_unlock(&screen.draw_mutex);
     [pool release];
 }
 
@@ -1928,24 +2002,24 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
 
     if (qemu_input_is_absolute()) {
         dispatch_async(dispatch_get_main_queue(), ^{
-            if (![cocoaView isAbsoluteEnabled]) {
-                if ([cocoaView isMouseGrabbed]) {
-                    [cocoaView ungrabMouse];
+            if (![[appController cocoaView] isAbsoluteEnabled]) {
+                if ([[appController cocoaView] isMouseGrabbed]) {
+                    [[appController cocoaView] ungrabMouse];
                 }
             }
-            [cocoaView setAbsoluteEnabled:YES];
+            [[appController cocoaView] setAbsoluteEnabled:YES];
         });
     }
 
     if (cbchangecount != [[NSPasteboard generalPasteboard] changeCount]) {
-        qemu_clipboard_info_unref(cbinfo);
-        cbinfo = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
+        qemu_clipboard_info_unref(qemucb.info);
+        qemucb.info = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
         if ([[NSPasteboard generalPasteboard] availableTypeFromArray:@[NSPasteboardTypeString]]) {
-            cbinfo->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
+            qemucb.info->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
         }
-        qemu_clipboard_update(cbinfo);
+        qemu_clipboard_update(qemucb.info);
         cbchangecount = [[NSPasteboard generalPasteboard] changeCount];
-        qemu_event_set(&cbevent);
+        qemu_event_set(&qemucb.event);
     }
 
     [pool release];
@@ -1953,42 +2027,33 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
 
 static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
 {
-    qemu_mutex_lock(&draw_mutex);
-    int full_height = surface_height(surface);
-    size_t cursor_width = CGImageGetWidth(cursor_cgimage);
-    size_t cursor_height = CGImageGetHeight(cursor_cgimage);
-    int old_x = mouse_x;
-    int old_y = mouse_y;
-    int old_on = mouse_on;
-    mouse_x = x;
-    mouse_y = y;
-    mouse_on = on;
-    qemu_mutex_unlock(&draw_mutex);
+    qemu_mutex_lock(&screen.draw_mutex);
+    int full_height = surface_height(screen.surface);
+    size_t cursor_width = CGImageGetWidth(screen.cursor_cgimage);
+    size_t cursor_height = CGImageGetHeight(screen.cursor_cgimage);
+    int old_x = screen.mouse_x;
+    int old_y = screen.mouse_y;
+    int old_on = screen.mouse_on;
+    screen.mouse_x = x;
+    screen.mouse_y = y;
+    screen.mouse_on = on;
+    qemu_mutex_unlock(&screen.draw_mutex);
 
     dispatch_async(dispatch_get_main_queue(), ^{
         if (old_on) {
-            CGRect clip_rect = compute_cursor_clip_rect(full_height,
-                                                        old_x, old_y,
-                                                        cursor_width,
-                                                        cursor_height);
-            CGRect draw_rect =
-                [cocoaView convertCursorClipRectToDraw:clip_rect
-                                          screenHeight:full_height
-                                                mouseX:old_x
-                                                mouseY:old_y];
-            [cocoaView setNeedsDisplayInRect:draw_rect];
+            [[appController cocoaView] setNeedsDisplayForCursorX:old_x
+                                                               y:old_y
+                                                           width:cursor_width
+                                                           height:cursor_height
+                                                     screenHeight:full_height];
         }
 
         if (on) {
-            CGRect clip_rect = compute_cursor_clip_rect(full_height, x, y,
-                                                        cursor_width,
-                                                        cursor_height);
-            CGRect draw_rect =
-                [cocoaView convertCursorClipRectToDraw:clip_rect
-                                          screenHeight:full_height
-                                                mouseX:x
-                                                mouseY:y];
-            [cocoaView setNeedsDisplayInRect:draw_rect];
+            [[appController cocoaView] setNeedsDisplayForCursorX:x
+                                                               y:y
+                                                           width:cursor_width
+                                                           height:cursor_height
+                                                     screenHeight:full_height];
         }
     });
 }
@@ -2019,42 +2084,42 @@ static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
         kCGRenderingIntentDefault //intent
     );
 
-    qemu_mutex_lock(&draw_mutex);
-    int full_height = surface_height(surface);
-    int x = mouse_x;
-    int y = mouse_y;
-    int on = mouse_on;
+    qemu_mutex_lock(&screen.draw_mutex);
+    int full_height = surface_height(screen.surface);
+    int x = screen.mouse_x;
+    int y = screen.mouse_y;
+    int on = screen.mouse_on;
     size_t old_width;
     size_t old_height;
-    if (cursor_cgimage) {
-        old_width = CGImageGetWidth(cursor_cgimage);
-        old_height = CGImageGetHeight(cursor_cgimage);
+    if (screen.cursor_cgimage) {
+        old_width = CGImageGetWidth(screen.cursor_cgimage);
+        old_height = CGImageGetHeight(screen.cursor_cgimage);
     } else {
         old_width = 0;
         old_height = 0;
     }
-    cursor_cgimage = CGImageCreateCopy(imageRef);
-    qemu_mutex_unlock(&draw_mutex);
+    screen.cursor_cgimage = CGImageCreateCopy(imageRef);
+    qemu_mutex_unlock(&screen.draw_mutex);
 
     CGImageRelease(imageRef);
     CGDataProviderRelease(dataProviderRef);
 
     if (on) {
         dispatch_async(dispatch_get_main_queue(), ^{
-            CGFloat d = [cocoaView frame].size.height / full_height;
+            CGFloat d = [[appController cocoaView] frame].size.height / full_height;
             NSRect rect;
 
             rect.origin.x = d * x;
             rect.origin.y = d * (full_height - y - old_height);
             rect.size.width = d * old_width;
             rect.size.height = d * old_height;
-            [cocoaView setNeedsDisplayInRect:rect];
+            [[appController cocoaView] setNeedsDisplayInRect:rect];
 
             rect.origin.x = d * x;
             rect.origin.y = d * (full_height - y - height);
             rect.size.width = d * width;
             rect.size.height = d * height;
-            [cocoaView setNeedsDisplayInRect:rect];
+            [[appController cocoaView] setNeedsDisplayInRect:rect];
        });
     }
 }
@@ -2111,7 +2176,7 @@ static void with_view_ctx(CodeBlock block)
 
     [ctx retain];
     dispatch_async(dispatch_get_main_queue(), ^{
-        [ctx setView:cocoaView];
+        [ctx setView:[appController cocoaView]];
         [ctx release];
     });
 
@@ -2149,7 +2214,7 @@ static QEMUGLContext cocoa_gl_create_context(void *dg, QEMUGLParams *params)
     }
 #endif
 
-    int bpp = PIXMAN_FORMAT_BPP(surface_format(surface));
+    int bpp = PIXMAN_FORMAT_BPP(surface_format(screen.surface));
     return cocoa_gl_create_context_ns(view_ctx, bpp);
 }
 
@@ -2195,25 +2260,26 @@ static void cocoa_scanout_disable(DisplayGL *dg)
 
     dg->scanout_id = 0;
 
-    if (surface) {
-        surface_gl_destroy_texture(gls, surface);
-        surface_gl_create_texture(gls, surface);
+    if (screen.surface) {
+        surface_gl_destroy_texture(gls, screen.surface);
+        surface_gl_create_texture(gls, screen.surface);
     }
 }
 
 static void cocoa_gl_render_cursor()
 {
-    if (!mouse_on) {
+    if (!screen.mouse_on) {
         return;
     }
 
+    QemuCocoaView *cocoaView = [appController cocoaView];
     NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
-    int full_height = surface_height(surface);
+    int full_height = surface_height(screen.surface);
     CGFloat d = size.height / full_height;
 
     glViewport(
-        d * mouse_x,
-        d * (full_height - mouse_y - cursor_texture_height),
+        d * screen.mouse_x,
+        d * (full_height - screen.mouse_y - cursor_texture_height),
         d * cursor_texture_width,
         d * cursor_texture_height
     );
@@ -2228,11 +2294,12 @@ static void cocoa_gl_render_surface(DisplayGL *dg)
 {
     cocoa_scanout_disable(dg);
 
+    QemuCocoaView *cocoaView = [appController cocoaView];
     NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
 
-    surface_gl_setup_viewport(gls, surface, size.width, size.height);
-    glBindTexture(GL_TEXTURE_2D, surface->texture);
-    surface_gl_render_texture(gls, surface);
+    surface_gl_setup_viewport(gls, screen.surface, size.width, size.height);
+    glBindTexture(GL_TEXTURE_2D, screen.surface->texture);
+    surface_gl_render_texture(gls, screen.surface);
 
     cocoa_gl_render_cursor();
 
@@ -2243,7 +2310,7 @@ static void cocoa_gl_update(DisplayChangeListener *dcl,
                             int x, int y, int w, int h)
 {
     with_view_ctx(^{
-        surface_gl_update_texture(gls, surface, x, y, w, h);
+        surface_gl_update_texture(gls, screen.surface, x, y, w, h);
         dgs[qemu_console_get_index(dcl->con)].surface_dirty = true;
     });
 }
@@ -2265,7 +2332,7 @@ static void cocoa_gl_refresh(DisplayChangeListener *dcl)
     with_view_ctx(^{
         DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
 
-        if (dg->surface_dirty && surface) {
+        if (dg->surface_dirty && screen.surface) {
             dg->surface_dirty = false;
             cocoa_gl_render_surface(dg);
         }
@@ -2310,6 +2377,7 @@ static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
     }
 
     with_view_ctx(^{
+        QemuCocoaView *cocoaView = [appController cocoaView];
         NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
 
         glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
@@ -2325,9 +2393,9 @@ static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
 
 static void cocoa_gl_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
 {
-    mouse_x = x;
-    mouse_y = y;
-    mouse_on = on;
+    screen.mouse_x = x;
+    screen.mouse_y = y;
+    screen.mouse_on = on;
 
     DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
 
@@ -2394,31 +2462,26 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 {
     COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
 
+    screen.cursor_show = opts->has_show_cursor && opts->show_cursor;
+    screen.swap_option_command = opts->u.cocoa.has_swap_option_command &&
+        opts->u.cocoa.swap_option_command;
+
     /* Tell main thread to go ahead and create the app and enter the run loop */
     qemu_sem_post(&display_init_sem);
     qemu_sem_wait(&app_started_sem);
     COCOA_DEBUG("cocoa_display_init: app start completed\n");
 
-    QemuCocoaAppController* controller = (QemuCocoaAppController*)[[NSApplication sharedApplication] delegate];
     /* if fullscreen mode is to be used */
     if (opts->has_full_screen && opts->full_screen) {
         dispatch_async(dispatch_get_main_queue(), ^{
-            [normalWindow toggleFullScreen: nil];
+            [[[appController cocoaView] window] toggleFullScreen: nil];
         });
     }
     if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {
         dispatch_async(dispatch_get_main_queue(), ^{
-            [controller setFullGrab: nil];
-        });
-    }
-    if (opts->u.cocoa.has_swap_option_command && opts->u.cocoa.swap_option_command) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            [controller setSwapOptionCommand: nil];
+            [[appController cocoaView] setFullGrab: nil];
         });
     }
-    if (opts->has_show_cursor && opts->show_cursor) {
-        cursor_hide = 0;
-    }
 
     if (display_opengl) {
 #ifdef CONFIG_OPENGL
@@ -2436,10 +2499,16 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 
         if (opts->gl == DISPLAYGL_MODE_ES) {
 #ifdef CONFIG_EGL
-            qemu_egl_init_dpy_cocoa(DISPLAYGL_MODE_ES);
+            if (qemu_egl_init_dpy_cocoa(DISPLAYGL_MODE_ES)) {
+                exit(1);
+            }
             view_ctx = qemu_egl_init_ctx();
+            if (!view_ctx) {
+                exit(1);
+            }
             dispatch_sync(dispatch_get_main_queue(), ^{
-                egl_surface = qemu_egl_init_surface(view_ctx, [cocoaView layer]);
+                CALayer *layer = [[appController cocoaView] layer];
+                egl_surface = qemu_egl_init_surface(view_ctx, layer);
             });
 #else
             error_report("OpenGLES without EGL is not supported - exiting");
@@ -2457,7 +2526,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
         glGenTextures(1, &cursor_texture);
 
         // register vga output callbacks
-        dcl.ops = &dcl_gl_ops;
+        screen.dcl.ops = &dcl_gl_ops;
 
         register_displayglops(&dg_ops);
 #else
@@ -2466,15 +2535,14 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 #endif
     } else {
         // register vga output callbacks
-        dcl.ops = &dcl_ops;
+        screen.dcl.ops = &dcl_ops;
     }
 
-    register_displaychangelistener(&dcl);
+    register_displaychangelistener(&screen.dcl);
+    qatomic_store_release(&screen.inited, true);
 
-    qatomic_store_release(&inited, true);
-
-    qemu_event_init(&cbevent, false);
-    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
+    qemu_event_init(&qemucb.event, false);
+    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] initWith:&qemucb];
     qemu_clipboard_peer_register(&cbpeer);
 }
 
@@ -2494,3 +2562,6 @@ static void register_cocoa(void)
 #ifdef CONFIG_OPENGL
 module_dep("ui-opengl");
 #endif
+#endif
+
+#endif
diff --git a/ui/cocoa/app_controller.m b/ui/cocoa/app_controller.m
new file mode 100644
index 000000000000..5d1df04d2c3a
--- /dev/null
+++ b/ui/cocoa/app_controller.m
@@ -0,0 +1,26 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define UI_COCOA_APP_CONTROLLER
+#include "ui/cocoa.h"
diff --git a/ui/cocoa/main.m b/ui/cocoa/main.m
new file mode 100644
index 000000000000..e6d8fdeb4efb
--- /dev/null
+++ b/ui/cocoa/main.m
@@ -0,0 +1,26 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define UI_COCOA_MAIN
+#include "ui/cocoa.h"
diff --git a/ui/cocoa/pasteboard_type_owner.m b/ui/cocoa/pasteboard_type_owner.m
new file mode 100644
index 000000000000..691366755682
--- /dev/null
+++ b/ui/cocoa/pasteboard_type_owner.m
@@ -0,0 +1,26 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define UI_COCOA_PASTEBOARD_TYPE_OWNER
+#include "ui/cocoa.h"
diff --git a/ui/cocoa/view.m b/ui/cocoa/view.m
new file mode 100644
index 000000000000..31f195d224d0
--- /dev/null
+++ b/ui/cocoa/view.m
@@ -0,0 +1,27 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define UI_COCOA_VIEW
+#include "ui/cocoa.h"
+
diff --git a/ui/meson.build b/ui/meson.build
index 846251159e3f..0879481141a4 100644
--- a/ui/meson.build
+++ b/ui/meson.build
@@ -18,7 +18,9 @@ softmmu_ss.add([spice_headers, files('spice-module.c')])
 softmmu_ss.add(when: spice_protocol, if_true: files('vdagent.c'))
 
 softmmu_ss.add(when: 'CONFIG_LINUX', if_true: files('input-linux.c'))
-softmmu_ss.add(when: cocoa, if_true: files('cocoa.m'))
+softmmu_ss.add(when: cocoa,
+               if_true: files('cocoa/main.m', 'cocoa/pasteboard_type_owner.m',
+                              'cocoa/view.m', 'cocoa/app_controller.m'))
 
 vnc_ss = ss.source_set()
 vnc_ss.add(files(

From c61c853e1f46df5a53cfc34978a1a1a8b707a442 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 14 Jul 2021 13:04:55 +0900
Subject: [PATCH 106/180] ui/cocoa: Divide ui/cocoa.m

---
 include/ui/cocoa.h               | 2440 ------------------------------
 ui/cocoa/app_controller.m        |  637 +++++++-
 ui/cocoa/main.m                  |  828 +++++++++-
 ui/cocoa/pasteboard_type_owner.m |   51 +-
 ui/cocoa/view.m                  |  896 ++++++++++-
 5 files changed, 2408 insertions(+), 2444 deletions(-)

diff --git a/include/ui/cocoa.h b/include/ui/cocoa.h
index 7d5f084a2908..12ccc97e6fbd 100644
--- a/include/ui/cocoa.h
+++ b/include/ui/cocoa.h
@@ -25,73 +25,12 @@
 #ifndef UI_COCOA_H
 #define UI_COCOA_H
 
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_PASTEBOARD_TYPE_OWNER) || defined(UI_COCOA_VIEW)
-#include "qemu/osdep.h"
-#endif
-
 #import <Cocoa/Cocoa.h>
-#ifdef UI_COCOA_MAIN
-#include <crt_externs.h>
-#endif
 
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER)
-#include "qemu-common.h"
-#endif
 #include "ui/clipboard.h"
 #include "ui/console.h"
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_VIEW)
-#include "ui/input.h"
-#endif
 #include "ui/kbd-state.h"
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_VIEW)
-#include "sysemu/sysemu.h"
-#endif
-#ifdef UI_COCOA_APP_CONTROLLER
-#include "sysemu/runstate.h"
-#include "sysemu/cpu-throttle.h"
-#include "qapi/error.h"
-#include "qapi/qapi-commands-block.h"
-#include "qapi/qapi-commands-machine.h"
-#include "qapi/qapi-commands-misc.h"
-#include "sysemu/blockdev.h"
-#include "qemu-version.h"
-#include "qemu/cutils.h"
-#endif
-#if defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_PASTEBOARD_TYPE_OWNER) || defined(UI_COCOA_VIEW)
-#include "qemu/main-loop.h"
-#endif
-#ifdef UI_COCOA_APP_CONTROLLER
-#include "qemu/module.h"
-#endif
-#ifdef UI_COCOA_VIEW
-#include "qemu/error-report.h"
-#include <Carbon/Carbon.h>
-#endif
 #include "qemu/thread.h"
-#ifdef UI_COCOA_APP_CONTROLLER
-#include "hw/core/cpu.h"
-#endif
-
-#ifdef UI_COCOA_MAIN
-#ifdef CONFIG_EGL
-#include "ui/egl-context.h"
-#endif
-#endif
-
-#ifdef UI_COCOA_APP_CONTROLLER
-#ifndef MAC_OS_X_VERSION_10_13
-#define MAC_OS_X_VERSION_10_13 101300
-#endif
-
-/* 10.14 deprecates NSOnState and NSOffState in favor of
- * NSControlStateValueOn/Off, which were introduced in 10.13.
- * Define for older versions
- */
-#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_13
-#define NSControlStateValueOn NSOnState
-#define NSControlStateValueOff NSOffState
-#endif
-#endif
 
 //#define DEBUG
 
@@ -185,2383 +124,4 @@ typedef struct {
 - (id) initWith:(QemuCocoaClipboard *)aCb;
 @end
 
-#ifdef UI_COCOA_VIEW
-#define cgrect(nsrect) (*(CGRect *)&(nsrect))
-#endif
-
-#ifdef UI_COCOA_MAIN
-static QEMUScreen screen;
-static QemuCocoaAppController *appController;
-
-static int gArgc;
-static char **gArgv;
-
-static QemuSemaphore display_init_sem;
-static QemuSemaphore app_started_sem;
-
-static NSInteger cbchangecount = -1;
-static QemuCocoaClipboard qemucb;
-static QemuCocoaPasteboardTypeOwner *cbowner;
-
-#ifdef CONFIG_OPENGL
-
-typedef struct {
-    uint32_t scanout_id;
-    DisplayGLTextureBorrower scanout_borrow;
-    bool surface_dirty;
-} DisplayGL;
-
-static DisplayGL *dgs;
-static QEMUGLContext view_ctx;
-static QemuGLShader *gls;
-static GLuint cursor_texture;
-static int cursor_texture_width;
-static int cursor_texture_height;
-
-#ifdef CONFIG_EGL
-static EGLSurface egl_surface;
-#endif
-
-static void cocoa_gl_destroy_context(void *dg, QEMUGLContext ctx);
-
-#endif
-#endif
-
-#ifdef UI_COCOA_APP_CONTROLLER
-// Utility function to run specified code block with iothread lock held
-static void with_iothread_lock(CodeBlock block)
-{
-    bool locked = qemu_mutex_iothread_locked();
-    if (!locked) {
-        qemu_mutex_lock_iothread();
-    }
-    block();
-    if (!locked) {
-        qemu_mutex_unlock_iothread();
-    }
-}
-#endif
-
-#ifdef UI_COCOA_VIEW
-static int cocoa_keycode_to_qemu(int keycode)
-{
-    if (qemu_input_map_osx_to_qcode_len <= keycode) {
-        error_report("(cocoa) warning unknown keycode 0x%x", keycode);
-        return 0;
-    }
-    return qemu_input_map_osx_to_qcode[keycode];
-}
-#endif
-
-#ifdef UI_COCOA_APP_CONTROLLER
-/* Displays an alert dialog box with the specified message */
-static void QEMU_Alert(NSString *message)
-{
-    NSAlert *alert;
-    alert = [NSAlert new];
-    [alert setMessageText: message];
-    [alert runModal];
-}
-
-/* Handles any errors that happen with a device transaction */
-static void handleAnyDeviceErrors(Error * err)
-{
-    if (err) {
-        QEMU_Alert([NSString stringWithCString: error_get_pretty(err)
-                                      encoding: NSASCIIStringEncoding]);
-        error_free(err);
-    }
-}
-#endif
-
-#ifdef UI_COCOA_VIEW
-static CGRect compute_cursor_clip_rect(int screen_height,
-                                       int given_mouse_x, int given_mouse_y,
-                                       int cursor_width, int cursor_height)
-{
-    CGRect rect;
-
-    rect.origin.x = MAX(0, -given_mouse_x);
-    rect.origin.y = 0;
-    rect.size.width = MIN(cursor_width, cursor_width + given_mouse_x);
-    rect.size.height = cursor_height - rect.origin.x;
-
-    return rect;
-}
-
-static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
-{
-    QemuCocoaView *cocoaView = (QemuCocoaView*) userInfo;
-    NSEvent* event = [NSEvent eventWithCGEvent:cgEvent];
-    if ([cocoaView isMouseGrabbed] && [cocoaView handleEvent:event]) {
-        COCOA_DEBUG("Global events tap: qemu handled the event, capturing!\n");
-        return NULL;
-    }
-    COCOA_DEBUG("Global events tap: qemu did not handle the event, letting it through...\n");
-
-    return cgEvent;
-}
-
-@implementation QemuCocoaView
-- (id)initWithFrame:(NSRect)frameRect
-             screen:(QEMUScreen *)given_screen
-{
-    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
-
-    self = [super initWithFrame:frameRect];
-    if (self) {
-
-        screen = given_screen;
-        screen_width = frameRect.size.width;
-        screen_height = frameRect.size.height;
-        kbd = qkbd_state_init(screen->dcl.con);
-
-        /* Used for displaying pause on the screen */
-        pauseLabel = [NSTextField new];
-        [pauseLabel setBezeled:YES];
-        [pauseLabel setDrawsBackground:YES];
-        [pauseLabel setBackgroundColor: [NSColor whiteColor]];
-        [pauseLabel setEditable:NO];
-        [pauseLabel setSelectable:NO];
-        [pauseLabel setStringValue: @"Paused"];
-        [pauseLabel setFont: [NSFont fontWithName: @"Helvetica" size: 90]];
-        [pauseLabel setTextColor: [NSColor blackColor]];
-        [pauseLabel sizeToFit];
-
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-    COCOA_DEBUG("QemuCocoaView: dealloc\n");
-
-    if (pauseLabel) {
-        [pauseLabel release];
-    }
-
-    qkbd_state_free(kbd);
-
-    if (eventsTap) {
-        CFRelease(eventsTap);
-    }
-
-    [super dealloc];
-}
-
-- (BOOL) isOpaque
-{
-    return YES;
-}
-
-- (void) removeTrackingRect
-{
-    if (trackingArea) {
-        [self removeTrackingArea:trackingArea];
-        [trackingArea release];
-        trackingArea = nil;
-    }
-}
-
-- (void) frameUpdated
-{
-    [self removeTrackingRect];
-
-    if ([self window]) {
-        NSTrackingAreaOptions options = NSTrackingActiveInKeyWindow |
-                                        NSTrackingMouseEnteredAndExited |
-                                        NSTrackingMouseMoved;
-        trackingArea = [[NSTrackingArea alloc] initWithRect:[self frame]
-                                                    options:options
-                                                      owner:self
-                                                   userInfo:nil];
-        [self addTrackingArea:trackingArea];
-        [self updateUIInfo];
-    }
-}
-
-- (void) viewDidMoveToWindow
-{
-    [self resizeWindow];
-    [self frameUpdated];
-}
-
-- (void) viewWillMoveToWindow:(NSWindow *)newWindow
-{
-    [self removeTrackingRect];
-}
-
-- (void) hideCursor
-{
-    if (screen->cursor_show) {
-        return;
-    }
-    [NSCursor hide];
-}
-
-- (void) unhideCursor
-{
-    if (screen->cursor_show) {
-        return;
-    }
-    [NSCursor unhide];
-}
-
-- (CGRect) convertCursorClipRectToDraw:(CGRect)rect
-                          screenHeight:(int)given_screen_height
-                                mouseX:(int)mouse_x
-                                mouseY:(int)mouse_y
-{
-    CGFloat d = [self frame].size.height / (CGFloat)given_screen_height;
-
-    rect.origin.x = (rect.origin.x + mouse_x) * d;
-    rect.origin.y = (given_screen_height - rect.origin.y - mouse_y - rect.size.height) * d;
-    rect.size.width *= d;
-    rect.size.height *= d;
-
-    return rect;
-}
-
-- (void) drawRect:(NSRect) rect
-{
-    COCOA_DEBUG("QemuCocoaView: drawRect\n");
-
-#ifdef CONFIG_OPENGL
-    if (display_opengl) {
-        return;
-    }
-#endif
-
-    // get CoreGraphic context
-    CGContextRef viewContextRef = [[NSGraphicsContext currentContext] CGContext];
-
-    CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
-    CGContextSetShouldAntialias (viewContextRef, NO);
-
-    qemu_mutex_lock(&screen->draw_mutex);
-
-    // draw screen bitmap directly to Core Graphics context
-    if (!screen->surface) {
-        // Draw request before any guest device has set up a framebuffer:
-        // just draw an opaque black rectangle
-        CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
-        CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
-    } else {
-        int w = surface_width(screen->surface);
-        int h = surface_height(screen->surface);
-        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(screen->surface));
-        int stride = surface_stride(screen->surface);
-
-        CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
-            NULL,
-            surface_data(screen->surface),
-            stride * h,
-            NULL
-        );
-
-        CGImageRef imageRef = CGImageCreate(
-            w, //width
-            h, //height
-            DIV_ROUND_UP(bitsPerPixel, 8) * 2, //bitsPerComponent
-            bitsPerPixel, //bitsPerPixel
-            stride, //bytesPerRow
-            CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
-            kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipFirst, //bitmapInfo
-            dataProviderRef, //provider
-            NULL, //decode
-            0, //interpolate
-            kCGRenderingIntentDefault //intent
-        );
-        // selective drawing code (draws only dirty rectangles) (OS X >= 10.4)
-        const NSRect *rectList;
-        NSInteger rectCount;
-        int i;
-        CGImageRef clipImageRef;
-        CGRect clipRect;
-        CGFloat d = (CGFloat)h / [self frame].size.height;
-
-        [self getRectsBeingDrawn:&rectList count:&rectCount];
-        for (i = 0; i < rectCount; i++) {
-            clipRect.origin.x = rectList[i].origin.x * d;
-            clipRect.origin.y = (float)h - (rectList[i].origin.y + rectList[i].size.height) * d;
-            clipRect.size.width = rectList[i].size.width * d;
-            clipRect.size.height = rectList[i].size.height * d;
-            clipImageRef = CGImageCreateWithImageInRect(
-                                                        imageRef,
-                                                        clipRect
-                                                        );
-            CGContextDrawImage (viewContextRef, cgrect(rectList[i]), clipImageRef);
-            CGImageRelease (clipImageRef);
-        }
-        CGImageRelease (imageRef);
-        CGDataProviderRelease(dataProviderRef);
-
-        if (screen->mouse_on) {
-            size_t cursor_width = CGImageGetWidth(screen->cursor_cgimage);
-            size_t cursor_height = CGImageGetHeight(screen->cursor_cgimage);
-            clipRect = compute_cursor_clip_rect(h, screen->mouse_x, screen->mouse_y,
-                                                cursor_width,
-                                                cursor_height);
-            CGRect drawRect = [self convertCursorClipRectToDraw:clipRect
-                                                   screenHeight:h
-                                                         mouseX:screen->mouse_x
-                                                         mouseY:screen->mouse_y];
-            clipImageRef = CGImageCreateWithImageInRect(
-                                                        screen->cursor_cgimage,
-                                                        clipRect
-                                                        );
-            CGContextDrawImage(viewContextRef, drawRect, clipImageRef);
-            CGImageRelease (clipImageRef);
-        }
-    }
-
-    qemu_mutex_unlock(&screen->draw_mutex);
-}
-
-- (NSSize) computeUnzoomedSize
-{
-    CGFloat width = screen_width / [[self window] backingScaleFactor];
-    CGFloat height = screen_height / [[self window] backingScaleFactor];
-
-    return NSMakeSize(width, height);
-}
-
-- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
-{
-    NSSize size;
-
-    size.width = (CGFloat)screen_width * proposedSize.height;
-    size.height = (CGFloat)screen_height * proposedSize.width;
-
-    if (size.width < size.height) {
-        size.width /= screen_height;
-        size.height = proposedSize.height;
-    } else {
-        size.width = proposedSize.width;
-        size.height /= screen_width;
-    }
-
-    return size;
-}
-
-- (void) resizeWindow
-{
-    [[self window] setContentAspectRatio:NSMakeSize(screen_width, screen_height)];
-
-    if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
-        [[self window] setContentSize:[self computeUnzoomedSize]];
-        [[self window] center];
-    } else if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
-        [[self window] setContentSize:[self fixZoomedFullScreenSize:[[[self window] screen] frame].size]];
-        [[self window] center];
-    }
-}
-
-- (void) updateUIInfo
-{
-    NSSize frameSize;
-    QemuUIInfo info = {};
-
-    if (!qatomic_load_acquire(&screen->inited)) {
-        return;
-    }
-
-    if ([self window]) {
-        NSDictionary *description = [[[self window] screen] deviceDescription];
-        CGDirectDisplayID display = [[description objectForKey:@"NSScreenNumber"] unsignedIntValue];
-        NSSize screenSize = [[[self window] screen] frame].size;
-        CGSize screenPhysicalSize = CGDisplayScreenSize(display);
-        CVDisplayLinkRef displayLink;
-
-        if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) == 0) {
-            frameSize = [self frame].size;
-        } else {
-            frameSize = screenSize;
-        }
-
-        if (!CVDisplayLinkCreateWithCGDisplay(display, &displayLink)) {
-            CVTime period = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink);
-            CVDisplayLinkRelease(displayLink);
-            if (!(period.flags & kCVTimeIsIndefinite)) {
-                update_displaychangelistener(&screen->dcl,
-                                             1000 * period.timeValue / period.timeScale);
-                info.refresh_rate = (int64_t)1000 * period.timeScale / period.timeValue;
-            }
-        }
-
-        info.width_mm = frameSize.width / screenSize.width * screenPhysicalSize.width;
-        info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
-    } else {
-        frameSize = [self frame].size;
-    }
-
-    NSSize frameBackingSize = [self convertSizeToBacking:frameSize];
-
-    info.width = frameBackingSize.width;
-    info.height = frameBackingSize.height;
-
-    dpy_set_ui_info(screen->dcl.con, &info);
-}
-
-- (void) updateScreenWidth:(int)w height:(int)h
-{
-    COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
-
-    if (w != screen_width || h != screen_height) {
-        COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
-        screen_width = w;
-        screen_height = h;
-        [self resizeWindow];
-    }
-}
-
-- (void) setFullGrab:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaView: setFullGrab\n");
-
-    CGEventMask mask = CGEventMaskBit(kCGEventKeyDown) | CGEventMaskBit(kCGEventKeyUp) | CGEventMaskBit(kCGEventFlagsChanged);
-    eventsTap = CGEventTapCreate(kCGHIDEventTap, kCGHeadInsertEventTap, kCGEventTapOptionDefault,
-                                 mask, handleTapEvent, self);
-    if (!eventsTap) {
-        warn_report("Could not create event tap, system key combos will not be captured.\n");
-        return;
-    } else {
-        COCOA_DEBUG("Global events tap created! Will capture system key combos.\n");
-    }
-
-    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
-    if (!runLoop) {
-        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
-        return;
-    }
-
-    CFRunLoopSourceRef tapEventsSrc = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventsTap, 0);
-    if (!tapEventsSrc ) {
-        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
-        return;
-    }
-
-    CFRunLoopAddSource(runLoop, tapEventsSrc, kCFRunLoopDefaultMode);
-    CFRelease(tapEventsSrc);
-}
-
-- (void) toggleKey: (int)keycode {
-    qkbd_state_key_event(kbd, keycode, !qkbd_state_key_get(kbd, keycode));
-}
-
-// Does the work of sending input to the monitor
-- (void) handleMonitorInput:(NSEvent *)event
-{
-    int keysym = 0;
-    int control_key = 0;
-
-    // if the control key is down
-    if ([event modifierFlags] & NSEventModifierFlagControl) {
-        control_key = 1;
-    }
-
-    /* translates Macintosh keycodes to QEMU's keysym */
-
-    int without_control_translation[] = {
-        [0 ... 0xff] = 0,   // invalid key
-
-        [kVK_UpArrow]       = QEMU_KEY_UP,
-        [kVK_DownArrow]     = QEMU_KEY_DOWN,
-        [kVK_RightArrow]    = QEMU_KEY_RIGHT,
-        [kVK_LeftArrow]     = QEMU_KEY_LEFT,
-        [kVK_Home]          = QEMU_KEY_HOME,
-        [kVK_End]           = QEMU_KEY_END,
-        [kVK_PageUp]        = QEMU_KEY_PAGEUP,
-        [kVK_PageDown]      = QEMU_KEY_PAGEDOWN,
-        [kVK_ForwardDelete] = QEMU_KEY_DELETE,
-        [kVK_Delete]        = QEMU_KEY_BACKSPACE,
-    };
-
-    int with_control_translation[] = {
-        [0 ... 0xff] = 0,   // invalid key
-
-        [kVK_UpArrow]       = QEMU_KEY_CTRL_UP,
-        [kVK_DownArrow]     = QEMU_KEY_CTRL_DOWN,
-        [kVK_RightArrow]    = QEMU_KEY_CTRL_RIGHT,
-        [kVK_LeftArrow]     = QEMU_KEY_CTRL_LEFT,
-        [kVK_Home]          = QEMU_KEY_CTRL_HOME,
-        [kVK_End]           = QEMU_KEY_CTRL_END,
-        [kVK_PageUp]        = QEMU_KEY_CTRL_PAGEUP,
-        [kVK_PageDown]      = QEMU_KEY_CTRL_PAGEDOWN,
-    };
-
-    if (control_key != 0) { /* If the control key is being used */
-        if ([event keyCode] < ARRAY_SIZE(with_control_translation)) {
-            keysym = with_control_translation[[event keyCode]];
-        }
-    } else {
-        if ([event keyCode] < ARRAY_SIZE(without_control_translation)) {
-            keysym = without_control_translation[[event keyCode]];
-        }
-    }
-
-    // if not a key that needs translating
-    if (keysym == 0) {
-        NSString *ks = [event characters];
-        if ([ks length] > 0) {
-            keysym = [ks characterAtIndex:0];
-        }
-    }
-
-    if (keysym) {
-        kbd_put_keysym(keysym);
-    }
-}
-
-- (bool) handleEvent:(NSEvent *)event
-{
-    if(!qatomic_read(&screen->inited)) {
-        /*
-         * Just let OSX have all events that arrive before
-         * applicationDidFinishLaunching.
-         * This avoids a deadlock on the iothread lock, which cocoa_display_init()
-         * will not drop until after the app_started_sem is posted. (In theory
-         * there should not be any such events, but OSX Catalina now emits some.)
-         */
-        return false;
-    }
-
-    qemu_mutex_lock_iothread();
-    bool handled = [self handleEventLocked:event];
-    qemu_mutex_unlock_iothread();
-    return handled;
-}
-
-- (bool) handleEventLocked:(NSEvent *)event
-{
-    /* Return true if we handled the event, false if it should be given to OSX */
-    COCOA_DEBUG("QemuCocoaView: handleEvent\n");
-    int keycode = 0;
-    NSUInteger modifiers = [event modifierFlags];
-
-    /*
-     * Check -[NSEvent modifierFlags] here.
-     *
-     * There is a NSEventType for an event notifying the change of
-     * -[NSEvent modifierFlags], NSEventTypeFlagsChanged but these operations
-     * are performed for any events because a modifier state may change while
-     * the application is inactive (i.e. no events fire) and we don't want to
-     * wait for another modifier state change to detect such a change.
-     *
-     * NSEventModifierFlagCapsLock requires a special treatment. The other flags
-     * are handled in similar manners.
-     *
-     * NSEventModifierFlagCapsLock
-     * ---------------------------
-     *
-     * If CapsLock state is changed, "up" and "down" events will be fired in
-     * sequence, effectively updates CapsLock state on the guest.
-     *
-     * The other flags
-     * ---------------
-     *
-     * If a flag is not set, fire "up" events for all keys which correspond to
-     * the flag. Note that "down" events are not fired here because the flags
-     * checked here do not tell what exact keys are down.
-     *
-     * If one of the keys corresponding to a flag is down, we rely on
-     * -[NSEvent keyCode] of an event whose -[NSEvent type] is
-     * NSEventTypeFlagsChanged to know the exact key which is down, which has
-     * the following two downsides:
-     * - It does not work when the application is inactive as described above.
-     * - It malfactions *after* the modifier state is changed while the
-     *   application is inactive. It is because -[NSEvent keyCode] does not tell
-     *   if the key is up or down, and requires to infer the current state from
-     *   the previous state. It is still possible to fix such a malfanction by
-     *   completely leaving your hands from the keyboard, which hopefully makes
-     *   this implementation usable enough.
-     */
-    if (!!(modifiers & NSEventModifierFlagCapsLock) !=
-        qkbd_state_modifier_get(kbd, QKBD_MOD_CAPSLOCK)) {
-        qkbd_state_key_event(kbd, Q_KEY_CODE_CAPS_LOCK, true);
-        qkbd_state_key_event(kbd, Q_KEY_CODE_CAPS_LOCK, false);
-    }
-
-    if (!(modifiers & NSEventModifierFlagShift)) {
-        qkbd_state_key_event(kbd, Q_KEY_CODE_SHIFT, false);
-        qkbd_state_key_event(kbd, Q_KEY_CODE_SHIFT_R, false);
-    }
-    if (!(modifiers & NSEventModifierFlagControl)) {
-        qkbd_state_key_event(kbd, Q_KEY_CODE_CTRL, false);
-        qkbd_state_key_event(kbd, Q_KEY_CODE_CTRL_R, false);
-    }
-    if (!(modifiers & NSEventModifierFlagOption)) {
-        if ([self isSwapOptionCommandEnabled]) {
-            qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
-            qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
-        } else {
-            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
-            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
-        }
-    }
-    if (!(modifiers & NSEventModifierFlagCommand)) {
-        if ([self isSwapOptionCommandEnabled]) {
-            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
-            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
-        } else {
-            qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
-            qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
-        }
-    }
-
-    switch ([event type]) {
-        case NSEventTypeFlagsChanged:
-            switch ([event keyCode]) {
-                case kVK_Shift:
-                    if (!!(modifiers & NSEventModifierFlagShift)) {
-                        [self toggleKey:Q_KEY_CODE_SHIFT];
-                    }
-                    return true;
-
-                case kVK_RightShift:
-                    if (!!(modifiers & NSEventModifierFlagShift)) {
-                        [self toggleKey:Q_KEY_CODE_SHIFT_R];
-                    }
-                    return true;
-
-                case kVK_Control:
-                    if (!!(modifiers & NSEventModifierFlagControl)) {
-                        [self toggleKey:Q_KEY_CODE_CTRL];
-                    }
-                    return true;
-
-                case kVK_RightControl:
-                    if (!!(modifiers & NSEventModifierFlagControl)) {
-                        [self toggleKey:Q_KEY_CODE_CTRL_R];
-                    }
-                    return true;
-
-                case kVK_Option:
-                    if (!!(modifiers & NSEventModifierFlagOption)) {
-                        if ([self isSwapOptionCommandEnabled]) {
-                            [self toggleKey:Q_KEY_CODE_META_L];
-                        } else {
-                            [self toggleKey:Q_KEY_CODE_ALT];
-                        }
-                    }
-                    return true;
-
-                case kVK_RightOption:
-                    if (!!(modifiers & NSEventModifierFlagOption)) {
-                        if ([self isSwapOptionCommandEnabled]) {
-                            [self toggleKey:Q_KEY_CODE_META_R];
-                        } else {
-                            [self toggleKey:Q_KEY_CODE_ALT_R];
-                        }
-                    }
-                    return true;
-
-                /* Don't pass command key changes to guest unless mouse is grabbed */
-                case kVK_Command:
-                    if (isMouseGrabbed &&
-                        !!(modifiers & NSEventModifierFlagCommand)) {
-                        if ([self isSwapOptionCommandEnabled]) {
-                            [self toggleKey:Q_KEY_CODE_ALT];
-                        } else {
-                            [self toggleKey:Q_KEY_CODE_META_L];
-                        }
-                    }
-                    return true;
-
-                case kVK_RightCommand:
-                    if (isMouseGrabbed &&
-                        !!(modifiers & NSEventModifierFlagCommand)) {
-                        if ([self isSwapOptionCommandEnabled]) {
-                            [self toggleKey:Q_KEY_CODE_ALT_R];
-                        } else {
-                            [self toggleKey:Q_KEY_CODE_META_R];
-                        }
-                    }
-                    return true;
-
-                default:
-                    return true;
-            }
-        case NSEventTypeKeyDown:
-            keycode = cocoa_keycode_to_qemu([event keyCode]);
-
-            // forward command key combos to the host UI unless the mouse is grabbed
-            if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
-                return false;
-            }
-
-            // default
-
-            // handle control + alt Key Combos (ctrl+alt+[1..9,g] is reserved for QEMU)
-            if (([event modifierFlags] & NSEventModifierFlagControl) && ([event modifierFlags] & NSEventModifierFlagOption)) {
-                NSString *keychar = [event charactersIgnoringModifiers];
-                if ([keychar length] == 1) {
-                    char key = [keychar characterAtIndex:0];
-                    switch (key) {
-
-                        // enable graphic console
-                        case '1' ... '9':
-                            console_select(key - '0' - 1); /* ascii math */
-                            return true;
-
-                        // release the mouse grab
-                        case 'g':
-                            [self ungrabMouseLocked];
-                            return true;
-                    }
-                }
-            }
-
-            if (qemu_console_is_graphic(NULL)) {
-                qkbd_state_key_event(kbd, keycode, true);
-            } else {
-                [self handleMonitorInput: event];
-            }
-            return true;
-        case NSEventTypeKeyUp:
-            keycode = cocoa_keycode_to_qemu([event keyCode]);
-
-            // don't pass the guest a spurious key-up if we treated this
-            // command-key combo as a host UI action
-            if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
-                return true;
-            }
-
-            if (qemu_console_is_graphic(NULL)) {
-                qkbd_state_key_event(kbd, keycode, false);
-            }
-            return true;
-        case NSEventTypeScrollWheel:
-            /*
-             * Send wheel events to the guest regardless of window focus.
-             * This is in-line with standard Mac OS X UI behaviour.
-             */
-
-            /*
-             * When deltaY is zero, it means that this scrolling event was
-             * either horizontal, or so fine that it only appears in
-             * scrollingDeltaY. So we drop the event.
-             */
-            if ([event deltaY] != 0) {
-            /* Determine if this is a scroll up or scroll down event */
-                int buttons = ([event deltaY] > 0) ?
-                    INPUT_BUTTON_WHEEL_UP : INPUT_BUTTON_WHEEL_DOWN;
-                qemu_input_queue_btn(screen->dcl.con, buttons, true);
-                qemu_input_event_sync();
-                qemu_input_queue_btn(screen->dcl.con, buttons, false);
-                qemu_input_event_sync();
-            }
-            /*
-             * Since deltaY also reports scroll wheel events we prevent mouse
-             * movement code from executing.
-             */
-            return true;
-        default:
-            return false;
-    }
-}
-
-- (void) handleMouseEvent:(NSEvent *)event
-{
-    if (!isMouseGrabbed) {
-        return;
-    }
-
-    qemu_mutex_lock_iothread();
-
-    if (isAbsoluteEnabled) {
-        CGFloat d = (CGFloat)screen_height / [self frame].size.height;
-        NSPoint p = [event locationInWindow];
-        // Note that the origin for Cocoa mouse coords is bottom left, not top left.
-        qemu_input_queue_abs(screen->dcl.con, INPUT_AXIS_X, p.x * d, 0, screen_width);
-        qemu_input_queue_abs(screen->dcl.con, INPUT_AXIS_Y, screen_height - p.y * d, 0, screen_height);
-    } else {
-        CGFloat d = (CGFloat)screen_height / [self convertSizeToBacking:[self frame].size].height;
-        qemu_input_queue_rel(screen->dcl.con, INPUT_AXIS_X, [event deltaX] * d);
-        qemu_input_queue_rel(screen->dcl.con, INPUT_AXIS_Y, [event deltaY] * d);
-    }
-
-    qemu_input_event_sync();
-
-    qemu_mutex_unlock_iothread();
-}
-
-- (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool)down
-{
-    if (!isMouseGrabbed) {
-        return;
-    }
-
-    qemu_mutex_lock_iothread();
-    qemu_input_queue_btn(screen->dcl.con, button, down);
-    qemu_mutex_unlock_iothread();
-
-    [self handleMouseEvent:event];
-}
-
-- (void) mouseExited:(NSEvent *)event
-{
-    if (isAbsoluteEnabled && isMouseGrabbed) {
-        [self ungrabMouse];
-    }
-}
-
-- (void) mouseEntered:(NSEvent *)event
-{
-    if (isAbsoluteEnabled && !isMouseGrabbed) {
-        [self grabMouse];
-    }
-}
-
-- (void) mouseMoved:(NSEvent *)event
-{
-    [self handleMouseEvent:event];
-}
-
-- (void) mouseDown:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:true];
-}
-
-- (void) rightMouseDown:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:true];
-}
-
-- (void) otherMouseDown:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:true];
-}
-
-- (void) mouseDragged:(NSEvent *)event
-{
-    [self handleMouseEvent:event];
-}
-
-- (void) rightMouseDragged:(NSEvent *)event
-{
-    [self handleMouseEvent:event];
-}
-
-- (void) otherMouseDragged:(NSEvent *)event
-{
-    [self handleMouseEvent:event];
-}
-
-- (void) mouseUp:(NSEvent *)event
-{
-    if (!isMouseGrabbed) {
-        [self grabMouse];
-    }
-
-    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:false];
-}
-
-- (void) rightMouseUp:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:false];
-}
-
-- (void) otherMouseUp:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:false];
-}
-
-- (void) grabMouse
-{
-    COCOA_DEBUG("QemuCocoaView: grabMouse\n");
-
-    if (qemu_name)
-        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
-    else
-        [[self window] setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
-    [self hideCursor];
-    CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
-    isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
-}
-
-- (void) ungrabMouse
-{
-    qemu_mutex_lock_iothread();
-    [self ungrabMouseLocked];
-    qemu_mutex_unlock_iothread();
-}
-
-- (void) ungrabMouseLocked
-{
-    COCOA_DEBUG("QemuCocoaView: ungrabMouseLocked\n");
-
-    if (qemu_name)
-        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
-    else
-        [[self window] setTitle:@"QEMU"];
-    [self unhideCursor];
-    CGAssociateMouseAndMouseCursorPosition(TRUE);
-    isMouseGrabbed = FALSE;
-    [self raiseAllButtonsLocked];
-}
-
-- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
-    isAbsoluteEnabled = tIsAbsoluteEnabled;
-    if (isMouseGrabbed) {
-        CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
-    }
-}
-- (BOOL) isMouseGrabbed {return isMouseGrabbed;}
-- (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
-- (BOOL) isSwapOptionCommandEnabled {return screen->swap_option_command;}
-
-- (void) raiseAllButtonsLocked
-{
-    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_LEFT, false);
-    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_RIGHT, false);
-    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_MIDDLE, false);
-}
-
-- (void) setNeedsDisplayForCursorX:(int)x
-                                 y:(int)y
-                             width:(int)width
-                            height:(int)height
-                      screenHeight:(int)given_screen_height
-{
-    CGRect clip_rect = compute_cursor_clip_rect(given_screen_height, x, y,
-                                                width, height);
-    CGRect draw_rect = [self convertCursorClipRectToDraw:clip_rect
-                                            screenHeight:given_screen_height
-                                                  mouseX:x
-                                                  mouseY:y];
-    [self setNeedsDisplayInRect:draw_rect];
-}
-
-/* Displays the word pause on the screen */
-- (void)displayPause
-{
-    /* Coordinates have to be calculated each time because the window can change its size */
-    int xCoord, yCoord, width, height;
-    xCoord = ([[self window] frame].size.width - [pauseLabel frame].size.width)/2;
-    yCoord = [[self window] frame].size.height - [pauseLabel frame].size.height - ([pauseLabel frame].size.height * .5);
-    width = [pauseLabel frame].size.width;
-    height = [pauseLabel frame].size.height;
-    [pauseLabel setFrame: NSMakeRect(xCoord, yCoord, width, height)];
-    [self addSubview: pauseLabel];
-}
-
-/* Removes the word pause from the screen */
-- (void)removePause
-{
-    [pauseLabel removeFromSuperview];
-}
-@end
-#endif
-
-#ifdef UI_COCOA_APP_CONTROLLER
-static void create_initial_menus(void)
-{
-    // Add menus
-    NSMenu      *menu;
-    NSMenuItem  *menuItem;
-
-    [NSApp setMainMenu:[[NSMenu alloc] init]];
-
-    // Application menu
-    menu = [[NSMenu alloc] initWithTitle:@""];
-    [menu addItemWithTitle:@"About QEMU" action:@selector(do_about_menu_item:) keyEquivalent:@""]; // About QEMU
-    [menu addItem:[NSMenuItem separatorItem]]; //Separator
-    [menu addItemWithTitle:@"Hide QEMU" action:@selector(hide:) keyEquivalent:@"h"]; //Hide QEMU
-    menuItem = (NSMenuItem *)[menu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"]; // Hide Others
-    [menuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];
-    [menu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""]; // Show All
-    [menu addItem:[NSMenuItem separatorItem]]; //Separator
-    [menu addItemWithTitle:@"Quit QEMU" action:@selector(terminate:) keyEquivalent:@"q"];
-    menuItem = [[NSMenuItem alloc] initWithTitle:@"Apple" action:nil keyEquivalent:@""];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-    [NSApp performSelector:@selector(setAppleMenu:) withObject:menu]; // Workaround (this method is private since 10.4+)
-
-    // Machine menu
-    menu = [[NSMenu alloc] initWithTitle: @"Machine"];
-    [menu setAutoenablesItems: NO];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Pause" action: @selector(pauseQEMU:) keyEquivalent: @""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Resume" action: @selector(resumeQEMU:) keyEquivalent: @""] autorelease];
-    [menu addItem: menuItem];
-    [menuItem setEnabled: NO];
-    [menu addItem: [NSMenuItem separatorItem]];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Reset" action: @selector(restartQEMU:) keyEquivalent: @""] autorelease]];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Power Down" action: @selector(powerDownQEMU:) keyEquivalent: @""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Machine" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // View menu
-    menu = [[NSMenu alloc] initWithTitle:@"View"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Enter Fullscreen" action:@selector(doToggleFullScreen:) keyEquivalent:@"f"] autorelease]]; // Fullscreen
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Zoom To Fit" action:@selector(zoomToFit:) keyEquivalent:@""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"View" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // Speed menu
-    menu = [[NSMenu alloc] initWithTitle:@"Speed"];
-
-    // Add the rest of the Speed menu items
-    int p, percentage, throttle_pct;
-    for (p = 10; p >= 0; p--)
-    {
-        percentage = p * 10 > 1 ? p * 10 : 1; // prevent a 0% menu item
-
-        menuItem = [[[NSMenuItem alloc]
-                   initWithTitle: [NSString stringWithFormat: @"%d%%", percentage] action:@selector(adjustSpeed:) keyEquivalent:@""] autorelease];
-
-        if (percentage == 100) {
-            [menuItem setState: NSControlStateValueOn];
-        }
-
-        /* Calculate the throttle percentage */
-        throttle_pct = -1 * percentage + 100;
-
-        [menuItem setTag: throttle_pct];
-        [menu addItem: menuItem];
-    }
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Speed" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // Window menu
-    menu = [[NSMenu alloc] initWithTitle:@"Window"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"] autorelease]]; // Miniaturize
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-    [NSApp setWindowsMenu:menu];
-
-    // Help menu
-    menu = [[NSMenu alloc] initWithTitle:@"Help"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"QEMU Documentation" action:@selector(showQEMUDoc:) keyEquivalent:@"?"] autorelease]]; // QEMU Help
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-}
-
-/* Returns a name for a given console */
-static NSString * getConsoleName(QemuConsole * console)
-{
-    return [NSString stringWithFormat: @"%s", qemu_console_get_label(console)];
-}
-
-/* Add an entry to the View menu for each console */
-static void add_console_menu_entries(void)
-{
-    NSMenu *menu;
-    NSMenuItem *menuItem;
-    int index = 0;
-
-    menu = [[[NSApp mainMenu] itemWithTitle:@"View"] submenu];
-
-    [menu addItem:[NSMenuItem separatorItem]];
-
-    while (qemu_console_lookup_by_index(index) != NULL) {
-        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(qemu_console_lookup_by_index(index))
-                                               action: @selector(displayConsole:) keyEquivalent: @""] autorelease];
-        [menuItem setTag: index];
-        [menu addItem: menuItem];
-        index++;
-    }
-}
-
-/* Make menu items for all removable devices.
- * Each device is given an 'Eject' and 'Change' menu item.
- */
-static void addRemovableDevicesMenuItems(void)
-{
-    NSMenu *menu;
-    NSMenuItem *menuItem;
-    BlockInfoList *currentDevice, *pointerToFree;
-    NSString *deviceName;
-
-    currentDevice = qmp_query_block(NULL);
-    pointerToFree = currentDevice;
-    if(currentDevice == NULL) {
-        NSBeep();
-        QEMU_Alert(@"Failed to query for block devices!");
-        return;
-    }
-
-    menu = [[[NSApp mainMenu] itemWithTitle:@"Machine"] submenu];
-
-    // Add a separator between related groups of menu items
-    [menu addItem:[NSMenuItem separatorItem]];
-
-    // Set the attributes to the "Removable Media" menu item
-    NSString *titleString = @"Removable Media";
-    NSMutableAttributedString *attString=[[NSMutableAttributedString alloc] initWithString:titleString];
-    NSColor *newColor = [NSColor blackColor];
-    NSFontManager *fontManager = [NSFontManager sharedFontManager];
-    NSFont *font = [fontManager fontWithFamily:@"Helvetica"
-                                          traits:NSBoldFontMask|NSItalicFontMask
-                                          weight:0
-                                            size:14];
-    [attString addAttribute:NSFontAttributeName value:font range:NSMakeRange(0, [titleString length])];
-    [attString addAttribute:NSForegroundColorAttributeName value:newColor range:NSMakeRange(0, [titleString length])];
-    [attString addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInt: 1] range:NSMakeRange(0, [titleString length])];
-
-    // Add the "Removable Media" menu item
-    menuItem = [NSMenuItem new];
-    [menuItem setAttributedTitle: attString];
-    [menuItem setEnabled: NO];
-    [menu addItem: menuItem];
-
-    /* Loop through all the block devices in the emulator */
-    while (currentDevice) {
-        deviceName = [[NSString stringWithFormat: @"%s", currentDevice->value->device] retain];
-
-        if(currentDevice->value->removable) {
-            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Change %s...", currentDevice->value->device]
-                                                  action: @selector(changeDeviceMedia:)
-                                           keyEquivalent: @""];
-            [menu addItem: menuItem];
-            [menuItem setRepresentedObject: deviceName];
-            [menuItem autorelease];
-
-            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Eject %s", currentDevice->value->device]
-                                                  action: @selector(ejectDeviceMedia:)
-                                           keyEquivalent: @""];
-            [menu addItem: menuItem];
-            [menuItem setRepresentedObject: deviceName];
-            [menuItem autorelease];
-        }
-        currentDevice = currentDevice->next;
-    }
-    qapi_free_BlockInfoList(pointerToFree);
-}
-
-@implementation QemuCocoaAppController
-- (id) initWithStartedSem:(QemuSemaphore *)given_started_sem
-                   screen:(QEMUScreen *)screen
-{
-    COCOA_DEBUG("%s\n", __func__);
-
-    self = [super init];
-    if (self) {
-
-        started_sem = given_started_sem;
-
-        create_initial_menus();
-
-        /*
-         * Create the menu entries which depend on QEMU state (for consoles
-         * and removeable devices). These make calls back into QEMU functions,
-         * which is OK because at this point we know that the second thread
-         * holds the iothread lock and is synchronously waiting for us to
-         * finish.
-         */
-        add_console_menu_entries();
-        addRemovableDevicesMenuItems();
-
-        // create a view and add it to the window
-        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)
-                                                  screen:screen];
-        if(!cocoaView) {
-            error_report("(cocoa) can't create a view");
-            exit(1);
-        }
-
-        // create a window
-        NSWindow *normalWindow = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
-            styleMask:NSWindowStyleMaskTitled|NSWindowStyleMaskMiniaturizable|NSWindowStyleMaskClosable
-            backing:NSBackingStoreBuffered defer:NO];
-        if(!normalWindow) {
-            error_report("(cocoa) can't create window");
-            exit(1);
-        }
-        [normalWindow setAcceptsMouseMovedEvents:YES];
-        [normalWindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
-        [normalWindow setTitle:qemu_name ? [NSString stringWithFormat:@"QEMU %s", qemu_name] : @"QEMU"];
-        [normalWindow setContentView:cocoaView];
-        [normalWindow makeKeyAndOrderFront:self];
-        [normalWindow center];
-        [normalWindow setDelegate: self];
-        [normalWindow release];
-
-        // set the supported image file types that can be opened
-        supportedImageFileTypes = [NSArray arrayWithObjects: @"img", @"iso", @"dmg",
-                                 @"qcow", @"qcow2", @"cloop", @"vmdk", @"cdr",
-                                  @"toast", nil];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-    COCOA_DEBUG("QemuCocoaAppController: dealloc\n");
-
-    if (cocoaView)
-        [cocoaView release];
-    [super dealloc];
-}
-
-- (void)applicationDidFinishLaunching: (NSNotification *) note
-{
-    COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
-    /* Tell cocoa_display_init to proceed */
-    qemu_sem_post(started_sem);
-}
-
-- (void)applicationWillTerminate:(NSNotification *)aNotification
-{
-    COCOA_DEBUG("QemuCocoaAppController: applicationWillTerminate\n");
-
-    qemu_system_shutdown_request(SHUTDOWN_CAUSE_HOST_UI);
-
-    /*
-     * Sleep here, because returning will cause OSX to kill us
-     * immediately; the QEMU main loop will handle the shutdown
-     * request and terminate the process.
-     */
-    [NSThread sleepForTimeInterval:INFINITY];
-}
-
-- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)theApplication
-{
-    return YES;
-}
-
-- (NSApplicationTerminateReply)applicationShouldTerminate:
-                                                         (NSApplication *)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: applicationShouldTerminate\n");
-    return [self verifyQuit];
-}
-
-- (void)windowDidChangeScreen:(NSNotification *)notification
-{
-    [cocoaView updateUIInfo];
-}
-
-- (void)windowDidEnterFullScreen:(NSNotification *)notification
-{
-    [cocoaView grabMouse];
-}
-
-- (void)windowDidExitFullScreen:(NSNotification *)notification
-{
-    [cocoaView resizeWindow];
-    [cocoaView ungrabMouse];
-}
-
-- (void)windowDidResize:(NSNotification *)notification
-{
-    [cocoaView frameUpdated];
-}
-
-/* Called when the user clicks on a window's close button */
-- (BOOL)windowShouldClose:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: windowShouldClose\n");
-    [NSApp terminate: sender];
-    /* If the user allows the application to quit then the call to
-     * NSApp terminate will never return. If we get here then the user
-     * cancelled the quit, so we should return NO to not permit the
-     * closing of this window.
-     */
-    return NO;
-}
-
-- (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
-{
-    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
-        return [cocoaView computeUnzoomedSize];
-    }
-
-    return [cocoaView fixZoomedFullScreenSize:proposedSize];
-}
-
-- (NSApplicationPresentationOptions) window:(NSWindow *)window
-                                     willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions;
-
-{
-    return (proposedOptions & ~(NSApplicationPresentationAutoHideDock | NSApplicationPresentationAutoHideMenuBar)) |
-           NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar;
-}
-
-/* We abstract the method called by the Enter Fullscreen menu item
- * because Mac OS 10.7 and higher disables it. This is because of the
- * menu item's old selector's name toggleFullScreen:
- */
-- (void) doToggleFullScreen:(id)sender
-{
-    [[cocoaView window] toggleFullScreen:sender];
-}
-
-/* Tries to find then open the specified filename */
-- (void) openDocumentation: (NSString *) filename
-{
-    /* Where to look for local files */
-    NSString *path_array[] = {@"../share/doc/qemu/", @"../doc/qemu/", @"docs/"};
-    NSString *full_file_path;
-    NSURL *full_file_url;
-
-    /* iterate thru the possible paths until the file is found */
-    int index;
-    for (index = 0; index < ARRAY_SIZE(path_array); index++) {
-        full_file_path = [[NSBundle mainBundle] executablePath];
-        full_file_path = [full_file_path stringByDeletingLastPathComponent];
-        full_file_path = [NSString stringWithFormat: @"%@/%@%@", full_file_path,
-                          path_array[index], filename];
-        full_file_url = [NSURL fileURLWithPath: full_file_path
-                                   isDirectory: false];
-        if ([[NSWorkspace sharedWorkspace] openURL: full_file_url] == YES) {
-            return;
-        }
-    }
-
-    /* If none of the paths opened a file */
-    NSBeep();
-    QEMU_Alert(@"Failed to open file");
-}
-
-- (void)showQEMUDoc:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: showQEMUDoc\n");
-
-    [self openDocumentation: @"index.html"];
-}
-
-/* Toggles the flag which stretches video to fit host window size */
-- (void)zoomToFit:(id) sender
-{
-    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
-        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] | NSWindowStyleMaskResizable];
-        [sender setState: NSControlStateValueOn];
-    } else {
-        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] & ~NSWindowStyleMaskResizable];
-        [cocoaView resizeWindow];
-        [sender setState: NSControlStateValueOff];
-    }
-}
-
-/* Displays the console on the screen */
-- (void)displayConsole:(id)sender
-{
-    with_iothread_lock(^{
-        console_select([sender tag]);
-    });
-}
-
-/* Pause the guest */
-- (void)pauseQEMU:(id)sender
-{
-    with_iothread_lock(^{
-        qmp_stop(NULL);
-    });
-    [sender setEnabled: NO];
-    [[[sender menu] itemWithTitle: @"Resume"] setEnabled: YES];
-    [cocoaView displayPause];
-}
-
-/* Resume running the guest operating system */
-- (void)resumeQEMU:(id) sender
-{
-    with_iothread_lock(^{
-        qmp_cont(NULL);
-    });
-    [sender setEnabled: NO];
-    [[[sender menu] itemWithTitle: @"Pause"] setEnabled: YES];
-    [cocoaView removePause];
-}
-
-/* Restarts QEMU */
-- (void)restartQEMU:(id)sender
-{
-    with_iothread_lock(^{
-        qmp_system_reset(NULL);
-    });
-}
-
-/* Powers down QEMU */
-- (void)powerDownQEMU:(id)sender
-{
-    with_iothread_lock(^{
-        qmp_system_powerdown(NULL);
-    });
-}
-
-/* Ejects the media.
- * Uses sender's tag to figure out the device to eject.
- */
-- (void)ejectDeviceMedia:(id)sender
-{
-    NSString * drive;
-    drive = [sender representedObject];
-    if(drive == nil) {
-        NSBeep();
-        QEMU_Alert(@"Failed to find drive to eject!");
-        return;
-    }
-
-    __block Error *err = NULL;
-    with_iothread_lock(^{
-        qmp_eject(true, [drive cStringUsingEncoding: NSASCIIStringEncoding],
-                  false, NULL, false, false, &err);
-    });
-    handleAnyDeviceErrors(err);
-}
-
-/* Displays a dialog box asking the user to select an image file to load.
- * Uses sender's represented object value to figure out which drive to use.
- */
-- (void)changeDeviceMedia:(id)sender
-{
-    /* Find the drive name */
-    NSString * drive;
-    drive = [sender representedObject];
-    if(drive == nil) {
-        NSBeep();
-        QEMU_Alert(@"Could not find drive!");
-        return;
-    }
-
-    /* Display the file open dialog */
-    NSOpenPanel * openPanel;
-    openPanel = [NSOpenPanel openPanel];
-    [openPanel setCanChooseFiles: YES];
-    [openPanel setAllowsMultipleSelection: NO];
-    [openPanel setAllowedFileTypes: supportedImageFileTypes];
-    if([openPanel runModal] == NSModalResponseOK) {
-        NSString * file = [[[openPanel URLs] objectAtIndex: 0] path];
-        if(file == nil) {
-            NSBeep();
-            QEMU_Alert(@"Failed to convert URL to file path!");
-            return;
-        }
-
-        __block Error *err = NULL;
-        with_iothread_lock(^{
-            qmp_blockdev_change_medium(true,
-                                       [drive cStringUsingEncoding:
-                                                  NSASCIIStringEncoding],
-                                       false, NULL,
-                                       [file cStringUsingEncoding:
-                                                 NSASCIIStringEncoding],
-                                       true, "raw",
-                                       false, 0,
-                                       &err);
-        });
-        handleAnyDeviceErrors(err);
-    }
-}
-
-/* Verifies if the user really wants to quit */
-- (BOOL)verifyQuit
-{
-    NSAlert *alert = [NSAlert new];
-    [alert autorelease];
-    [alert setMessageText: @"Are you sure you want to quit QEMU?"];
-    [alert addButtonWithTitle: @"Cancel"];
-    [alert addButtonWithTitle: @"Quit"];
-    if([alert runModal] == NSAlertSecondButtonReturn) {
-        return YES;
-    } else {
-        return NO;
-    }
-}
-
-/* The action method for the About menu item */
-- (IBAction) do_about_menu_item: (id) sender
-{
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-    char *icon_path_c = get_relocated_path(CONFIG_QEMU_ICONDIR "/hicolor/512x512/apps/qemu.png");
-    NSString *icon_path = [NSString stringWithUTF8String:icon_path_c];
-    g_free(icon_path_c);
-    NSImage *icon = [[NSImage alloc] initWithContentsOfFile:icon_path];
-    NSString *version = @"QEMU emulator version " QEMU_FULL_VERSION;
-    NSString *copyright = @QEMU_COPYRIGHT;
-    NSDictionary *options;
-    if (icon) {
-        options = @{
-            NSAboutPanelOptionApplicationIcon : icon,
-            NSAboutPanelOptionApplicationVersion : version,
-            @"Copyright" : copyright,
-        };
-        [icon release];
-    } else {
-        options = @{
-            NSAboutPanelOptionApplicationVersion : version,
-            @"Copyright" : copyright,
-        };
-    }
-    [NSApp orderFrontStandardAboutPanelWithOptions:options];
-    [pool release];
-}
-
-/* Used by the Speed menu items */
-- (void)adjustSpeed:(id)sender
-{
-    int throttle_pct; /* throttle percentage */
-    NSMenu *menu;
-
-    menu = [sender menu];
-    if (menu != nil)
-    {
-        /* Unselect the currently selected item */
-        for (NSMenuItem *item in [menu itemArray]) {
-            if (item.state == NSControlStateValueOn) {
-                [item setState: NSControlStateValueOff];
-                break;
-            }
-        }
-    }
-
-    // check the menu item
-    [sender setState: NSControlStateValueOn];
-
-    // get the throttle percentage
-    throttle_pct = [sender tag];
-
-    with_iothread_lock(^{
-        cpu_throttle_set(throttle_pct);
-    });
-    COCOA_DEBUG("cpu throttling at %d%c\n", cpu_throttle_get_percentage(), '%');
-}
-
-- (QemuCocoaView *)cocoaView
-{
-    return cocoaView;
-}
-
-@end
-#endif
-
-#ifdef UI_COCOA_MAIN
-@interface QemuApplication : NSApplication
-@end
-
-@implementation QemuApplication
-- (void)sendEvent:(NSEvent *)event
-{
-    COCOA_DEBUG("QemuApplication: sendEvent\n");
-    if (![[appController cocoaView] handleEvent:event]) {
-        [super sendEvent: event];
-    }
-}
-@end
-#endif
-
-#ifdef UI_COCOA_PASTEBOARD_TYPE_OWNER
-@implementation QemuCocoaPasteboardTypeOwner
-
-- (id)initWith:(QemuCocoaClipboard *)aCb
-{
-    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
-
-    self = [super init];
-    if (self) {
-        cb = aCb;
-    }
-    return self;
-}
-
-- (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
-{
-    if (type != NSPasteboardTypeString) {
-        return;
-    }
-
-    qemu_mutex_lock_iothread();
-
-    QemuClipboardInfo *info = qemu_clipboard_info_ref(cb->info);
-    qemu_event_reset(&cb->event);
-    qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
-
-    while (info == cb->info &&
-           info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
-           info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
-        qemu_mutex_unlock_iothread();
-        qemu_event_wait(&cb->event);
-        qemu_mutex_lock_iothread();
-    }
-
-    if (info == cb->info) {
-        NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
-                                       length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
-        [sender setData:data forType:NSPasteboardTypeString];
-        [data release];
-    }
-
-    qemu_clipboard_info_unref(info);
-
-    qemu_mutex_unlock_iothread();
-}
-
-@end
-#endif
-
-#ifdef UI_COCOA_MAIN
-static void cocoa_clipboard_notify(Notifier *notifier, void *data);
-static void cocoa_clipboard_request(QemuClipboardInfo *info,
-                                    QemuClipboardType type);
-
-static QemuClipboardPeer cbpeer = {
-    .name = "cocoa",
-    .update = { .notify = cocoa_clipboard_notify },
-    .request = cocoa_clipboard_request
-};
-
-static void cocoa_clipboard_notify(Notifier *notifier, void *data)
-{
-    QemuClipboardInfo *info = data;
-
-    if (info->owner == &cbpeer || info->selection != QEMU_CLIPBOARD_SELECTION_CLIPBOARD) {
-        return;
-    }
-
-    if (info != qemucb.info) {
-        NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-        qemu_clipboard_info_unref(qemucb.info);
-        qemucb.info = qemu_clipboard_info_ref(info);
-        cbchangecount = [[NSPasteboard generalPasteboard] declareTypes:@[NSPasteboardTypeString] owner:cbowner];
-        [pool release];
-    }
-
-    qemu_event_set(&qemucb.event);
-}
-
-static void cocoa_clipboard_request(QemuClipboardInfo *info,
-                                    QemuClipboardType type)
-{
-    NSData *text;
-
-    switch (type) {
-    case QEMU_CLIPBOARD_TYPE_TEXT:
-        text = [[NSPasteboard generalPasteboard] dataForType:NSPasteboardTypeString];
-        if (text) {
-            qemu_clipboard_set_data(&cbpeer, info, type,
-                                    [text length], [text bytes], true);
-            [text release];
-        }
-        break;
-    default:
-        break;
-    }
-}
-
-/*
- * The startup process for the OSX/Cocoa UI is complicated, because
- * OSX insists that the UI runs on the initial main thread, and so we
- * need to start a second thread which runs the vl.c qemu_main():
- *
- * Initial thread:                    2nd thread:
- * in main():
- *  create qemu-main thread
- *  wait on display_init semaphore
- *                                    call qemu_main()
- *                                    ...
- *                                    in cocoa_display_init():
- *                                     post the display_init semaphore
- *                                     wait on app_started semaphore
- *  create application, menus, etc
- *  enter OSX run loop
- * in applicationDidFinishLaunching:
- *  post app_started semaphore
- *                                     tell main thread to fullscreen if needed
- *                                    [...]
- *                                    run qemu main-loop
- *
- * We do this in two stages so that we don't do the creation of the
- * GUI application menus and so on for command line options like --help
- * where we want to just print text to stdout and exit immediately.
- */
-
-static void *call_qemu_main(void *opaque)
-{
-    int status;
-
-    COCOA_DEBUG("Second thread: calling qemu_main()\n");
-    status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
-    COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
-    [cbowner release];
-    CGImageRelease(screen.cursor_cgimage);
-#ifdef CONFIG_OPENGL
-    g_free(dgs);
-    qemu_gl_fini_shader(gls);
-    if (view_ctx) {
-        cocoa_gl_destroy_context(NULL, view_ctx);
-    }
-    if (appController) {
-        [appController release];
-    }
-#endif
-    exit(status);
-}
-
-int main (int argc, char **argv) {
-    QemuThread thread;
-
-    COCOA_DEBUG("Entered main()\n");
-    gArgc = argc;
-    gArgv = argv;
-
-    qemu_sem_init(&display_init_sem, 0);
-    qemu_sem_init(&app_started_sem, 0);
-
-    qemu_thread_create(&thread, "qemu_main", call_qemu_main,
-                       NULL, QEMU_THREAD_DETACHED);
-
-    qemu_mutex_init(&screen.draw_mutex);
-
-    COCOA_DEBUG("Main thread: waiting for display_init_sem\n");
-    qemu_sem_wait(&display_init_sem);
-    COCOA_DEBUG("Main thread: initializing app\n");
-
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-
-    // Pull this console process up to being a fully-fledged graphical
-    // app with a menubar and Dock icon
-    ProcessSerialNumber psn = { 0, kCurrentProcess };
-    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
-
-    [QemuApplication sharedApplication];
-
-    // Create an Application controller
-    appController = [[QemuCocoaAppController alloc] initWithStartedSem:&app_started_sem
-                                                                screen:&screen];
-    [NSApp setDelegate:appController];
-
-    // Start the main event loop
-    COCOA_DEBUG("Main thread: entering OSX run loop\n");
-    [NSApp run];
-    COCOA_DEBUG("Main thread: left OSX run loop, exiting\n");
-
-    [pool release];
-
-    return 0;
-}
-
-
-
-#pragma mark qemu
-static void cocoa_update(DisplayChangeListener *dcl,
-                         int x, int y, int w, int h)
-{
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-    DisplaySurface *updated = screen.surface;
-
-    COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
-
-    dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&screen.draw_mutex);
-        if (updated != screen.surface) {
-            qemu_mutex_unlock(&screen.draw_mutex);
-            return;
-        }
-        int full_height = surface_height(screen.surface);
-        qemu_mutex_unlock(&screen.draw_mutex);
-
-        CGFloat d = [[appController cocoaView] frame].size.height / full_height;
-        NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
-        [[appController cocoaView] setNeedsDisplayInRect:rect];
-    });
-
-    [pool release];
-}
-
-static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *new_surface)
-{
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-    static bool updating_screen;
-
-    COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
-
-    [[appController cocoaView] updateUIInfo];
-
-    qemu_mutex_lock(&screen.draw_mutex);
-    screen.surface = new_surface;
-    if (!updating_screen) {
-        updating_screen = true;
-
-        dispatch_async(dispatch_get_main_queue(), ^{
-            qemu_mutex_lock(&screen.draw_mutex);
-            updating_screen = false;
-            int w = surface_width(screen.surface);
-            int h = surface_height(screen.surface);
-            qemu_mutex_unlock(&screen.draw_mutex);
-
-            [[appController cocoaView] updateScreenWidth:w height:h];
-        });
-    }
-    qemu_mutex_unlock(&screen.draw_mutex);
-    [pool release];
-}
-
-static void cocoa_refresh(DisplayChangeListener *dcl)
-{
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-
-    COCOA_DEBUG("qemu_cocoa: cocoa_refresh\n");
-    graphic_hw_update(NULL);
-
-    if (qemu_input_is_absolute()) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            if (![[appController cocoaView] isAbsoluteEnabled]) {
-                if ([[appController cocoaView] isMouseGrabbed]) {
-                    [[appController cocoaView] ungrabMouse];
-                }
-            }
-            [[appController cocoaView] setAbsoluteEnabled:YES];
-        });
-    }
-
-    if (cbchangecount != [[NSPasteboard generalPasteboard] changeCount]) {
-        qemu_clipboard_info_unref(qemucb.info);
-        qemucb.info = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
-        if ([[NSPasteboard generalPasteboard] availableTypeFromArray:@[NSPasteboardTypeString]]) {
-            qemucb.info->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
-        }
-        qemu_clipboard_update(qemucb.info);
-        cbchangecount = [[NSPasteboard generalPasteboard] changeCount];
-        qemu_event_set(&qemucb.event);
-    }
-
-    [pool release];
-}
-
-static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
-{
-    qemu_mutex_lock(&screen.draw_mutex);
-    int full_height = surface_height(screen.surface);
-    size_t cursor_width = CGImageGetWidth(screen.cursor_cgimage);
-    size_t cursor_height = CGImageGetHeight(screen.cursor_cgimage);
-    int old_x = screen.mouse_x;
-    int old_y = screen.mouse_y;
-    int old_on = screen.mouse_on;
-    screen.mouse_x = x;
-    screen.mouse_y = y;
-    screen.mouse_on = on;
-    qemu_mutex_unlock(&screen.draw_mutex);
-
-    dispatch_async(dispatch_get_main_queue(), ^{
-        if (old_on) {
-            [[appController cocoaView] setNeedsDisplayForCursorX:old_x
-                                                               y:old_y
-                                                           width:cursor_width
-                                                           height:cursor_height
-                                                     screenHeight:full_height];
-        }
-
-        if (on) {
-            [[appController cocoaView] setNeedsDisplayForCursorX:x
-                                                               y:y
-                                                           width:cursor_width
-                                                           height:cursor_height
-                                                     screenHeight:full_height];
-        }
-    });
-}
-
-static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
-{
-    int width = cursor->width;
-    int height = cursor->height;
-
-    CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
-        NULL,
-        cursor->data,
-        width * height * 4,
-        NULL
-    );
-
-    CGImageRef imageRef = CGImageCreate(
-        width, //width
-        height, //height
-        8, //bitsPerComponent
-        32, //bitsPerPixel
-        width * 4, //bytesPerRow
-        CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
-        kCGBitmapByteOrder32Little | kCGImageAlphaFirst, //bitmapInfo
-        dataProviderRef, //provider
-        NULL, //decode
-        0, //interpolate
-        kCGRenderingIntentDefault //intent
-    );
-
-    qemu_mutex_lock(&screen.draw_mutex);
-    int full_height = surface_height(screen.surface);
-    int x = screen.mouse_x;
-    int y = screen.mouse_y;
-    int on = screen.mouse_on;
-    size_t old_width;
-    size_t old_height;
-    if (screen.cursor_cgimage) {
-        old_width = CGImageGetWidth(screen.cursor_cgimage);
-        old_height = CGImageGetHeight(screen.cursor_cgimage);
-    } else {
-        old_width = 0;
-        old_height = 0;
-    }
-    screen.cursor_cgimage = CGImageCreateCopy(imageRef);
-    qemu_mutex_unlock(&screen.draw_mutex);
-
-    CGImageRelease(imageRef);
-    CGDataProviderRelease(dataProviderRef);
-
-    if (on) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            CGFloat d = [[appController cocoaView] frame].size.height / full_height;
-            NSRect rect;
-
-            rect.origin.x = d * x;
-            rect.origin.y = d * (full_height - y - old_height);
-            rect.size.width = d * old_width;
-            rect.size.height = d * old_height;
-            [[appController cocoaView] setNeedsDisplayInRect:rect];
-
-            rect.origin.x = d * x;
-            rect.origin.y = d * (full_height - y - height);
-            rect.size.width = d * width;
-            rect.size.height = d * height;
-            [[appController cocoaView] setNeedsDisplayInRect:rect];
-       });
-    }
-}
-
-static const DisplayChangeListenerOps dcl_ops = {
-    .dpy_name          = "cocoa",
-    .dpy_gfx_update = cocoa_update,
-    .dpy_gfx_switch = cocoa_switch,
-    .dpy_refresh = cocoa_refresh,
-    .dpy_mouse_set = cocoa_mouse_set,
-    .dpy_cursor_define = cocoa_cursor_define,
-};
-
-#ifdef CONFIG_OPENGL
-
-static void with_view_ctx(CodeBlock block)
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
-        block();
-        return;
-    }
-#endif
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-    [(NSOpenGLContext *)view_ctx lock];
-    [(NSOpenGLContext *)view_ctx makeCurrentContext];
-    block();
-    [(NSOpenGLContext *)view_ctx unlock];
-#pragma clang diagnostic pop
-}
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-static NSOpenGLContext *cocoa_gl_create_context_ns(NSOpenGLContext *share_context,
-                                                   int bpp)
-{
-    NSOpenGLPixelFormatAttribute attributes[] = {
-        NSOpenGLPFAOpenGLProfile,
-        NSOpenGLProfileVersion4_1Core,
-        NSOpenGLPFAColorSize,
-        bpp,
-        NSOpenGLPFADoubleBuffer,
-        0,
-    };
-    NSOpenGLPixelFormat *format;
-    NSOpenGLContext *ctx;
-
-    format = [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
-    ctx = [[NSOpenGLContext alloc] initWithFormat:format shareContext:share_context];
-    [format release];
-
-    [ctx retain];
-    dispatch_async(dispatch_get_main_queue(), ^{
-        [ctx setView:[appController cocoaView]];
-        [ctx release];
-    });
-
-    return (QEMUGLContext)ctx;
-}
-#pragma clang diagnostic pop
-
-static int cocoa_gl_make_context_current(void *dg, QEMUGLContext ctx)
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        EGLSurface surface = ctx == EGL_NO_CONTEXT ? EGL_NO_SURFACE : egl_surface;
-        return eglMakeCurrent(qemu_egl_display, surface, surface, ctx);
-    }
-#endif
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-    if (ctx) {
-        [(NSOpenGLContext *)ctx makeCurrentContext];
-    } else {
-        [NSOpenGLContext clearCurrentContext];
-    }
-#pragma clang diagnostic pop
-
-    return 0;
-}
-
-static QEMUGLContext cocoa_gl_create_context(void *dg, QEMUGLParams *params)
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
-        return qemu_egl_create_context(dg, params);
-    }
-#endif
-
-    int bpp = PIXMAN_FORMAT_BPP(surface_format(screen.surface));
-    return cocoa_gl_create_context_ns(view_ctx, bpp);
-}
-
-static void cocoa_gl_destroy_context(void *dg, QEMUGLContext ctx)
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        eglDestroyContext(qemu_egl_display, ctx);
-        return;
-    }
-#endif
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-    [(NSOpenGLContext *)ctx release];
-#pragma clang diagnostic pop
-}
-
-static void cocoa_gl_flush()
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        eglSwapBuffers(qemu_egl_display, egl_surface);
-        return;
-    }
-#endif
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-    [[NSOpenGLContext currentContext] flushBuffer];
-
-    dispatch_async(dispatch_get_main_queue(), ^{
-        [(NSOpenGLContext *)view_ctx update];
-    });
-#pragma clang diagnostic pop
-}
-
-static void cocoa_scanout_disable(DisplayGL *dg)
-{
-    if (!dg->scanout_id) {
-        return;
-    }
-
-    dg->scanout_id = 0;
-
-    if (screen.surface) {
-        surface_gl_destroy_texture(gls, screen.surface);
-        surface_gl_create_texture(gls, screen.surface);
-    }
-}
-
-static void cocoa_gl_render_cursor()
-{
-    if (!screen.mouse_on) {
-        return;
-    }
-
-    QemuCocoaView *cocoaView = [appController cocoaView];
-    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
-    int full_height = surface_height(screen.surface);
-    CGFloat d = size.height / full_height;
-
-    glViewport(
-        d * screen.mouse_x,
-        d * (full_height - screen.mouse_y - cursor_texture_height),
-        d * cursor_texture_width,
-        d * cursor_texture_height
-    );
-    glBindTexture(GL_TEXTURE_2D, cursor_texture);
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    qemu_gl_run_texture_blit(gls, false);
-    glDisable(GL_BLEND);
-}
-
-static void cocoa_gl_render_surface(DisplayGL *dg)
-{
-    cocoa_scanout_disable(dg);
-
-    QemuCocoaView *cocoaView = [appController cocoaView];
-    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
-
-    surface_gl_setup_viewport(gls, screen.surface, size.width, size.height);
-    glBindTexture(GL_TEXTURE_2D, screen.surface->texture);
-    surface_gl_render_texture(gls, screen.surface);
-
-    cocoa_gl_render_cursor();
-
-    cocoa_gl_flush();
-}
-
-static void cocoa_gl_update(DisplayChangeListener *dcl,
-                            int x, int y, int w, int h)
-{
-    with_view_ctx(^{
-        surface_gl_update_texture(gls, screen.surface, x, y, w, h);
-        dgs[qemu_console_get_index(dcl->con)].surface_dirty = true;
-    });
-}
-
-static void cocoa_gl_switch(DisplayChangeListener *dcl,
-                            DisplaySurface *new_surface)
-{
-    cocoa_switch(dcl, new_surface);
-
-    with_view_ctx(^{
-        surface_gl_create_texture(gls, new_surface);
-    });
-}
-
-static void cocoa_gl_refresh(DisplayChangeListener *dcl)
-{
-    cocoa_refresh(dcl);
-
-    with_view_ctx(^{
-        DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
-
-        if (dg->surface_dirty && screen.surface) {
-            dg->surface_dirty = false;
-            cocoa_gl_render_surface(dg);
-        }
-    });
-}
-
-static bool cocoa_gl_scanout_get_enabled(void *dg)
-{
-    return ((DisplayGL *)dg)->scanout_id != 0;
-}
-
-static void cocoa_gl_scanout_disable(void *dg)
-{
-    with_view_ctx(^{
-        cocoa_scanout_disable((DisplayGL *)dg);
-    });
-}
-
-static void cocoa_gl_scanout_texture(void *dg,
-                                     uint32_t backing_id,
-                                     DisplayGLTextureBorrower backing_borrow,
-                                     uint32_t x, uint32_t y,
-                                     uint32_t w, uint32_t h)
-{
-    ((DisplayGL *)dg)->scanout_id = backing_id;
-    ((DisplayGL *)dg)->scanout_borrow = backing_borrow;
-}
-
-static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
-                                   uint32_t x, uint32_t y, uint32_t w, uint32_t h)
-{
-    DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
-    bool y0_top;
-
-    if (!dg->scanout_id) {
-        return;
-    }
-
-    GLint texture = dg->scanout_borrow(dg->scanout_id, &y0_top, NULL, NULL);
-    if (!texture) {
-        return;
-    }
-
-    with_view_ctx(^{
-        QemuCocoaView *cocoaView = [appController cocoaView];
-        NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
-
-        glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
-        glViewport(0, 0, size.width, size.height);
-        glBindTexture(GL_TEXTURE_2D, texture);
-        qemu_gl_run_texture_blit(gls, y0_top);
-
-        cocoa_gl_render_cursor();
-
-        cocoa_gl_flush();
-    });
-}
-
-static void cocoa_gl_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
-{
-    screen.mouse_x = x;
-    screen.mouse_y = y;
-    screen.mouse_on = on;
-
-    DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
-
-    if (dg->scanout_id) {
-        cocoa_gl_scanout_flush(dcl, 0, 0, 0, 0);
-    } else {
-        with_view_ctx(^{
-            cocoa_gl_render_surface(dg);
-        });
-    }
-}
-
-static void cocoa_gl_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
-{
-    cursor_texture_width = cursor->width;
-    cursor_texture_height = cursor->height;
-
-    with_view_ctx(^{
-        glBindTexture(GL_TEXTURE_2D, cursor_texture);
-        glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, cursor->width);
-        glTexImage2D(GL_TEXTURE_2D, 0,
-                     epoxy_is_desktop_gl() ? GL_RGBA : GL_BGRA,
-                     cursor->width,
-                     cursor->height,
-                     0, GL_BGRA, GL_UNSIGNED_BYTE,
-                     cursor->data);
-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    });
-}
-
-static const DisplayGLOps dg_ops = {
-    .dpy_gl_ctx_create           = cocoa_gl_create_context,
-    .dpy_gl_ctx_destroy          = cocoa_gl_destroy_context,
-    .dpy_gl_ctx_make_current     = cocoa_gl_make_context_current,
-    .dpy_gl_scanout_get_enabled  = cocoa_gl_scanout_get_enabled,
-    .dpy_gl_scanout_disable      = cocoa_gl_scanout_disable,
-    .dpy_gl_scanout_texture      = cocoa_gl_scanout_texture,
-};
-
-static const DisplayChangeListenerOps dcl_gl_ops = {
-    .dpy_name                = "cocoa-gl",
-    .dpy_gfx_update          = cocoa_gl_update,
-    .dpy_gfx_switch          = cocoa_gl_switch,
-    .dpy_gfx_check_format    = console_gl_check_format,
-    .dpy_refresh             = cocoa_gl_refresh,
-    .dpy_mouse_set           = cocoa_gl_mouse_set,
-    .dpy_cursor_define       = cocoa_gl_cursor_define,
-
-    .dpy_gl_update           = cocoa_gl_scanout_flush,
-};
-
-#endif
-
-static void cocoa_display_early_init(DisplayOptions *o)
-{
-    assert(o->type == DISPLAY_TYPE_COCOA);
-    if (o->has_gl && o->gl) {
-        display_opengl = 1;
-    }
-}
-
-static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
-{
-    COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
-
-    screen.cursor_show = opts->has_show_cursor && opts->show_cursor;
-    screen.swap_option_command = opts->u.cocoa.has_swap_option_command &&
-        opts->u.cocoa.swap_option_command;
-
-    /* Tell main thread to go ahead and create the app and enter the run loop */
-    qemu_sem_post(&display_init_sem);
-    qemu_sem_wait(&app_started_sem);
-    COCOA_DEBUG("cocoa_display_init: app start completed\n");
-
-    /* if fullscreen mode is to be used */
-    if (opts->has_full_screen && opts->full_screen) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            [[[appController cocoaView] window] toggleFullScreen: nil];
-        });
-    }
-    if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            [[appController cocoaView] setFullGrab: nil];
-        });
-    }
-
-    if (display_opengl) {
-#ifdef CONFIG_OPENGL
-        unsigned int console_count = 0;
-        while (qemu_console_lookup_by_index(console_count)) {
-            console_count++;
-        }
-
-        dgs = g_new0(DisplayGL, console_count);
-
-        for (unsigned int index = 0; index < console_count; index++) {
-            QemuConsole *con = qemu_console_lookup_by_index(index);
-            console_set_displayglcontext(con, dgs + index);
-        }
-
-        if (opts->gl == DISPLAYGL_MODE_ES) {
-#ifdef CONFIG_EGL
-            if (qemu_egl_init_dpy_cocoa(DISPLAYGL_MODE_ES)) {
-                exit(1);
-            }
-            view_ctx = qemu_egl_init_ctx();
-            if (!view_ctx) {
-                exit(1);
-            }
-            dispatch_sync(dispatch_get_main_queue(), ^{
-                CALayer *layer = [[appController cocoaView] layer];
-                egl_surface = qemu_egl_init_surface(view_ctx, layer);
-            });
-#else
-            error_report("OpenGLES without EGL is not supported - exiting");
-            exit(1);
-#endif
-        } else {
-            view_ctx = cocoa_gl_create_context_ns(nil, 32);
-#ifdef CONFIG_EGL
-            egl_surface = EGL_NO_SURFACE;
-#endif
-            cocoa_gl_make_context_current(NULL, view_ctx);
-        }
-
-        gls = qemu_gl_init_shader();
-        glGenTextures(1, &cursor_texture);
-
-        // register vga output callbacks
-        screen.dcl.ops = &dcl_gl_ops;
-
-        register_displayglops(&dg_ops);
-#else
-        error_report("OpenGL is not enabled - exiting");
-        exit(1);
-#endif
-    } else {
-        // register vga output callbacks
-        screen.dcl.ops = &dcl_ops;
-    }
-
-    register_displaychangelistener(&screen.dcl);
-    qatomic_store_release(&screen.inited, true);
-
-    qemu_event_init(&qemucb.event, false);
-    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] initWith:&qemucb];
-    qemu_clipboard_peer_register(&cbpeer);
-}
-
-static QemuDisplay qemu_display_cocoa = {
-    .type       = DISPLAY_TYPE_COCOA,
-    .early_init = cocoa_display_early_init,
-    .init       = cocoa_display_init,
-};
-
-static void register_cocoa(void)
-{
-    qemu_display_register(&qemu_display_cocoa);
-}
-
-type_init(register_cocoa);
-
-#ifdef CONFIG_OPENGL
-module_dep("ui-opengl");
-#endif
-#endif
-
 #endif
diff --git a/ui/cocoa/app_controller.m b/ui/cocoa/app_controller.m
index 5d1df04d2c3a..f3b7d7382479 100644
--- a/ui/cocoa/app_controller.m
+++ b/ui/cocoa/app_controller.m
@@ -22,5 +22,640 @@
  * THE SOFTWARE.
  */
 
-#define UI_COCOA_APP_CONTROLLER
+#include "qemu/osdep.h"
+
+#include "qemu-common.h"
 #include "ui/cocoa.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/runstate.h"
+#include "sysemu/cpu-throttle.h"
+#include "qapi/error.h"
+#include "qapi/qapi-commands-block.h"
+#include "qapi/qapi-commands-machine.h"
+#include "qapi/qapi-commands-misc.h"
+#include "sysemu/blockdev.h"
+#include "qemu-version.h"
+#include "qemu/cutils.h"
+#include "qemu/main-loop.h"
+#include "qemu/module.h"
+#include "hw/core/cpu.h"
+
+#ifndef MAC_OS_X_VERSION_10_13
+#define MAC_OS_X_VERSION_10_13 101300
+#endif
+
+/* 10.14 deprecates NSOnState and NSOffState in favor of
+ * NSControlStateValueOn/Off, which were introduced in 10.13.
+ * Define for older versions
+ */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_13
+#define NSControlStateValueOn NSOnState
+#define NSControlStateValueOff NSOffState
+#endif
+
+// Utility function to run specified code block with iothread lock held
+static void with_iothread_lock(CodeBlock block)
+{
+    bool locked = qemu_mutex_iothread_locked();
+    if (!locked) {
+        qemu_mutex_lock_iothread();
+    }
+    block();
+    if (!locked) {
+        qemu_mutex_unlock_iothread();
+    }
+}
+
+/* Displays an alert dialog box with the specified message */
+static void QEMU_Alert(NSString *message)
+{
+    NSAlert *alert;
+    alert = [NSAlert new];
+    [alert setMessageText: message];
+    [alert runModal];
+}
+
+/* Handles any errors that happen with a device transaction */
+static void handleAnyDeviceErrors(Error * err)
+{
+    if (err) {
+        QEMU_Alert([NSString stringWithCString: error_get_pretty(err)
+                                      encoding: NSASCIIStringEncoding]);
+        error_free(err);
+    }
+}
+
+static void create_initial_menus(void)
+{
+    // Add menus
+    NSMenu      *menu;
+    NSMenuItem  *menuItem;
+
+    [NSApp setMainMenu:[[NSMenu alloc] init]];
+
+    // Application menu
+    menu = [[NSMenu alloc] initWithTitle:@""];
+    [menu addItemWithTitle:@"About QEMU" action:@selector(do_about_menu_item:) keyEquivalent:@""]; // About QEMU
+    [menu addItem:[NSMenuItem separatorItem]]; //Separator
+    [menu addItemWithTitle:@"Hide QEMU" action:@selector(hide:) keyEquivalent:@"h"]; //Hide QEMU
+    menuItem = (NSMenuItem *)[menu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"]; // Hide Others
+    [menuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];
+    [menu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""]; // Show All
+    [menu addItem:[NSMenuItem separatorItem]]; //Separator
+    [menu addItemWithTitle:@"Quit QEMU" action:@selector(terminate:) keyEquivalent:@"q"];
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Apple" action:nil keyEquivalent:@""];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+    [NSApp performSelector:@selector(setAppleMenu:) withObject:menu]; // Workaround (this method is private since 10.4+)
+
+    // Machine menu
+    menu = [[NSMenu alloc] initWithTitle: @"Machine"];
+    [menu setAutoenablesItems: NO];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Pause" action: @selector(pauseQEMU:) keyEquivalent: @""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Resume" action: @selector(resumeQEMU:) keyEquivalent: @""] autorelease];
+    [menu addItem: menuItem];
+    [menuItem setEnabled: NO];
+    [menu addItem: [NSMenuItem separatorItem]];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Reset" action: @selector(restartQEMU:) keyEquivalent: @""] autorelease]];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Power Down" action: @selector(powerDownQEMU:) keyEquivalent: @""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Machine" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // View menu
+    menu = [[NSMenu alloc] initWithTitle:@"View"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Enter Fullscreen" action:@selector(doToggleFullScreen:) keyEquivalent:@"f"] autorelease]]; // Fullscreen
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Zoom To Fit" action:@selector(zoomToFit:) keyEquivalent:@""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"View" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // Speed menu
+    menu = [[NSMenu alloc] initWithTitle:@"Speed"];
+
+    // Add the rest of the Speed menu items
+    int p, percentage, throttle_pct;
+    for (p = 10; p >= 0; p--)
+    {
+        percentage = p * 10 > 1 ? p * 10 : 1; // prevent a 0% menu item
+
+        menuItem = [[[NSMenuItem alloc]
+                   initWithTitle: [NSString stringWithFormat: @"%d%%", percentage] action:@selector(adjustSpeed:) keyEquivalent:@""] autorelease];
+
+        if (percentage == 100) {
+            [menuItem setState: NSControlStateValueOn];
+        }
+
+        /* Calculate the throttle percentage */
+        throttle_pct = -1 * percentage + 100;
+
+        [menuItem setTag: throttle_pct];
+        [menu addItem: menuItem];
+    }
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Speed" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // Window menu
+    menu = [[NSMenu alloc] initWithTitle:@"Window"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"] autorelease]]; // Miniaturize
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+    [NSApp setWindowsMenu:menu];
+
+    // Help menu
+    menu = [[NSMenu alloc] initWithTitle:@"Help"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"QEMU Documentation" action:@selector(showQEMUDoc:) keyEquivalent:@"?"] autorelease]]; // QEMU Help
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+}
+
+/* Returns a name for a given console */
+static NSString * getConsoleName(QemuConsole * console)
+{
+    return [NSString stringWithFormat: @"%s", qemu_console_get_label(console)];
+}
+
+/* Add an entry to the View menu for each console */
+static void add_console_menu_entries(void)
+{
+    NSMenu *menu;
+    NSMenuItem *menuItem;
+    int index = 0;
+
+    menu = [[[NSApp mainMenu] itemWithTitle:@"View"] submenu];
+
+    [menu addItem:[NSMenuItem separatorItem]];
+
+    while (qemu_console_lookup_by_index(index) != NULL) {
+        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(qemu_console_lookup_by_index(index))
+                                               action: @selector(displayConsole:) keyEquivalent: @""] autorelease];
+        [menuItem setTag: index];
+        [menu addItem: menuItem];
+        index++;
+    }
+}
+
+/* Make menu items for all removable devices.
+ * Each device is given an 'Eject' and 'Change' menu item.
+ */
+static void addRemovableDevicesMenuItems(void)
+{
+    NSMenu *menu;
+    NSMenuItem *menuItem;
+    BlockInfoList *currentDevice, *pointerToFree;
+    NSString *deviceName;
+
+    currentDevice = qmp_query_block(NULL);
+    pointerToFree = currentDevice;
+    if(currentDevice == NULL) {
+        NSBeep();
+        QEMU_Alert(@"Failed to query for block devices!");
+        return;
+    }
+
+    menu = [[[NSApp mainMenu] itemWithTitle:@"Machine"] submenu];
+
+    // Add a separator between related groups of menu items
+    [menu addItem:[NSMenuItem separatorItem]];
+
+    // Set the attributes to the "Removable Media" menu item
+    NSString *titleString = @"Removable Media";
+    NSMutableAttributedString *attString=[[NSMutableAttributedString alloc] initWithString:titleString];
+    NSColor *newColor = [NSColor blackColor];
+    NSFontManager *fontManager = [NSFontManager sharedFontManager];
+    NSFont *font = [fontManager fontWithFamily:@"Helvetica"
+                                          traits:NSBoldFontMask|NSItalicFontMask
+                                          weight:0
+                                            size:14];
+    [attString addAttribute:NSFontAttributeName value:font range:NSMakeRange(0, [titleString length])];
+    [attString addAttribute:NSForegroundColorAttributeName value:newColor range:NSMakeRange(0, [titleString length])];
+    [attString addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInt: 1] range:NSMakeRange(0, [titleString length])];
+
+    // Add the "Removable Media" menu item
+    menuItem = [NSMenuItem new];
+    [menuItem setAttributedTitle: attString];
+    [menuItem setEnabled: NO];
+    [menu addItem: menuItem];
+
+    /* Loop through all the block devices in the emulator */
+    while (currentDevice) {
+        deviceName = [[NSString stringWithFormat: @"%s", currentDevice->value->device] retain];
+
+        if(currentDevice->value->removable) {
+            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Change %s...", currentDevice->value->device]
+                                                  action: @selector(changeDeviceMedia:)
+                                           keyEquivalent: @""];
+            [menu addItem: menuItem];
+            [menuItem setRepresentedObject: deviceName];
+            [menuItem autorelease];
+
+            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Eject %s", currentDevice->value->device]
+                                                  action: @selector(ejectDeviceMedia:)
+                                           keyEquivalent: @""];
+            [menu addItem: menuItem];
+            [menuItem setRepresentedObject: deviceName];
+            [menuItem autorelease];
+        }
+        currentDevice = currentDevice->next;
+    }
+    qapi_free_BlockInfoList(pointerToFree);
+}
+
+@implementation QemuCocoaAppController
+- (id) initWithStartedSem:(QemuSemaphore *)given_started_sem
+                   screen:(QEMUScreen *)screen
+{
+    COCOA_DEBUG("%s\n", __func__);
+
+    self = [super init];
+    if (self) {
+
+        started_sem = given_started_sem;
+
+        create_initial_menus();
+
+        /*
+         * Create the menu entries which depend on QEMU state (for consoles
+         * and removeable devices). These make calls back into QEMU functions,
+         * which is OK because at this point we know that the second thread
+         * holds the iothread lock and is synchronously waiting for us to
+         * finish.
+         */
+        add_console_menu_entries();
+        addRemovableDevicesMenuItems();
+
+        // create a view and add it to the window
+        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)
+                                                  screen:screen];
+        if(!cocoaView) {
+            error_report("(cocoa) can't create a view");
+            exit(1);
+        }
+
+        // create a window
+        NSWindow *normalWindow = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
+            styleMask:NSWindowStyleMaskTitled|NSWindowStyleMaskMiniaturizable|NSWindowStyleMaskClosable
+            backing:NSBackingStoreBuffered defer:NO];
+        if(!normalWindow) {
+            error_report("(cocoa) can't create window");
+            exit(1);
+        }
+        [normalWindow setAcceptsMouseMovedEvents:YES];
+        [normalWindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
+        [normalWindow setTitle:qemu_name ? [NSString stringWithFormat:@"QEMU %s", qemu_name] : @"QEMU"];
+        [normalWindow setContentView:cocoaView];
+        [normalWindow makeKeyAndOrderFront:self];
+        [normalWindow center];
+        [normalWindow setDelegate: self];
+        [normalWindow release];
+
+        // set the supported image file types that can be opened
+        supportedImageFileTypes = [NSArray arrayWithObjects: @"img", @"iso", @"dmg",
+                                 @"qcow", @"qcow2", @"cloop", @"vmdk", @"cdr",
+                                  @"toast", nil];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+    COCOA_DEBUG("QemuCocoaAppController: dealloc\n");
+
+    if (cocoaView)
+        [cocoaView release];
+    [super dealloc];
+}
+
+- (void)applicationDidFinishLaunching: (NSNotification *) note
+{
+    COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
+    /* Tell cocoa_display_init to proceed */
+    qemu_sem_post(started_sem);
+}
+
+- (void)applicationWillTerminate:(NSNotification *)aNotification
+{
+    COCOA_DEBUG("QemuCocoaAppController: applicationWillTerminate\n");
+
+    qemu_system_shutdown_request(SHUTDOWN_CAUSE_HOST_UI);
+
+    /*
+     * Sleep here, because returning will cause OSX to kill us
+     * immediately; the QEMU main loop will handle the shutdown
+     * request and terminate the process.
+     */
+    [NSThread sleepForTimeInterval:INFINITY];
+}
+
+- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)theApplication
+{
+    return YES;
+}
+
+- (NSApplicationTerminateReply)applicationShouldTerminate:
+                                                         (NSApplication *)sender
+{
+    COCOA_DEBUG("QemuCocoaAppController: applicationShouldTerminate\n");
+    return [self verifyQuit];
+}
+
+- (void)windowDidChangeScreen:(NSNotification *)notification
+{
+    [cocoaView updateUIInfo];
+}
+
+- (void)windowDidEnterFullScreen:(NSNotification *)notification
+{
+    [cocoaView grabMouse];
+}
+
+- (void)windowDidExitFullScreen:(NSNotification *)notification
+{
+    [cocoaView resizeWindow];
+    [cocoaView ungrabMouse];
+}
+
+- (void)windowDidResize:(NSNotification *)notification
+{
+    [cocoaView frameUpdated];
+}
+
+/* Called when the user clicks on a window's close button */
+- (BOOL)windowShouldClose:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaAppController: windowShouldClose\n");
+    [NSApp terminate: sender];
+    /* If the user allows the application to quit then the call to
+     * NSApp terminate will never return. If we get here then the user
+     * cancelled the quit, so we should return NO to not permit the
+     * closing of this window.
+     */
+    return NO;
+}
+
+- (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
+{
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        return [cocoaView computeUnzoomedSize];
+    }
+
+    return [cocoaView fixZoomedFullScreenSize:proposedSize];
+}
+
+- (NSApplicationPresentationOptions) window:(NSWindow *)window
+                                     willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions;
+
+{
+    return (proposedOptions & ~(NSApplicationPresentationAutoHideDock | NSApplicationPresentationAutoHideMenuBar)) |
+           NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar;
+}
+
+/* We abstract the method called by the Enter Fullscreen menu item
+ * because Mac OS 10.7 and higher disables it. This is because of the
+ * menu item's old selector's name toggleFullScreen:
+ */
+- (void) doToggleFullScreen:(id)sender
+{
+    [[cocoaView window] toggleFullScreen:sender];
+}
+
+/* Tries to find then open the specified filename */
+- (void) openDocumentation: (NSString *) filename
+{
+    /* Where to look for local files */
+    NSString *path_array[] = {@"../share/doc/qemu/", @"../doc/qemu/", @"docs/"};
+    NSString *full_file_path;
+    NSURL *full_file_url;
+
+    /* iterate thru the possible paths until the file is found */
+    int index;
+    for (index = 0; index < ARRAY_SIZE(path_array); index++) {
+        full_file_path = [[NSBundle mainBundle] executablePath];
+        full_file_path = [full_file_path stringByDeletingLastPathComponent];
+        full_file_path = [NSString stringWithFormat: @"%@/%@%@", full_file_path,
+                          path_array[index], filename];
+        full_file_url = [NSURL fileURLWithPath: full_file_path
+                                   isDirectory: false];
+        if ([[NSWorkspace sharedWorkspace] openURL: full_file_url] == YES) {
+            return;
+        }
+    }
+
+    /* If none of the paths opened a file */
+    NSBeep();
+    QEMU_Alert(@"Failed to open file");
+}
+
+- (void)showQEMUDoc:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaAppController: showQEMUDoc\n");
+
+    [self openDocumentation: @"index.html"];
+}
+
+/* Toggles the flag which stretches video to fit host window size */
+- (void)zoomToFit:(id) sender
+{
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] | NSWindowStyleMaskResizable];
+        [sender setState: NSControlStateValueOn];
+    } else {
+        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] & ~NSWindowStyleMaskResizable];
+        [cocoaView resizeWindow];
+        [sender setState: NSControlStateValueOff];
+    }
+}
+
+/* Displays the console on the screen */
+- (void)displayConsole:(id)sender
+{
+    with_iothread_lock(^{
+        console_select([sender tag]);
+    });
+}
+
+/* Pause the guest */
+- (void)pauseQEMU:(id)sender
+{
+    with_iothread_lock(^{
+        qmp_stop(NULL);
+    });
+    [sender setEnabled: NO];
+    [[[sender menu] itemWithTitle: @"Resume"] setEnabled: YES];
+    [cocoaView displayPause];
+}
+
+/* Resume running the guest operating system */
+- (void)resumeQEMU:(id) sender
+{
+    with_iothread_lock(^{
+        qmp_cont(NULL);
+    });
+    [sender setEnabled: NO];
+    [[[sender menu] itemWithTitle: @"Pause"] setEnabled: YES];
+    [cocoaView removePause];
+}
+
+/* Restarts QEMU */
+- (void)restartQEMU:(id)sender
+{
+    with_iothread_lock(^{
+        qmp_system_reset(NULL);
+    });
+}
+
+/* Powers down QEMU */
+- (void)powerDownQEMU:(id)sender
+{
+    with_iothread_lock(^{
+        qmp_system_powerdown(NULL);
+    });
+}
+
+/* Ejects the media.
+ * Uses sender's tag to figure out the device to eject.
+ */
+- (void)ejectDeviceMedia:(id)sender
+{
+    NSString * drive;
+    drive = [sender representedObject];
+    if(drive == nil) {
+        NSBeep();
+        QEMU_Alert(@"Failed to find drive to eject!");
+        return;
+    }
+
+    __block Error *err = NULL;
+    with_iothread_lock(^{
+        qmp_eject(true, [drive cStringUsingEncoding: NSASCIIStringEncoding],
+                  false, NULL, false, false, &err);
+    });
+    handleAnyDeviceErrors(err);
+}
+
+/* Displays a dialog box asking the user to select an image file to load.
+ * Uses sender's represented object value to figure out which drive to use.
+ */
+- (void)changeDeviceMedia:(id)sender
+{
+    /* Find the drive name */
+    NSString * drive;
+    drive = [sender representedObject];
+    if(drive == nil) {
+        NSBeep();
+        QEMU_Alert(@"Could not find drive!");
+        return;
+    }
+
+    /* Display the file open dialog */
+    NSOpenPanel * openPanel;
+    openPanel = [NSOpenPanel openPanel];
+    [openPanel setCanChooseFiles: YES];
+    [openPanel setAllowsMultipleSelection: NO];
+    [openPanel setAllowedFileTypes: supportedImageFileTypes];
+    if([openPanel runModal] == NSModalResponseOK) {
+        NSString * file = [[[openPanel URLs] objectAtIndex: 0] path];
+        if(file == nil) {
+            NSBeep();
+            QEMU_Alert(@"Failed to convert URL to file path!");
+            return;
+        }
+
+        __block Error *err = NULL;
+        with_iothread_lock(^{
+            qmp_blockdev_change_medium(true,
+                                       [drive cStringUsingEncoding:
+                                                  NSASCIIStringEncoding],
+                                       false, NULL,
+                                       [file cStringUsingEncoding:
+                                                 NSASCIIStringEncoding],
+                                       true, "raw",
+                                       false, 0,
+                                       &err);
+        });
+        handleAnyDeviceErrors(err);
+    }
+}
+
+/* Verifies if the user really wants to quit */
+- (BOOL)verifyQuit
+{
+    NSAlert *alert = [NSAlert new];
+    [alert autorelease];
+    [alert setMessageText: @"Are you sure you want to quit QEMU?"];
+    [alert addButtonWithTitle: @"Cancel"];
+    [alert addButtonWithTitle: @"Quit"];
+    if([alert runModal] == NSAlertSecondButtonReturn) {
+        return YES;
+    } else {
+        return NO;
+    }
+}
+
+/* The action method for the About menu item */
+- (IBAction) do_about_menu_item: (id) sender
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    char *icon_path_c = get_relocated_path(CONFIG_QEMU_ICONDIR "/hicolor/512x512/apps/qemu.png");
+    NSString *icon_path = [NSString stringWithUTF8String:icon_path_c];
+    g_free(icon_path_c);
+    NSImage *icon = [[NSImage alloc] initWithContentsOfFile:icon_path];
+    NSString *version = @"QEMU emulator version " QEMU_FULL_VERSION;
+    NSString *copyright = @QEMU_COPYRIGHT;
+    NSDictionary *options;
+    if (icon) {
+        options = @{
+            NSAboutPanelOptionApplicationIcon : icon,
+            NSAboutPanelOptionApplicationVersion : version,
+            @"Copyright" : copyright,
+        };
+        [icon release];
+    } else {
+        options = @{
+            NSAboutPanelOptionApplicationVersion : version,
+            @"Copyright" : copyright,
+        };
+    }
+    [NSApp orderFrontStandardAboutPanelWithOptions:options];
+    [pool release];
+}
+
+/* Used by the Speed menu items */
+- (void)adjustSpeed:(id)sender
+{
+    int throttle_pct; /* throttle percentage */
+    NSMenu *menu;
+
+    menu = [sender menu];
+    if (menu != nil)
+    {
+        /* Unselect the currently selected item */
+        for (NSMenuItem *item in [menu itemArray]) {
+            if (item.state == NSControlStateValueOn) {
+                [item setState: NSControlStateValueOff];
+                break;
+            }
+        }
+    }
+
+    // check the menu item
+    [sender setState: NSControlStateValueOn];
+
+    // get the throttle percentage
+    throttle_pct = [sender tag];
+
+    with_iothread_lock(^{
+        cpu_throttle_set(throttle_pct);
+    });
+    COCOA_DEBUG("cpu throttling at %d%c\n", cpu_throttle_get_percentage(), '%');
+}
+
+- (QemuCocoaView *)cocoaView
+{
+    return cocoaView;
+}
+
+@end
diff --git a/ui/cocoa/main.m b/ui/cocoa/main.m
index e6d8fdeb4efb..16bb4ace82c9 100644
--- a/ui/cocoa/main.m
+++ b/ui/cocoa/main.m
@@ -22,5 +22,831 @@
  * THE SOFTWARE.
  */
 
-#define UI_COCOA_MAIN
+#include "qemu/osdep.h"
+
+#include <crt_externs.h>
+
+#include "qemu-common.h"
 #include "ui/cocoa.h"
+#include "ui/input.h"
+#include "sysemu/sysemu.h"
+
+#ifdef CONFIG_EGL
+#include "ui/egl-context.h"
+#endif
+
+static QEMUScreen screen;
+static QemuCocoaAppController *appController;
+
+static int gArgc;
+static char **gArgv;
+
+static QemuSemaphore display_init_sem;
+static QemuSemaphore app_started_sem;
+
+static NSInteger cbchangecount = -1;
+static QemuCocoaClipboard qemucb;
+static QemuCocoaPasteboardTypeOwner *cbowner;
+
+#ifdef CONFIG_OPENGL
+
+typedef struct {
+    uint32_t scanout_id;
+    DisplayGLTextureBorrower scanout_borrow;
+    bool surface_dirty;
+} DisplayGL;
+
+static DisplayGL *dgs;
+static QEMUGLContext view_ctx;
+static QemuGLShader *gls;
+static GLuint cursor_texture;
+static int cursor_texture_width;
+static int cursor_texture_height;
+
+#ifdef CONFIG_EGL
+static EGLSurface egl_surface;
+#endif
+
+static void cocoa_gl_destroy_context(void *dg, QEMUGLContext ctx);
+
+#endif
+
+@interface QemuApplication : NSApplication
+@end
+
+@implementation QemuApplication
+- (void)sendEvent:(NSEvent *)event
+{
+    COCOA_DEBUG("QemuApplication: sendEvent\n");
+    if (![[appController cocoaView] handleEvent:event]) {
+        [super sendEvent: event];
+    }
+}
+@end
+
+static void cocoa_clipboard_notify(Notifier *notifier, void *data);
+static void cocoa_clipboard_request(QemuClipboardInfo *info,
+                                    QemuClipboardType type);
+
+static QemuClipboardPeer cbpeer = {
+    .name = "cocoa",
+    .update = { .notify = cocoa_clipboard_notify },
+    .request = cocoa_clipboard_request
+};
+
+static void cocoa_clipboard_notify(Notifier *notifier, void *data)
+{
+    QemuClipboardInfo *info = data;
+
+    if (info->owner == &cbpeer || info->selection != QEMU_CLIPBOARD_SELECTION_CLIPBOARD) {
+        return;
+    }
+
+    if (info != qemucb.info) {
+        NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+        qemu_clipboard_info_unref(qemucb.info);
+        qemucb.info = qemu_clipboard_info_ref(info);
+        cbchangecount = [[NSPasteboard generalPasteboard] declareTypes:@[NSPasteboardTypeString] owner:cbowner];
+        [pool release];
+    }
+
+    qemu_event_set(&qemucb.event);
+}
+
+static void cocoa_clipboard_request(QemuClipboardInfo *info,
+                                    QemuClipboardType type)
+{
+    NSData *text;
+
+    switch (type) {
+    case QEMU_CLIPBOARD_TYPE_TEXT:
+        text = [[NSPasteboard generalPasteboard] dataForType:NSPasteboardTypeString];
+        if (text) {
+            qemu_clipboard_set_data(&cbpeer, info, type,
+                                    [text length], [text bytes], true);
+            [text release];
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+/*
+ * The startup process for the OSX/Cocoa UI is complicated, because
+ * OSX insists that the UI runs on the initial main thread, and so we
+ * need to start a second thread which runs the vl.c qemu_main():
+ *
+ * Initial thread:                    2nd thread:
+ * in main():
+ *  create qemu-main thread
+ *  wait on display_init semaphore
+ *                                    call qemu_main()
+ *                                    ...
+ *                                    in cocoa_display_init():
+ *                                     post the display_init semaphore
+ *                                     wait on app_started semaphore
+ *  create application, menus, etc
+ *  enter OSX run loop
+ * in applicationDidFinishLaunching:
+ *  post app_started semaphore
+ *                                     tell main thread to fullscreen if needed
+ *                                    [...]
+ *                                    run qemu main-loop
+ *
+ * We do this in two stages so that we don't do the creation of the
+ * GUI application menus and so on for command line options like --help
+ * where we want to just print text to stdout and exit immediately.
+ */
+
+static void *call_qemu_main(void *opaque)
+{
+    int status;
+
+    COCOA_DEBUG("Second thread: calling qemu_main()\n");
+    status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
+    COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
+    [cbowner release];
+    CGImageRelease(screen.cursor_cgimage);
+#ifdef CONFIG_OPENGL
+    g_free(dgs);
+    qemu_gl_fini_shader(gls);
+    if (view_ctx) {
+        cocoa_gl_destroy_context(NULL, view_ctx);
+    }
+    if (appController) {
+        [appController release];
+    }
+#endif
+    exit(status);
+}
+
+int main (int argc, char **argv) {
+    QemuThread thread;
+
+    COCOA_DEBUG("Entered main()\n");
+    gArgc = argc;
+    gArgv = argv;
+
+    qemu_sem_init(&display_init_sem, 0);
+    qemu_sem_init(&app_started_sem, 0);
+
+    qemu_thread_create(&thread, "qemu_main", call_qemu_main,
+                       NULL, QEMU_THREAD_DETACHED);
+
+    qemu_mutex_init(&screen.draw_mutex);
+
+    COCOA_DEBUG("Main thread: waiting for display_init_sem\n");
+    qemu_sem_wait(&display_init_sem);
+    COCOA_DEBUG("Main thread: initializing app\n");
+
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    // Pull this console process up to being a fully-fledged graphical
+    // app with a menubar and Dock icon
+    ProcessSerialNumber psn = { 0, kCurrentProcess };
+    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+
+    [QemuApplication sharedApplication];
+
+    // Create an Application controller
+    appController = [[QemuCocoaAppController alloc] initWithStartedSem:&app_started_sem
+                                                                screen:&screen];
+    [NSApp setDelegate:appController];
+
+    // Start the main event loop
+    COCOA_DEBUG("Main thread: entering OSX run loop\n");
+    [NSApp run];
+    COCOA_DEBUG("Main thread: left OSX run loop, exiting\n");
+
+    [pool release];
+
+    return 0;
+}
+
+
+
+#pragma mark qemu
+static void cocoa_update(DisplayChangeListener *dcl,
+                         int x, int y, int w, int h)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    DisplaySurface *updated = screen.surface;
+
+    COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        qemu_mutex_lock(&screen.draw_mutex);
+        if (updated != screen.surface) {
+            qemu_mutex_unlock(&screen.draw_mutex);
+            return;
+        }
+        int full_height = surface_height(screen.surface);
+        qemu_mutex_unlock(&screen.draw_mutex);
+
+        CGFloat d = [[appController cocoaView] frame].size.height / full_height;
+        NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
+        [[appController cocoaView] setNeedsDisplayInRect:rect];
+    });
+
+    [pool release];
+}
+
+static void cocoa_switch(DisplayChangeListener *dcl,
+                         DisplaySurface *new_surface)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    static bool updating_screen;
+
+    COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
+
+    [[appController cocoaView] updateUIInfo];
+
+    qemu_mutex_lock(&screen.draw_mutex);
+    screen.surface = new_surface;
+    if (!updating_screen) {
+        updating_screen = true;
+
+        dispatch_async(dispatch_get_main_queue(), ^{
+            qemu_mutex_lock(&screen.draw_mutex);
+            updating_screen = false;
+            int w = surface_width(screen.surface);
+            int h = surface_height(screen.surface);
+            qemu_mutex_unlock(&screen.draw_mutex);
+
+            [[appController cocoaView] updateScreenWidth:w height:h];
+        });
+    }
+    qemu_mutex_unlock(&screen.draw_mutex);
+    [pool release];
+}
+
+static void cocoa_refresh(DisplayChangeListener *dcl)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    COCOA_DEBUG("qemu_cocoa: cocoa_refresh\n");
+    graphic_hw_update(NULL);
+
+    if (qemu_input_is_absolute()) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            if (![[appController cocoaView] isAbsoluteEnabled]) {
+                if ([[appController cocoaView] isMouseGrabbed]) {
+                    [[appController cocoaView] ungrabMouse];
+                }
+            }
+            [[appController cocoaView] setAbsoluteEnabled:YES];
+        });
+    }
+
+    if (cbchangecount != [[NSPasteboard generalPasteboard] changeCount]) {
+        qemu_clipboard_info_unref(qemucb.info);
+        qemucb.info = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
+        if ([[NSPasteboard generalPasteboard] availableTypeFromArray:@[NSPasteboardTypeString]]) {
+            qemucb.info->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
+        }
+        qemu_clipboard_update(qemucb.info);
+        cbchangecount = [[NSPasteboard generalPasteboard] changeCount];
+        qemu_event_set(&qemucb.event);
+    }
+
+    [pool release];
+}
+
+static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
+{
+    qemu_mutex_lock(&screen.draw_mutex);
+    int full_height = surface_height(screen.surface);
+    size_t cursor_width = CGImageGetWidth(screen.cursor_cgimage);
+    size_t cursor_height = CGImageGetHeight(screen.cursor_cgimage);
+    int old_x = screen.mouse_x;
+    int old_y = screen.mouse_y;
+    int old_on = screen.mouse_on;
+    screen.mouse_x = x;
+    screen.mouse_y = y;
+    screen.mouse_on = on;
+    qemu_mutex_unlock(&screen.draw_mutex);
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        if (old_on) {
+            [[appController cocoaView] setNeedsDisplayForCursorX:old_x
+                                                               y:old_y
+                                                           width:cursor_width
+                                                           height:cursor_height
+                                                     screenHeight:full_height];
+        }
+
+        if (on) {
+            [[appController cocoaView] setNeedsDisplayForCursorX:x
+                                                               y:y
+                                                           width:cursor_width
+                                                           height:cursor_height
+                                                     screenHeight:full_height];
+        }
+    });
+}
+
+static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
+{
+    int width = cursor->width;
+    int height = cursor->height;
+
+    CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
+        NULL,
+        cursor->data,
+        width * height * 4,
+        NULL
+    );
+
+    CGImageRef imageRef = CGImageCreate(
+        width, //width
+        height, //height
+        8, //bitsPerComponent
+        32, //bitsPerPixel
+        width * 4, //bytesPerRow
+        CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
+        kCGBitmapByteOrder32Little | kCGImageAlphaFirst, //bitmapInfo
+        dataProviderRef, //provider
+        NULL, //decode
+        0, //interpolate
+        kCGRenderingIntentDefault //intent
+    );
+
+    qemu_mutex_lock(&screen.draw_mutex);
+    int full_height = surface_height(screen.surface);
+    int x = screen.mouse_x;
+    int y = screen.mouse_y;
+    int on = screen.mouse_on;
+    size_t old_width;
+    size_t old_height;
+    if (screen.cursor_cgimage) {
+        old_width = CGImageGetWidth(screen.cursor_cgimage);
+        old_height = CGImageGetHeight(screen.cursor_cgimage);
+    } else {
+        old_width = 0;
+        old_height = 0;
+    }
+    screen.cursor_cgimage = CGImageCreateCopy(imageRef);
+    qemu_mutex_unlock(&screen.draw_mutex);
+
+    CGImageRelease(imageRef);
+    CGDataProviderRelease(dataProviderRef);
+
+    if (on) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            CGFloat d = [[appController cocoaView] frame].size.height / full_height;
+            NSRect rect;
+
+            rect.origin.x = d * x;
+            rect.origin.y = d * (full_height - y - old_height);
+            rect.size.width = d * old_width;
+            rect.size.height = d * old_height;
+            [[appController cocoaView] setNeedsDisplayInRect:rect];
+
+            rect.origin.x = d * x;
+            rect.origin.y = d * (full_height - y - height);
+            rect.size.width = d * width;
+            rect.size.height = d * height;
+            [[appController cocoaView] setNeedsDisplayInRect:rect];
+       });
+    }
+}
+
+static const DisplayChangeListenerOps dcl_ops = {
+    .dpy_name          = "cocoa",
+    .dpy_gfx_update = cocoa_update,
+    .dpy_gfx_switch = cocoa_switch,
+    .dpy_refresh = cocoa_refresh,
+    .dpy_mouse_set = cocoa_mouse_set,
+    .dpy_cursor_define = cocoa_cursor_define,
+};
+
+#ifdef CONFIG_OPENGL
+
+static void with_view_ctx(CodeBlock block)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
+        block();
+        return;
+    }
+#endif
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    [(NSOpenGLContext *)view_ctx lock];
+    [(NSOpenGLContext *)view_ctx makeCurrentContext];
+    block();
+    [(NSOpenGLContext *)view_ctx unlock];
+#pragma clang diagnostic pop
+}
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+static NSOpenGLContext *cocoa_gl_create_context_ns(NSOpenGLContext *share_context,
+                                                   int bpp)
+{
+    NSOpenGLPixelFormatAttribute attributes[] = {
+        NSOpenGLPFAOpenGLProfile,
+        NSOpenGLProfileVersion4_1Core,
+        NSOpenGLPFAColorSize,
+        bpp,
+        NSOpenGLPFADoubleBuffer,
+        0,
+    };
+    NSOpenGLPixelFormat *format;
+    NSOpenGLContext *ctx;
+
+    format = [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
+    ctx = [[NSOpenGLContext alloc] initWithFormat:format shareContext:share_context];
+    [format release];
+
+    [ctx retain];
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [ctx setView:[appController cocoaView]];
+        [ctx release];
+    });
+
+    return (QEMUGLContext)ctx;
+}
+#pragma clang diagnostic pop
+
+static int cocoa_gl_make_context_current(void *dg, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        EGLSurface surface = ctx == EGL_NO_CONTEXT ? EGL_NO_SURFACE : egl_surface;
+        return eglMakeCurrent(qemu_egl_display, surface, surface, ctx);
+    }
+#endif
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    if (ctx) {
+        [(NSOpenGLContext *)ctx makeCurrentContext];
+    } else {
+        [NSOpenGLContext clearCurrentContext];
+    }
+#pragma clang diagnostic pop
+
+    return 0;
+}
+
+static QEMUGLContext cocoa_gl_create_context(void *dg, QEMUGLParams *params)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
+        return qemu_egl_create_context(dg, params);
+    }
+#endif
+
+    int bpp = PIXMAN_FORMAT_BPP(surface_format(screen.surface));
+    return cocoa_gl_create_context_ns(view_ctx, bpp);
+}
+
+static void cocoa_gl_destroy_context(void *dg, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglDestroyContext(qemu_egl_display, ctx);
+        return;
+    }
+#endif
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    [(NSOpenGLContext *)ctx release];
+#pragma clang diagnostic pop
+}
+
+static void cocoa_gl_flush()
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglSwapBuffers(qemu_egl_display, egl_surface);
+        return;
+    }
+#endif
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    [[NSOpenGLContext currentContext] flushBuffer];
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [(NSOpenGLContext *)view_ctx update];
+    });
+#pragma clang diagnostic pop
+}
+
+static void cocoa_scanout_disable(DisplayGL *dg)
+{
+    if (!dg->scanout_id) {
+        return;
+    }
+
+    dg->scanout_id = 0;
+
+    if (screen.surface) {
+        surface_gl_destroy_texture(gls, screen.surface);
+        surface_gl_create_texture(gls, screen.surface);
+    }
+}
+
+static void cocoa_gl_render_cursor()
+{
+    if (!screen.mouse_on) {
+        return;
+    }
+
+    QemuCocoaView *cocoaView = [appController cocoaView];
+    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+    int full_height = surface_height(screen.surface);
+    CGFloat d = size.height / full_height;
+
+    glViewport(
+        d * screen.mouse_x,
+        d * (full_height - screen.mouse_y - cursor_texture_height),
+        d * cursor_texture_width,
+        d * cursor_texture_height
+    );
+    glBindTexture(GL_TEXTURE_2D, cursor_texture);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    qemu_gl_run_texture_blit(gls, false);
+    glDisable(GL_BLEND);
+}
+
+static void cocoa_gl_render_surface(DisplayGL *dg)
+{
+    cocoa_scanout_disable(dg);
+
+    QemuCocoaView *cocoaView = [appController cocoaView];
+    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+
+    surface_gl_setup_viewport(gls, screen.surface, size.width, size.height);
+    glBindTexture(GL_TEXTURE_2D, screen.surface->texture);
+    surface_gl_render_texture(gls, screen.surface);
+
+    cocoa_gl_render_cursor();
+
+    cocoa_gl_flush();
+}
+
+static void cocoa_gl_update(DisplayChangeListener *dcl,
+                            int x, int y, int w, int h)
+{
+    with_view_ctx(^{
+        surface_gl_update_texture(gls, screen.surface, x, y, w, h);
+        dgs[qemu_console_get_index(dcl->con)].surface_dirty = true;
+    });
+}
+
+static void cocoa_gl_switch(DisplayChangeListener *dcl,
+                            DisplaySurface *new_surface)
+{
+    cocoa_switch(dcl, new_surface);
+
+    with_view_ctx(^{
+        surface_gl_create_texture(gls, new_surface);
+    });
+}
+
+static void cocoa_gl_refresh(DisplayChangeListener *dcl)
+{
+    cocoa_refresh(dcl);
+
+    with_view_ctx(^{
+        DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
+
+        if (dg->surface_dirty && screen.surface) {
+            dg->surface_dirty = false;
+            cocoa_gl_render_surface(dg);
+        }
+    });
+}
+
+static bool cocoa_gl_scanout_get_enabled(void *dg)
+{
+    return ((DisplayGL *)dg)->scanout_id != 0;
+}
+
+static void cocoa_gl_scanout_disable(void *dg)
+{
+    with_view_ctx(^{
+        cocoa_scanout_disable((DisplayGL *)dg);
+    });
+}
+
+static void cocoa_gl_scanout_texture(void *dg,
+                                     uint32_t backing_id,
+                                     DisplayGLTextureBorrower backing_borrow,
+                                     uint32_t x, uint32_t y,
+                                     uint32_t w, uint32_t h)
+{
+    ((DisplayGL *)dg)->scanout_id = backing_id;
+    ((DisplayGL *)dg)->scanout_borrow = backing_borrow;
+}
+
+static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
+                                   uint32_t x, uint32_t y, uint32_t w, uint32_t h)
+{
+    DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
+    bool y0_top;
+
+    if (!dg->scanout_id) {
+        return;
+    }
+
+    GLint texture = dg->scanout_borrow(dg->scanout_id, &y0_top, NULL, NULL);
+    if (!texture) {
+        return;
+    }
+
+    with_view_ctx(^{
+        QemuCocoaView *cocoaView = [appController cocoaView];
+        NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+
+        glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+        glViewport(0, 0, size.width, size.height);
+        glBindTexture(GL_TEXTURE_2D, texture);
+        qemu_gl_run_texture_blit(gls, y0_top);
+
+        cocoa_gl_render_cursor();
+
+        cocoa_gl_flush();
+    });
+}
+
+static void cocoa_gl_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
+{
+    screen.mouse_x = x;
+    screen.mouse_y = y;
+    screen.mouse_on = on;
+
+    DisplayGL *dg = dgs + qemu_console_get_index(dcl->con);
+
+    if (dg->scanout_id) {
+        cocoa_gl_scanout_flush(dcl, 0, 0, 0, 0);
+    } else {
+        with_view_ctx(^{
+            cocoa_gl_render_surface(dg);
+        });
+    }
+}
+
+static void cocoa_gl_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
+{
+    cursor_texture_width = cursor->width;
+    cursor_texture_height = cursor->height;
+
+    with_view_ctx(^{
+        glBindTexture(GL_TEXTURE_2D, cursor_texture);
+        glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, cursor->width);
+        glTexImage2D(GL_TEXTURE_2D, 0,
+                     epoxy_is_desktop_gl() ? GL_RGBA : GL_BGRA,
+                     cursor->width,
+                     cursor->height,
+                     0, GL_BGRA, GL_UNSIGNED_BYTE,
+                     cursor->data);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    });
+}
+
+static const DisplayGLOps dg_ops = {
+    .dpy_gl_ctx_create           = cocoa_gl_create_context,
+    .dpy_gl_ctx_destroy          = cocoa_gl_destroy_context,
+    .dpy_gl_ctx_make_current     = cocoa_gl_make_context_current,
+    .dpy_gl_scanout_get_enabled  = cocoa_gl_scanout_get_enabled,
+    .dpy_gl_scanout_disable      = cocoa_gl_scanout_disable,
+    .dpy_gl_scanout_texture      = cocoa_gl_scanout_texture,
+};
+
+static const DisplayChangeListenerOps dcl_gl_ops = {
+    .dpy_name                = "cocoa-gl",
+    .dpy_gfx_update          = cocoa_gl_update,
+    .dpy_gfx_switch          = cocoa_gl_switch,
+    .dpy_gfx_check_format    = console_gl_check_format,
+    .dpy_refresh             = cocoa_gl_refresh,
+    .dpy_mouse_set           = cocoa_gl_mouse_set,
+    .dpy_cursor_define       = cocoa_gl_cursor_define,
+
+    .dpy_gl_update           = cocoa_gl_scanout_flush,
+};
+
+#endif
+
+static void cocoa_display_early_init(DisplayOptions *o)
+{
+    assert(o->type == DISPLAY_TYPE_COCOA);
+    if (o->has_gl && o->gl) {
+        display_opengl = 1;
+    }
+}
+
+static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
+{
+    COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
+
+    screen.cursor_show = opts->has_show_cursor && opts->show_cursor;
+    screen.swap_option_command = opts->u.cocoa.has_swap_option_command &&
+        opts->u.cocoa.swap_option_command;
+
+    /* Tell main thread to go ahead and create the app and enter the run loop */
+    qemu_sem_post(&display_init_sem);
+    qemu_sem_wait(&app_started_sem);
+    COCOA_DEBUG("cocoa_display_init: app start completed\n");
+
+    /* if fullscreen mode is to be used */
+    if (opts->has_full_screen && opts->full_screen) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            [[[appController cocoaView] window] toggleFullScreen: nil];
+        });
+    }
+    if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            [[appController cocoaView] setFullGrab: nil];
+        });
+    }
+
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        unsigned int console_count = 0;
+        while (qemu_console_lookup_by_index(console_count)) {
+            console_count++;
+        }
+
+        dgs = g_new0(DisplayGL, console_count);
+
+        for (unsigned int index = 0; index < console_count; index++) {
+            QemuConsole *con = qemu_console_lookup_by_index(index);
+            console_set_displayglcontext(con, dgs + index);
+        }
+
+        if (opts->gl == DISPLAYGL_MODE_ES) {
+#ifdef CONFIG_EGL
+            if (qemu_egl_init_dpy_cocoa(DISPLAYGL_MODE_ES)) {
+                exit(1);
+            }
+            view_ctx = qemu_egl_init_ctx();
+            if (!view_ctx) {
+                exit(1);
+            }
+            dispatch_sync(dispatch_get_main_queue(), ^{
+                CALayer *layer = [[appController cocoaView] layer];
+                egl_surface = qemu_egl_init_surface(view_ctx, layer);
+            });
+#else
+            error_report("OpenGLES without EGL is not supported - exiting");
+            exit(1);
+#endif
+        } else {
+            view_ctx = cocoa_gl_create_context_ns(nil, 32);
+#ifdef CONFIG_EGL
+            egl_surface = EGL_NO_SURFACE;
+#endif
+            cocoa_gl_make_context_current(NULL, view_ctx);
+        }
+
+        gls = qemu_gl_init_shader();
+        glGenTextures(1, &cursor_texture);
+
+        // register vga output callbacks
+        screen.dcl.ops = &dcl_gl_ops;
+
+        register_displayglops(&dg_ops);
+#else
+        error_report("OpenGL is not enabled - exiting");
+        exit(1);
+#endif
+    } else {
+        // register vga output callbacks
+        screen.dcl.ops = &dcl_ops;
+    }
+
+    register_displaychangelistener(&screen.dcl);
+    qatomic_store_release(&screen.inited, true);
+
+    qemu_event_init(&qemucb.event, false);
+    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] initWith:&qemucb];
+    qemu_clipboard_peer_register(&cbpeer);
+}
+
+static QemuDisplay qemu_display_cocoa = {
+    .type       = DISPLAY_TYPE_COCOA,
+    .early_init = cocoa_display_early_init,
+    .init       = cocoa_display_init,
+};
+
+static void register_cocoa(void)
+{
+    qemu_display_register(&qemu_display_cocoa);
+}
+
+type_init(register_cocoa);
+
+#ifdef CONFIG_OPENGL
+module_dep("ui-opengl");
+#endif
diff --git a/ui/cocoa/pasteboard_type_owner.m b/ui/cocoa/pasteboard_type_owner.m
index 691366755682..1dd1e987d7dc 100644
--- a/ui/cocoa/pasteboard_type_owner.m
+++ b/ui/cocoa/pasteboard_type_owner.m
@@ -22,5 +22,54 @@
  * THE SOFTWARE.
  */
 
-#define UI_COCOA_PASTEBOARD_TYPE_OWNER
+#include "qemu/osdep.h"
+
 #include "ui/cocoa.h"
+#include "qemu/main-loop.h"
+
+@implementation QemuCocoaPasteboardTypeOwner
+
+- (id)initWith:(QemuCocoaClipboard *)aCb
+{
+    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
+
+    self = [super init];
+    if (self) {
+        cb = aCb;
+    }
+    return self;
+}
+
+- (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
+{
+    if (type != NSPasteboardTypeString) {
+        return;
+    }
+
+    qemu_mutex_lock_iothread();
+
+    QemuClipboardInfo *info = qemu_clipboard_info_ref(cb->info);
+    qemu_event_reset(&cb->event);
+    qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
+
+    while (info == cb->info &&
+           info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
+           info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
+        qemu_mutex_unlock_iothread();
+        qemu_event_wait(&cb->event);
+        qemu_mutex_lock_iothread();
+    }
+
+    if (info == cb->info) {
+        NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
+                                       length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
+        [sender setData:data forType:NSPasteboardTypeString];
+        [data release];
+    }
+
+    qemu_clipboard_info_unref(info);
+
+    qemu_mutex_unlock_iothread();
+}
+
+@end
diff --git a/ui/cocoa/view.m b/ui/cocoa/view.m
index 31f195d224d0..8beb963cbdf3 100644
--- a/ui/cocoa/view.m
+++ b/ui/cocoa/view.m
@@ -22,6 +22,900 @@
  * THE SOFTWARE.
  */
 
-#define UI_COCOA_VIEW
+#include "qemu/osdep.h"
+
 #include "ui/cocoa.h"
+#include "ui/input.h"
+#include "sysemu/sysemu.h"
+#include "qemu/main-loop.h"
+#include "qemu/error-report.h"
+#include <Carbon/Carbon.h>
+
+#define cgrect(nsrect) (*(CGRect *)&(nsrect))
+
+static int cocoa_keycode_to_qemu(int keycode)
+{
+    if (qemu_input_map_osx_to_qcode_len <= keycode) {
+        error_report("(cocoa) warning unknown keycode 0x%x", keycode);
+        return 0;
+    }
+    return qemu_input_map_osx_to_qcode[keycode];
+}
+
+static CGRect compute_cursor_clip_rect(int screen_height,
+                                       int given_mouse_x, int given_mouse_y,
+                                       int cursor_width, int cursor_height)
+{
+    CGRect rect;
+
+    rect.origin.x = MAX(0, -given_mouse_x);
+    rect.origin.y = 0;
+    rect.size.width = MIN(cursor_width, cursor_width + given_mouse_x);
+    rect.size.height = cursor_height - rect.origin.x;
+
+    return rect;
+}
+
+static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
+{
+    QemuCocoaView *cocoaView = (QemuCocoaView*) userInfo;
+    NSEvent* event = [NSEvent eventWithCGEvent:cgEvent];
+    if ([cocoaView isMouseGrabbed] && [cocoaView handleEvent:event]) {
+        COCOA_DEBUG("Global events tap: qemu handled the event, capturing!\n");
+        return NULL;
+    }
+    COCOA_DEBUG("Global events tap: qemu did not handle the event, letting it through...\n");
+
+    return cgEvent;
+}
+
+@implementation QemuCocoaView
+- (id)initWithFrame:(NSRect)frameRect
+             screen:(QEMUScreen *)given_screen
+{
+    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
+
+    self = [super initWithFrame:frameRect];
+    if (self) {
+
+        screen = given_screen;
+        screen_width = frameRect.size.width;
+        screen_height = frameRect.size.height;
+        kbd = qkbd_state_init(screen->dcl.con);
+
+        /* Used for displaying pause on the screen */
+        pauseLabel = [NSTextField new];
+        [pauseLabel setBezeled:YES];
+        [pauseLabel setDrawsBackground:YES];
+        [pauseLabel setBackgroundColor: [NSColor whiteColor]];
+        [pauseLabel setEditable:NO];
+        [pauseLabel setSelectable:NO];
+        [pauseLabel setStringValue: @"Paused"];
+        [pauseLabel setFont: [NSFont fontWithName: @"Helvetica" size: 90]];
+        [pauseLabel setTextColor: [NSColor blackColor]];
+        [pauseLabel sizeToFit];
+
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+    COCOA_DEBUG("QemuCocoaView: dealloc\n");
+
+    if (pauseLabel) {
+        [pauseLabel release];
+    }
+
+    qkbd_state_free(kbd);
+
+    if (eventsTap) {
+        CFRelease(eventsTap);
+    }
+
+    [super dealloc];
+}
+
+- (BOOL) isOpaque
+{
+    return YES;
+}
+
+- (void) removeTrackingRect
+{
+    if (trackingArea) {
+        [self removeTrackingArea:trackingArea];
+        [trackingArea release];
+        trackingArea = nil;
+    }
+}
+
+- (void) frameUpdated
+{
+    [self removeTrackingRect];
+
+    if ([self window]) {
+        NSTrackingAreaOptions options = NSTrackingActiveInKeyWindow |
+                                        NSTrackingMouseEnteredAndExited |
+                                        NSTrackingMouseMoved;
+        trackingArea = [[NSTrackingArea alloc] initWithRect:[self frame]
+                                                    options:options
+                                                      owner:self
+                                                   userInfo:nil];
+        [self addTrackingArea:trackingArea];
+        [self updateUIInfo];
+    }
+}
+
+- (void) viewDidMoveToWindow
+{
+    [self resizeWindow];
+    [self frameUpdated];
+}
+
+- (void) viewWillMoveToWindow:(NSWindow *)newWindow
+{
+    [self removeTrackingRect];
+}
+
+- (void) hideCursor
+{
+    if (screen->cursor_show) {
+        return;
+    }
+    [NSCursor hide];
+}
+
+- (void) unhideCursor
+{
+    if (screen->cursor_show) {
+        return;
+    }
+    [NSCursor unhide];
+}
+
+- (CGRect) convertCursorClipRectToDraw:(CGRect)rect
+                          screenHeight:(int)given_screen_height
+                                mouseX:(int)mouse_x
+                                mouseY:(int)mouse_y
+{
+    CGFloat d = [self frame].size.height / (CGFloat)given_screen_height;
+
+    rect.origin.x = (rect.origin.x + mouse_x) * d;
+    rect.origin.y = (given_screen_height - rect.origin.y - mouse_y - rect.size.height) * d;
+    rect.size.width *= d;
+    rect.size.height *= d;
+
+    return rect;
+}
+
+- (void) drawRect:(NSRect) rect
+{
+    COCOA_DEBUG("QemuCocoaView: drawRect\n");
+
+#ifdef CONFIG_OPENGL
+    if (display_opengl) {
+        return;
+    }
+#endif
+
+    // get CoreGraphic context
+    CGContextRef viewContextRef = [[NSGraphicsContext currentContext] CGContext];
+
+    CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
+    CGContextSetShouldAntialias (viewContextRef, NO);
+
+    qemu_mutex_lock(&screen->draw_mutex);
+
+    // draw screen bitmap directly to Core Graphics context
+    if (!screen->surface) {
+        // Draw request before any guest device has set up a framebuffer:
+        // just draw an opaque black rectangle
+        CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
+        CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
+    } else {
+        int w = surface_width(screen->surface);
+        int h = surface_height(screen->surface);
+        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(screen->surface));
+        int stride = surface_stride(screen->surface);
+
+        CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
+            NULL,
+            surface_data(screen->surface),
+            stride * h,
+            NULL
+        );
+
+        CGImageRef imageRef = CGImageCreate(
+            w, //width
+            h, //height
+            DIV_ROUND_UP(bitsPerPixel, 8) * 2, //bitsPerComponent
+            bitsPerPixel, //bitsPerPixel
+            stride, //bytesPerRow
+            CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
+            kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipFirst, //bitmapInfo
+            dataProviderRef, //provider
+            NULL, //decode
+            0, //interpolate
+            kCGRenderingIntentDefault //intent
+        );
+        // selective drawing code (draws only dirty rectangles) (OS X >= 10.4)
+        const NSRect *rectList;
+        NSInteger rectCount;
+        int i;
+        CGImageRef clipImageRef;
+        CGRect clipRect;
+        CGFloat d = (CGFloat)h / [self frame].size.height;
+
+        [self getRectsBeingDrawn:&rectList count:&rectCount];
+        for (i = 0; i < rectCount; i++) {
+            clipRect.origin.x = rectList[i].origin.x * d;
+            clipRect.origin.y = (float)h - (rectList[i].origin.y + rectList[i].size.height) * d;
+            clipRect.size.width = rectList[i].size.width * d;
+            clipRect.size.height = rectList[i].size.height * d;
+            clipImageRef = CGImageCreateWithImageInRect(
+                                                        imageRef,
+                                                        clipRect
+                                                        );
+            CGContextDrawImage (viewContextRef, cgrect(rectList[i]), clipImageRef);
+            CGImageRelease (clipImageRef);
+        }
+        CGImageRelease (imageRef);
+        CGDataProviderRelease(dataProviderRef);
+
+        if (screen->mouse_on) {
+            size_t cursor_width = CGImageGetWidth(screen->cursor_cgimage);
+            size_t cursor_height = CGImageGetHeight(screen->cursor_cgimage);
+            clipRect = compute_cursor_clip_rect(h, screen->mouse_x, screen->mouse_y,
+                                                cursor_width,
+                                                cursor_height);
+            CGRect drawRect = [self convertCursorClipRectToDraw:clipRect
+                                                   screenHeight:h
+                                                         mouseX:screen->mouse_x
+                                                         mouseY:screen->mouse_y];
+            clipImageRef = CGImageCreateWithImageInRect(
+                                                        screen->cursor_cgimage,
+                                                        clipRect
+                                                        );
+            CGContextDrawImage(viewContextRef, drawRect, clipImageRef);
+            CGImageRelease (clipImageRef);
+        }
+    }
+
+    qemu_mutex_unlock(&screen->draw_mutex);
+}
+
+- (NSSize) computeUnzoomedSize
+{
+    CGFloat width = screen_width / [[self window] backingScaleFactor];
+    CGFloat height = screen_height / [[self window] backingScaleFactor];
+
+    return NSMakeSize(width, height);
+}
+
+- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
+{
+    NSSize size;
+
+    size.width = (CGFloat)screen_width * proposedSize.height;
+    size.height = (CGFloat)screen_height * proposedSize.width;
+
+    if (size.width < size.height) {
+        size.width /= screen_height;
+        size.height = proposedSize.height;
+    } else {
+        size.width = proposedSize.width;
+        size.height /= screen_width;
+    }
+
+    return size;
+}
+
+- (void) resizeWindow
+{
+    [[self window] setContentAspectRatio:NSMakeSize(screen_width, screen_height)];
+
+    if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [[self window] setContentSize:[self computeUnzoomedSize]];
+        [[self window] center];
+    } else if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
+        [[self window] setContentSize:[self fixZoomedFullScreenSize:[[[self window] screen] frame].size]];
+        [[self window] center];
+    }
+}
+
+- (void) updateUIInfo
+{
+    NSSize frameSize;
+    QemuUIInfo info = {};
+
+    if (!qatomic_load_acquire(&screen->inited)) {
+        return;
+    }
+
+    if ([self window]) {
+        NSDictionary *description = [[[self window] screen] deviceDescription];
+        CGDirectDisplayID display = [[description objectForKey:@"NSScreenNumber"] unsignedIntValue];
+        NSSize screenSize = [[[self window] screen] frame].size;
+        CGSize screenPhysicalSize = CGDisplayScreenSize(display);
+        CVDisplayLinkRef displayLink;
+
+        if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) == 0) {
+            frameSize = [self frame].size;
+        } else {
+            frameSize = screenSize;
+        }
+
+        if (!CVDisplayLinkCreateWithCGDisplay(display, &displayLink)) {
+            CVTime period = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink);
+            CVDisplayLinkRelease(displayLink);
+            if (!(period.flags & kCVTimeIsIndefinite)) {
+                update_displaychangelistener(&screen->dcl,
+                                             1000 * period.timeValue / period.timeScale);
+                info.refresh_rate = (int64_t)1000 * period.timeScale / period.timeValue;
+            }
+        }
+
+        info.width_mm = frameSize.width / screenSize.width * screenPhysicalSize.width;
+        info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
+    } else {
+        frameSize = [self frame].size;
+    }
+
+    NSSize frameBackingSize = [self convertSizeToBacking:frameSize];
+
+    info.width = frameBackingSize.width;
+    info.height = frameBackingSize.height;
+
+    dpy_set_ui_info(screen->dcl.con, &info);
+}
+
+- (void) updateScreenWidth:(int)w height:(int)h
+{
+    COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
+
+    if (w != screen_width || h != screen_height) {
+        COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
+        screen_width = w;
+        screen_height = h;
+        [self resizeWindow];
+    }
+}
+
+- (void) setFullGrab:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaView: setFullGrab\n");
+
+    CGEventMask mask = CGEventMaskBit(kCGEventKeyDown) | CGEventMaskBit(kCGEventKeyUp) | CGEventMaskBit(kCGEventFlagsChanged);
+    eventsTap = CGEventTapCreate(kCGHIDEventTap, kCGHeadInsertEventTap, kCGEventTapOptionDefault,
+                                 mask, handleTapEvent, self);
+    if (!eventsTap) {
+        warn_report("Could not create event tap, system key combos will not be captured.\n");
+        return;
+    } else {
+        COCOA_DEBUG("Global events tap created! Will capture system key combos.\n");
+    }
+
+    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
+    if (!runLoop) {
+        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
+        return;
+    }
+
+    CFRunLoopSourceRef tapEventsSrc = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventsTap, 0);
+    if (!tapEventsSrc ) {
+        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
+        return;
+    }
+
+    CFRunLoopAddSource(runLoop, tapEventsSrc, kCFRunLoopDefaultMode);
+    CFRelease(tapEventsSrc);
+}
+
+- (void) toggleKey: (int)keycode {
+    qkbd_state_key_event(kbd, keycode, !qkbd_state_key_get(kbd, keycode));
+}
+
+// Does the work of sending input to the monitor
+- (void) handleMonitorInput:(NSEvent *)event
+{
+    int keysym = 0;
+    int control_key = 0;
+
+    // if the control key is down
+    if ([event modifierFlags] & NSEventModifierFlagControl) {
+        control_key = 1;
+    }
+
+    /* translates Macintosh keycodes to QEMU's keysym */
+
+    int without_control_translation[] = {
+        [0 ... 0xff] = 0,   // invalid key
+
+        [kVK_UpArrow]       = QEMU_KEY_UP,
+        [kVK_DownArrow]     = QEMU_KEY_DOWN,
+        [kVK_RightArrow]    = QEMU_KEY_RIGHT,
+        [kVK_LeftArrow]     = QEMU_KEY_LEFT,
+        [kVK_Home]          = QEMU_KEY_HOME,
+        [kVK_End]           = QEMU_KEY_END,
+        [kVK_PageUp]        = QEMU_KEY_PAGEUP,
+        [kVK_PageDown]      = QEMU_KEY_PAGEDOWN,
+        [kVK_ForwardDelete] = QEMU_KEY_DELETE,
+        [kVK_Delete]        = QEMU_KEY_BACKSPACE,
+    };
+
+    int with_control_translation[] = {
+        [0 ... 0xff] = 0,   // invalid key
+
+        [kVK_UpArrow]       = QEMU_KEY_CTRL_UP,
+        [kVK_DownArrow]     = QEMU_KEY_CTRL_DOWN,
+        [kVK_RightArrow]    = QEMU_KEY_CTRL_RIGHT,
+        [kVK_LeftArrow]     = QEMU_KEY_CTRL_LEFT,
+        [kVK_Home]          = QEMU_KEY_CTRL_HOME,
+        [kVK_End]           = QEMU_KEY_CTRL_END,
+        [kVK_PageUp]        = QEMU_KEY_CTRL_PAGEUP,
+        [kVK_PageDown]      = QEMU_KEY_CTRL_PAGEDOWN,
+    };
+
+    if (control_key != 0) { /* If the control key is being used */
+        if ([event keyCode] < ARRAY_SIZE(with_control_translation)) {
+            keysym = with_control_translation[[event keyCode]];
+        }
+    } else {
+        if ([event keyCode] < ARRAY_SIZE(without_control_translation)) {
+            keysym = without_control_translation[[event keyCode]];
+        }
+    }
+
+    // if not a key that needs translating
+    if (keysym == 0) {
+        NSString *ks = [event characters];
+        if ([ks length] > 0) {
+            keysym = [ks characterAtIndex:0];
+        }
+    }
+
+    if (keysym) {
+        kbd_put_keysym(keysym);
+    }
+}
+
+- (bool) handleEvent:(NSEvent *)event
+{
+    if(!qatomic_read(&screen->inited)) {
+        /*
+         * Just let OSX have all events that arrive before
+         * applicationDidFinishLaunching.
+         * This avoids a deadlock on the iothread lock, which cocoa_display_init()
+         * will not drop until after the app_started_sem is posted. (In theory
+         * there should not be any such events, but OSX Catalina now emits some.)
+         */
+        return false;
+    }
+
+    qemu_mutex_lock_iothread();
+    bool handled = [self handleEventLocked:event];
+    qemu_mutex_unlock_iothread();
+    return handled;
+}
+
+- (bool) handleEventLocked:(NSEvent *)event
+{
+    /* Return true if we handled the event, false if it should be given to OSX */
+    COCOA_DEBUG("QemuCocoaView: handleEvent\n");
+    int keycode = 0;
+    NSUInteger modifiers = [event modifierFlags];
+
+    /*
+     * Check -[NSEvent modifierFlags] here.
+     *
+     * There is a NSEventType for an event notifying the change of
+     * -[NSEvent modifierFlags], NSEventTypeFlagsChanged but these operations
+     * are performed for any events because a modifier state may change while
+     * the application is inactive (i.e. no events fire) and we don't want to
+     * wait for another modifier state change to detect such a change.
+     *
+     * NSEventModifierFlagCapsLock requires a special treatment. The other flags
+     * are handled in similar manners.
+     *
+     * NSEventModifierFlagCapsLock
+     * ---------------------------
+     *
+     * If CapsLock state is changed, "up" and "down" events will be fired in
+     * sequence, effectively updates CapsLock state on the guest.
+     *
+     * The other flags
+     * ---------------
+     *
+     * If a flag is not set, fire "up" events for all keys which correspond to
+     * the flag. Note that "down" events are not fired here because the flags
+     * checked here do not tell what exact keys are down.
+     *
+     * If one of the keys corresponding to a flag is down, we rely on
+     * -[NSEvent keyCode] of an event whose -[NSEvent type] is
+     * NSEventTypeFlagsChanged to know the exact key which is down, which has
+     * the following two downsides:
+     * - It does not work when the application is inactive as described above.
+     * - It malfactions *after* the modifier state is changed while the
+     *   application is inactive. It is because -[NSEvent keyCode] does not tell
+     *   if the key is up or down, and requires to infer the current state from
+     *   the previous state. It is still possible to fix such a malfanction by
+     *   completely leaving your hands from the keyboard, which hopefully makes
+     *   this implementation usable enough.
+     */
+    if (!!(modifiers & NSEventModifierFlagCapsLock) !=
+        qkbd_state_modifier_get(kbd, QKBD_MOD_CAPSLOCK)) {
+        qkbd_state_key_event(kbd, Q_KEY_CODE_CAPS_LOCK, true);
+        qkbd_state_key_event(kbd, Q_KEY_CODE_CAPS_LOCK, false);
+    }
+
+    if (!(modifiers & NSEventModifierFlagShift)) {
+        qkbd_state_key_event(kbd, Q_KEY_CODE_SHIFT, false);
+        qkbd_state_key_event(kbd, Q_KEY_CODE_SHIFT_R, false);
+    }
+    if (!(modifiers & NSEventModifierFlagControl)) {
+        qkbd_state_key_event(kbd, Q_KEY_CODE_CTRL, false);
+        qkbd_state_key_event(kbd, Q_KEY_CODE_CTRL_R, false);
+    }
+    if (!(modifiers & NSEventModifierFlagOption)) {
+        if ([self isSwapOptionCommandEnabled]) {
+            qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
+            qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
+        } else {
+            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
+            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
+        }
+    }
+    if (!(modifiers & NSEventModifierFlagCommand)) {
+        if ([self isSwapOptionCommandEnabled]) {
+            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
+            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
+        } else {
+            qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
+            qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
+        }
+    }
+
+    switch ([event type]) {
+        case NSEventTypeFlagsChanged:
+            switch ([event keyCode]) {
+                case kVK_Shift:
+                    if (!!(modifiers & NSEventModifierFlagShift)) {
+                        [self toggleKey:Q_KEY_CODE_SHIFT];
+                    }
+                    return true;
+
+                case kVK_RightShift:
+                    if (!!(modifiers & NSEventModifierFlagShift)) {
+                        [self toggleKey:Q_KEY_CODE_SHIFT_R];
+                    }
+                    return true;
+
+                case kVK_Control:
+                    if (!!(modifiers & NSEventModifierFlagControl)) {
+                        [self toggleKey:Q_KEY_CODE_CTRL];
+                    }
+                    return true;
+
+                case kVK_RightControl:
+                    if (!!(modifiers & NSEventModifierFlagControl)) {
+                        [self toggleKey:Q_KEY_CODE_CTRL_R];
+                    }
+                    return true;
+
+                case kVK_Option:
+                    if (!!(modifiers & NSEventModifierFlagOption)) {
+                        if ([self isSwapOptionCommandEnabled]) {
+                            [self toggleKey:Q_KEY_CODE_META_L];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_ALT];
+                        }
+                    }
+                    return true;
+
+                case kVK_RightOption:
+                    if (!!(modifiers & NSEventModifierFlagOption)) {
+                        if ([self isSwapOptionCommandEnabled]) {
+                            [self toggleKey:Q_KEY_CODE_META_R];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_ALT_R];
+                        }
+                    }
+                    return true;
+
+                /* Don't pass command key changes to guest unless mouse is grabbed */
+                case kVK_Command:
+                    if (isMouseGrabbed &&
+                        !!(modifiers & NSEventModifierFlagCommand)) {
+                        if ([self isSwapOptionCommandEnabled]) {
+                            [self toggleKey:Q_KEY_CODE_ALT];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_META_L];
+                        }
+                    }
+                    return true;
+
+                case kVK_RightCommand:
+                    if (isMouseGrabbed &&
+                        !!(modifiers & NSEventModifierFlagCommand)) {
+                        if ([self isSwapOptionCommandEnabled]) {
+                            [self toggleKey:Q_KEY_CODE_ALT_R];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_META_R];
+                        }
+                    }
+                    return true;
+
+                default:
+                    return true;
+            }
+        case NSEventTypeKeyDown:
+            keycode = cocoa_keycode_to_qemu([event keyCode]);
+
+            // forward command key combos to the host UI unless the mouse is grabbed
+            if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
+                return false;
+            }
+
+            // default
+
+            // handle control + alt Key Combos (ctrl+alt+[1..9,g] is reserved for QEMU)
+            if (([event modifierFlags] & NSEventModifierFlagControl) && ([event modifierFlags] & NSEventModifierFlagOption)) {
+                NSString *keychar = [event charactersIgnoringModifiers];
+                if ([keychar length] == 1) {
+                    char key = [keychar characterAtIndex:0];
+                    switch (key) {
+
+                        // enable graphic console
+                        case '1' ... '9':
+                            console_select(key - '0' - 1); /* ascii math */
+                            return true;
+
+                        // release the mouse grab
+                        case 'g':
+                            [self ungrabMouseLocked];
+                            return true;
+                    }
+                }
+            }
+
+            if (qemu_console_is_graphic(NULL)) {
+                qkbd_state_key_event(kbd, keycode, true);
+            } else {
+                [self handleMonitorInput: event];
+            }
+            return true;
+        case NSEventTypeKeyUp:
+            keycode = cocoa_keycode_to_qemu([event keyCode]);
+
+            // don't pass the guest a spurious key-up if we treated this
+            // command-key combo as a host UI action
+            if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
+                return true;
+            }
+
+            if (qemu_console_is_graphic(NULL)) {
+                qkbd_state_key_event(kbd, keycode, false);
+            }
+            return true;
+        case NSEventTypeScrollWheel:
+            /*
+             * Send wheel events to the guest regardless of window focus.
+             * This is in-line with standard Mac OS X UI behaviour.
+             */
+
+            /*
+             * When deltaY is zero, it means that this scrolling event was
+             * either horizontal, or so fine that it only appears in
+             * scrollingDeltaY. So we drop the event.
+             */
+            if ([event deltaY] != 0) {
+            /* Determine if this is a scroll up or scroll down event */
+                int buttons = ([event deltaY] > 0) ?
+                    INPUT_BUTTON_WHEEL_UP : INPUT_BUTTON_WHEEL_DOWN;
+                qemu_input_queue_btn(screen->dcl.con, buttons, true);
+                qemu_input_event_sync();
+                qemu_input_queue_btn(screen->dcl.con, buttons, false);
+                qemu_input_event_sync();
+            }
+            /*
+             * Since deltaY also reports scroll wheel events we prevent mouse
+             * movement code from executing.
+             */
+            return true;
+        default:
+            return false;
+    }
+}
+
+- (void) handleMouseEvent:(NSEvent *)event
+{
+    if (!isMouseGrabbed) {
+        return;
+    }
+
+    qemu_mutex_lock_iothread();
+
+    if (isAbsoluteEnabled) {
+        CGFloat d = (CGFloat)screen_height / [self frame].size.height;
+        NSPoint p = [event locationInWindow];
+        // Note that the origin for Cocoa mouse coords is bottom left, not top left.
+        qemu_input_queue_abs(screen->dcl.con, INPUT_AXIS_X, p.x * d, 0, screen_width);
+        qemu_input_queue_abs(screen->dcl.con, INPUT_AXIS_Y, screen_height - p.y * d, 0, screen_height);
+    } else {
+        CGFloat d = (CGFloat)screen_height / [self convertSizeToBacking:[self frame].size].height;
+        qemu_input_queue_rel(screen->dcl.con, INPUT_AXIS_X, [event deltaX] * d);
+        qemu_input_queue_rel(screen->dcl.con, INPUT_AXIS_Y, [event deltaY] * d);
+    }
+
+    qemu_input_event_sync();
+
+    qemu_mutex_unlock_iothread();
+}
+
+- (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool)down
+{
+    if (!isMouseGrabbed) {
+        return;
+    }
+
+    qemu_mutex_lock_iothread();
+    qemu_input_queue_btn(screen->dcl.con, button, down);
+    qemu_mutex_unlock_iothread();
+
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseExited:(NSEvent *)event
+{
+    if (isAbsoluteEnabled && isMouseGrabbed) {
+        [self ungrabMouse];
+    }
+}
+
+- (void) mouseEntered:(NSEvent *)event
+{
+    if (isAbsoluteEnabled && !isMouseGrabbed) {
+        [self grabMouse];
+    }
+}
+
+- (void) mouseMoved:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:true];
+}
+
+- (void) rightMouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:true];
+}
+
+- (void) otherMouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:true];
+}
+
+- (void) mouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) rightMouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) otherMouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseUp:(NSEvent *)event
+{
+    if (!isMouseGrabbed) {
+        [self grabMouse];
+    }
+
+    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:false];
+}
+
+- (void) rightMouseUp:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:false];
+}
+
+- (void) otherMouseUp:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:false];
+}
+
+- (void) grabMouse
+{
+    COCOA_DEBUG("QemuCocoaView: grabMouse\n");
+
+    if (qemu_name)
+        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
+    else
+        [[self window] setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
+    [self hideCursor];
+    CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
+    isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
+}
+
+- (void) ungrabMouse
+{
+    qemu_mutex_lock_iothread();
+    [self ungrabMouseLocked];
+    qemu_mutex_unlock_iothread();
+}
+
+- (void) ungrabMouseLocked
+{
+    COCOA_DEBUG("QemuCocoaView: ungrabMouseLocked\n");
+
+    if (qemu_name)
+        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
+    else
+        [[self window] setTitle:@"QEMU"];
+    [self unhideCursor];
+    CGAssociateMouseAndMouseCursorPosition(TRUE);
+    isMouseGrabbed = FALSE;
+    [self raiseAllButtonsLocked];
+}
+
+- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
+    isAbsoluteEnabled = tIsAbsoluteEnabled;
+    if (isMouseGrabbed) {
+        CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
+    }
+}
+- (BOOL) isMouseGrabbed {return isMouseGrabbed;}
+- (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
+- (BOOL) isSwapOptionCommandEnabled {return screen->swap_option_command;}
+
+- (void) raiseAllButtonsLocked
+{
+    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_LEFT, false);
+    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_RIGHT, false);
+    qemu_input_queue_btn(screen->dcl.con, INPUT_BUTTON_MIDDLE, false);
+}
+
+- (void) setNeedsDisplayForCursorX:(int)x
+                                 y:(int)y
+                             width:(int)width
+                            height:(int)height
+                      screenHeight:(int)given_screen_height
+{
+    CGRect clip_rect = compute_cursor_clip_rect(given_screen_height, x, y,
+                                                width, height);
+    CGRect draw_rect = [self convertCursorClipRectToDraw:clip_rect
+                                            screenHeight:given_screen_height
+                                                  mouseX:x
+                                                  mouseY:y];
+    [self setNeedsDisplayInRect:draw_rect];
+}
+
+/* Displays the word pause on the screen */
+- (void)displayPause
+{
+    /* Coordinates have to be calculated each time because the window can change its size */
+    int xCoord, yCoord, width, height;
+    xCoord = ([[self window] frame].size.width - [pauseLabel frame].size.width)/2;
+    yCoord = [[self window] frame].size.height - [pauseLabel frame].size.height - ([pauseLabel frame].size.height * .5);
+    width = [pauseLabel frame].size.width;
+    height = [pauseLabel frame].size.height;
+    [pauseLabel setFrame: NSMakeRect(xCoord, yCoord, width, height)];
+    [self addSubview: pauseLabel];
+}
 
+/* Removes the word pause from the screen */
+- (void)removePause
+{
+    [pauseLabel removeFromSuperview];
+}
+@end

From 1b10cab21aa01a21995f2bc75d092de37fba90ba Mon Sep 17 00:00:00 2001
From: Phillip Tennen <phillip@axleos.com>
Date: Mon, 15 Mar 2021 19:32:09 +0900
Subject: [PATCH 107/180] net/macos: implement vmnet-based netdev
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This patch implements a new netdev device, reachable via -netdev
vmnet-macos, that’s backed by macOS’s vmnet framework.

The vmnet framework provides native bridging support, and its usage in
this patch is intended as a replacement for attempts to use a tap device
via the tuntaposx kernel extension. Notably, the tap/tuntaposx approach
never would have worked in the first place, as QEMU interacts with the
tap device via poll(), and macOS does not support polling device files.

vmnet requires either a special entitlement, granted via a provisioning
profile, or root access. Otherwise attempts to create the virtual
interface will fail with a “generic error” status code. QEMU may not
currently be signed with an entitlement granted in a provisioning
profile, as this would necessitate pre-signed binary build distribution,
rather than source-code distribution. As such, using this netdev
currently requires that qemu be run with root access. I’ve opened a
feedback report with Apple to allow the use of the relevant entitlement
with this use case:
https://openradar.appspot.com/radar?id=5007417364447232

vmnet offers three operating modes, all of which are supported by this
patch via the “mode=host|shared|bridge” option:

* "Host" mode: Allows the vmnet interface to communicate with other
* vmnet
interfaces that are in host mode and also with the native host.
* "Shared" mode: Allows traffic originating from the vmnet interface to
reach the Internet through a NAT. The vmnet interface can also
communicate with the native host.
* "Bridged" mode: Bridges the vmnet interface with a physical network
interface.

Each of these modes also provide some extra configuration that’s
supported by this patch:

* "Bridged" mode: The user may specify the physical interface to bridge
with. Defaults to en0.
* "Host" mode / "Shared" mode: The user may specify the DHCP range and
subnet. Allocated by vmnet if not provided.

vmnet also offers some extra configuration options that are not
supported by this patch:

* Enable isolation from other VMs using vmnet
* Port forwarding rules
* Enabling TCP segmentation offload
* Only applicable in "shared" mode: specifying the NAT IPv6 prefix
* Only available in "host" mode: specifying the IP address for the VM
within an isolated network

Note that this patch requires macOS 10.15 as a minimum, as this is when
bridging support was implemented in vmnet.framework.

Rebased to commit 9aef0954195cc592e86846dbbe7f3c2c5603690a by Akihiko
Odaki.

Signed-off-by: Phillip Tennen <phillip@axleos.com>
Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
Message-Id: <20210315103209.20870-1-akihiko.odaki@gmail.com>
---
 meson.build       |   3 +
 net/clients.h     |   5 +
 net/meson.build   |   1 +
 net/net.c         |   3 +
 net/vmnet-macos.c | 447 ++++++++++++++++++++++++++++++++++++++++++++++
 qapi/net.json     | 120 ++++++++++++-
 qemu-options.hx   |   9 +
 7 files changed, 586 insertions(+), 2 deletions(-)
 create mode 100644 net/vmnet-macos.c

diff --git a/meson.build b/meson.build
index ed1bfee6e13f..6d4d26ab943e 100644
--- a/meson.build
+++ b/meson.build
@@ -180,6 +180,7 @@ socket = []
 version_res = []
 coref = []
 iokit = []
+vmnet = not_found
 emulator_link_args = []
 nvmm =not_found
 hvf = not_found
@@ -194,6 +195,7 @@ if targetos == 'windows'
 elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
   iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
+  vmnet = dependency('appleframeworks', modules: 'vmnet')
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
             cc.find_library('nsl'),
@@ -1264,6 +1266,7 @@ config_host_data.set('CONFIG_FUSE', fuse.found())
 config_host_data.set('CONFIG_FUSE_LSEEK', fuse_lseek.found())
 config_host_data.set('CONFIG_X11', x11.found())
 config_host_data.set('CONFIG_CFI', get_option('cfi'))
+config_host_data.set('CONFIG_VMNET', vmnet.found())
 config_host_data.set('QEMU_VERSION', '"@0@"'.format(meson.project_version()))
 config_host_data.set('QEMU_VERSION_MAJOR', meson.project_version().split('.')[0])
 config_host_data.set('QEMU_VERSION_MINOR', meson.project_version().split('.')[1])
diff --git a/net/clients.h b/net/clients.h
index 92f9b59aedce..2c2af67f82ab 100644
--- a/net/clients.h
+++ b/net/clients.h
@@ -63,4 +63,9 @@ int net_init_vhost_user(const Netdev *netdev, const char *name,
 
 int net_init_vhost_vdpa(const Netdev *netdev, const char *name,
                         NetClientState *peer, Error **errp);
+
+#ifdef CONFIG_VMNET
+int net_init_vmnet_macos(const Netdev *netdev, const char *name,
+                        NetClientState *peer, Error **errp);
+#endif
 #endif /* QEMU_NET_CLIENTS_H */
diff --git a/net/meson.build b/net/meson.build
index 1076b0a7ab43..ba6a5b7fa0ba 100644
--- a/net/meson.build
+++ b/net/meson.build
@@ -37,5 +37,6 @@ endif
 softmmu_ss.add(when: 'CONFIG_POSIX', if_true: files(tap_posix))
 softmmu_ss.add(when: 'CONFIG_WIN32', if_true: files('tap-win32.c'))
 softmmu_ss.add(when: 'CONFIG_VHOST_NET_VDPA', if_true: files('vhost-vdpa.c'))
+softmmu_ss.add(when: vmnet, if_true: files('vmnet-macos.c'))
 
 subdir('can')
diff --git a/net/net.c b/net/net.c
index 76bbb7c31b49..e753063a275a 100644
--- a/net/net.c
+++ b/net/net.c
@@ -1001,6 +1001,9 @@ static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
 #ifdef CONFIG_L2TPV3
         [NET_CLIENT_DRIVER_L2TPV3]    = net_init_l2tpv3,
 #endif
+#ifdef CONFIG_VMNET
+        [NET_CLIENT_DRIVER_VMNET_MACOS] = net_init_vmnet_macos,
+#endif
 };
 
 
diff --git a/net/vmnet-macos.c b/net/vmnet-macos.c
new file mode 100644
index 000000000000..062ba2091e87
--- /dev/null
+++ b/net/vmnet-macos.c
@@ -0,0 +1,447 @@
+/*
+ * vmnet.framework backed netdev for macOS 10.15+ hosts
+ *
+ * Copyright (c) 2021 Phillip Tennen <phillip@axleos.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+#include "qemu/osdep.h"
+#include "qemu/main-loop.h"
+#include "qemu/error-report.h"
+#include "qapi/qapi-types-net.h"
+#include "net/net.h"
+/* macOS vmnet framework header */
+#include <vmnet/vmnet.h>
+
+typedef struct vmnet_state {
+    NetClientState nc;
+    interface_ref vmnet_iface_ref;
+    /* Switched on after vmnet informs us that the interface has started */
+    bool link_up;
+    /*
+     * If qemu_send_packet_async returns 0, this is switched off until our
+     * delivery callback is invoked
+     */
+    bool qemu_ready_to_receive;
+} vmnet_state_t;
+
+int net_init_vmnet_macos(const Netdev *netdev, const char *name,
+                         NetClientState *peer, Error **errp);
+
+static const char *_vmnet_status_repr(vmnet_return_t status)
+{
+    switch (status) {
+    case VMNET_SUCCESS:
+        return "success";
+    case VMNET_FAILURE:
+        return "generic failure";
+    case VMNET_MEM_FAILURE:
+        return "out of memory";
+    case VMNET_INVALID_ARGUMENT:
+        return "invalid argument";
+    case VMNET_SETUP_INCOMPLETE:
+        return "setup is incomplete";
+    case VMNET_INVALID_ACCESS:
+        return "insufficient permissions";
+    case VMNET_PACKET_TOO_BIG:
+        return "packet size exceeds MTU";
+    case VMNET_BUFFER_EXHAUSTED:
+        return "kernel buffers temporarily exhausted";
+    case VMNET_TOO_MANY_PACKETS:
+        return "number of packets exceeds system limit";
+    /* This error code was introduced in macOS 11.0 */
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
+    case VMNET_SHARING_SERVICE_BUSY:
+        return "sharing service busy";
+#endif
+    default:
+        return "unknown status code";
+    }
+}
+
+static operating_modes_t _vmnet_operating_mode_enum_compat(
+    VmnetOperatingMode mode)
+{
+    switch (mode) {
+    case VMNET_OPERATING_MODE_HOST:
+        return VMNET_HOST_MODE;
+    case VMNET_OPERATING_MODE_SHARED:
+        return VMNET_SHARED_MODE;
+    case VMNET_OPERATING_MODE_BRIDGED:
+        return VMNET_BRIDGED_MODE;
+    default:
+        /* Should never happen as the modes are parsed before we get here */
+        assert(false);
+    }
+}
+
+static bool vmnet_can_receive(NetClientState *nc)
+{
+    vmnet_state_t *s = DO_UPCAST(vmnet_state_t, nc, nc);
+    return s->link_up;
+}
+
+static ssize_t vmnet_receive_iov(NetClientState *nc,
+                                 const struct iovec *iovs,
+                                 int iovcnt)
+{
+    vmnet_state_t *s = DO_UPCAST(vmnet_state_t, nc, nc);
+
+    /* Combine the provided iovs into a single vmnet packet */
+    struct vmpktdesc *packet = g_new0(struct vmpktdesc, 1);
+    packet->vm_pkt_iov = g_new0(struct iovec, iovcnt);
+    memcpy(packet->vm_pkt_iov, iovs, sizeof(struct iovec) * iovcnt);
+    packet->vm_pkt_iovcnt = iovcnt;
+    packet->vm_flags = 0;
+
+    /* Figure out the packet size by iterating the iov's */
+    for (int i = 0; i < iovcnt; i++) {
+        const struct iovec *iov = iovs + i;
+        packet->vm_pkt_size += iov->iov_len;
+    }
+
+    /* Finally, write the packet to the vmnet interface */
+    int packet_count = 1;
+    vmnet_return_t result = vmnet_write(s->vmnet_iface_ref, packet,
+                                        &packet_count);
+    if (result != VMNET_SUCCESS || packet_count != 1) {
+        error_printf("Failed to send packet to host: %s\n",
+            _vmnet_status_repr(result));
+    }
+    ssize_t wrote_bytes = packet->vm_pkt_size;
+    g_free(packet->vm_pkt_iov);
+    g_free(packet);
+    return wrote_bytes;
+}
+
+static void vmnet_send_completed(NetClientState *nc, ssize_t len)
+{
+    vmnet_state_t *vmnet_client_state = DO_UPCAST(vmnet_state_t, nc, nc);
+    /* Ready to receive more packets! */
+    vmnet_client_state->qemu_ready_to_receive = true;
+}
+
+static NetClientInfo net_vmnet_macos_info = {
+    .type = NET_CLIENT_DRIVER_VMNET_MACOS,
+    .size = sizeof(vmnet_state_t),
+    .receive_iov = vmnet_receive_iov,
+    .can_receive = vmnet_can_receive,
+};
+
+static bool _validate_ifname_is_valid_bridge_target(const char *ifname)
+{
+    /* Iterate available bridge interfaces, ensure the provided one is valid */
+    xpc_object_t bridge_interfaces = vmnet_copy_shared_interface_list();
+    bool failed_to_match_iface_name = xpc_array_apply(
+        bridge_interfaces,
+        ^bool(size_t index, xpc_object_t  _Nonnull value) {
+        if (!strcmp(xpc_string_get_string_ptr(value), ifname)) {
+            /* The interface name is valid! Stop iterating */
+            return false;
+        }
+        return true;
+    });
+
+    if (failed_to_match_iface_name) {
+        error_printf("Invalid bridge interface name provided: %s\n", ifname);
+        error_printf("Valid bridge interfaces:\n");
+        xpc_array_apply(
+            vmnet_copy_shared_interface_list(),
+            ^bool(size_t index, xpc_object_t  _Nonnull value) {
+            error_printf("\t%s\n", xpc_string_get_string_ptr(value));
+            /* Keep iterating */
+            return true;
+        });
+        exit(1);
+        return false;
+    }
+
+    return true;
+}
+
+static xpc_object_t _construct_vmnet_interface_description(
+    const NetdevVmnetModeOptions *vmnet_opts)
+{
+    operating_modes_t mode = _vmnet_operating_mode_enum_compat(
+        vmnet_opts->mode);
+
+    /* Validate options */
+    if (mode == VMNET_HOST_MODE || mode == VMNET_SHARED_MODE) {
+        NetdevVmnetModeOptionsHostOrShared mode_opts = vmnet_opts->u.host;
+        /* If one DHCP parameter is configured, all 3 are required */
+        if (mode_opts.has_dhcp_start_address ||
+            mode_opts.has_dhcp_end_address ||
+            mode_opts.has_dhcp_subnet_mask) {
+            if (!(mode_opts.has_dhcp_start_address &&
+                  mode_opts.has_dhcp_end_address &&
+                  mode_opts.has_dhcp_subnet_mask)) {
+                error_printf("Incomplete DHCP configuration provided\n");
+                exit(1);
+            }
+        }
+    } else if (mode == VMNET_BRIDGED_MODE) {
+        /* Nothing to validate */
+    } else {
+        error_printf("Unknown vmnet mode %d\n", mode);
+        exit(1);
+    }
+
+    xpc_object_t interface_desc = xpc_dictionary_create(NULL, NULL, 0);
+    xpc_dictionary_set_uint64(
+        interface_desc,
+        vmnet_operation_mode_key,
+        mode
+    );
+
+    if (mode == VMNET_BRIDGED_MODE) {
+        /*
+         * Configure the provided physical interface to act
+         * as a bridge with QEMU
+         */
+        NetdevVmnetModeOptionsBridged mode_opts = vmnet_opts->u.bridged;
+        /* Bridge with en0 by default */
+        const char *physical_ifname = mode_opts.has_ifname ? mode_opts.ifname :
+                                                             "en0";
+        _validate_ifname_is_valid_bridge_target(physical_ifname);
+        xpc_dictionary_set_string(interface_desc,
+                                  vmnet_shared_interface_name_key,
+                                  physical_ifname);
+    } else if (mode == VMNET_HOST_MODE || mode == VMNET_SHARED_MODE) {
+        /* Pass the DHCP configuration to vmnet, if the user provided one */
+        NetdevVmnetModeOptionsHostOrShared mode_opts = vmnet_opts->u.host;
+        if (mode_opts.has_dhcp_start_address) {
+            /* All DHCP arguments are available, as per the checks above */
+            xpc_dictionary_set_string(interface_desc,
+                                      vmnet_start_address_key,
+                                      mode_opts.dhcp_start_address);
+            xpc_dictionary_set_string(interface_desc,
+                                      vmnet_end_address_key,
+                                      mode_opts.dhcp_end_address);
+            xpc_dictionary_set_string(interface_desc,
+                                      vmnet_subnet_mask_key,
+                                      mode_opts.dhcp_subnet_mask);
+        }
+    }
+
+    return interface_desc;
+}
+
+int net_init_vmnet_macos(const Netdev *netdev, const char *name,
+                        NetClientState *peer, Error **errp)
+{
+    assert(netdev->type == NET_CLIENT_DRIVER_VMNET_MACOS);
+
+    NetdevVmnetModeOptions *vmnet_opts = netdev->u.vmnet_macos.options;
+    xpc_object_t iface_desc = _construct_vmnet_interface_description(vmnet_opts);
+
+    NetClientState *nc = qemu_new_net_client(&net_vmnet_macos_info, peer,
+                                             "vmnet", name);
+    vmnet_state_t *vmnet_client_state = DO_UPCAST(vmnet_state_t, nc, nc);
+
+    dispatch_queue_t vmnet_dispatch_queue = dispatch_queue_create(
+        "org.qemu.vmnet.iface_queue",
+        DISPATCH_QUEUE_SERIAL
+    );
+
+    __block vmnet_return_t vmnet_start_status = 0;
+    __block uint64_t vmnet_iface_mtu = 0;
+    __block uint64_t vmnet_max_packet_size = 0;
+    __block const char *vmnet_mac_address = NULL;
+    /*
+     * We can't refer to an array type directly within a block,
+     * so hold a pointer instead.
+     */
+    uuid_string_t vmnet_iface_uuid = {0};
+    __block uuid_string_t *vmnet_iface_uuid_ptr = &vmnet_iface_uuid;
+    /* These are only provided in VMNET_HOST_MODE and VMNET_SHARED_MODE */
+    bool vmnet_provides_dhcp_info = (
+        vmnet_opts->mode == VMNET_OPERATING_MODE_HOST ||
+        vmnet_opts->mode == VMNET_OPERATING_MODE_SHARED);
+    __block const char *vmnet_subnet_mask = NULL;
+    __block const char *vmnet_dhcp_range_start = NULL;
+    __block const char *vmnet_dhcp_range_end = NULL;
+
+    /* Create the vmnet interface */
+    dispatch_semaphore_t vmnet_iface_sem = dispatch_semaphore_create(0);
+    interface_ref vmnet_iface_ref = vmnet_start_interface(
+        iface_desc,
+        vmnet_dispatch_queue,
+        ^(vmnet_return_t status, xpc_object_t  _Nullable interface_param) {
+        vmnet_start_status = status;
+        if (vmnet_start_status != VMNET_SUCCESS || !interface_param) {
+            /* Early return if the interface couldn't be started */
+            dispatch_semaphore_signal(vmnet_iface_sem);
+            return;
+        }
+
+        /*
+         * Read the configuration that vmnet provided us.
+         * The provided dictionary is owned by XPC and may be freed
+         * shortly after this block's execution.
+         * So, copy data buffers now.
+         */
+        vmnet_iface_mtu = xpc_dictionary_get_uint64(
+            interface_param,
+            vmnet_mtu_key
+        );
+        vmnet_max_packet_size = xpc_dictionary_get_uint64(
+            interface_param,
+            vmnet_max_packet_size_key
+        );
+        vmnet_mac_address = strdup(xpc_dictionary_get_string(
+            interface_param,
+            vmnet_mac_address_key
+        ));
+
+        const uint8_t *iface_uuid = xpc_dictionary_get_uuid(
+            interface_param,
+            vmnet_interface_id_key
+        );
+        uuid_unparse_upper(iface_uuid, *vmnet_iface_uuid_ptr);
+
+        /* If we're in a mode that provides DHCP info, read it out now */
+        if (vmnet_provides_dhcp_info) {
+            vmnet_dhcp_range_start = strdup(xpc_dictionary_get_string(
+                interface_param,
+                vmnet_start_address_key
+            ));
+            vmnet_dhcp_range_end = strdup(xpc_dictionary_get_string(
+                interface_param,
+                vmnet_end_address_key
+            ));
+            vmnet_subnet_mask = strdup(xpc_dictionary_get_string(
+                interface_param,
+                vmnet_subnet_mask_key
+            ));
+        }
+        dispatch_semaphore_signal(vmnet_iface_sem);
+    });
+
+    /* And block until we receive a response from vmnet */
+    dispatch_semaphore_wait(vmnet_iface_sem, DISPATCH_TIME_FOREVER);
+
+    /* Did we manage to start the interface? */
+    if (vmnet_start_status != VMNET_SUCCESS || !vmnet_iface_ref) {
+        error_printf("Failed to start interface: %s\n",
+            _vmnet_status_repr(vmnet_start_status));
+        if (vmnet_start_status == VMNET_FAILURE) {
+            error_printf("Hint: vmnet requires running with root access\n");
+        }
+        return -1;
+    }
+
+    info_report("Started vmnet interface with configuration:");
+    info_report("MTU:              %llu", vmnet_iface_mtu);
+    info_report("Max packet size:  %llu", vmnet_max_packet_size);
+    info_report("MAC:              %s", vmnet_mac_address);
+    if (vmnet_provides_dhcp_info) {
+        info_report("DHCP IPv4 start:  %s", vmnet_dhcp_range_start);
+        info_report("DHCP IPv4 end:    %s", vmnet_dhcp_range_end);
+        info_report("IPv4 subnet mask: %s", vmnet_subnet_mask);
+    }
+    info_report("UUID:             %s", vmnet_iface_uuid);
+
+    /* The interface is up! Set a block to run when packets are received */
+    vmnet_client_state->vmnet_iface_ref = vmnet_iface_ref;
+    vmnet_return_t event_cb_stat = vmnet_interface_set_event_callback(
+        vmnet_iface_ref,
+        VMNET_INTERFACE_PACKETS_AVAILABLE,
+        vmnet_dispatch_queue,
+        ^(interface_event_t event_mask, xpc_object_t  _Nonnull event) {
+        if (event_mask != VMNET_INTERFACE_PACKETS_AVAILABLE) {
+            error_printf("Unknown vmnet interface event 0x%08x\n", event_mask);
+            return;
+        }
+
+        /* If we're unable to handle more packets now, drop this packet */
+        if (!vmnet_client_state->qemu_ready_to_receive) {
+            return;
+        }
+
+        /*
+         * TODO(Phillip Tennen <phillip@axleos.com>): There may be more than
+         * one packet available.
+         * As an optimization, we could read
+         * vmnet_estimated_packets_available_key packets now.
+         */
+        char *packet_buf = g_malloc0(vmnet_max_packet_size);
+        struct iovec *iov = g_new0(struct iovec, 1);
+        iov->iov_base = packet_buf;
+        iov->iov_len = vmnet_max_packet_size;
+
+        int pktcnt = 1;
+        struct vmpktdesc *v = g_new0(struct vmpktdesc, pktcnt);
+        v->vm_pkt_size = vmnet_max_packet_size;
+        v->vm_pkt_iov = iov;
+        v->vm_pkt_iovcnt = 1;
+        v->vm_flags = 0;
+
+        vmnet_return_t result = vmnet_read(vmnet_iface_ref, v, &pktcnt);
+        if (result != VMNET_SUCCESS) {
+            error_printf("Failed to read packet from host: %s\n",
+                _vmnet_status_repr(result));
+        }
+
+        /* Ensure we read exactly one packet */
+        assert(pktcnt == 1);
+
+        /* Dispatch this block to a global queue instead of the main queue,
+         * which is only created when the program has a Cocoa event loop.
+         * If QEMU is started with -nographic, no Cocoa event loop will be
+         * created and thus the main queue will be unavailable.
+         */
+        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,
+                                                 0),
+                       ^{
+            qemu_mutex_lock_iothread();
+
+            /*
+             * Deliver the packet to the guest
+             * If the delivery succeeded synchronously, this returns the length
+             * of the sent packet.
+             */
+            if (qemu_send_packet_async(nc, iov->iov_base,
+                                       v->vm_pkt_size,
+                                       vmnet_send_completed) == 0) {
+                vmnet_client_state->qemu_ready_to_receive = false;
+            }
+
+            /*
+             * It's safe to free the packet buffers.
+             * Even if delivery needs to wait, qemu_net_queue_append copies
+             * the packet buffer.
+             */
+            g_free(v);
+            g_free(iov);
+            g_free(packet_buf);
+
+            qemu_mutex_unlock_iothread();
+        });
+    });
+
+    /* Did we manage to set an event callback? */
+    if (event_cb_stat != VMNET_SUCCESS) {
+        error_printf("Failed to set up a callback to receive packets: %s\n",
+            _vmnet_status_repr(vmnet_start_status));
+        exit(1);
+    }
+
+    /* We're now ready to receive packets */
+    vmnet_client_state->qemu_ready_to_receive = true;
+    vmnet_client_state->link_up = true;
+
+    /* Include DHCP info if we're in a relevant mode */
+    if (vmnet_provides_dhcp_info) {
+        snprintf(nc->info_str, sizeof(nc->info_str),
+                 "dhcp_start=%s,dhcp_end=%s,mask=%s",
+                 vmnet_dhcp_range_start, vmnet_dhcp_range_end,
+                 vmnet_subnet_mask);
+    } else {
+        snprintf(nc->info_str, sizeof(nc->info_str),
+                 "mac=%s", vmnet_mac_address);
+    }
+
+    return 0;
+}
diff --git a/qapi/net.json b/qapi/net.json
index 7fab2e7cd8aa..e3b67f174fce 100644
--- a/qapi/net.json
+++ b/qapi/net.json
@@ -452,6 +452,115 @@
     '*vhostdev':     'str',
     '*queues':       'int' } }
 
+##
+# @VmnetOperatingMode:
+#
+# The operating modes in which a vmnet netdev can run
+# Only available on macOS
+#
+# @host: the guest may communicate with the host
+#        and other guest network interfaces
+#
+# @shared: the guest may reach the Internet through a NAT,
+#          and may communicate with the host and other guest
+#          network interfaces
+#
+# @bridged: the guest's traffic is bridged with a
+#           physical network interface of the host
+#
+# Since: 6.0
+##
+{ 'enum': 'VmnetOperatingMode',
+  'data': [ 'host', 'shared', 'bridged' ],
+  'if': 'defined(CONFIG_VMNET)' }
+
+##
+# @NetdevVmnetModeOptionsBridged:
+#
+# Options for the vmnet-macos netdev
+# that are only available in 'bridged' mode
+# Only available on macOS
+#
+# @ifname: the physical network interface to bridge with
+#          (defaults to en0 if not specified)
+#
+# Since: 6.0
+##
+{ 'struct': 'NetdevVmnetModeOptionsBridged',
+  'data': { '*ifname':  'str' },
+  'if': 'defined(CONFIG_VMNET)' }
+
+##
+# @NetdevVmnetModeOptionsHostOrShared:
+#
+# Options for the vmnet-macos netdev
+# that are only available in 'host' or 'shared' mode
+# Only available on macOS
+#
+# @dhcp-start-address: the gateway address to use for the interface.
+#                      The range to dhcp_end_address is placed in the DHCP pool.
+#                      (only valid with mode=host|shared)
+#                      (must be specified with dhcp-end-address and
+#                       dhcp-subnet-mask)
+#                      (allocated automatically if unset)
+#
+# @dhcp-end-address: the DHCP IPv4 range end address to use for the interface.
+#                      (only valid with mode=host|shared)
+#                      (must be specified with dhcp-start-address and
+#                       dhcp-subnet-mask)
+#                      (allocated automatically if unset)
+#
+# @dhcp-subnet-mask: the IPv4 subnet mask (string) to use on the interface.
+#                    (only valid with mode=host|shared)
+#                    (must be specified with dhcp-start-address and
+#                     dhcp-end-address)
+#                    (allocated automatically if unset)
+#
+# Since: 6.0
+##
+{ 'struct': 'NetdevVmnetModeOptionsHostOrShared',
+  'data': {
+    '*dhcp-start-address': 'str' ,
+    '*dhcp-end-address':   'str',
+    '*dhcp-subnet-mask':   'str' },
+  'if': 'defined(CONFIG_VMNET)' }
+
+##
+# @NetdevVmnetModeOptions:
+#
+# Options specific to different operating modes of a vmnet netdev
+# Only available on macOS
+#
+# @mode: the operating mode vmnet should run in
+#
+# Since: 6.0
+##
+{ 'union': 'NetdevVmnetModeOptions',
+  'base': { 'mode': 'VmnetOperatingMode' },
+  'discriminator': 'mode',
+  'data': {
+    'bridged':      'NetdevVmnetModeOptionsBridged',
+    'host':         'NetdevVmnetModeOptionsHostOrShared',
+    'shared':       'NetdevVmnetModeOptionsHostOrShared' },
+  'if': 'defined(CONFIG_VMNET)' }
+
+##
+# @NetdevVmnetOptions:
+#
+# vmnet network backend
+# Only available on macOS
+#
+# @options: a structure specifying the mode and mode-specific options
+#           (once QAPI supports a union type as a branch to another union type,
+#            this structure can be changed to a union, and the contents of
+#            NetdevVmnetModeOptions moved here)
+#
+# Since: 6.0
+##
+{ 'struct': 'NetdevVmnetOptions',
+  'data': {'options': 'NetdevVmnetModeOptions' },
+  'if': 'defined(CONFIG_VMNET)' }
+
 ##
 # @NetClientDriver:
 #
@@ -460,10 +569,13 @@
 # Since: 2.7
 #
 #        @vhost-vdpa since 5.1
+#
+#        @vmnet-macos since 6.0 (only available on macOS)
 ##
 { 'enum': 'NetClientDriver',
   'data': [ 'none', 'nic', 'user', 'tap', 'l2tpv3', 'socket', 'vde',
-            'bridge', 'hubport', 'netmap', 'vhost-user', 'vhost-vdpa' ] }
+            'bridge', 'hubport', 'netmap', 'vhost-user', 'vhost-vdpa',
+            { 'name': 'vmnet-macos', 'if': 'defined(CONFIG_VMNET)' } ] }
 
 ##
 # @Netdev:
@@ -477,6 +589,8 @@
 # Since: 1.2
 #
 #        'l2tpv3' - since 2.1
+#
+#        'vmnet-macos' since 6.0 (only available on macOS)
 ##
 { 'union': 'Netdev',
   'base': { 'id': 'str', 'type': 'NetClientDriver' },
@@ -492,7 +606,9 @@
     'hubport':  'NetdevHubPortOptions',
     'netmap':   'NetdevNetmapOptions',
     'vhost-user': 'NetdevVhostUserOptions',
-    'vhost-vdpa': 'NetdevVhostVDPAOptions' } }
+    'vhost-vdpa': 'NetdevVhostVDPAOptions',
+    'vmnet-macos': { 'type': 'NetdevVmnetOptions',
+                     'if': 'defined(CONFIG_VMNET)' } } }
 
 ##
 # @RxState:
diff --git a/qemu-options.hx b/qemu-options.hx
index f72107794097..5ff872b3e84b 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -2609,6 +2609,15 @@ DEF("netdev", HAS_ARG, QEMU_OPTION_netdev,
 #ifdef __linux__
     "-netdev vhost-vdpa,id=str,vhostdev=/path/to/dev\n"
     "                configure a vhost-vdpa network,Establish a vhost-vdpa netdev\n"
+#endif
+#ifdef CONFIG_VMNET
+    "-netdev vmnet-macos,id=str,mode=bridged[,ifname=ifname]\n"
+    "         configure a macOS-provided vmnet network in \"physical interface bridge\" mode\n"
+    "         the physical interface to bridge with defaults to en0 if unspecified\n"
+    "-netdev vmnet-macos,id=str,mode=host|shared\n"
+    "                     [,dhcp_start_address=addr,dhcp_end_address=addr,dhcp_subnet_mask=mask]\n"
+    "         configure a macOS-provided vmnet network in \"host\" or \"shared\" mode\n"
+    "         the DHCP configuration will be set automatically if unspecified\n"
 #endif
     "-netdev hubport,id=str,hubid=n[,netdev=nd]\n"
     "                configure a hub port on the hub with ID 'n'\n", QEMU_ARCH_ALL)

From 45c171c238685f081a447ba7a547e309d782876e Mon Sep 17 00:00:00 2001
From: Gustavo Noronha Silva <gustavo@noronha.eti.br>
Date: Thu, 6 May 2021 07:04:55 -0300
Subject: [PATCH 108/180] ui/cocoa: handle mouse grab properly on window being
 key changes

Being key is similar to being focused on other platforms. When the
window loses focus at the moment it will still keep the mouse grabbed
unless it is using an absolute pointing device like a USB tablet.

That may happen in several ways as Mac OS does not let Qemu handle some
of the events even when it has a grab. Command-Tab will switch applications
if full-grab is off, and even if it is on you can still switch away from
by using 3-finger gestures on the trackpad to change spaces or open
Mission Control, for instance.

That behaviour is not ideal, as even though Qemu still believes it is
getting all the events, Mac OS has effectively released the mouse.
And it is worse with full-grab turned on, as it will still capture
the key events, making you unable to use the keyboard on the Mac OS
environment.

This change makes Qemu properly release the grab when Mac OS effectively
does it. In addition, it properly automatically regrabs the mouse when
the window becomes key and is fullscreen. While it makes sense to wait
for a click on a non-fullscreen window, as the user may just be moving
the window around, for instance, when it's fullscreen there is no point.

Signed-off-by: Gustavo Noronha Silva <gustavo@noronha.eti.br>
---
 ui/cocoa/app_controller.m | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/ui/cocoa/app_controller.m b/ui/cocoa/app_controller.m
index f3b7d7382479..d79ffd4f7b01 100644
--- a/ui/cocoa/app_controller.m
+++ b/ui/cocoa/app_controller.m
@@ -383,6 +383,21 @@ - (void)windowDidResize:(NSNotification *)notification
     [cocoaView frameUpdated];
 }
 
+- (void)windowDidResignKey:(NSNotification *)notification
+{
+    [cocoaView ungrabMouse];
+}
+
+- (void)windowDidBecomeKey:(NSNotification *)notification
+{
+    /* If we became key and are fullscreen there is no point in waiting for
+     * a click to grab the mouse.
+     */
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
+        [cocoaView grabMouse];
+    }
+}
+
 /* Called when the user clicks on a window's close button */
 - (BOOL)windowShouldClose:(id)sender
 {

From 61f5befa07196f76ccb2d4b94274a4db0f14da6d Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 17 Jun 2021 20:22:46 +0900
Subject: [PATCH 109/180] virtio-gpu: Call Virgl only in the main thread

Virgl relies on callbacks provided by the OpenGL display, and such a
display may rely on eglMakeCurrent. eglMakeCurrent will fail if the
given context is current to some other thread. The easiest way to avoid
such a failure is to call the OpenGL display in a single thread. As all
operations except virtio_gpu_virgl_reset happens in the main thread,
this change makes virtio_gpu_virgl_reset happen only in the main thread.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 hw/display/virtio-gpu-gl.c | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/hw/display/virtio-gpu-gl.c b/hw/display/virtio-gpu-gl.c
index 7ab93bf8c829..ef0d0b75aad6 100644
--- a/hw/display/virtio-gpu-gl.c
+++ b/hw/display/virtio-gpu-gl.c
@@ -90,17 +90,12 @@ static void virtio_gpu_gl_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
 
 static void virtio_gpu_gl_reset(VirtIODevice *vdev)
 {
-    VirtIOGPU *g = VIRTIO_GPU(vdev);
     VirtIOGPUGL *gl = VIRTIO_GPU_GL(vdev);
 
     virtio_gpu_reset(vdev);
 
     if (gl->renderer_inited) {
-        if (g->parent_obj.renderer_blocked) {
-            gl->renderer_reset = true;
-        } else {
-            virtio_gpu_virgl_reset(g);
-        }
+        gl->renderer_reset = true;
     }
 }
 

From 21954ae12ace1bcd0c7324df905055719fa194a7 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sat, 19 Jun 2021 14:12:11 +0900
Subject: [PATCH 110/180] coreaudio: Commit the result of init in the end

init_out_device may only commit some part of the result and leave the
state inconsistent when it encounters an error. Commit the result in
the end of the function so that it commits the result iif it sees no
error.

With this change, handle_voice_change can rely on core->outputDeviceID
to know whether the output device is initialized after calling
init_out_device.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 audio/coreaudio.c | 47 +++++++++++++++++++++++++----------------------
 1 file changed, 25 insertions(+), 22 deletions(-)

diff --git a/audio/coreaudio.c b/audio/coreaudio.c
index d8a21d3e5075..eb29be71d18d 100644
--- a/audio/coreaudio.c
+++ b/audio/coreaudio.c
@@ -356,7 +356,10 @@ static OSStatus audioDeviceIOProc(
 static OSStatus init_out_device(coreaudioVoiceOut *core)
 {
     OSStatus status;
+    AudioDeviceID deviceID;
     AudioValueRange frameRange;
+    UInt32 audioDevicePropertyBufferFrameSize;
+    AudioDeviceIOProcID ioprocid;
 
     AudioStreamBasicDescription streamBasicDescription = {
         .mBitsPerChannel = core->hw.info.bits,
@@ -369,20 +372,19 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
         .mSampleRate = core->hw.info.freq
     };
 
-    status = coreaudio_get_voice(&core->outputDeviceID);
+    status = coreaudio_get_voice(&deviceID);
     if (status != kAudioHardwareNoError) {
         coreaudio_playback_logerr (status,
                                    "Could not get default output Device\n");
         return status;
     }
-    if (core->outputDeviceID == kAudioDeviceUnknown) {
+    if (deviceID == kAudioDeviceUnknown) {
         dolog ("Could not initialize playback - Unknown Audiodevice\n");
         return status;
     }
 
     /* get minimum and maximum buffer frame sizes */
-    status = coreaudio_get_framesizerange(core->outputDeviceID,
-                                          &frameRange);
+    status = coreaudio_get_framesizerange(deviceID, &frameRange);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -393,31 +395,31 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
     }
 
     if (frameRange.mMinimum > core->frameSizeSetting) {
-        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMinimum;
+        audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMinimum;
         dolog ("warning: Upsizing Buffer Frames to %f\n", frameRange.mMinimum);
     } else if (frameRange.mMaximum < core->frameSizeSetting) {
-        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMaximum;
+        audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMaximum;
         dolog ("warning: Downsizing Buffer Frames to %f\n", frameRange.mMaximum);
     } else {
-        core->audioDevicePropertyBufferFrameSize = core->frameSizeSetting;
+        audioDevicePropertyBufferFrameSize = core->frameSizeSetting;
     }
 
     /* set Buffer Frame Size */
-    status = coreaudio_set_framesize(core->outputDeviceID,
-                                     &core->audioDevicePropertyBufferFrameSize);
+    status = coreaudio_set_framesize(deviceID,
+                                     &audioDevicePropertyBufferFrameSize);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
     if (status != kAudioHardwareNoError) {
         coreaudio_playback_logerr (status,
                                     "Could not set device buffer frame size %" PRIu32 "\n",
-                                    (uint32_t)core->audioDevicePropertyBufferFrameSize);
+                                    (uint32_t)audioDevicePropertyBufferFrameSize);
         return status;
     }
 
     /* get Buffer Frame Size */
-    status = coreaudio_get_framesize(core->outputDeviceID,
-                                     &core->audioDevicePropertyBufferFrameSize);
+    status = coreaudio_get_framesize(deviceID,
+                                     &audioDevicePropertyBufferFrameSize);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -426,11 +428,9 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
                                     "Could not get device buffer frame size\n");
         return status;
     }
-    core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
 
     /* set Samplerate */
-    status = coreaudio_set_streamformat(core->outputDeviceID,
-                                        &streamBasicDescription);
+    status = coreaudio_set_streamformat(deviceID, &streamBasicDescription);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -438,7 +438,6 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
         coreaudio_playback_logerr (status,
                                    "Could not set samplerate %lf\n",
                                    streamBasicDescription.mSampleRate);
-        core->outputDeviceID = kAudioDeviceUnknown;
         return status;
     }
 
@@ -452,20 +451,24 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
      * Therefore, the specified callback must be designed to avoid a deadlock
      * with the callers of AudioObjectGetPropertyData.
      */
-    core->ioprocid = NULL;
-    status = AudioDeviceCreateIOProcID(core->outputDeviceID,
+    ioprocid = NULL;
+    status = AudioDeviceCreateIOProcID(deviceID,
                                        audioDeviceIOProc,
                                        &core->hw,
-                                       &core->ioprocid);
+                                       &ioprocid);
     if (status == kAudioHardwareBadDeviceError) {
         return 0;
     }
-    if (status != kAudioHardwareNoError || core->ioprocid == NULL) {
+    if (status != kAudioHardwareNoError || ioprocid == NULL) {
         coreaudio_playback_logerr (status, "Could not set IOProc\n");
-        core->outputDeviceID = kAudioDeviceUnknown;
         return status;
     }
 
+    core->outputDeviceID = deviceID;
+    core->audioDevicePropertyBufferFrameSize = audioDevicePropertyBufferFrameSize;
+    core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
+    core->ioprocid = ioprocid;
+
     return 0;
 }
 
@@ -551,7 +554,7 @@ static OSStatus handle_voice_change(
     }
 
     status = init_out_device(core);
-    if (!status) {
+    if (core->outputDeviceID) {
         update_device_playback_state(core);
     }
 

From b3a305701eb790ee90346f61fbe9666f910d605a Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Mon, 5 Jul 2021 16:52:28 +0900
Subject: [PATCH 111/180] ui: update keycodemapdb submodule commit

The change of ui/keycodemapdb effective on QEMU is only commit
d21009b1c9f94b740ea66be8e48a1d8ad8124023, which adds mappings for key
codes added in commit d7696ff884e35c6dacf83a7cbe3355e3b0a90125.

d21009b1c9f94b740ea66be8e48a1d8ad8124023 Add QEMU QKeyCode "lang1" and "lang2"
320f92c36a80bfafc5d57834592a7be5fd79f104 rust: fix cargo clippy
e62d42f0fd76f7bb8bf78385a83c060e66ff52b0 tests: add rust test
3e25e1ca1772fc3f2039f739f8f920450dc68e50 gen: add --lang rust
9133a0b8022d1fb063a81cc2ba3b627c14ccdfd1 tests: fix argument order

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/keycodemapdb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ui/keycodemapdb b/ui/keycodemapdb
index 6119e6e19a05..d21009b1c9f9 160000
--- a/ui/keycodemapdb
+++ b/ui/keycodemapdb
@@ -1 +1 @@
-Subproject commit 6119e6e19a050df847418de7babe5166779955e4
+Subproject commit d21009b1c9f94b740ea66be8e48a1d8ad8124023

From c800dbb61e39547b97ce8278e8a293d10e365053 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 7 Jul 2021 03:31:01 +0900
Subject: [PATCH 112/180] block/file-posix: Use O_RDWR for locking on macOS

qemu_lock_fd_test always returns 0 when fd is not open for writing and
exclusive is true on macOS 11.3.1.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 block/file-posix.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/block/file-posix.c b/block/file-posix.c
index cb9bffe0471c..6fbde4484dc4 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -134,6 +134,14 @@
 #define RAW_LOCK_PERM_BASE             100
 #define RAW_LOCK_SHARED_BASE           200
 
+/*
+ * qemu_lock_fd_test always returns 0 when fd is not open for writing and
+ * exclusive is true on macOS 11.3.1.
+ */
+#ifdef __APPLE__
+#define RAW_LOCK_WRITES
+#endif
+
 typedef struct BDRVRawState {
     int fd;
     bool use_lock;
@@ -652,7 +660,11 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
                                                false);
 
     s->open_flags = open_flags;
+#ifdef RAW_LOCK_WRITES
+    raw_parse_flags(bdrv_flags, &s->open_flags, s->use_lock);
+#else
     raw_parse_flags(bdrv_flags, &s->open_flags, false);
+#endif
 
     s->fd = -1;
     fd = qemu_open(filename, s->open_flags, errp);
@@ -1018,6 +1030,11 @@ static int raw_reconfigure_getfd(BlockDriverState *bs, int flags,
     bool has_writers = perm &
         (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED | BLK_PERM_RESIZE);
     int fcntl_flags = O_APPEND | O_NONBLOCK;
+#ifdef RAW_LOCK_WRITES
+    if (s->use_lock) {
+        has_writers = true;
+    }
+#endif
 #ifdef O_NOATIME
     fcntl_flags |= O_NOATIME;
 #endif

From 1e8db1949d969f0b4b75dd98d12e53572d422de2 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 26 Jul 2021 14:32:28 -0700
Subject: [PATCH 113/180] file-posix: fix holepunch build on iOS

---
 block/file-posix.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/block/file-posix.c b/block/file-posix.c
index 6fbde4484dc4..23bd7522c6dd 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -43,10 +43,10 @@
 
 #if defined(__APPLE__) && (__MACH__)
 #include <sys/ioctl.h>
-#if defined(HAVE_HOST_BLOCK_DEVICE)
-#include <paths.h>
 #include <sys/param.h>
 #include <sys/mount.h>
+#if defined(HAVE_HOST_BLOCK_DEVICE)
+#include <paths.h>
 #include <IOKit/IOKitLib.h>
 #include <IOKit/IOBSD.h>
 #include <IOKit/storage/IOMediaBSDClient.h>

From 3428101c02857456a68a59c93d195e4d89f1e845 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 26 Jul 2021 14:32:44 -0700
Subject: [PATCH 114/180] configure: disable plugins for shared_lib builds

---
 configure | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/configure b/configure
index 6483b3da6f05..ea84eb678262 100755
--- a/configure
+++ b/configure
@@ -1585,7 +1585,9 @@ for opt do
   ;;
   --disable-slirp-smbd) slirp_smbd=no
   ;;
-  --enable-shared-lib) shared_lib=true
+  --enable-shared-lib)
+      shared_lib=true
+      plugins="no"
   ;;
   --disable-shared-lib) shared_lib=false
   ;;
@@ -1602,6 +1604,10 @@ if test "$plugins" = "yes" -a "$tcg" = "disabled"; then
     error_exit "Can't enable plugins on non-TCG builds"
 fi
 
+if test "$plugins" = "yes" -a "$shared_lib" = "true"; then
+    error_exit "Can't enable plugins on shared library builds"
+fi
+
 case $git_submodules_action in
     update|validate)
         if test ! -e "$source_path/.git"; then

From edba23a4d49e6c6c7b88e10be5f5f29e5d98f2ee Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Fri, 5 Mar 2021 04:38:01 +0900
Subject: [PATCH 115/180] egl-headless: Allow to test with Mesa on macOS

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 include/ui/egl-helpers.h |  1 +
 ui/egl-headless.c        | 25 ++++++++++++
 ui/egl-helpers.c         | 88 ++++++++++++++++++++++++++++------------
 ui/meson.build           |  4 +-
 4 files changed, 90 insertions(+), 28 deletions(-)

diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
index e36cc0060553..54967e24a489 100644
--- a/include/ui/egl-helpers.h
+++ b/include/ui/egl-helpers.h
@@ -51,6 +51,7 @@ void egl_dmabuf_release_texture(QemuDmaBuf *dmabuf);
 EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win);
 
 int qemu_egl_init_dpy_cocoa(DisplayGLMode mode);
+int qemu_egl_init_dpy_surfaceless(DisplayGLMode mode);
 
 #if defined(CONFIG_X11) || defined(CONFIG_GBM)
 
diff --git a/ui/egl-headless.c b/ui/egl-headless.c
index 183e98a36563..460a4f9e8fac 100644
--- a/ui/egl-headless.c
+++ b/ui/egl-headless.c
@@ -18,6 +18,10 @@ typedef struct egl_dpy {
     uint32_t pos_y;
 } egl_dpy;
 
+#ifndef CONFIG_GBM
+static EGLContext ctx;
+#endif
+
 /* ------------------------------------------------------------------ */
 
 static void egl_refresh(DisplayChangeListener *dcl)
@@ -41,8 +45,12 @@ static void egl_gfx_switch(DisplayChangeListener *dcl,
 static QEMUGLContext egl_create_context(void *dg,
                                         QEMUGLParams *params)
 {
+#ifdef CONFIG_GBM
     eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                    qemu_egl_rn_ctx);
+#else
+    eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, ctx);
+#endif
     return qemu_egl_create_context(dg, params);
 }
 
@@ -98,6 +106,7 @@ static void egl_scanout_texture(void *dg,
     }
 }
 
+#ifdef CONFIG_GBM
 static void egl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
     egl_dmabuf_import_texture(dmabuf);
@@ -140,6 +149,7 @@ static void egl_release_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
     egl_dmabuf_release_texture(dmabuf);
 }
+#endif
 
 static void egl_scanout_flush(DisplayChangeListener *dcl,
                               uint32_t x, uint32_t y,
@@ -176,10 +186,12 @@ static const DisplayGLOps dg_egl_ops = {
     .dpy_gl_scanout_get_enabled = egl_scanout_get_enabled,
     .dpy_gl_scanout_disable     = egl_scanout_disable,
     .dpy_gl_scanout_texture     = egl_scanout_texture,
+#ifdef CONFIG_GBM
     .dpy_gl_scanout_dmabuf      = egl_scanout_dmabuf,
     .dpy_gl_cursor_dmabuf       = egl_cursor_dmabuf,
     .dpy_gl_cursor_position     = egl_cursor_position,
     .dpy_gl_release_dmabuf      = egl_release_dmabuf,
+#endif
 };
 
 static const DisplayChangeListenerOps dcl_egl_ops = {
@@ -203,10 +215,23 @@ static void egl_headless_init(DisplayState *ds, DisplayOptions *opts)
     egl_dpy *edpy;
     int idx;
 
+#ifdef CONFIG_GBM
     if (egl_rendernode_init(opts->u.egl_headless.rendernode, mode) < 0) {
         error_report("egl: render node init failed");
         exit(1);
     }
+#else
+    if (qemu_egl_init_dpy_surfaceless(mode)) {
+        error_report("egl: display init failed");
+        exit(1);
+    }
+
+    ctx = qemu_egl_init_ctx();
+    if (!ctx) {
+        error_report("egl: egl_init_ctx failed");
+        exit(1);
+    }
+#endif
 
     register_displayglops(&dg_egl_ops);
 
diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index ac30d990eca0..1a0bdf87ab02 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -316,6 +316,31 @@ EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win)
 /* ---------------------------------------------------------------------- */
 
 static int qemu_egl_init_dpy(EGLDisplay dpy, DisplayGLMode mode)
+{
+    EGLint major, minor;
+    EGLBoolean b;
+    bool gles = (mode == DISPLAYGL_MODE_ES);
+
+    qemu_egl_display = dpy;
+
+    b = eglInitialize(qemu_egl_display, &major, &minor);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglInitialize failed");
+        return -1;
+    }
+
+    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglBindAPI failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    qemu_egl_mode = gles ? DISPLAYGL_MODE_ES : DISPLAYGL_MODE_CORE;
+    return 0;
+}
+
+static int qemu_egl_config_dpy()
 {
     static const EGLint conf_att_core[] = {
         EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
@@ -335,25 +360,9 @@ static int qemu_egl_init_dpy(EGLDisplay dpy, DisplayGLMode mode)
         EGL_ALPHA_SIZE, 0,
         EGL_NONE,
     };
-    EGLint major, minor;
     EGLBoolean b;
     EGLint n;
-    bool gles = (mode == DISPLAYGL_MODE_ES);
-
-    qemu_egl_display = dpy;
-
-    b = eglInitialize(qemu_egl_display, &major, &minor);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglInitialize failed");
-        return -1;
-    }
-
-    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglBindAPI failed (%s mode)",
-                     gles ? "gles" : "core");
-        return -1;
-    }
+    bool gles = (qemu_egl_mode == DISPLAYGL_MODE_ES);
 
     b = eglChooseConfig(qemu_egl_display,
                         gles ? conf_att_gles : conf_att_core,
@@ -364,22 +373,26 @@ static int qemu_egl_init_dpy(EGLDisplay dpy, DisplayGLMode mode)
         return -1;
     }
 
-    qemu_egl_mode = gles ? DISPLAYGL_MODE_ES : DISPLAYGL_MODE_CORE;
     return 0;
 }
 
 int qemu_egl_init_dpy_cocoa(DisplayGLMode mode)
 {
+    int result;
+
     EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
     if (dpy == EGL_NO_DISPLAY) {
         error_report("egl: eglGetDisplay failed");
         return -1;
     }
 
-    return qemu_egl_init_dpy(dpy, mode);
-}
+    result = qemu_egl_init_dpy(dpy, mode);
+    if (!result) {
+        result = qemu_egl_config_dpy();
+    }
 
-#if defined(CONFIG_X11) || defined(CONFIG_GBM)
+    return result;
+}
 
 /*
  * Taken from glamor_egl.h from the Xorg xserver, which is MIT licensed
@@ -409,7 +422,7 @@ int qemu_egl_init_dpy_cocoa(DisplayGLMode mode)
  * platform extensions (EGL_KHR_platform_gbm and friends) yet it doesn't seem
  * like mesa will be able to advertise these (even though it can do EGL 1.5).
  */
-static int qemu_egl_init_dpy_platform(EGLNativeDisplayType native,
+static int qemu_egl_init_dpy_platform(void *native,
                                       EGLenum platform,
                                       DisplayGLMode mode)
 {
@@ -424,10 +437,12 @@ static int qemu_egl_init_dpy_platform(EGLNativeDisplayType native,
         }
     }
 
+#if defined(CONFIG_X11) || defined(CONFIG_GBM)
     if (dpy == EGL_NO_DISPLAY) {
         /* fallback */
         dpy = eglGetDisplay(native);
     }
+#endif
 
     if (dpy == EGL_NO_DISPLAY) {
         error_report("egl: eglGetDisplay failed");
@@ -437,22 +452,43 @@ static int qemu_egl_init_dpy_platform(EGLNativeDisplayType native,
     return qemu_egl_init_dpy(dpy, mode);
 }
 
+int qemu_egl_init_dpy_surfaceless(DisplayGLMode mode)
+{
+    return qemu_egl_init_dpy_platform(NULL, EGL_PLATFORM_SURFACELESS_MESA, mode);
+}
+
+#if defined(CONFIG_X11) || defined(CONFIG_GBM)
+
 int qemu_egl_init_dpy_x11(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
+    int result;
+
 #ifdef EGL_KHR_platform_x11
-    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_X11_KHR, mode);
+    result = qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_X11_KHR, mode);
 #else
-    return qemu_egl_init_dpy_platform(dpy, 0, mode);
+    result = qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
+    if (!result) {
+        result = qemu_egl_config_dpy();
+    }
+
+    return result;
 }
 
 int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
+    int result;
+
 #ifdef EGL_MESA_platform_gbm
-    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_GBM_MESA, mode);
+    result = qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_GBM_MESA, mode);
 #else
-    return qemu_egl_init_dpy_platform(dpy, 0, mode);
+    result = qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
+    if (!result) {
+        result = qemu_egl_config_dpy();
+    }
+
+    return result;
 }
 
 #endif
diff --git a/ui/meson.build b/ui/meson.build
index 0879481141a4..06724d0e9dff 100644
--- a/ui/meson.build
+++ b/ui/meson.build
@@ -59,9 +59,9 @@ if config_host.has_key('CONFIG_OPENGL')
   ui_modules += {'opengl' : opengl_ss}
 endif
 
-if config_host.has_key('CONFIG_OPENGL') and gbm.found()
+if config_host.has_key('CONFIG_OPENGL')
   egl_headless_ss = ss.source_set()
-  egl_headless_ss.add(when: [opengl, gbm, pixman, 'CONFIG_OPENGL', 'CONFIG_EGL'],
+  egl_headless_ss.add(when: [opengl, pixman, 'CONFIG_OPENGL', 'CONFIG_EGL'],
                       if_true: files('egl-headless.c'))
   ui_modules += {'egl-headless' : egl_headless_ss}
 endif

From f357b925b319b83d4cb9a5210cfcece616b09805 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 1 Aug 2021 22:13:11 -0700
Subject: [PATCH 116/180] egl-helpers: update EGL client version to 3.0

Required for Metal ANGLE to work on iOS
---
 ui/egl-helpers.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index 1a0bdf87ab02..5f5777f51f50 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -510,7 +510,7 @@ EGLContext qemu_egl_init_ctx(void)
         EGL_NONE
     };
     static const EGLint ctx_att_gles[] = {
-        EGL_CONTEXT_CLIENT_VERSION, 2,
+        EGL_CONTEXT_CLIENT_VERSION, 3,
         EGL_NONE
     };
     bool gles = (qemu_egl_mode == DISPLAYGL_MODE_ES);

From ce01739e6dfb480bf373c9ee5b60bc0058723532 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 1 Aug 2021 22:13:51 -0700
Subject: [PATCH 117/180] egl-headless: fix compile without GBM

---
 qapi/ui.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/qapi/ui.json b/qapi/ui.json
index 7d8d3b532e58..a73a2b1d8313 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -1157,7 +1157,7 @@
     { 'name': 'gtk', 'if': 'defined(CONFIG_GTK)' },
     { 'name': 'sdl', 'if': 'defined(CONFIG_SDL)' },
     { 'name': 'egl-headless',
-              'if': 'defined(CONFIG_OPENGL) && defined(CONFIG_GBM)' },
+              'if': 'defined(CONFIG_OPENGL)' },
     { 'name': 'curses', 'if': 'defined(CONFIG_CURSES)' },
     { 'name': 'cocoa', 'if': 'defined(CONFIG_COCOA)' },
     { 'name': 'spice-app', 'if': 'defined(CONFIG_SPICE)'} ] }

From 1adb9ff17d3aeb6cf1ba3017d8a0764ac45f2319 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 1 Aug 2021 22:15:50 -0700
Subject: [PATCH 118/180] spice-display: make GBM conditional

---
 include/ui/spice-display.h |  4 +++-
 ui/spice-display.c         | 35 ++++++++++++++++++++++++++---------
 2 files changed, 29 insertions(+), 10 deletions(-)

diff --git a/include/ui/spice-display.h b/include/ui/spice-display.h
index 894234e87462..dff25d93a7a8 100644
--- a/include/ui/spice-display.h
+++ b/include/ui/spice-display.h
@@ -27,7 +27,7 @@
 #include "ui/qemu-pixman.h"
 #include "ui/console.h"
 
-#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL) && defined(CONFIG_GBM)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 # if SPICE_SERVER_VERSION >= 0x000d01 /* release 0.13.1 */
 #  define HAVE_SPICE_GL 1
 #  include "ui/egl-helpers.h"
@@ -126,8 +126,10 @@ struct SimpleSpiceDisplay {
     bool have_scanout;
     bool have_surface;
 
+#if defined(CONFIG_GBM)
     QemuDmaBuf *guest_dmabuf;
     bool guest_dmabuf_refresh;
+#endif
     bool render_cursor;
 
     egl_fb guest_fb;
diff --git a/ui/spice-display.c b/ui/spice-display.c
index 94efe07c9061..75c61a256364 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -873,15 +873,19 @@ static void spice_gl_switch(DisplayChangeListener *dcl,
                             struct DisplaySurface *new_surface)
 {
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
-    EGLint stride, fourcc;
-    int fd;
+    EGLint stride = 0, fourcc = 0;
+    int fd = -1;
+    int width = 0, height = 0;
 
     if (ssd->ds) {
         surface_gl_destroy_texture(ssd->gls, ssd->ds);
     }
     ssd->ds = new_surface;
+    width = surface_width(new_surface);
+    height = surface_height(new_surface);
     if (ssd->ds) {
         surface_gl_create_texture(ssd->gls, ssd->ds);
+#if defined(CONFIG_GBM)
         fd = egl_get_fd_for_texture(ssd->ds->texture,
                                     &stride, &fourcc,
                                     NULL);
@@ -889,31 +893,34 @@ static void spice_gl_switch(DisplayChangeListener *dcl,
             surface_gl_destroy_texture(ssd->gls, ssd->ds);
             return;
         }
+#endif
 
         trace_qemu_spice_gl_surface(ssd->qxl.id,
-                                    surface_width(ssd->ds),
-                                    surface_height(ssd->ds),
+                                    width,
+                                    height,
                                     fourcc);
 
         /* note: spice server will close the fd */
         spice_qxl_gl_scanout(&ssd->qxl, fd,
-                             surface_width(ssd->ds),
-                             surface_height(ssd->ds),
+                             width,
+                             height,
                              stride, fourcc, false);
         ssd->have_surface = true;
         ssd->have_scanout = false;
 
         qemu_spice_gl_monitor_config(ssd, 0, 0,
-                                     surface_width(ssd->ds),
-                                     surface_height(ssd->ds));
+                                     width,
+                                     height);
     }
 }
 
 static QEMUGLContext qemu_spice_gl_create_context(void *dg,
                                                   QEMUGLParams *params)
 {
+#if defined(CONFIG_GBM)
     eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                    qemu_egl_rn_ctx);
+#endif
     return qemu_egl_create_context(dg, params);
 }
 
@@ -947,7 +954,9 @@ static void qemu_spice_gl_scanout_texture(void *dg,
         return;
     }
 
+#if defined(CONFIG_GBM)
     fd = egl_get_fd_for_texture(tex_id, &stride, &fourcc, NULL);
+#endif
     if (fd < 0) {
         fprintf(stderr, "%s: failed to get fd for texture\n", __func__);
         return;
@@ -962,6 +971,7 @@ static void qemu_spice_gl_scanout_texture(void *dg,
     ssd->have_scanout = true;
 }
 
+#ifdef CONFIG_GBM
 static void qemu_spice_gl_scanout_dmabuf(void *dg, QemuDmaBuf *dmabuf)
 {
     SimpleSpiceDisplay *ssd = dg;
@@ -1017,21 +1027,25 @@ static void qemu_spice_gl_release_dmabuf(void *dg, QemuDmaBuf *dmabuf)
     }
     egl_dmabuf_release_texture(dmabuf);
 }
+#endif // CONFIG_GBM
 
 static void qemu_spice_gl_update(DisplayChangeListener *dcl,
                                  uint32_t x, uint32_t y, uint32_t w, uint32_t h)
 {
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
+#ifdef CONFIG_GBM
     EGLint stride = 0, fourcc = 0;
+    int fd;
     bool render_cursor = false;
+#endif
     bool y_0_top = false; /* FIXME */
     uint64_t cookie;
-    int fd;
 
     if (!ssd->have_scanout) {
         return;
     }
 
+#ifdef CONFIG_GBM
     if (ssd->cursor_fb.texture) {
         render_cursor = true;
     }
@@ -1093,6 +1107,7 @@ static void qemu_spice_gl_update(DisplayChangeListener *dcl,
                           !y_0_top, x, y, 1.0, 1.0);
         glFlush();
     }
+#endif
 
     trace_qemu_spice_gl_update(ssd->qxl.id, w, h, x, y);
     qemu_spice_gl_block(ssd, true);
@@ -1119,10 +1134,12 @@ static const DisplayGLOps display_gl_ops = {
 
     .dpy_gl_scanout_disable  = qemu_spice_gl_scanout_disable,
     .dpy_gl_scanout_texture  = qemu_spice_gl_scanout_texture,
+#ifdef CONFIG_GBM
     .dpy_gl_scanout_dmabuf   = qemu_spice_gl_scanout_dmabuf,
     .dpy_gl_cursor_dmabuf    = qemu_spice_gl_cursor_dmabuf,
     .dpy_gl_cursor_position  = qemu_spice_gl_cursor_position,
     .dpy_gl_release_dmabuf   = qemu_spice_gl_release_dmabuf,
+#endif
 };
 
 #endif /* HAVE_SPICE_GL */

From dc386f9eb020dd76c73bf354c6813bd2dba26daf Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 1 Aug 2021 22:22:14 -0700
Subject: [PATCH 119/180] spice-display: support ANGLE backend

Add support for creating a pbuffer surface and setup from SPICE.
---
 include/ui/egl-helpers.h   | 12 ++++++++++
 include/ui/spice-display.h |  6 +++++
 meson.build                |  1 +
 ui/egl-helpers.c           | 48 ++++++++++++++++++++++++++++++++++++++
 ui/spice-core.c            | 20 ++++++++++++++++
 ui/spice-display.c         | 16 +++++++++++++
 6 files changed, 103 insertions(+)

diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
index 54967e24a489..117596c1cb67 100644
--- a/include/ui/egl-helpers.h
+++ b/include/ui/egl-helpers.h
@@ -6,6 +6,9 @@
 #ifdef CONFIG_GBM
 #include <gbm.h>
 #endif
+#ifdef CONFIG_ANGLE
+#include <EGL/eglext_angle.h>
+#endif
 #include "ui/console.h"
 #include "ui/shader.h"
 
@@ -49,6 +52,9 @@ void egl_dmabuf_release_texture(QemuDmaBuf *dmabuf);
 #endif
 
 EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win);
+EGLSurface qemu_egl_init_buffer_surface(EGLContext ectx, EGLenum buftype,
+                                        EGLClientBuffer buffer, const EGLint *attrib_list);
+bool qemu_egl_destroy_surface(EGLSurface surface);
 
 int qemu_egl_init_dpy_cocoa(DisplayGLMode mode);
 int qemu_egl_init_dpy_surfaceless(DisplayGLMode mode);
@@ -60,6 +66,12 @@ int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode);
 
 #endif
 
+#if defined(CONFIG_ANGLE)
+
+int qemu_egl_init_dpy_angle(DisplayGLMode mode);
+
+#endif
+
 EGLContext qemu_egl_init_ctx(void);
 bool qemu_egl_has_dmabuf(void);
 
diff --git a/include/ui/spice-display.h b/include/ui/spice-display.h
index dff25d93a7a8..6eaaebd6d614 100644
--- a/include/ui/spice-display.h
+++ b/include/ui/spice-display.h
@@ -129,6 +129,12 @@ struct SimpleSpiceDisplay {
 #if defined(CONFIG_GBM)
     QemuDmaBuf *guest_dmabuf;
     bool guest_dmabuf_refresh;
+#endif
+#if defined(CONFIG_ANGLE)
+    EGLSurface esurface;
+    egl_fb iosurface_fb;
+    DisplayGLTextureBorrower backing_borrow;
+    uint32_t backing_id;
 #endif
     bool render_cursor;
 
diff --git a/meson.build b/meson.build
index 15e005cdbce1..01fccb310c29 100644
--- a/meson.build
+++ b/meson.build
@@ -1339,6 +1339,7 @@ config_host_data.set('HAVE_PTY_H', cc.has_header('pty.h'))
 config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h'))
 config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
+config_host_data.set('CONFIG_ANGLE', cc.has_header('EGL/eglext_angle.h'))
 
 # has_function
 config_host_data.set('CONFIG_ACCEPT4', cc.has_function('accept4'))
diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index 5f5777f51f50..0b68f70d6a45 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -313,6 +313,38 @@ EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win)
     return esurface;
 }
 
+EGLSurface qemu_egl_init_buffer_surface(EGLContext ectx,
+                                        EGLenum buftype,
+                                        EGLClientBuffer buffer,
+                                        const EGLint *attrib_list)
+{
+    EGLSurface esurface;
+    EGLBoolean b;
+
+    esurface = eglCreatePbufferFromClientBuffer(qemu_egl_display,
+                                                buftype,
+                                                buffer,
+                                                qemu_egl_config,
+                                                attrib_list);
+    if (esurface == EGL_NO_SURFACE) {
+        error_report("egl: eglCreatePbufferFromClientBuffer failed");
+        return NULL;
+    }
+
+    b = eglMakeCurrent(qemu_egl_display, esurface, esurface, ectx);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglMakeCurrent failed");
+        return NULL;
+    }
+
+    return esurface;
+}
+
+bool qemu_egl_destroy_surface(EGLSurface surface)
+{
+    return eglDestroySurface(qemu_egl_display, surface);
+}
+
 /* ---------------------------------------------------------------------- */
 
 static int qemu_egl_init_dpy(EGLDisplay dpy, DisplayGLMode mode)
@@ -493,6 +525,22 @@ int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode)
 
 #endif
 
+#if defined(CONFIG_ANGLE)
+
+int qemu_egl_init_dpy_angle(DisplayGLMode mode)
+{
+    int result;
+
+    result = qemu_egl_init_dpy_platform(NULL, EGL_PLATFORM_ANGLE_ANGLE, mode);
+    if (!result) {
+        result = qemu_egl_config_dpy();
+    }
+
+    return result;
+}
+
+#endif
+
 bool qemu_egl_has_dmabuf(void)
 {
     if (qemu_egl_display == EGL_NO_DISPLAY) {
diff --git a/ui/spice-core.c b/ui/spice-core.c
index 0371055e6c17..f089e398b951 100644
--- a/ui/spice-core.c
+++ b/ui/spice-core.c
@@ -52,6 +52,10 @@ static int spice_have_target_host;
 
 static QemuThread me;
 
+#ifdef CONFIG_ANGLE
+extern EGLContext spice_gl_ctx;
+#endif
+
 struct SpiceTimer {
     QEMUTimer *timer;
 };
@@ -845,11 +849,27 @@ static void qemu_spice_init(void)
                          "incompatible with -spice port/tls-port");
             exit(1);
         }
+#if defined(CONFIG_GBM)
         if (egl_rendernode_init(qemu_opt_get(opts, "rendernode"),
                                 DISPLAYGL_MODE_ON) != 0) {
             error_report("Failed to initialize EGL render node for SPICE GL");
             exit(1);
         }
+#elif defined(CONFIG_ANGLE)
+        if (qemu_egl_init_dpy_angle(DISPLAYGL_MODE_ES)) {
+            error_report("SPICE GL failed to initialize ANGLE display");
+            exit(1);
+        }
+
+        spice_gl_ctx = qemu_egl_init_ctx();
+        if (!spice_gl_ctx) {
+            error_report("egl: egl_init_ctx failed");
+            exit(1);
+        }
+#else
+        error_report("No backend to support SPICE GL");
+        exit(1);
+#endif
         display_opengl = 1;
         spice_opengl = 1;
     }
diff --git a/ui/spice-display.c b/ui/spice-display.c
index 75c61a256364..0b5f8801dab5 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -29,6 +29,10 @@
 
 bool spice_opengl;
 
+#ifdef CONFIG_ANGLE
+EGLContext spice_gl_ctx;
+#endif
+
 int qemu_spice_rect_is_empty(const QXLRect* r)
 {
     return r->top == r->bottom || r->left == r->right;
@@ -920,6 +924,9 @@ static QEMUGLContext qemu_spice_gl_create_context(void *dg,
 #if defined(CONFIG_GBM)
     eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                    qemu_egl_rn_ctx);
+#elif defined(CONFIG_ANGLE)
+    eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
+                   spice_gl_ctx);
 #endif
     return qemu_egl_create_context(dg, params);
 }
@@ -933,6 +940,10 @@ static void qemu_spice_gl_scanout_disable(void *dg)
     qemu_spice_gl_monitor_config(ssd, 0, 0, 0, 0);
     ssd->have_surface = false;
     ssd->have_scanout = false;
+#if defined(CONFIG_ANGLE)
+    ssd->backing_borrow = NULL;
+    ssd->backing_id = -1;
+#endif
 }
 
 static void qemu_spice_gl_scanout_texture(void *dg,
@@ -1160,6 +1171,11 @@ static void qemu_spice_display_init_one(QemuConsole *con)
         ssd->gls = qemu_gl_init_shader();
         ssd->have_surface = false;
         ssd->have_scanout = false;
+#if defined(CONFIG_ANGLE)
+        ssd->esurface = EGL_NO_SURFACE;
+        ssd->backing_borrow = NULL;
+        ssd->backing_id = -1;
+#endif
         console_set_displayglcontext(con, ssd);
         register_displayglops(&display_gl_ops);
     }

From f384e2c7eb8458ca587be7ed7da142819a092ff2 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 1 Aug 2021 22:24:02 -0700
Subject: [PATCH 120/180] spice-display: initial support for IOSurface
 rendering

In both surface and scanout mode, we blit the texture to a ANGLE texture
backed pbuffer using IOSurface. This IOSurface can be shared with a
separate process.

What needs to be done:
1) Handing of IOSurfaceRef through mach ports (Unix sockets are not
   supported. This implementation hacks in by passing the pointer through
   a file descriptor but this will fail if client is running in a separate
   process).
2) Cursor handling through QEMU (currently, the SPICE client will handle
   it).
---
 include/ui/spice-display.h |   8 ++
 meson.build                |   3 +
 ui/meson.build             |   3 +
 ui/spice-display.c         | 170 +++++++++++++++++++++++++++++++++++++
 4 files changed, 184 insertions(+)

diff --git a/include/ui/spice-display.h b/include/ui/spice-display.h
index 6eaaebd6d614..b2f6570706e6 100644
--- a/include/ui/spice-display.h
+++ b/include/ui/spice-display.h
@@ -27,6 +27,11 @@
 #include "ui/qemu-pixman.h"
 #include "ui/console.h"
 
+#if defined(CONFIG_IOSURFACE)
+#include <CoreFoundation/CoreFoundation.h>
+#include <IOSurface/IOSurfaceRef.h>
+#endif
+
 #if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 # if SPICE_SERVER_VERSION >= 0x000d01 /* release 0.13.1 */
 #  define HAVE_SPICE_GL 1
@@ -130,6 +135,9 @@ struct SimpleSpiceDisplay {
     QemuDmaBuf *guest_dmabuf;
     bool guest_dmabuf_refresh;
 #endif
+#if defined(CONFIG_IOSURFACE)
+    IOSurfaceRef iosurface;
+#endif
 #if defined(CONFIG_ANGLE)
     EGLSurface esurface;
     egl_fb iosurface_fb;
diff --git a/meson.build b/meson.build
index 01fccb310c29..a9ccbace6643 100644
--- a/meson.build
+++ b/meson.build
@@ -186,6 +186,7 @@ version_res = []
 coref = []
 iokit = []
 vmnet = not_found
+iosurface = not_found
 emulator_link_args = []
 nvmm =not_found
 hvf = not_found
@@ -201,6 +202,7 @@ elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
   iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
   vmnet = dependency('appleframeworks', modules: 'vmnet', required: false)
+  iosurface = dependency('appleframeworks', modules: 'IOSurface', required: false)
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
             cc.find_library('nsl'),
@@ -1322,6 +1324,7 @@ config_host_data.set('CONFIG_FUSE_LSEEK', fuse_lseek.found())
 config_host_data.set('CONFIG_X11', x11.found())
 config_host_data.set('CONFIG_CFI', get_option('cfi'))
 config_host_data.set('CONFIG_VMNET', vmnet.found())
+config_host_data.set('CONFIG_IOSURFACE', iosurface.found())
 config_host_data.set('QEMU_VERSION', '"@0@"'.format(meson.project_version()))
 config_host_data.set('QEMU_VERSION_MAJOR', meson.project_version().split('.')[0])
 config_host_data.set('QEMU_VERSION_MINOR', meson.project_version().split('.')[1])
diff --git a/ui/meson.build b/ui/meson.build
index 06724d0e9dff..70a815b04f9d 100644
--- a/ui/meson.build
+++ b/ui/meson.build
@@ -100,6 +100,9 @@ if config_host.has_key('CONFIG_SPICE')
     'spice-input.c',
     'spice-display.c'
   ))
+  if iosurface.found()
+    spice_core_ss.add(iosurface)
+  endif
   ui_modules += {'spice-core' : spice_core_ss}
 endif
 
diff --git a/ui/spice-display.c b/ui/spice-display.c
index 0b5f8801dab5..f75654702e64 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -792,6 +792,124 @@ static const DisplayChangeListenerOps display_listener_ops = {
 
 #ifdef HAVE_SPICE_GL
 
+#if defined(CONFIG_IOSURFACE)
+
+static void AddIntegerValue(CFMutableDictionaryRef dictionary, const CFStringRef key, int32_t value)
+{
+    CFNumberRef number = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &value);
+    CFDictionaryAddValue(dictionary, key, number);
+    CFRelease(number);
+}
+
+static int spice_iosurface_create(SimpleSpiceDisplay *ssd, int width, int height)
+{
+    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(
+        kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+    AddIntegerValue(dict, kIOSurfaceWidth, width);
+    AddIntegerValue(dict, kIOSurfaceHeight, height);
+    AddIntegerValue(dict, kIOSurfacePixelFormat, 'BGRA');
+    AddIntegerValue(dict, kIOSurfaceBytesPerElement, 4);
+
+    ssd->iosurface = IOSurfaceCreate(dict);
+    CFRelease(dict);
+
+    if (!ssd->iosurface) {
+        error_report("spice_iosurface_create: IOSurfaceCreate failed");
+        return 0;
+    }
+
+#if defined(CONFIG_ANGLE)
+    const EGLint attribs[] = {
+        EGL_WIDTH,                         width,
+        EGL_HEIGHT,                        height,
+        EGL_IOSURFACE_PLANE_ANGLE,         0,
+        EGL_TEXTURE_TARGET,                EGL_TEXTURE_2D,
+        EGL_TEXTURE_INTERNAL_FORMAT_ANGLE, GL_BGRA_EXT,
+        EGL_TEXTURE_FORMAT,                EGL_TEXTURE_RGBA,
+        EGL_TEXTURE_TYPE_ANGLE,            GL_UNSIGNED_BYTE,
+        EGL_IOSURFACE_USAGE_HINT_ANGLE,    EGL_IOSURFACE_WRITE_HINT_ANGLE,
+        EGL_NONE,                          EGL_NONE,
+    };
+    ssd->esurface = qemu_egl_init_buffer_surface(spice_gl_ctx,
+                                                 EGL_IOSURFACE_ANGLE,
+                                                 ssd->iosurface,
+                                                 attribs);
+
+    if (ssd->esurface == NULL) {
+        goto gl_error;
+    }
+
+    egl_fb_setup_new_tex(&ssd->iosurface_fb, width, height);
+
+    return 1;
+gl_error:
+    CFRelease(ssd->iosurface);
+    ssd->iosurface = NULL;
+    return 0;
+#else
+    error_report("spice_iosurface_create: ANGLE not found");
+    return 0;
+#endif
+}
+
+static void spice_iosurface_destroy(SimpleSpiceDisplay *ssd)
+{
+    if (!ssd->iosurface) {
+        return;
+    }
+#if defined(CONFIG_ANGLE)
+    egl_fb_destroy(&ssd->iosurface_fb);
+    qemu_egl_destroy_surface(ssd->esurface);
+    ssd->esurface = EGL_NO_SURFACE;
+#endif
+    CFRelease(ssd->iosurface);
+    ssd->iosurface = NULL;
+}
+
+static int spice_iosurface_resize(SimpleSpiceDisplay *ssd, int width, int height)
+{
+    if (ssd->iosurface) {
+        if (IOSurfaceGetHeight(ssd->iosurface) != width ||
+            IOSurfaceGetWidth(ssd->iosurface) != height) {
+            spice_iosurface_destroy(ssd);
+            return spice_iosurface_create(ssd, width, height);
+        } else {
+            return 1;
+        }
+    } else {
+        return spice_iosurface_create(ssd, width, height);
+    }
+}
+
+static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bool flip)
+{
+    egl_fb tmp_fb = { .texture = src_texture };
+    if (!ssd->iosurface) {
+        return;
+    }
+
+#if defined(CONFIG_ANGLE)
+    eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
+    glBindTexture(GL_TEXTURE_2D, ssd->iosurface_fb.texture);
+    eglBindTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
+    egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip);
+#endif
+}
+
+static void spice_iosurface_flush(SimpleSpiceDisplay *ssd)
+{
+    if (!ssd->iosurface) {
+        return;
+    }
+
+#if defined(CONFIG_ANGLE)
+    eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
+    eglReleaseTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
+#endif
+}
+
+#endif
+
 static void qemu_spice_gl_monitor_config(SimpleSpiceDisplay *ssd,
                                          int x, int y, int w, int h)
 {
@@ -854,6 +972,9 @@ static void spice_gl_refresh(DisplayChangeListener *dcl)
     graphic_hw_update(dcl->con);
     if (ssd->gl_updates && ssd->have_surface) {
         qemu_spice_gl_block(ssd, true);
+#if defined(CONFIG_IOSURFACE)
+        spice_iosurface_flush(ssd);
+#endif
         glFlush();
         cookie = (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_GL_DRAW_DONE, 0);
         spice_qxl_gl_draw_async(&ssd->qxl, 0, 0,
@@ -870,6 +991,11 @@ static void spice_gl_update(DisplayChangeListener *dcl,
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
 
     surface_gl_update_texture(ssd->gls, ssd->ds, x, y, w, h);
+#if defined(CONFIG_IOSURFACE)
+    if (!qemu_console_is_gl_blocked(ssd->dcl.con)) {
+        spice_iosurface_blit(ssd, ssd->ds->texture, true);
+    }
+#endif
     ssd->gl_updates++;
 }
 
@@ -897,6 +1023,21 @@ static void spice_gl_switch(DisplayChangeListener *dcl,
             surface_gl_destroy_texture(ssd->gls, ssd->ds);
             return;
         }
+#elif defined(CONFIG_IOSURFACE)
+        if (spice_iosurface_resize(ssd, width, height)) {
+            // FIXME: replace test code with mach ports!
+            int fds[2];
+            if (pipe(fds) != 0) {
+            }
+            fd = fds[0];
+            fourcc = 'BGRA';
+            CFRetain(ssd->iosurface);
+            write(fds[1], &ssd->iosurface, sizeof(ssd->iosurface));
+            close(fds[1]);
+        } else {
+            error_report("spice_gl_switch: failed to create IOSurface");
+            return;
+        }
 #endif
 
         trace_qemu_spice_gl_surface(ssd->qxl.id,
@@ -940,6 +1081,9 @@ static void qemu_spice_gl_scanout_disable(void *dg)
     qemu_spice_gl_monitor_config(ssd, 0, 0, 0, 0);
     ssd->have_surface = false;
     ssd->have_scanout = false;
+#if defined(CONFIG_IOSURFACE)
+    spice_iosurface_destroy(ssd);
+#endif
 #if defined(CONFIG_ANGLE)
     ssd->backing_borrow = NULL;
     ssd->backing_id = -1;
@@ -967,6 +1111,23 @@ static void qemu_spice_gl_scanout_texture(void *dg,
 
 #if defined(CONFIG_GBM)
     fd = egl_get_fd_for_texture(tex_id, &stride, &fourcc, NULL);
+#elif defined(CONFIG_IOSURFACE)
+    if (spice_iosurface_resize(ssd, backing_width, backing_height)) {
+        // FIXME: replace test code with mach ports!
+#if defined(CONFIG_ANGLE)
+        ssd->backing_borrow = backing_borrow;
+        ssd->backing_id = backing_id;
+#endif
+        int fds[2];
+        pipe(fds);
+        fd = fds[0];
+        fourcc = 'BGRA';
+        CFRetain(ssd->iosurface);
+        write(fds[1], &ssd->iosurface, sizeof(ssd->iosurface));
+        close(fds[1]);
+    } else {
+        fd = -1;
+    }
 #endif
     if (fd < 0) {
         fprintf(stderr, "%s: failed to get fd for texture\n", __func__);
@@ -1118,6 +1279,12 @@ static void qemu_spice_gl_update(DisplayChangeListener *dcl,
                           !y_0_top, x, y, 1.0, 1.0);
         glFlush();
     }
+#elif defined(CONFIG_ANGLE) && defined(CONFIG_IOSURFACE)
+    GLuint tex_id = ssd->backing_borrow(ssd->backing_id, &y_0_top,
+                                        NULL, NULL);
+    spice_iosurface_blit(ssd, tex_id, !y_0_top);
+    spice_iosurface_flush(ssd);
+    //TODO: cursor stuff
 #endif
 
     trace_qemu_spice_gl_update(ssd->qxl.id, w, h, x, y);
@@ -1171,6 +1338,9 @@ static void qemu_spice_display_init_one(QemuConsole *con)
         ssd->gls = qemu_gl_init_shader();
         ssd->have_surface = false;
         ssd->have_scanout = false;
+#if defined(CONFIG_IOSURFACE)
+        ssd->iosurface = NULL;
+#endif
 #if defined(CONFIG_ANGLE)
         ssd->esurface = EGL_NO_SURFACE;
         ssd->backing_borrow = NULL;

From e8f82206187f38e1fa8da5ff49f8fa4b47d1e27a Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 2 Aug 2021 11:27:44 -0700
Subject: [PATCH 121/180] spice-display: fix crash in destroy texture with
 IOSurface

---
 ui/spice-display.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/ui/spice-display.c b/ui/spice-display.c
index f75654702e64..64ed3f37e995 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -1008,6 +1008,10 @@ static void spice_gl_switch(DisplayChangeListener *dcl,
     int width = 0, height = 0;
 
     if (ssd->ds) {
+#if defined(CONFIG_IOSURFACE)
+        // need to release texture from surface before destorying it
+        spice_iosurface_flush(ssd);
+#endif
         surface_gl_destroy_texture(ssd->gls, ssd->ds);
     }
     ssd->ds = new_surface;

From 345ec3279ba59aa3a5379a7c2600993131935d35 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 2 Aug 2021 18:08:15 -0700
Subject: [PATCH 122/180] tcti: fix build after latest TCG changes

---
 accel/tcg/tcg-accel-ops.c         | 5 +++++
 include/tcg/tcg-opc.h             | 4 ++++
 tcg/aarch64-tcti/tcg-target.c.inc | 6 ++----
 tcg/aarch64-tcti/tcg-target.h     | 6 +-----
 tcg/tcg.c                         | 8 +++++++-
 5 files changed, 19 insertions(+), 10 deletions(-)

diff --git a/accel/tcg/tcg-accel-ops.c b/accel/tcg/tcg-accel-ops.c
index 1a8e8390bd60..bfc4105bcf1f 100644
--- a/accel/tcg/tcg-accel-ops.c
+++ b/accel/tcg/tcg-accel-ops.c
@@ -45,6 +45,11 @@ void tcg_cpu_init_cflags(CPUState *cpu, bool parallel)
     uint32_t cflags = cpu->cluster_index << CF_CLUSTER_SHIFT;
     cflags |= parallel ? CF_PARALLEL : 0;
     cflags |= icount_enabled() ? CF_USE_ICOUNT : 0;
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+    // GOTO_PTR is too complex to emit a simple gadget for.
+    // We'll let C handle it, since the overhead is similar.
+    cflags |= CF_NO_GOTO_PTR;
+#endif
     cpu->tcg_cflags = cflags;
 }
 
diff --git a/include/tcg/tcg-opc.h b/include/tcg/tcg-opc.h
index 675873e200f3..7db7899c86ce 100644
--- a/include/tcg/tcg-opc.h
+++ b/include/tcg/tcg-opc.h
@@ -194,7 +194,11 @@ DEF(insn_start, 0, 0, TLADDR_ARGS * TARGET_INSN_START_WORDS,
     TCG_OPF_NOT_PRESENT)
 DEF(exit_tb, 0, 0, 1, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
 DEF(goto_tb, 0, 0, 1, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+DEF(goto_ptr, 0, 1, 0, TCG_OPF_BB_EXIT | TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT)
+#else
 DEF(goto_ptr, 0, 1, 0, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
+#endif
 
 DEF(plugin_cb_start, 0, 0, 3, TCG_OPF_NOT_PRESENT)
 DEF(plugin_cb_end, 0, 0, 0, TCG_OPF_NOT_PRESENT)
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index d7bb67a92140..5a77d2f96da6 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -1214,11 +1214,9 @@ static inline bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
 }
 
 /* Test if a constant matches the constraint. */
-static int tcg_target_const_match(tcg_target_long val, TCGType type,
-                                  const TCGArgConstraint *arg_ct)
+static bool tcg_target_const_match(int64_t val, TCGType type, int ct)
 {
-    /* No need to return 0 or 1, 0 or != 0 is good enough. */
-    return arg_ct->ct & TCG_CT_CONST;
+    return ct & TCG_CT_CONST;
 }
 
 static void tcg_target_init(TCGContext *s)
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
index fa2ae5c40a3e..7eb3bb1c3d94 100644
--- a/tcg/aarch64-tcti/tcg-target.h
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -50,6 +50,7 @@
 
 #define TCG_TARGET_INSN_UNIT_SIZE        1
 #define TCG_TARGET_TLB_DISPLACEMENT_BITS 32
+#define MAX_CODE_GEN_BUFFER_SIZE  ((size_t)-1)
 
 // We're an interpreted target; even if we're JIT-compiling to our interpreter's
 // weird psuedo-native bytecode. We'll indicate that we're intepreted.
@@ -142,11 +143,6 @@
 #define TCG_TARGET_HAS_ctz_i64          0
 #define TCG_TARGET_HAS_ctpop_i64        0
 
-
-// GOTO_PTR is too complex to emit a simple gadget for.
-// We'll let C handle it, since the overhead is similar.
-#define TCG_TARGET_HAS_goto_ptr         0
-
 // We don't have a simple gadget for this, since we're always assuming softmmu.
 #define TCG_TARGET_HAS_qemu_st8_i32     0
 
diff --git a/tcg/tcg.c b/tcg/tcg.c
index b6031417d6d9..4b6c5ba5e396 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -1175,13 +1175,19 @@ bool tcg_op_supported(TCGOpcode op)
     case INDEX_op_insn_start:
     case INDEX_op_exit_tb:
     case INDEX_op_goto_tb:
-    case INDEX_op_goto_ptr:
     case INDEX_op_qemu_ld_i32:
     case INDEX_op_qemu_st_i32:
     case INDEX_op_qemu_ld_i64:
     case INDEX_op_qemu_st_i64:
         return true;
 
+    case INDEX_op_goto_ptr:
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+        return false;
+#else
+        return true;
+#endif
+
     case INDEX_op_qemu_st8_i32:
         return TCG_TARGET_HAS_qemu_st8_i32;
 

From fdd3d1d3a09e640eab7ad3ecc10a1c676d9b4b3a Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 2 Aug 2021 21:02:02 -0700
Subject: [PATCH 123/180] virtio-ramfb: enable GL if supported

---
 hw/display/virtio-ramfb.c | 49 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 46 insertions(+), 3 deletions(-)

diff --git a/hw/display/virtio-ramfb.c b/hw/display/virtio-ramfb.c
index d08bb90a14d4..19a050ae5d79 100644
--- a/hw/display/virtio-ramfb.c
+++ b/hw/display/virtio-ramfb.c
@@ -1,4 +1,5 @@
 #include "qemu/osdep.h"
+#include "sysemu/sysemu.h"
 #include "hw/pci/pci.h"
 #include "ui/console.h"
 #include "hw/qdev-properties.h"
@@ -27,6 +28,18 @@ struct VirtIORAMFBBaseClass {
     DeviceReset parent_reset;
 };
 
+static int virtio_ramfb_get_flags(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->get_flags) {
+        return g->hw_ops->get_flags(g);
+    } else {
+        return 0;
+    }
+}
+
 static void virtio_ramfb_invalidate_display(void *opaque)
 {
     VirtIORAMFBBase *vramfb = opaque;
@@ -37,6 +50,16 @@ static void virtio_ramfb_invalidate_display(void *opaque)
     }
 }
 
+static void virtio_ramfb_text_update(void *opaque, console_ch_t *chardata)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->text_update) {
+        g->hw_ops->text_update(g, chardata);
+    }
+}
+
 static void virtio_ramfb_update_display(void *opaque)
 {
     VirtIORAMFBBase *vramfb = opaque;
@@ -70,11 +93,24 @@ static void virtio_ramfb_gl_block(void *opaque, bool block)
     }
 }
 
+static void virtio_ramfb_gl_flushed(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->gl_flushed) {
+        g->hw_ops->gl_flushed(g);
+    }
+}
+
 static const GraphicHwOps virtio_ramfb_ops = {
+    .get_flags = virtio_ramfb_get_flags,
     .invalidate = virtio_ramfb_invalidate_display,
     .gfx_update = virtio_ramfb_update_display,
+    .text_update = virtio_ramfb_text_update,
     .ui_info = virtio_ramfb_ui_info,
     .gl_block = virtio_ramfb_gl_block,
+    .gl_flushed = virtio_ramfb_gl_flushed,
 };
 
 static const VMStateDescription vmstate_virtio_ramfb = {
@@ -161,15 +197,22 @@ struct VirtIORAMFB {
     VirtIORAMFBBase parent_obj;
 
     VirtIOGPU     vdev;
+    VirtIOGPUGL   vdevgl;
 };
 
 static void virtio_ramfb_inst_initfn(Object *obj)
 {
     VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
 
-    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
-                                TYPE_VIRTIO_GPU);
-    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+    if (display_opengl) {
+        virtio_instance_init_common(obj, &dev->vdevgl, sizeof(dev->vdevgl),
+                                    TYPE_VIRTIO_GPU_GL);
+        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdevgl);
+    } else {
+        virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                    TYPE_VIRTIO_GPU);
+        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+    }
 }
 
 static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {

From 929b3859bdab1c3d771450545ba48cc4b7659b1e Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sat, 7 Aug 2021 17:41:32 -0700
Subject: [PATCH 124/180] spice-display: send IOSurfaceID through pipe

This is still a hacky workaround to using mach ports but should support
different processes on macOS.
---
 ui/spice-display.c | 47 ++++++++++++++++++++++++++++++----------------
 1 file changed, 31 insertions(+), 16 deletions(-)

diff --git a/ui/spice-display.c b/ui/spice-display.c
index 64ed3f37e995..8f1f3734b01b 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -24,6 +24,9 @@
 #include "qemu/queue.h"
 #include "ui/console.h"
 #include "trace.h"
+#ifdef CONFIG_IOSURFACE
+#include <TargetConditionals.h>
+#endif
 
 #include "ui/spice-display.h"
 
@@ -809,6 +812,9 @@ static int spice_iosurface_create(SimpleSpiceDisplay *ssd, int width, int height
     AddIntegerValue(dict, kIOSurfaceHeight, height);
     AddIntegerValue(dict, kIOSurfacePixelFormat, 'BGRA');
     AddIntegerValue(dict, kIOSurfaceBytesPerElement, 4);
+#if TARGET_OS_OSX
+    CFDictionaryAddValue(dict, kIOSurfaceIsGlobal, kCFBooleanTrue);
+#endif
 
     ssd->iosurface = IOSurfaceCreate(dict);
     CFRelease(dict);
@@ -881,6 +887,26 @@ static int spice_iosurface_resize(SimpleSpiceDisplay *ssd, int width, int height
     }
 }
 
+/* FIXME: use mach ports instead of this hack */
+static int spice_iosurface_create_fd(SimpleSpiceDisplay *ssd, int *fourcc)
+{
+    int fds[2];
+    IOSurfaceID surfaceid;
+
+    if (!ssd->iosurface) {
+        return -1;
+    }
+    if (pipe(fds) < 0) {
+        error_report("spice_iosurface_create_fd: failed to create pipe");
+        return -1;
+    }
+    *fourcc = 'BGRA';
+    surfaceid = IOSurfaceGetID(ssd->iosurface);
+    write(fds[1], &surfaceid, sizeof(surfaceid));
+    close(fds[1]);
+    return fds[0];
+}
+
 static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bool flip)
 {
     egl_fb tmp_fb = { .texture = src_texture };
@@ -1029,15 +1055,11 @@ static void spice_gl_switch(DisplayChangeListener *dcl,
         }
 #elif defined(CONFIG_IOSURFACE)
         if (spice_iosurface_resize(ssd, width, height)) {
-            // FIXME: replace test code with mach ports!
-            int fds[2];
-            if (pipe(fds) != 0) {
+            fd = spice_iosurface_create_fd(ssd, &fourcc);
+            if (fd < 0) {
+                error_report("spice_gl_switch: failed to create fd");
+                return;
             }
-            fd = fds[0];
-            fourcc = 'BGRA';
-            CFRetain(ssd->iosurface);
-            write(fds[1], &ssd->iosurface, sizeof(ssd->iosurface));
-            close(fds[1]);
         } else {
             error_report("spice_gl_switch: failed to create IOSurface");
             return;
@@ -1117,18 +1139,11 @@ static void qemu_spice_gl_scanout_texture(void *dg,
     fd = egl_get_fd_for_texture(tex_id, &stride, &fourcc, NULL);
 #elif defined(CONFIG_IOSURFACE)
     if (spice_iosurface_resize(ssd, backing_width, backing_height)) {
-        // FIXME: replace test code with mach ports!
 #if defined(CONFIG_ANGLE)
         ssd->backing_borrow = backing_borrow;
         ssd->backing_id = backing_id;
 #endif
-        int fds[2];
-        pipe(fds);
-        fd = fds[0];
-        fourcc = 'BGRA';
-        CFRetain(ssd->iosurface);
-        write(fds[1], &ssd->iosurface, sizeof(ssd->iosurface));
-        close(fds[1]);
+        fd = spice_iosurface_create_fd(ssd, &fourcc);
     } else {
         fd = -1;
     }

From 753fffe1ea17517548f58ea52560789157c8ef45 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Wed, 25 Aug 2021 15:46:30 -0700
Subject: [PATCH 125/180] spice-display: support GL_TEXTURE_RECTANGLE_ANGLE

On macOS with CGL rendering backend, IOSurface only supports rectangle
texture targets. On iOS, EAGL, and Metal rendering backends IOSurface
only supports 2D texture targets.
---
 include/ui/egl-helpers.h |  4 ++++
 ui/egl-helpers.c         | 30 +++++++++++++++++++++---------
 ui/spice-display.c       | 30 ++++++++++++++++++++++++++----
 3 files changed, 51 insertions(+), 13 deletions(-)

diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
index 117596c1cb67..c6e95b4d5f4a 100644
--- a/include/ui/egl-helpers.h
+++ b/include/ui/egl-helpers.h
@@ -20,14 +20,18 @@ typedef struct egl_fb {
     int width;
     int height;
     GLuint texture;
+    GLenum texture_target;
     GLuint framebuffer;
     bool delete_texture;
 } egl_fb;
 
 void egl_fb_destroy(egl_fb *fb);
 void egl_fb_setup_default(egl_fb *fb, int width, int height);
+void egl_fb_setup_for_tex_target(egl_fb *fb, int width, int height,
+                                 GLuint texture, GLenum target, bool delete);
 void egl_fb_setup_for_tex(egl_fb *fb, int width, int height,
                           GLuint texture, bool delete);
+void egl_fb_setup_new_tex_target(egl_fb *fb, int width, int height, GLenum target);
 void egl_fb_setup_new_tex(egl_fb *fb, int width, int height);
 void egl_fb_blit(egl_fb *dst, egl_fb *src, bool flip);
 void egl_fb_read(DisplaySurface *dst, egl_fb *src);
diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index 0b68f70d6a45..c38667661b5e 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -58,14 +58,15 @@ void egl_fb_setup_default(egl_fb *fb, int width, int height)
     fb->framebuffer = 0; /* default framebuffer */
 }
 
-void egl_fb_setup_for_tex(egl_fb *fb, int width, int height,
-                          GLuint texture, bool delete)
+void egl_fb_setup_for_tex_target(egl_fb *fb, int width, int height,
+                                 GLuint texture, GLenum target, bool delete)
 {
     egl_fb_delete_texture(fb);
 
     fb->width = width;
     fb->height = height;
     fb->texture = texture;
+    fb->texture_target = target;
     fb->delete_texture = delete;
     if (!fb->framebuffer) {
         glGenFramebuffers(1, &fb->framebuffer);
@@ -73,19 +74,30 @@ void egl_fb_setup_for_tex(egl_fb *fb, int width, int height,
 
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, fb->framebuffer);
     glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
-                              GL_TEXTURE_2D, fb->texture, 0);
+                              fb->texture_target, fb->texture, 0);
 }
 
-void egl_fb_setup_new_tex(egl_fb *fb, int width, int height)
+void egl_fb_setup_for_tex(egl_fb *fb, int width, int height,
+                          GLuint texture, bool delete)
+{
+    egl_fb_setup_for_tex_target(fb, width, height, texture, GL_TEXTURE_2D, delete);
+}
+
+void egl_fb_setup_new_tex_target(egl_fb *fb, int width, int height, GLenum target)
 {
     GLuint texture;
 
     glGenTextures(1, &texture);
-    glBindTexture(GL_TEXTURE_2D, texture);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,
+    glBindTexture(target, texture);
+    glTexImage2D(target, 0, GL_RGBA, width, height,
                  0, GL_BGRA, GL_UNSIGNED_BYTE, 0);
 
-    egl_fb_setup_for_tex(fb, width, height, texture, true);
+    egl_fb_setup_for_tex_target(fb, width, height, texture, target, true);
+}
+
+void egl_fb_setup_new_tex(egl_fb *fb, int width, int height)
+{
+    egl_fb_setup_new_tex_target(fb, width, height, GL_TEXTURE_2D);
 }
 
 void egl_fb_blit(egl_fb *dst, egl_fb *src, bool flip)
@@ -115,7 +127,7 @@ void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip)
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, dst->framebuffer);
     glViewport(0, 0, dst->width, dst->height);
     glEnable(GL_TEXTURE_2D);
-    glBindTexture(GL_TEXTURE_2D, src->texture);
+    glBindTexture(src->texture_target, src->texture);
     qemu_gl_run_texture_blit(gls, flip);
 }
 
@@ -131,7 +143,7 @@ void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
         glViewport(x, dst->height - h - y, w, h);
     }
     glEnable(GL_TEXTURE_2D);
-    glBindTexture(GL_TEXTURE_2D, src->texture);
+    glBindTexture(src->texture_target, src->texture);
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
     qemu_gl_run_texture_blit(gls, flip);
diff --git a/ui/spice-display.c b/ui/spice-display.c
index 8f1f3734b01b..0bb210a2c265 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -27,6 +27,10 @@
 #ifdef CONFIG_IOSURFACE
 #include <TargetConditionals.h>
 #endif
+#ifdef CONFIG_ANGLE
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#endif
 
 #include "ui/spice-display.h"
 
@@ -825,11 +829,29 @@ static int spice_iosurface_create(SimpleSpiceDisplay *ssd, int width, int height
     }
 
 #if defined(CONFIG_ANGLE)
+    EGLint target = 0;
+    GLenum tex_target = 0;
+    if (eglGetConfigAttrib(qemu_egl_display,
+                           qemu_egl_config,
+                           EGL_BIND_TO_TEXTURE_TARGET_ANGLE,
+                           &target) != EGL_TRUE) {
+        error_report("spice_iosurface_create: eglGetConfigAttrib failed");
+        return 0;
+    }
+    if (target == EGL_TEXTURE_2D) {
+        tex_target = GL_TEXTURE_2D;
+    } else if (target == EGL_TEXTURE_RECTANGLE_ANGLE) {
+        tex_target = GL_TEXTURE_RECTANGLE_ANGLE;
+    } else {
+        error_report("spice_iosurface_create: unsupported texture target");
+        return 0;
+    }
+
     const EGLint attribs[] = {
         EGL_WIDTH,                         width,
         EGL_HEIGHT,                        height,
         EGL_IOSURFACE_PLANE_ANGLE,         0,
-        EGL_TEXTURE_TARGET,                EGL_TEXTURE_2D,
+        EGL_TEXTURE_TARGET,                target,
         EGL_TEXTURE_INTERNAL_FORMAT_ANGLE, GL_BGRA_EXT,
         EGL_TEXTURE_FORMAT,                EGL_TEXTURE_RGBA,
         EGL_TEXTURE_TYPE_ANGLE,            GL_UNSIGNED_BYTE,
@@ -845,7 +867,7 @@ static int spice_iosurface_create(SimpleSpiceDisplay *ssd, int width, int height
         goto gl_error;
     }
 
-    egl_fb_setup_new_tex(&ssd->iosurface_fb, width, height);
+    egl_fb_setup_new_tex_target(&ssd->iosurface_fb, width, height, tex_target);
 
     return 1;
 gl_error:
@@ -909,14 +931,14 @@ static int spice_iosurface_create_fd(SimpleSpiceDisplay *ssd, int *fourcc)
 
 static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bool flip)
 {
-    egl_fb tmp_fb = { .texture = src_texture };
+    egl_fb tmp_fb = { .texture = src_texture, .texture_target = GL_TEXTURE_2D };
     if (!ssd->iosurface) {
         return;
     }
 
 #if defined(CONFIG_ANGLE)
     eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
-    glBindTexture(GL_TEXTURE_2D, ssd->iosurface_fb.texture);
+    glBindTexture(ssd->iosurface_fb.texture_target, ssd->iosurface_fb.texture);
     eglBindTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
     egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip);
 #endif

From 2b73a7937ddc83f4ec0bdbe16abf8453c07fb990 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Tue, 7 Sep 2021 01:36:59 -0700
Subject: [PATCH 126/180] virtio-ramfb: break out GL supported device

This follows the same convention as other devices.
---
 hw/display/meson.build       | 11 +++++++-
 hw/display/virtio-ramfb-gl.c | 50 ++++++++++++++++++++++++++++++++++++
 hw/display/virtio-ramfb.c    | 36 +++-----------------------
 hw/display/virtio-ramfb.h    | 28 ++++++++++++++++++++
 4 files changed, 92 insertions(+), 33 deletions(-)
 create mode 100644 hw/display/virtio-ramfb-gl.c
 create mode 100644 hw/display/virtio-ramfb.h

diff --git a/hw/display/meson.build b/hw/display/meson.build
index b3d1cccadcac..cadfa1479dc9 100644
--- a/hw/display/meson.build
+++ b/hw/display/meson.build
@@ -58,7 +58,6 @@ if config_all_devices.has_key('CONFIG_VIRTIO_GPU')
                     if_true: [files('virtio-gpu-base.c', 'virtio-gpu.c'), pixman])
   virtio_gpu_ss.add(when: 'CONFIG_LINUX', if_true: files('virtio-gpu-udmabuf.c'))
   virtio_gpu_ss.add(when: 'CONFIG_VHOST_USER_GPU', if_true: files('vhost-user-gpu.c'))
-  virtio_gpu_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('virtio-ramfb.c'))
   hw_display_modules += {'virtio-gpu': virtio_gpu_ss}
 
   virtio_gpu_gl_ss = ss.source_set()
@@ -67,6 +66,16 @@ if config_all_devices.has_key('CONFIG_VIRTIO_GPU')
   hw_display_modules += {'virtio-gpu-gl': virtio_gpu_gl_ss}
 endif
 
+if config_all_devices.has_key('CONFIG_FW_CFG_DMA')
+  virtio_ramfb_ss = ss.source_set()
+  virtio_ramfb_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('virtio-ramfb.c'))
+  hw_display_modules += {'virtio-ramfb': virtio_ramfb_ss}
+  virtio_ramfb_gl_ss = ss.source_set()
+  virtio_ramfb_gl_ss.add(when: ['CONFIG_FW_CFG_DMA', virgl, opengl],
+                       if_true: files('virtio-ramfb-gl.c'))
+  hw_display_modules += {'virtio-ramfb-gl': virtio_ramfb_gl_ss}
+endif
+
 if config_all_devices.has_key('CONFIG_VIRTIO_PCI')
   virtio_gpu_pci_ss = ss.source_set()
   virtio_gpu_pci_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRTIO_PCI'],
diff --git a/hw/display/virtio-ramfb-gl.c b/hw/display/virtio-ramfb-gl.c
new file mode 100644
index 000000000000..19ddfd59de9d
--- /dev/null
+++ b/hw/display/virtio-ramfb-gl.c
@@ -0,0 +1,50 @@
+#include "qemu/osdep.h"
+#include "hw/pci/pci.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-gpu.h"
+#include "hw/display/vga.h"
+#include "qapi/error.h"
+#include "qemu/module.h"
+#include "virtio-ramfb.h"
+#include "qom/object.h"
+
+#define TYPE_VIRTIO_RAMFB_GL "virtio-ramfb-gl"
+
+typedef struct VirtIORAMFBGL VirtIORAMFBGL;
+DECLARE_INSTANCE_CHECKER(VirtIORAMFBGL, VIRTIO_RAMFB_GL,
+                         TYPE_VIRTIO_RAMFB_GL)
+
+struct VirtIORAMFBGL {
+    VirtIORAMFBBase parent_obj;
+
+    VirtIOGPUGL   vdev;
+};
+
+static void virtio_ramfb_gl_inst_initfn(Object *obj)
+{
+    VirtIORAMFBGL *dev = VIRTIO_RAMFB_GL(obj);
+    
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU_GL);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+}
+
+
+static VirtioPCIDeviceTypeInfo virtio_ramfb_gl_info = {
+    .generic_name  = TYPE_VIRTIO_RAMFB_GL,
+    .parent        = TYPE_VIRTIO_RAMFB_BASE,
+    .instance_size = sizeof(VirtIORAMFBGL),
+    .instance_init = virtio_ramfb_gl_inst_initfn,
+};
+module_obj(TYPE_VIRTIO_RAMFB_GL);
+
+static void virtio_ramfb_register_types(void)
+{
+    if (have_vga) {
+        virtio_pci_types_register(&virtio_ramfb_gl_info);
+    }
+}
+
+type_init(virtio_ramfb_register_types)
+
+module_dep("hw-display-virtio-ramfb");
diff --git a/hw/display/virtio-ramfb.c b/hw/display/virtio-ramfb.c
index 19a050ae5d79..f7f7d23c8d00 100644
--- a/hw/display/virtio-ramfb.c
+++ b/hw/display/virtio-ramfb.c
@@ -3,31 +3,10 @@
 #include "hw/pci/pci.h"
 #include "ui/console.h"
 #include "hw/qdev-properties.h"
-#include "hw/virtio/virtio-gpu-pci.h"
+#include "virtio-ramfb.h"
 #include "qapi/error.h"
-#include "hw/display/ramfb.h"
 #include "qom/object.h"
 
-/*
- * virtio-ramfb-base: This extends VirtioPCIProxy.
- */
-#define TYPE_VIRTIO_RAMFB_BASE "virtio-ramfb-base"
-OBJECT_DECLARE_TYPE(VirtIORAMFBBase, VirtIORAMFBBaseClass,
-                    VIRTIO_RAMFB_BASE)
-
-struct VirtIORAMFBBase {
-    VirtIOPCIProxy parent_obj;
-
-    VirtIOGPUBase *vgpu;
-    RAMFBState    *ramfb;
-};
-
-struct VirtIORAMFBBaseClass {
-    VirtioPCIClass parent_class;
-
-    DeviceReset parent_reset;
-};
-
 static int virtio_ramfb_get_flags(void *opaque)
 {
     VirtIORAMFBBase *vramfb = opaque;
@@ -197,22 +176,15 @@ struct VirtIORAMFB {
     VirtIORAMFBBase parent_obj;
 
     VirtIOGPU     vdev;
-    VirtIOGPUGL   vdevgl;
 };
 
 static void virtio_ramfb_inst_initfn(Object *obj)
 {
     VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
 
-    if (display_opengl) {
-        virtio_instance_init_common(obj, &dev->vdevgl, sizeof(dev->vdevgl),
-                                    TYPE_VIRTIO_GPU_GL);
-        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdevgl);
-    } else {
-        virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
-                                    TYPE_VIRTIO_GPU);
-        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
-    }
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
 }
 
 static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {
diff --git a/hw/display/virtio-ramfb.h b/hw/display/virtio-ramfb.h
new file mode 100644
index 000000000000..73bde4ba0e10
--- /dev/null
+++ b/hw/display/virtio-ramfb.h
@@ -0,0 +1,28 @@
+#ifndef VIRTIO_RAMFB_H
+#define VIRTIO_RAMFB_H
+
+#include "hw/virtio/virtio-gpu-pci.h"
+#include "hw/display/ramfb.h"
+#include "qom/object.h"
+
+/*
+ * virtio-ramfb-base: This extends VirtioPCIProxy.
+ */
+#define TYPE_VIRTIO_RAMFB_BASE "virtio-ramfb-base"
+OBJECT_DECLARE_TYPE(VirtIORAMFBBase, VirtIORAMFBBaseClass,
+                    VIRTIO_RAMFB_BASE)
+
+struct VirtIORAMFBBase {
+    VirtIOPCIProxy parent_obj;
+
+    VirtIOGPUBase *vgpu;
+    RAMFBState    *ramfb;
+};
+
+struct VirtIORAMFBBaseClass {
+    VirtioPCIClass parent_class;
+
+    DeviceReset parent_reset;
+};
+
+#endif /* VIRTIO_RAMFB_H */

From e73864e11d4f3224174a677a96925d253ccf892d Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Wed, 8 Sep 2021 19:58:01 -0700
Subject: [PATCH 127/180] shaders: support byte swapping of pixels

Some EGL implementations do not support GL_BGRA_EXT so we always use
a surface format of GL_RGBA and then swap the bytes with a fragment
shader.
---
 include/ui/console.h             |  1 +
 include/ui/egl-helpers.h         |  4 ++--
 include/ui/shader.h              |  2 +-
 ui/cocoa/main.m                  |  4 ++--
 ui/console-gl.c                  |  5 +++--
 ui/egl-headless.c                |  4 ++--
 ui/egl-helpers.c                 |  8 ++++----
 ui/gtk-egl.c                     |  4 ++--
 ui/shader.c                      | 26 +++++++++++++++++++++-----
 ui/shader/meson.build            |  1 +
 ui/shader/texture-blit-swap.frag |  7 +++++++
 ui/spice-display.c               | 12 ++++++------
 12 files changed, 52 insertions(+), 26 deletions(-)
 create mode 100644 ui/shader/texture-blit-swap.frag

diff --git a/include/ui/console.h b/include/ui/console.h
index d8d7649b1478..bd615dd56304 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -116,6 +116,7 @@ typedef struct DisplaySurface {
     GLenum glformat;
     GLenum gltype;
     GLuint texture;
+    bool   glswapped;
 #endif
 } DisplaySurface;
 
diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
index c6e95b4d5f4a..86a3dc6a2922 100644
--- a/include/ui/egl-helpers.h
+++ b/include/ui/egl-helpers.h
@@ -36,9 +36,9 @@ void egl_fb_setup_new_tex(egl_fb *fb, int width, int height);
 void egl_fb_blit(egl_fb *dst, egl_fb *src, bool flip);
 void egl_fb_read(DisplaySurface *dst, egl_fb *src);
 
-void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip);
+void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip, bool swap);
 void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
-                       int x, int y, double scale_x, double scale_y);
+                       bool swap, int x, int y, double scale_x, double scale_y);
 
 #ifdef CONFIG_GBM
 
diff --git a/include/ui/shader.h b/include/ui/shader.h
index 4c5acb2ce8b2..252192793a52 100644
--- a/include/ui/shader.h
+++ b/include/ui/shader.h
@@ -5,7 +5,7 @@
 
 typedef struct QemuGLShader QemuGLShader;
 
-void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip);
+void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip, bool swapped);
 
 QemuGLShader *qemu_gl_init_shader(void);
 void qemu_gl_fini_shader(QemuGLShader *gls);
diff --git a/ui/cocoa/main.m b/ui/cocoa/main.m
index 16bb4ace82c9..75bfedd3afcf 100644
--- a/ui/cocoa/main.m
+++ b/ui/cocoa/main.m
@@ -574,7 +574,7 @@ static void cocoa_gl_render_cursor()
     glBindTexture(GL_TEXTURE_2D, cursor_texture);
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    qemu_gl_run_texture_blit(gls, false);
+    qemu_gl_run_texture_blit(gls, false, false);
     glDisable(GL_BLEND);
 }
 
@@ -671,7 +671,7 @@ static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
         glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
         glViewport(0, 0, size.width, size.height);
         glBindTexture(GL_TEXTURE_2D, texture);
-        qemu_gl_run_texture_blit(gls, y0_top);
+        qemu_gl_run_texture_blit(gls, y0_top, false);
 
         cocoa_gl_render_cursor();
 
diff --git a/ui/console-gl.c b/ui/console-gl.c
index 7c9894a51d99..7d702b7a2181 100644
--- a/ui/console-gl.c
+++ b/ui/console-gl.c
@@ -52,8 +52,9 @@ void surface_gl_create_texture(QemuGLShader *gls,
     switch (surface->format) {
     case PIXMAN_BE_b8g8r8x8:
     case PIXMAN_BE_b8g8r8a8:
-        surface->glformat = GL_BGRA_EXT;
+        surface->glformat = GL_RGBA;
         surface->gltype = GL_UNSIGNED_BYTE;
+        surface->glswapped = true;
         break;
     case PIXMAN_BE_x8r8g8b8:
     case PIXMAN_BE_a8r8g8b8:
@@ -121,7 +122,7 @@ void surface_gl_render_texture(QemuGLShader *gls,
     glClearColor(0.1f, 0.1f, 0.1f, 0.0f);
     glClear(GL_COLOR_BUFFER_BIT);
 
-    qemu_gl_run_texture_blit(gls, false);
+    qemu_gl_run_texture_blit(gls, false, false);
 }
 
 void surface_gl_destroy_texture(QemuGLShader *gls,
diff --git a/ui/egl-headless.c b/ui/egl-headless.c
index 460a4f9e8fac..03afc57bdfcb 100644
--- a/ui/egl-headless.c
+++ b/ui/egl-headless.c
@@ -165,9 +165,9 @@ static void egl_scanout_flush(DisplayChangeListener *dcl,
     if (edpy->cursor_fb.texture) {
         /* have cursor -> render using textures */
         egl_texture_blit(edpy->gls, &edpy->blit_fb, &edpy->guest_fb,
-                         !edpy->y_0_top);
+                         !edpy->y_0_top, false);
         egl_texture_blend(edpy->gls, &edpy->blit_fb, &edpy->cursor_fb,
-                          !edpy->y_0_top, edpy->pos_x, edpy->pos_y,
+                          false, !edpy->y_0_top, edpy->pos_x, edpy->pos_y,
                           1.0, 1.0);
     } else {
         /* no cursor -> use simple framebuffer blit */
diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index c38667661b5e..8620a2272ddb 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -122,17 +122,17 @@ void egl_fb_read(DisplaySurface *dst, egl_fb *src)
                  GL_BGRA, GL_UNSIGNED_BYTE, surface_data(dst));
 }
 
-void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip)
+void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip, bool swap)
 {
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, dst->framebuffer);
     glViewport(0, 0, dst->width, dst->height);
     glEnable(GL_TEXTURE_2D);
     glBindTexture(src->texture_target, src->texture);
-    qemu_gl_run_texture_blit(gls, flip);
+    qemu_gl_run_texture_blit(gls, flip, swap);
 }
 
 void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
-                       int x, int y, double scale_x, double scale_y)
+                       bool swap, int x, int y, double scale_x, double scale_y)
 {
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, dst->framebuffer);
     int w = scale_x * src->width;
@@ -146,7 +146,7 @@ void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
     glBindTexture(src->texture_target, src->texture);
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    qemu_gl_run_texture_blit(gls, flip);
+    qemu_gl_run_texture_blit(gls, flip, swap);
     glDisable(GL_BLEND);
 }
 
diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
index 43be2a36108b..95b2c99ec595 100644
--- a/ui/gtk-egl.c
+++ b/ui/gtk-egl.c
@@ -299,9 +299,9 @@ void gd_egl_scanout_flush(DisplayChangeListener *dcl,
     egl_fb_setup_default(&vc->gfx.win_fb, ww, wh);
     if (vc->gfx.cursor_fb.texture) {
         egl_texture_blit(vc->gfx.gls, &vc->gfx.win_fb, &vc->gfx.guest_fb,
-                         vc->gfx.y0_top);
+                         vc->gfx.y0_top, false);
         egl_texture_blend(vc->gfx.gls, &vc->gfx.win_fb, &vc->gfx.cursor_fb,
-                          vc->gfx.y0_top,
+                          vc->gfx.y0_top, false,
                           vc->gfx.cursor_x, vc->gfx.cursor_y,
                           vc->gfx.scale_x, vc->gfx.scale_y);
     } else {
diff --git a/ui/shader.c b/ui/shader.c
index ae1784e7c4e1..26c5618298f1 100644
--- a/ui/shader.c
+++ b/ui/shader.c
@@ -30,10 +30,13 @@
 #include "ui/shader/texture-blit-vert.h"
 #include "ui/shader/texture-blit-flip-vert.h"
 #include "ui/shader/texture-blit-frag.h"
+#include "ui/shader/texture-blit-swap-frag.h"
 
 struct QemuGLShader {
     GLint texture_blit_prog;
     GLint texture_blit_flip_prog;
+    GLint texture_blit_swap_prog;
+    GLint texture_blit_flip_swap_prog;
     GLint texture_blit_vao;
 };
 
@@ -69,11 +72,17 @@ static GLuint qemu_gl_init_texture_blit(GLint texture_blit_prog)
     return vao;
 }
 
-void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip)
+void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip, bool swapped)
 {
-    glUseProgram(flip
-                 ? gls->texture_blit_flip_prog
-                 : gls->texture_blit_prog);
+    if (flip && swapped) {
+        glUseProgram(gls->texture_blit_flip_swap_prog);
+    } else if (flip && !swapped) {
+        glUseProgram(gls->texture_blit_flip_prog);
+    } else if (!flip && swapped) {
+        glUseProgram(gls->texture_blit_swap_prog);
+    } else { // !flip && !swapped
+        glUseProgram(gls->texture_blit_prog);
+    }
     glBindVertexArray(gls->texture_blit_vao);
     glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 }
@@ -163,7 +172,14 @@ QemuGLShader *qemu_gl_init_shader(void)
     strcpy(vert_src_body, texture_blit_flip_vert_src);
     gls->texture_blit_flip_prog = qemu_gl_create_compile_link_program
         (vert_src, frag_src);
-    if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog) {
+    strcpy(frag_src_body, texture_blit_swap_frag_src);
+    gls->texture_blit_flip_swap_prog = qemu_gl_create_compile_link_program
+        (vert_src, frag_src);
+    strcpy(vert_src_body, texture_blit_vert_src);
+    gls->texture_blit_swap_prog = qemu_gl_create_compile_link_program
+        (vert_src, frag_src);
+    if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog ||
+        !gls->texture_blit_swap_prog || !gls->texture_blit_flip_swap_prog) {
         exit(1);
     }
 
diff --git a/ui/shader/meson.build b/ui/shader/meson.build
index 592bf596b9a5..90b5fa04e6f2 100644
--- a/ui/shader/meson.build
+++ b/ui/shader/meson.build
@@ -1,5 +1,6 @@
 shaders = [
   ['texture-blit', 'frag'],
+  ['texture-blit-swap', 'frag'],
   ['texture-blit', 'vert'],
   ['texture-blit-flip', 'vert'],
 ]
diff --git a/ui/shader/texture-blit-swap.frag b/ui/shader/texture-blit-swap.frag
new file mode 100644
index 000000000000..8c97bcbac551
--- /dev/null
+++ b/ui/shader/texture-blit-swap.frag
@@ -0,0 +1,7 @@
+uniform sampler2D image;
+in  mediump vec2 ex_tex_coord;
+out mediump vec4 out_frag_color;
+
+void main(void) {
+     out_frag_color = texture(image, ex_tex_coord).zyxw;
+}
diff --git a/ui/spice-display.c b/ui/spice-display.c
index 0bb210a2c265..a6afc87be823 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -929,7 +929,7 @@ static int spice_iosurface_create_fd(SimpleSpiceDisplay *ssd, int *fourcc)
     return fds[0];
 }
 
-static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bool flip)
+static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bool flip, bool swap)
 {
     egl_fb tmp_fb = { .texture = src_texture, .texture_target = GL_TEXTURE_2D };
     if (!ssd->iosurface) {
@@ -940,7 +940,7 @@ static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bo
     eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
     glBindTexture(ssd->iosurface_fb.texture_target, ssd->iosurface_fb.texture);
     eglBindTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
-    egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip);
+    egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip, swap);
 #endif
 }
 
@@ -1041,7 +1041,7 @@ static void spice_gl_update(DisplayChangeListener *dcl,
     surface_gl_update_texture(ssd->gls, ssd->ds, x, y, w, h);
 #if defined(CONFIG_IOSURFACE)
     if (!qemu_console_is_gl_blocked(ssd->dcl.con)) {
-        spice_iosurface_blit(ssd, ssd->ds->texture, true);
+        spice_iosurface_blit(ssd, ssd->ds->texture, true, ssd->ds->glswapped);
     }
 #endif
     ssd->gl_updates++;
@@ -1315,15 +1315,15 @@ static void qemu_spice_gl_update(DisplayChangeListener *dcl,
         y = ssd->ptr_y;
         qemu_mutex_unlock(&ssd->lock);
         egl_texture_blit(ssd->gls, &ssd->blit_fb, &ssd->guest_fb,
-                         !y_0_top);
+                         !y_0_top, false);
         egl_texture_blend(ssd->gls, &ssd->blit_fb, &ssd->cursor_fb,
-                          !y_0_top, x, y, 1.0, 1.0);
+                          !y_0_top, false, x, y, 1.0, 1.0);
         glFlush();
     }
 #elif defined(CONFIG_ANGLE) && defined(CONFIG_IOSURFACE)
     GLuint tex_id = ssd->backing_borrow(ssd->backing_id, &y_0_top,
                                         NULL, NULL);
-    spice_iosurface_blit(ssd, tex_id, !y_0_top);
+    spice_iosurface_blit(ssd, tex_id, !y_0_top, false);
     spice_iosurface_flush(ssd);
     //TODO: cursor stuff
 #endif

From 0d24c5332f79f11d412c32ce351e32a16a609df2 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@csgraf.de>
Date: Thu, 30 Dec 2021 11:41:18 +0100
Subject: [PATCH 128/180] HACK: hvf: arm: Always treat SMC as enabled conduit

The Windows 10 and 11 for ARM boot code implicitly assumes that SMC is a valid
SMCCC conduit to call for an OEM SMCCC call.

This patch forces HVF to treat SMC as an always active conduit, even when the
user has configured HVC. That way, the OEM SMCCC call gets handled as an
unimplemented SMCCC function (return -1) rather than an invalid conduit (inject
undefined instruction exception) which crashes Windows.

With this patch applied, I can successfully boot Windows for ARM Insider
Previews.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
---
 target/arm/hvf/hvf.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 0dc96560d346..b940b3d36548 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -61,6 +61,8 @@
 #define TMR_CTL_IMASK   (1 << 1)
 #define TMR_CTL_ISTATUS (1 << 2)
 
+static const bool windows_workaround_enabled = true;
+
 static void hvf_wfi(CPUState *cpu);
 
 typedef struct HVFVTimer {
@@ -1218,7 +1220,8 @@ int hvf_vcpu_exec(CPUState *cpu)
         break;
     case EC_AA64_SMC:
         cpu_synchronize_state(cpu);
-        if (arm_cpu->psci_conduit == QEMU_PSCI_CONDUIT_SMC) {
+        if (windows_workaround_enabled ||
+            arm_cpu->psci_conduit == QEMU_PSCI_CONDUIT_SMC) {
             advance_pc = true;
 
             if (!hvf_handle_psci_call(cpu)) {

From cc24c9b7cbeae33b651e17819e447b9280119b19 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 10 Jan 2022 15:35:44 -0800
Subject: [PATCH 129/180] meson: build qemu-img as shared library

---
 meson.build | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/meson.build b/meson.build
index c016541ad842..7bba4a7a43e9 100644
--- a/meson.build
+++ b/meson.build
@@ -3072,6 +3072,10 @@ if xkbcommon.found()
 endif
 
 if have_tools
+  if config_all.has_key('CONFIG_SHARED_LIBRARY_BUILD')
+    qemu_img_lib = shared_library('qemu-img', [files('qemu-img.c'), hxdep],
+             dependencies: [authz, block, crypto, io, qom, qemuutil], install: true)
+  endif
   qemu_img = executable('qemu-img', [files('qemu-img.c'), hxdep],
              dependencies: [authz, block, crypto, io, qom, qemuutil], install: true)
   qemu_io = executable('qemu-io', files('qemu-io.c'),

From 6409730ff961a6251c858a135198b27fc3370c78 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 21 Feb 2022 18:04:32 -0800
Subject: [PATCH 130/180] spice-display: reduce race in sending IOSurface

There is a kernel bug detailed in
https://github.com/utmapp/UTM/issues/2743#issuecomment-1047175257
which results in a race whenever IOSurfaceGetID/IOSurfaceLookup is used.
As a result, we need a way to "indicate" to the receiver that the
surface id in the pipe is now stale and should not be used. To do this
we send POLLHUP to poll() by closing the write FD when the surface is
about to be deallocated.

Note this does not fix the race completely as there is still a small
chance that the race happens between the close() and the CFRelease() but
the chance of that is small and the whole FD passing surface ID system
is a hack anyways that should be replaced with a proper set of SPICE
APIs one day...
---
 include/ui/spice-display.h |  1 +
 ui/spice-display.c         | 18 ++++++++++++++++--
 2 files changed, 17 insertions(+), 2 deletions(-)

diff --git a/include/ui/spice-display.h b/include/ui/spice-display.h
index b2f6570706e6..b93d9ccb5945 100644
--- a/include/ui/spice-display.h
+++ b/include/ui/spice-display.h
@@ -137,6 +137,7 @@ struct SimpleSpiceDisplay {
 #endif
 #if defined(CONFIG_IOSURFACE)
     IOSurfaceRef iosurface;
+    int surface_send_fd;
 #endif
 #if defined(CONFIG_ANGLE)
     EGLSurface esurface;
diff --git a/ui/spice-display.c b/ui/spice-display.c
index a6afc87be823..bfadf686ae80 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -890,6 +890,13 @@ static void spice_iosurface_destroy(SimpleSpiceDisplay *ssd)
     qemu_egl_destroy_surface(ssd->esurface);
     ssd->esurface = EGL_NO_SURFACE;
 #endif
+    if (ssd->surface_send_fd > -1) {
+        // this sends POLLHUP and indicates that any unread data is stale
+        // and should not be used
+        close(ssd->surface_send_fd);
+        ssd->surface_send_fd = -1;
+    }
+    // FIXME: still a tiny race with the close() above
     CFRelease(ssd->iosurface);
     ssd->iosurface = NULL;
 }
@@ -922,10 +929,16 @@ static int spice_iosurface_create_fd(SimpleSpiceDisplay *ssd, int *fourcc)
         error_report("spice_iosurface_create_fd: failed to create pipe");
         return -1;
     }
+    if (ssd->surface_send_fd > -1) {
+        close(ssd->surface_send_fd);
+    }
+    // we keep the write end of the pipe open for the lifetime of this surface
+    // when we close it, POLLHUP will be seen by the other side and know that
+    // the surface ID is stale and should not be used
+    ssd->surface_send_fd = fds[1];
     *fourcc = 'BGRA';
     surfaceid = IOSurfaceGetID(ssd->iosurface);
-    write(fds[1], &surfaceid, sizeof(surfaceid));
-    close(fds[1]);
+    write(ssd->surface_send_fd, &surfaceid, sizeof(surfaceid));
     return fds[0];
 }
 
@@ -1381,6 +1394,7 @@ static void qemu_spice_display_init_one(QemuConsole *con)
         ssd->have_scanout = false;
 #if defined(CONFIG_IOSURFACE)
         ssd->iosurface = NULL;
+        ssd->surface_send_fd = -1;
 #endif
 #if defined(CONFIG_ANGLE)
         ssd->esurface = EGL_NO_SURFACE;

From fc43b65e0613ea629b64571db63fc17975fa173e Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Fri, 25 Feb 2022 23:57:19 -0800
Subject: [PATCH 131/180] rcu: do not register constructor thread if shared
 library

On iOS 15, the constructor can run on a new thread that is destroyed
after construction is finished in dyld. When this happens the TLS gets
freed and causes use-after-free when QEMU is built in shared library
mode. This moves the rcu_register_thread() call to qemu_init()
---
 softmmu/vl.c | 4 ++++
 util/rcu.c   | 3 +++
 2 files changed, 7 insertions(+)

diff --git a/softmmu/vl.c b/softmmu/vl.c
index 620a1f1367e2..fce310a1aa62 100644
--- a/softmmu/vl.c
+++ b/softmmu/vl.c
@@ -2773,6 +2773,10 @@ void qemu_init(int argc, char **argv, char **envp)
     bool userconfig = true;
     FILE *vmstate_dump_file = NULL;
 
+    /* in non-library builds this is done in a constructor */
+#ifdef CONFIG_SHARED_LIBRARY_BUILD
+    rcu_register_thread();
+#endif
     qemu_add_opts(&qemu_drive_opts);
     qemu_add_drive_opts(&qemu_legacy_drive_opts);
     qemu_add_drive_opts(&qemu_common_drive_opts);
diff --git a/util/rcu.c b/util/rcu.c
index c91da9f137c8..60fbf9440187 100644
--- a/util/rcu.c
+++ b/util/rcu.c
@@ -398,7 +398,10 @@ static void rcu_init_complete(void)
     qemu_thread_create(&thread, "call_rcu", call_rcu_thread,
                        NULL, QEMU_THREAD_DETACHED);
 
+    /* TLS not available in shared library */
+#ifndef CONFIG_SHARED_LIBRARY_BUILD
     rcu_register_thread();
+#endif
 }
 
 static int atfork_depth = 1;

From 8f1617b581bc4ed9d534ebfc276ceb9ae6d4c730 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 27 Feb 2022 12:48:07 -0800
Subject: [PATCH 132/180] pc: add option to disable PS/2 mouse/keyboard

On some older software like Windows 7 installer, having both a PS/2
mouse and USB mouse results in only one device working property (which
might be a different device each boot). While the workaround to not use
a USB mouse with such software is valid, it creates an inconsistent
experience if the user wishes to always use a USB mouse.

This introduces a new machine property to inhibit the creation of the
i8042 PS/2 controller.
---
 hw/i386/pc.c         | 28 ++++++++++++++++++++++++++--
 include/hw/i386/pc.h |  2 ++
 2 files changed, 28 insertions(+), 2 deletions(-)

diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index a2ef40ecbc24..8a6a089ee242 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1008,7 +1008,8 @@ static const MemoryRegionOps ioportF0_io_ops = {
     },
 };
 
-static void pc_superio_init(ISABus *isa_bus, bool create_fdctrl, bool no_vmport)
+static void pc_superio_init(ISABus *isa_bus, bool create_fdctrl,
+                            bool create_i8042, bool no_vmport)
 {
     int i;
     DriveInfo *fd[MAX_FD];
@@ -1030,6 +1031,10 @@ static void pc_superio_init(ISABus *isa_bus, bool create_fdctrl, bool no_vmport)
         }
     }
 
+    if (!create_i8042) {
+        return;
+    }
+
     i8042 = isa_create_simple(isa_bus, "i8042");
     if (!no_vmport) {
         isa_create_simple(isa_bus, TYPE_VMPORT);
@@ -1125,7 +1130,8 @@ void pc_basic_device_init(struct PCMachineState *pcms,
     i8257_dma_init(isa_bus, 0);
 
     /* Super I/O */
-    pc_superio_init(isa_bus, create_fdctrl, pcms->vmport != ON_OFF_AUTO_ON);
+    pc_superio_init(isa_bus, create_fdctrl, pcms->i8042_enabled,
+                    pcms->vmport != ON_OFF_AUTO_ON);
 }
 
 void pc_nic_init(PCMachineClass *pcmc, ISABus *isa_bus, PCIBus *pci_bus)
@@ -1506,6 +1512,20 @@ static void pc_machine_set_hpet(Object *obj, bool value, Error **errp)
     pcms->hpet_enabled = value;
 }
 
+static bool pc_machine_get_i8042(Object *obj, Error **errp)
+{
+    PCMachineState *pcms = PC_MACHINE(obj);
+
+    return pcms->i8042_enabled;
+}
+
+static void pc_machine_set_i8042(Object *obj, bool value, Error **errp)
+{
+    PCMachineState *pcms = PC_MACHINE(obj);
+
+    pcms->i8042_enabled = value;
+}
+
 static bool pc_machine_get_default_bus_bypass_iommu(Object *obj, Error **errp)
 {
     PCMachineState *pcms = PC_MACHINE(obj);
@@ -1616,6 +1636,7 @@ static void pc_machine_initfn(Object *obj)
     pcms->smbus_enabled = true;
     pcms->sata_enabled = true;
     pcms->pit_enabled = true;
+    pcms->i8042_enabled = true;
     pcms->max_fw_size = 8 * MiB;
 #ifdef CONFIG_HPET
     pcms->hpet_enabled = true;
@@ -1744,6 +1765,9 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
     object_class_property_add_bool(oc, "hpet",
         pc_machine_get_hpet, pc_machine_set_hpet);
 
+    object_class_property_add_bool(oc, PC_MACHINE_I8042,
+        pc_machine_get_i8042, pc_machine_set_i8042);
+
     object_class_property_add_bool(oc, "default-bus-bypass-iommu",
         pc_machine_get_default_bus_bypass_iommu,
         pc_machine_set_default_bus_bypass_iommu);
diff --git a/include/hw/i386/pc.h b/include/hw/i386/pc.h
index 9ab39e428f80..642c915aa39a 100644
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -46,6 +46,7 @@ typedef struct PCMachineState {
     bool sata_enabled;
     bool pit_enabled;
     bool hpet_enabled;
+    bool i8042_enabled;
     bool default_bus_bypass_iommu;
     uint64_t max_fw_size;
 
@@ -62,6 +63,7 @@ typedef struct PCMachineState {
 #define PC_MACHINE_SMBUS            "smbus"
 #define PC_MACHINE_SATA             "sata"
 #define PC_MACHINE_PIT              "pit"
+#define PC_MACHINE_I8042            "i8042"
 #define PC_MACHINE_MAX_FW_SIZE      "max-fw-size"
 /**
  * PCMachineClass:

From c94e174af82ce0a5f127ce335e583a815f93b396 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <f4bug@amsat.org>
Date: Thu, 17 Mar 2022 13:55:33 +0100
Subject: [PATCH 133/180] ui/cocoa: Code movement
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Pure code movement in preparation for the next commit.

Reviewed-by: Peter Maydell <peter.maydell@linaro.org>
Signed-off-by: Philippe Mathieu-Daudé <f4bug@amsat.org>
Message-Id: <20220317125534.38706-2-philippe.mathieu.daude@gmail.com>
---
 ui/cocoa.m | 86 +++++++++++++++++++++++++++---------------------------
 1 file changed, 43 insertions(+), 43 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index cb6e7c41dc6f..027c3053f782 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -75,6 +75,9 @@
     int height;
 } QEMUScreen;
 
+@interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
+@end
+
 static void cocoa_update(DisplayChangeListener *dcl,
                          int x, int y, int w, int h);
 
@@ -109,6 +112,8 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 
 static NSInteger cbchangecount = -1;
 static QemuClipboardInfo *cbinfo;
+static QemuClipboardPeer cbpeer;
+static QemuCocoaPasteboardTypeOwner *cbowner;
 static QemuEvent cbevent;
 
 // Utility functions to run specified code block with iothread lock held
@@ -142,6 +147,44 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
     return val;
 }
 
+/*
+ * The startup process for the OSX/Cocoa UI is complicated, because
+ * OSX insists that the UI runs on the initial main thread, and so we
+ * need to start a second thread which runs the vl.c qemu_main():
+ *
+ * Initial thread:                    2nd thread:
+ * in main():
+ *  create qemu-main thread
+ *  wait on display_init semaphore
+ *                                    call qemu_main()
+ *                                    ...
+ *                                    in cocoa_display_init():
+ *                                     post the display_init semaphore
+ *                                     wait on app_started semaphore
+ *  create application, menus, etc
+ *  enter OSX run loop
+ * in applicationDidFinishLaunching:
+ *  post app_started semaphore
+ *                                     tell main thread to fullscreen if needed
+ *                                    [...]
+ *                                    run qemu main-loop
+ *
+ * We do this in two stages so that we don't do the creation of the
+ * GUI application menus and so on for command line options like --help
+ * where we want to just print text to stdout and exit immediately.
+ */
+
+static void *call_qemu_main(void *opaque)
+{
+    int status;
+
+    COCOA_DEBUG("Second thread: calling qemu_main()\n");
+    status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
+    COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
+    [cbowner release];
+    exit(status);
+}
+
 // Mac to QKeyCode conversion
 static const int mac_to_qkeycode_map[] = {
     [kVK_ANSI_A] = Q_KEY_CODE_A,
@@ -1804,9 +1847,6 @@ static void addRemovableDevicesMenuItems(void)
     qapi_free_BlockInfoList(pointerToFree);
 }
 
-@interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
-@end
-
 @implementation QemuCocoaPasteboardTypeOwner
 
 - (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
@@ -1841,8 +1881,6 @@ - (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)t
 
 @end
 
-static QemuCocoaPasteboardTypeOwner *cbowner;
-
 static void cocoa_clipboard_notify(Notifier *notifier, void *data);
 static void cocoa_clipboard_request(QemuClipboardInfo *info,
                                     QemuClipboardType type);
@@ -1903,44 +1941,6 @@ static void cocoa_clipboard_request(QemuClipboardInfo *info,
     }
 }
 
-/*
- * The startup process for the OSX/Cocoa UI is complicated, because
- * OSX insists that the UI runs on the initial main thread, and so we
- * need to start a second thread which runs the vl.c qemu_main():
- *
- * Initial thread:                    2nd thread:
- * in main():
- *  create qemu-main thread
- *  wait on display_init semaphore
- *                                    call qemu_main()
- *                                    ...
- *                                    in cocoa_display_init():
- *                                     post the display_init semaphore
- *                                     wait on app_started semaphore
- *  create application, menus, etc
- *  enter OSX run loop
- * in applicationDidFinishLaunching:
- *  post app_started semaphore
- *                                     tell main thread to fullscreen if needed
- *                                    [...]
- *                                    run qemu main-loop
- *
- * We do this in two stages so that we don't do the creation of the
- * GUI application menus and so on for command line options like --help
- * where we want to just print text to stdout and exit immediately.
- */
-
-static void *call_qemu_main(void *opaque)
-{
-    int status;
-
-    COCOA_DEBUG("Second thread: calling qemu_main()\n");
-    status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
-    COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
-    [cbowner release];
-    exit(status);
-}
-
 int main (int argc, char **argv) {
     QemuThread thread;
 

From cd85cb5abeddb97117dbb0cfb741064b6443a3df Mon Sep 17 00:00:00 2001
From: Paolo Bonzini <pbonzini@redhat.com>
Date: Thu, 17 Mar 2022 13:55:34 +0100
Subject: [PATCH 134/180] ui/cocoa: run qemu_init in the main thread
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Simplify the initialization dance by running qemu_init() in the main
thread before the Cocoa event loop starts.  The cocoa_display_init()
code that is post-applicationDidFinishLaunching: moves to the
application delegate itself, and the secondary thread only runs
the rest of qemu_main(), namely qemu_main_loop() and qemu_cleanup().

This fixes a case where addRemovableDevicesMenuItems() calls
qmp_query_block() while expecting the main thread to still hold
the BQL.  The newly-introduced assertions in the block layer
complain about this.

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20220307151004.578069-1-pbonzini@redhat.com>
[PMD: Fixed trivial build failures & rebased]
Reviewed-by: Peter Maydell <peter.maydell@linaro.org>
Signed-off-by: Philippe Mathieu-Daudé <f4bug@amsat.org>
Message-Id: <20220317125534.38706-3-philippe.mathieu.daude@gmail.com>
---
 softmmu/main.c |  12 +++--
 ui/cocoa.m     | 123 +++++++++++++++++++++----------------------------
 2 files changed, 60 insertions(+), 75 deletions(-)

diff --git a/softmmu/main.c b/softmmu/main.c
index 639c67ff4893..0c4384e98012 100644
--- a/softmmu/main.c
+++ b/softmmu/main.c
@@ -39,16 +39,18 @@ int main(int argc, char **argv)
 #endif
 #endif /* CONFIG_SDL */
 
-#ifdef CONFIG_COCOA
-#undef main
-#define main qemu_main
-#endif /* CONFIG_COCOA */
-
+#ifndef CONFIG_COCOA
 int main(int argc, char **argv, char **envp)
 {
+    /*
+     * ui/cocoa.m relies on this being the exact content of main(),
+     * because it has to run everything after qemu_init in a secondary
+     * thread.
+     */
     qemu_init(argc, argv, envp);
     qemu_main_loop();
     qemu_cleanup();
 
     return 0;
 }
+#endif /* CONFIG_COCOA */
diff --git a/ui/cocoa.m b/ui/cocoa.m
index 027c3053f782..4483d5e648b4 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -100,14 +100,13 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 static int cursor_hide = 1;
 static int left_command_key_enabled = 1;
 static bool swap_opt_cmd;
+static bool full_screen;
+static bool full_grab;
+static bool have_cocoa_ui;
 
-static int gArgc;
-static char **gArgv;
 static bool stretch_video;
 static NSTextField *pauseLabel;
 
-static QemuSemaphore display_init_sem;
-static QemuSemaphore app_started_sem;
 static bool allow_events;
 
 static NSInteger cbchangecount = -1;
@@ -150,39 +149,28 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
 /*
  * The startup process for the OSX/Cocoa UI is complicated, because
  * OSX insists that the UI runs on the initial main thread, and so we
- * need to start a second thread which runs the vl.c qemu_main():
+ * need to start a second thread which runs qemu_main_loop():
  *
  * Initial thread:                    2nd thread:
  * in main():
- *  create qemu-main thread
- *  wait on display_init semaphore
- *                                    call qemu_main()
- *                                    ...
- *                                    in cocoa_display_init():
- *                                     post the display_init semaphore
- *                                     wait on app_started semaphore
+ *  qemu_init()
  *  create application, menus, etc
  *  enter OSX run loop
  * in applicationDidFinishLaunching:
- *  post app_started semaphore
- *                                     tell main thread to fullscreen if needed
- *                                    [...]
- *                                    run qemu main-loop
- *
- * We do this in two stages so that we don't do the creation of the
- * GUI application menus and so on for command line options like --help
- * where we want to just print text to stdout and exit immediately.
+ *  fullscreen if needed
+ *  create main loop thread
+ *                                    call qemu_main_loop()
  */
 
-static void *call_qemu_main(void *opaque)
+static void *call_qemu_main_loop(void *opaque)
 {
-    int status;
-
-    COCOA_DEBUG("Second thread: calling qemu_main()\n");
-    status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
-    COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
+    COCOA_DEBUG("Second thread: calling qemu_main_loop()\n");
+    qemu_mutex_lock_iothread();
+    qemu_main_loop();
+    COCOA_DEBUG("Second thread: qemu_main_loop() returned, exiting\n");
+    qemu_cleanup();
     [cbowner release];
-    exit(status);
+    exit(0);
 }
 
 // Mac to QKeyCode conversion
@@ -627,9 +615,9 @@ - (void) updateUIInfo
          * Don't try to tell QEMU about UI information in the application
          * startup phase -- we haven't yet registered dcl with the QEMU UI
          * layer, and also trying to take the iothread lock would deadlock.
-         * When cocoa_display_init() does register the dcl, the UI layer
-         * will call cocoa_switch(), which will call updateUIInfo, so
-         * we don't lose any information here.
+         * When applicationDidFinishLaunching() does register the dcl, the
+         * UI layer will call cocoa_switch(), which will call updateUIInfo,
+         * so we don't lose any information here.
          */
         return;
     }
@@ -823,9 +811,7 @@ - (bool) handleEvent:(NSEvent *)event
         /*
          * Just let OSX have all events that arrive before
          * applicationDidFinishLaunching.
-         * This avoids a deadlock on the iothread lock, which cocoa_display_init()
-         * will not drop until after the app_started_sem is posted. (In theory
-         * there should not be any such events, but OSX Catalina now emits some.)
+         * This may not be needed anymore?
          */
         return false;
     }
@@ -1321,10 +1307,27 @@ - (void) dealloc
 
 - (void)applicationDidFinishLaunching: (NSNotification *) note
 {
+    QemuThread main_thread;
+
     COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
     allow_events = true;
-    /* Tell cocoa_display_init to proceed */
-    qemu_sem_post(&app_started_sem);
+
+    // register vga output callbacks
+    register_displaychangelistener(&dcl);
+
+    qemu_clipboard_peer_register(&cbpeer);
+
+    qemu_mutex_unlock_iothread();
+    qemu_thread_create(&main_thread, "qemu_main_loop", call_qemu_main_loop,
+                       NULL, QEMU_THREAD_DETACHED);
+
+    if (full_screen) {
+        [NSApp activateIgnoringOtherApps: YES];
+        [self toggleFullScreen: nil];
+    }
+    if (full_grab) {
+        [self setFullGrab: nil];
+    }
 }
 
 - (void)applicationWillTerminate:(NSNotification *)aNotification
@@ -1941,22 +1944,17 @@ static void cocoa_clipboard_request(QemuClipboardInfo *info,
     }
 }
 
-int main (int argc, char **argv) {
-    QemuThread thread;
-
+int main(int argc, char **argv, char **envp)
+{
     COCOA_DEBUG("Entered main()\n");
-    gArgc = argc;
-    gArgv = argv;
-
-    qemu_sem_init(&display_init_sem, 0);
-    qemu_sem_init(&app_started_sem, 0);
-
-    qemu_thread_create(&thread, "qemu_main", call_qemu_main,
-                       NULL, QEMU_THREAD_DETACHED);
 
-    COCOA_DEBUG("Main thread: waiting for display_init_sem\n");
-    qemu_sem_wait(&display_init_sem);
-    COCOA_DEBUG("Main thread: initializing app\n");
+    /* Takes iothread lock, released in applicationDidFinishLaunching:.  */
+    qemu_init(argc, argv, envp);
+    if (!have_cocoa_ui) {
+         qemu_main_loop();
+         qemu_cleanup();
+         return 0;
+    }
 
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
 
@@ -1979,6 +1977,9 @@ int main (int argc, char **argv) {
     add_console_menu_entries();
     addRemovableDevicesMenuItems();
 
+    qemu_event_init(&cbevent, false);
+    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
+
     // Create an Application controller
     QemuCocoaAppController *appController = [[QemuCocoaAppController alloc] init];
     [NSApp setDelegate:appController];
@@ -2071,24 +2072,13 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
 static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 {
     COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
+    have_cocoa_ui = 1;
 
-    /* Tell main thread to go ahead and create the app and enter the run loop */
-    qemu_sem_post(&display_init_sem);
-    qemu_sem_wait(&app_started_sem);
-    COCOA_DEBUG("cocoa_display_init: app start completed\n");
-
-    QemuCocoaAppController *controller = (QemuCocoaAppController *)[[NSApplication sharedApplication] delegate];
-    /* if fullscreen mode is to be used */
     if (opts->has_full_screen && opts->full_screen) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            [NSApp activateIgnoringOtherApps: YES];
-            [controller toggleFullScreen: nil];
-        });
+        full_screen = 1;
     }
     if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            [controller setFullGrab: nil];
-        });
+        full_grab = 1;
     }
 
     if (opts->has_show_cursor && opts->show_cursor) {
@@ -2101,13 +2091,6 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
     if (opts->u.cocoa.has_left_command_key && !opts->u.cocoa.left_command_key) {
         left_command_key_enabled = 0;
     }
-
-    // register vga output callbacks
-    register_displaychangelistener(&dcl);
-
-    qemu_event_init(&cbevent, false);
-    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
-    qemu_clipboard_peer_register(&cbpeer);
 }
 
 static QemuDisplay qemu_display_cocoa = {

From d1792ff22842d8021b049e2a3da654a8c0615f2d Mon Sep 17 00:00:00 2001
From: Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
Date: Thu, 17 Mar 2022 20:28:33 +0300
Subject: [PATCH 135/180] net/vmnet: add vmnet dependency and customizable
 option

vmnet.framework dependency is added with 'vmnet' option
to enable or disable it. Default value is 'auto'.

used vmnet features are available since macOS 11.0,
but new backend can be built and work properly with
subset of them on 10.15 too.

Signed-off-by: Vladislav Yaroshchuk <Vladislav.Yaroshchuk@jetbrains.com>
Message-Id: <20220317172839.28984-2-Vladislav.Yaroshchuk@jetbrains.com>
---
 meson.build                   | 16 +++++++++++++++-
 meson_options.txt             |  2 ++
 scripts/meson-buildoptions.sh |  1 +
 3 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/meson.build b/meson.build
index bae62efc9c33..bacb0093e8b1 100644
--- a/meson.build
+++ b/meson.build
@@ -525,6 +525,18 @@ if cocoa.found() and get_option('gtk').enabled()
   error('Cocoa and GTK+ cannot be enabled at the same time')
 endif
 
+vmnet = dependency('appleframeworks', modules: 'vmnet', required: get_option('vmnet'))
+if vmnet.found() and not cc.has_header_symbol('vmnet/vmnet.h',
+                                              'VMNET_BRIDGED_MODE',
+                                              dependencies: vmnet)
+  vmnet = not_found
+  if get_option('vmnet').enabled()
+    error('vmnet.framework API is outdated')
+  else
+    warning('vmnet.framework API is outdated, disabling')
+  endif
+endif
+
 seccomp = not_found
 if not get_option('seccomp').auto() or have_system or have_tools
   seccomp = dependency('libseccomp', version: '>=2.3.0',
@@ -1553,6 +1565,7 @@ config_host_data.set('CONFIG_SNAPPY', snappy.found())
 config_host_data.set('CONFIG_TPM', have_tpm)
 config_host_data.set('CONFIG_USB_LIBUSB', libusb.found())
 config_host_data.set('CONFIG_VDE', vde.found())
+config_host_data.set('CONFIG_VMNET', vmnet.found())
 config_host_data.set('CONFIG_VHOST_USER_BLK_SERVER', have_vhost_user_blk_server)
 config_host_data.set('CONFIG_VNC', vnc.found())
 config_host_data.set('CONFIG_VNC_JPEG', jpeg.found())
@@ -3604,7 +3617,8 @@ summary(summary_info, bool_yn: true, section: 'Crypto')
 # Libraries
 summary_info = {}
 if targetos == 'darwin'
-  summary_info += {'Cocoa support':   cocoa}
+  summary_info += {'Cocoa support':           cocoa}
+  summary_info += {'vmnet.framework support': vmnet}
 endif
 summary_info += {'SDL support':       sdl}
 summary_info += {'SDL image support': sdl_image}
diff --git a/meson_options.txt b/meson_options.txt
index 52b11cead44a..d2c0b6b4123f 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -175,6 +175,8 @@ option('netmap', type : 'feature', value : 'auto',
        description: 'netmap network backend support')
 option('vde', type : 'feature', value : 'auto',
        description: 'vde network backend support')
+option('vmnet', type : 'feature', value : 'auto',
+       description: 'vmnet.framework network backend support')
 option('virglrenderer', type : 'feature', value : 'auto',
        description: 'virgl rendering support')
 option('vnc', type : 'feature', value : 'auto',
diff --git a/scripts/meson-buildoptions.sh b/scripts/meson-buildoptions.sh
index 1e26f4571ef4..a18d3660f95b 100644
--- a/scripts/meson-buildoptions.sh
+++ b/scripts/meson-buildoptions.sh
@@ -116,6 +116,7 @@ meson_options_help() {
   printf "%s\n" '  usb-redir       libusbredir support'
   printf "%s\n" '  vde             vde network backend support'
   printf "%s\n" '  vdi             vdi image format support'
+  printf "%s\n" '  vmnet           vmnet.framework network backend support'
   printf "%s\n" '  vhost-user-blk-server'
   printf "%s\n" '                  build vhost-user-blk server'
   printf "%s\n" '  virglrenderer   virgl rendering support'

From 1699eb16a7d19cd7fe7a1fe139df22b3135eafa2 Mon Sep 17 00:00:00 2001
From: Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
Date: Thu, 17 Mar 2022 20:28:34 +0300
Subject: [PATCH 136/180] net/vmnet: add vmnet backends to qapi/net

Create separate netdevs for each vmnet operating mode:
- vmnet-host
- vmnet-shared
- vmnet-bridged

Acked-by: Markus Armbruster <armbru@redhat.com>
Signed-off-by: Vladislav Yaroshchuk <Vladislav.Yaroshchuk@jetbrains.com>
Message-Id: <20220317172839.28984-3-Vladislav.Yaroshchuk@jetbrains.com>
---
 net/clients.h       |  11 ++++
 net/meson.build     |   7 +++
 net/net.c           |  10 ++++
 net/vmnet-bridged.m |  25 +++++++++
 net/vmnet-common.m  |  20 +++++++
 net/vmnet-host.c    |  24 ++++++++
 net/vmnet-shared.c  |  25 +++++++++
 net/vmnet_int.h     |  25 +++++++++
 qapi/net.json       | 133 +++++++++++++++++++++++++++++++++++++++++++-
 9 files changed, 278 insertions(+), 2 deletions(-)
 create mode 100644 net/vmnet-bridged.m
 create mode 100644 net/vmnet-common.m
 create mode 100644 net/vmnet-host.c
 create mode 100644 net/vmnet-shared.c
 create mode 100644 net/vmnet_int.h

diff --git a/net/clients.h b/net/clients.h
index 92f9b59aedce..c9157789f2ce 100644
--- a/net/clients.h
+++ b/net/clients.h
@@ -63,4 +63,15 @@ int net_init_vhost_user(const Netdev *netdev, const char *name,
 
 int net_init_vhost_vdpa(const Netdev *netdev, const char *name,
                         NetClientState *peer, Error **errp);
+#ifdef CONFIG_VMNET
+int net_init_vmnet_host(const Netdev *netdev, const char *name,
+                          NetClientState *peer, Error **errp);
+
+int net_init_vmnet_shared(const Netdev *netdev, const char *name,
+                          NetClientState *peer, Error **errp);
+
+int net_init_vmnet_bridged(const Netdev *netdev, const char *name,
+                          NetClientState *peer, Error **errp);
+#endif /* CONFIG_VMNET */
+
 #endif /* QEMU_NET_CLIENTS_H */
diff --git a/net/meson.build b/net/meson.build
index 847bc2ac85be..00a88c4951a2 100644
--- a/net/meson.build
+++ b/net/meson.build
@@ -42,4 +42,11 @@ softmmu_ss.add(when: 'CONFIG_POSIX', if_true: files(tap_posix))
 softmmu_ss.add(when: 'CONFIG_WIN32', if_true: files('tap-win32.c'))
 softmmu_ss.add(when: 'CONFIG_VHOST_NET_VDPA', if_true: files('vhost-vdpa.c'))
 
+vmnet_files = files(
+  'vmnet-common.m',
+  'vmnet-bridged.m',
+  'vmnet-host.c',
+  'vmnet-shared.c'
+)
+softmmu_ss.add(when: vmnet, if_true: vmnet_files)
 subdir('can')
diff --git a/net/net.c b/net/net.c
index f0d14dbfc1f0..1dbb64b9358a 100644
--- a/net/net.c
+++ b/net/net.c
@@ -1021,6 +1021,11 @@ static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
 #ifdef CONFIG_L2TPV3
         [NET_CLIENT_DRIVER_L2TPV3]    = net_init_l2tpv3,
 #endif
+#ifdef CONFIG_VMNET
+        [NET_CLIENT_DRIVER_VMNET_HOST] = net_init_vmnet_host,
+        [NET_CLIENT_DRIVER_VMNET_SHARED] = net_init_vmnet_shared,
+        [NET_CLIENT_DRIVER_VMNET_BRIDGED] = net_init_vmnet_bridged,
+#endif /* CONFIG_VMNET */
 };
 
 
@@ -1106,6 +1111,11 @@ void show_netdevs(void)
 #endif
 #ifdef CONFIG_VHOST_VDPA
         "vhost-vdpa",
+#endif
+#ifdef CONFIG_VMNET
+        "vmnet-host",
+        "vmnet-shared",
+        "vmnet-bridged",
 #endif
     };
 
diff --git a/net/vmnet-bridged.m b/net/vmnet-bridged.m
new file mode 100644
index 000000000000..91c1a2f2c7da
--- /dev/null
+++ b/net/vmnet-bridged.m
@@ -0,0 +1,25 @@
+/*
+ * vmnet-bridged.m
+ *
+ * Copyright(c) 2022 Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/qapi-types-net.h"
+#include "vmnet_int.h"
+#include "clients.h"
+#include "qemu/error-report.h"
+#include "qapi/error.h"
+
+#include <vmnet/vmnet.h>
+
+int net_init_vmnet_bridged(const Netdev *netdev, const char *name,
+                           NetClientState *peer, Error **errp)
+{
+  error_setg(errp, "vmnet-bridged is not implemented yet");
+  return -1;
+}
diff --git a/net/vmnet-common.m b/net/vmnet-common.m
new file mode 100644
index 000000000000..06326efb1cc3
--- /dev/null
+++ b/net/vmnet-common.m
@@ -0,0 +1,20 @@
+/*
+ * vmnet-common.m - network client wrapper for Apple vmnet.framework
+ *
+ * Copyright(c) 2022 Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
+ * Copyright(c) 2021 Phillip Tennen <phillip@axleos.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/qapi-types-net.h"
+#include "vmnet_int.h"
+#include "clients.h"
+#include "qemu/error-report.h"
+#include "qapi/error.h"
+
+#include <vmnet/vmnet.h>
+
diff --git a/net/vmnet-host.c b/net/vmnet-host.c
new file mode 100644
index 000000000000..a461d507c5f7
--- /dev/null
+++ b/net/vmnet-host.c
@@ -0,0 +1,24 @@
+/*
+ * vmnet-host.c
+ *
+ * Copyright(c) 2022 Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/qapi-types-net.h"
+#include "vmnet_int.h"
+#include "clients.h"
+#include "qemu/error-report.h"
+#include "qapi/error.h"
+
+#include <vmnet/vmnet.h>
+
+int net_init_vmnet_host(const Netdev *netdev, const char *name,
+                        NetClientState *peer, Error **errp) {
+  error_setg(errp, "vmnet-host is not implemented yet");
+  return -1;
+}
diff --git a/net/vmnet-shared.c b/net/vmnet-shared.c
new file mode 100644
index 000000000000..6dfb133a1821
--- /dev/null
+++ b/net/vmnet-shared.c
@@ -0,0 +1,25 @@
+/*
+ * vmnet-shared.c
+ *
+ * Copyright(c) 2022 Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/qapi-types-net.h"
+#include "vmnet_int.h"
+#include "clients.h"
+#include "qemu/error-report.h"
+#include "qapi/error.h"
+
+#include <vmnet/vmnet.h>
+
+int net_init_vmnet_shared(const Netdev *netdev, const char *name,
+                          NetClientState *peer, Error **errp)
+{
+  error_setg(errp, "vmnet-shared is not implemented yet");
+  return -1;
+}
diff --git a/net/vmnet_int.h b/net/vmnet_int.h
new file mode 100644
index 000000000000..c383038a1d87
--- /dev/null
+++ b/net/vmnet_int.h
@@ -0,0 +1,25 @@
+/*
+ * vmnet_int.h
+ *
+ * Copyright(c) 2022 Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+#ifndef VMNET_INT_H
+#define VMNET_INT_H
+
+#include "qemu/osdep.h"
+#include "vmnet_int.h"
+#include "clients.h"
+
+#include <vmnet/vmnet.h>
+
+typedef struct VmnetState {
+  NetClientState nc;
+
+} VmnetState;
+
+
+#endif /* VMNET_INT_H */
diff --git a/qapi/net.json b/qapi/net.json
index 7fab2e7cd8aa..4bff1c4e3772 100644
--- a/qapi/net.json
+++ b/qapi/net.json
@@ -452,6 +452,120 @@
     '*vhostdev':     'str',
     '*queues':       'int' } }
 
+##
+# @NetdevVmnetHostOptions:
+#
+# vmnet (host mode) network backend.
+#
+# Allows the vmnet interface to communicate with other vmnet
+# interfaces that are in host mode and also with the host.
+#
+# @start-address: The starting IPv4 address to use for the interface.
+#                 Must be in the private IP range (RFC 1918). Must be
+#                 specified along with @end-address and @subnet-mask.
+#                 This address is used as the gateway address. The
+#                 subsequent address up to and including end-address are
+#                 placed in the DHCP pool.
+#
+# @end-address: The DHCP IPv4 range end address to use for the
+#               interface. Must be in the private IP range (RFC 1918).
+#               Must be specified along with @start-address and
+#               @subnet-mask.
+#
+# @subnet-mask: The IPv4 subnet mask to use on the interface. Must
+#               be specified along with @start-address and @subnet-mask.
+#
+# @isolated: Enable isolation for this interface. Interface isolation
+#            ensures that vmnet interface is not able to communicate
+#            with any other vmnet interfaces. Only communication with
+#            host is allowed. Requires at least macOS Big Sur 11.0.
+#
+# @net-uuid: The identifier (UUID) to uniquely identify the isolated
+#            network vmnet interface should be added to. If
+#            set, no DHCP service is provided for this interface and
+#            network communication is allowed only with other interfaces
+#            added to this network identified by the UUID. Requires
+#            at least macOS Big Sur 11.0.
+#
+# Since: 7.1
+##
+{ 'struct': 'NetdevVmnetHostOptions',
+  'data': {
+    '*start-address': 'str',
+    '*end-address':   'str',
+    '*subnet-mask':   'str',
+    '*isolated':      'bool',
+    '*net-uuid':      'str' },
+  'if': 'CONFIG_VMNET' }
+
+##
+# @NetdevVmnetSharedOptions:
+#
+# vmnet (shared mode) network backend.
+#
+# Allows traffic originating from the vmnet interface to reach the
+# Internet through a network address translator (NAT).
+# The vmnet interface can communicate with the host and with
+# other shared mode interfaces on the same subnet. If no DHCP
+# settings, subnet mask and IPv6 prefix specified, the interface can
+# communicate with any of other interfaces in shared mode.
+#
+# @start-address: The starting IPv4 address to use for the interface.
+#                 Must be in the private IP range (RFC 1918). Must be
+#                 specified along with @end-address and @subnet-mask.
+#                 This address is used as the gateway address. The
+#                 subsequent address up to and including end-address are
+#                 placed in the DHCP pool.
+#
+# @end-address: The DHCP IPv4 range end address to use for the
+#               interface. Must be in the private IP range (RFC 1918).
+#               Must be specified along with @start-address and @subnet-mask.
+#
+# @subnet-mask: The IPv4 subnet mask to use on the interface. Must
+#                be specified along with @start-address and @subnet-mask.
+#
+# @isolated: Enable isolation for this interface. Interface isolation
+#            ensures that vmnet interface is not able to communicate
+#            with any other vmnet interfaces. Only communication with
+#            host is allowed. Requires at least macOS Big Sur 11.0.
+#
+# @nat66-prefix: The IPv6 prefix to use into guest network. Must be a
+#                unique local address i.e. start with fd00::/8 and have
+#                length of 64.
+#
+# Since: 7.1
+##
+{ 'struct': 'NetdevVmnetSharedOptions',
+  'data': {
+    '*start-address': 'str',
+    '*end-address':   'str',
+    '*subnet-mask':   'str',
+    '*isolated':      'bool',
+    '*nat66-prefix':  'str' },
+  'if': 'CONFIG_VMNET' }
+
+##
+# @NetdevVmnetBridgedOptions:
+#
+# vmnet (bridged mode) network backend.
+#
+# Bridges the vmnet interface with a physical network interface.
+#
+# @ifname: The name of the physical interface to be bridged.
+#
+# @isolated: Enable isolation for this interface. Interface isolation
+#            ensures that vmnet interface is not able to communicate
+#            with any other vmnet interfaces. Only communication with
+#            host is allowed. Requires at least macOS Big Sur 11.0.
+#
+# Since: 7.1
+##
+{ 'struct': 'NetdevVmnetBridgedOptions',
+  'data': {
+    'ifname':     'str',
+    '*isolated':  'bool' },
+  'if': 'CONFIG_VMNET' }
+
 ##
 # @NetClientDriver:
 #
@@ -460,10 +574,16 @@
 # Since: 2.7
 #
 #        @vhost-vdpa since 5.1
+#        @vmnet-host since 7.1
+#        @vmnet-shared since 7.1
+#        @vmnet-bridged since 7.1
 ##
 { 'enum': 'NetClientDriver',
   'data': [ 'none', 'nic', 'user', 'tap', 'l2tpv3', 'socket', 'vde',
-            'bridge', 'hubport', 'netmap', 'vhost-user', 'vhost-vdpa' ] }
+            'bridge', 'hubport', 'netmap', 'vhost-user', 'vhost-vdpa',
+            { 'name': 'vmnet-host', 'if': 'CONFIG_VMNET' },
+            { 'name': 'vmnet-shared', 'if': 'CONFIG_VMNET' },
+            { 'name': 'vmnet-bridged', 'if': 'CONFIG_VMNET' }] }
 
 ##
 # @Netdev:
@@ -477,6 +597,9 @@
 # Since: 1.2
 #
 #        'l2tpv3' - since 2.1
+#        'vmnet-host' - since 7.1
+#        'vmnet-shared' - since 7.1
+#        'vmnet-bridged' - since 7.1
 ##
 { 'union': 'Netdev',
   'base': { 'id': 'str', 'type': 'NetClientDriver' },
@@ -492,7 +615,13 @@
     'hubport':  'NetdevHubPortOptions',
     'netmap':   'NetdevNetmapOptions',
     'vhost-user': 'NetdevVhostUserOptions',
-    'vhost-vdpa': 'NetdevVhostVDPAOptions' } }
+    'vhost-vdpa': 'NetdevVhostVDPAOptions',
+    'vmnet-host': { 'type': 'NetdevVmnetHostOptions',
+                    'if': 'CONFIG_VMNET' },
+    'vmnet-shared': { 'type': 'NetdevVmnetSharedOptions',
+                      'if': 'CONFIG_VMNET' },
+    'vmnet-bridged': { 'type': 'NetdevVmnetBridgedOptions',
+                       'if': 'CONFIG_VMNET' } } }
 
 ##
 # @RxState:

From f854a87eeb01d2913cb3c505fd2b965f351609c8 Mon Sep 17 00:00:00 2001
From: Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
Date: Thu, 17 Mar 2022 20:28:35 +0300
Subject: [PATCH 137/180] net/vmnet: implement shared mode (vmnet-shared)

Interaction with vmnet.framework in different modes
differs only on configuration stage, so we can create
common `send`, `receive`, etc. procedures and reuse them.

Signed-off-by: Phillip Tennen <phillip@axleos.com>
Signed-off-by: Vladislav Yaroshchuk <Vladislav.Yaroshchuk@jetbrains.com>
Message-Id: <20220317172839.28984-4-Vladislav.Yaroshchuk@jetbrains.com>
---
 net/vmnet-common.m | 358 +++++++++++++++++++++++++++++++++++++++++++++
 net/vmnet-shared.c |  97 +++++++++++-
 net/vmnet_int.h    |  40 ++++-
 3 files changed, 490 insertions(+), 5 deletions(-)

diff --git a/net/vmnet-common.m b/net/vmnet-common.m
index 06326efb1cc3..2cb60b9ddde7 100644
--- a/net/vmnet-common.m
+++ b/net/vmnet-common.m
@@ -10,6 +10,8 @@
  */
 
 #include "qemu/osdep.h"
+#include "qemu/main-loop.h"
+#include "qemu/log.h"
 #include "qapi/qapi-types-net.h"
 #include "vmnet_int.h"
 #include "clients.h"
@@ -17,4 +19,360 @@
 #include "qapi/error.h"
 
 #include <vmnet/vmnet.h>
+#include <dispatch/dispatch.h>
 
+
+static void vmnet_send_completed(NetClientState *nc, ssize_t len);
+
+
+const char *vmnet_status_map_str(vmnet_return_t status)
+{
+    switch (status) {
+    case VMNET_SUCCESS:
+        return "success";
+    case VMNET_FAILURE:
+        return "general failure (possibly not enough privileges)";
+    case VMNET_MEM_FAILURE:
+        return "memory allocation failure";
+    case VMNET_INVALID_ARGUMENT:
+        return "invalid argument specified";
+    case VMNET_SETUP_INCOMPLETE:
+        return "interface setup is not complete";
+    case VMNET_INVALID_ACCESS:
+        return "invalid access, permission denied";
+    case VMNET_PACKET_TOO_BIG:
+        return "packet size is larger than MTU";
+    case VMNET_BUFFER_EXHAUSTED:
+        return "buffers exhausted in kernel";
+    case VMNET_TOO_MANY_PACKETS:
+        return "packet count exceeds limit";
+#if defined(MAC_OS_VERSION_11_0) && \
+    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
+    case VMNET_SHARING_SERVICE_BUSY:
+        return "conflict, sharing service is in use";
+#endif
+    default:
+        return "unknown vmnet error";
+    }
+}
+
+
+/**
+ * Write packets from QEMU to vmnet interface.
+ *
+ * vmnet.framework supports iov, but writing more than
+ * one iov into vmnet interface fails with
+ * 'VMNET_INVALID_ARGUMENT'. Collecting provided iovs into
+ * one and passing it to vmnet works fine. That's the
+ * reason why receive_iov() left unimplemented. But it still
+ * works with good performance having .receive() only.
+ */
+ssize_t vmnet_receive_common(NetClientState *nc,
+                             const uint8_t *buf,
+                             size_t size)
+{
+    VmnetState *s = DO_UPCAST(VmnetState, nc, nc);
+    struct vmpktdesc packet;
+    struct iovec iov;
+    int pkt_cnt;
+    vmnet_return_t if_status;
+
+    if (size > s->max_packet_size) {
+        warn_report("vmnet: packet is too big, %zu > %" PRIu64,
+            packet.vm_pkt_size,
+            s->max_packet_size);
+        return -1;
+    }
+
+    iov.iov_base = (char *) buf;
+    iov.iov_len = size;
+
+    packet.vm_pkt_iovcnt = 1;
+    packet.vm_flags = 0;
+    packet.vm_pkt_size = size;
+    packet.vm_pkt_iov = &iov;
+    pkt_cnt = 1;
+
+    if_status = vmnet_write(s->vmnet_if, &packet, &pkt_cnt);
+    if (if_status != VMNET_SUCCESS) {
+        error_report("vmnet: write error: %s\n",
+                     vmnet_status_map_str(if_status));
+        return -1;
+    }
+
+    if (pkt_cnt) {
+        return size;
+    }
+    return 0;
+}
+
+
+/**
+ * Read packets from vmnet interface and write them
+ * to temporary buffers in VmnetState.
+ *
+ * Returns read packets number (may be 0) on success,
+ * -1 on error
+ */
+static int vmnet_read_packets(VmnetState *s)
+{
+    assert(s->packets_send_current_pos == s->packets_send_end_pos);
+
+    struct vmpktdesc *packets = s->packets_buf;
+    vmnet_return_t status;
+    int i;
+
+    /* Read as many packets as present */
+    s->packets_send_current_pos = 0;
+    s->packets_send_end_pos = VMNET_PACKETS_LIMIT;
+    for (i = 0; i < s->packets_send_end_pos; ++i) {
+        packets[i].vm_pkt_size = s->max_packet_size;
+        packets[i].vm_pkt_iovcnt = 1;
+        packets[i].vm_flags = 0;
+    }
+
+    status = vmnet_read(s->vmnet_if, packets, &s->packets_send_end_pos);
+    if (status != VMNET_SUCCESS) {
+        error_printf("vmnet: read failed: %s\n",
+                     vmnet_status_map_str(status));
+        s->packets_send_current_pos = 0;
+        s->packets_send_end_pos = 0;
+        return -1;
+    }
+    return s->packets_send_end_pos;
+}
+
+
+/**
+ * Write packets from temporary buffers in VmnetState
+ * to QEMU.
+ */
+static void vmnet_write_packets_to_qemu(VmnetState *s)
+{
+    while (s->packets_send_current_pos < s->packets_send_end_pos) {
+        ssize_t size = qemu_send_packet_async(&s->nc,
+                                      s->iov_buf[s->packets_send_current_pos].iov_base,
+                                      s->packets_buf[s->packets_send_current_pos].vm_pkt_size,
+                                      vmnet_send_completed);
+
+        if (size == 0) {
+            /* QEMU is not ready to consume more packets -
+             * stop and wait for completion callback call */
+            return;
+        }
+        ++s->packets_send_current_pos;
+    }
+}
+
+
+/**
+ * Bottom half callback that transfers packets from vmnet interface
+ * to QEMU.
+ *
+ * The process of transferring packets is three-staged:
+ * 1. Handle vmnet event;
+ * 2. Read packets from vmnet interface into temporary buffer;
+ * 3. Write packets from temporary buffer to QEMU.
+ *
+ * QEMU may suspend this process on the last stage, returning 0 from
+ * qemu_send_packet_async function. If this happens, we should
+ * respectfully wait until it is ready to consume more packets,
+ * write left ones in temporary buffer and only after this
+ * continue reading more packets from vmnet interface.
+ *
+ * Packets to be transferred are stored into packets_buf,
+ * in the window [packets_send_current_pos..packets_send_end_pos)
+ * including current_pos, excluding end_pos.
+ *
+ * Thus, if QEMU is not ready, buffer is not read and
+ * packets_send_current_pos < packets_send_end_pos.
+ */
+static void vmnet_send_bh(void *opaque)
+{
+    NetClientState *nc = (NetClientState *) opaque;
+    VmnetState *s = DO_UPCAST(VmnetState, nc, nc);
+
+    /*
+     * Do nothing if QEMU is not ready - wait
+     * for completion callback invocation
+     */
+    if (s->packets_send_current_pos < s->packets_send_end_pos) {
+        return;
+    }
+
+    /* Read packets from vmnet interface */
+    if (vmnet_read_packets(s) > 0) {
+        /* Send them to QEMU */
+        vmnet_write_packets_to_qemu(s);
+    }
+}
+
+
+/**
+ * Completion callback to be invoked by QEMU when it becomes
+ * ready to consume more packets.
+ */
+static void vmnet_send_completed(NetClientState *nc, ssize_t len)
+{
+    VmnetState *s = DO_UPCAST(VmnetState, nc, nc);
+
+    /* Callback is invoked eq queued packet is sent */
+    ++s->packets_send_current_pos;
+
+    /* Complete sending packets left in VmnetState buffers */
+    vmnet_write_packets_to_qemu(s);
+
+    /* And read new ones from vmnet if VmnetState buffer is ready */
+    if (s->packets_send_current_pos < s->packets_send_end_pos) {
+        qemu_bh_schedule(s->send_bh);
+    }
+}
+
+
+static void vmnet_bufs_init(VmnetState *s)
+{
+    struct vmpktdesc *packets = s->packets_buf;
+    struct iovec *iov = s->iov_buf;
+    int i;
+
+    for (i = 0; i < VMNET_PACKETS_LIMIT; ++i) {
+        iov[i].iov_len = s->max_packet_size;
+        iov[i].iov_base = g_malloc0(iov[i].iov_len);
+        packets[i].vm_pkt_iov = iov + i;
+    }
+}
+
+
+int vmnet_if_create(NetClientState *nc,
+                    xpc_object_t if_desc,
+                    Error **errp)
+{
+    VmnetState *s = DO_UPCAST(VmnetState, nc, nc);
+    dispatch_semaphore_t if_created_sem = dispatch_semaphore_create(0);
+    __block vmnet_return_t if_status;
+
+    s->if_queue = dispatch_queue_create(
+        "org.qemu.vmnet.if_queue",
+        DISPATCH_QUEUE_SERIAL
+    );
+
+    xpc_dictionary_set_bool(
+        if_desc,
+        vmnet_allocate_mac_address_key,
+        false
+    );
+
+#ifdef DEBUG
+    qemu_log("vmnet.start.interface_desc:\n");
+    xpc_dictionary_apply(if_desc,
+                         ^bool(const char *k, xpc_object_t v) {
+                             char *desc = xpc_copy_description(v);
+                             qemu_log("  %s=%s\n", k, desc);
+                             free(desc);
+                             return true;
+                         });
+#endif /* DEBUG */
+
+    s->vmnet_if = vmnet_start_interface(
+        if_desc,
+        s->if_queue,
+        ^(vmnet_return_t status, xpc_object_t interface_param) {
+            if_status = status;
+            if (status != VMNET_SUCCESS || !interface_param) {
+                dispatch_semaphore_signal(if_created_sem);
+                return;
+            }
+
+#ifdef DEBUG
+            qemu_log("vmnet.start.interface_param:\n");
+            xpc_dictionary_apply(interface_param,
+                                 ^bool(const char *k, xpc_object_t v) {
+                                     char *desc = xpc_copy_description(v);
+                                     qemu_log("  %s=%s\n", k, desc);
+                                     free(desc);
+                                     return true;
+                                 });
+#endif /* DEBUG */
+
+            s->mtu = xpc_dictionary_get_uint64(
+                interface_param,
+                vmnet_mtu_key);
+            s->max_packet_size = xpc_dictionary_get_uint64(
+                interface_param,
+                vmnet_max_packet_size_key);
+
+            dispatch_semaphore_signal(if_created_sem);
+        });
+
+    if (s->vmnet_if == NULL) {
+        dispatch_release(s->if_queue);
+        dispatch_release(if_created_sem);
+        error_setg(errp,
+                   "unable to create interface with requested params");
+        return -1;
+    }
+
+    dispatch_semaphore_wait(if_created_sem, DISPATCH_TIME_FOREVER);
+    dispatch_release(if_created_sem);
+
+    if (if_status != VMNET_SUCCESS) {
+        dispatch_release(s->if_queue);
+        error_setg(errp,
+                   "cannot create vmnet interface: %s",
+                   vmnet_status_map_str(if_status));
+        return -1;
+    }
+
+    s->send_bh = aio_bh_new(qemu_get_aio_context(), vmnet_send_bh, nc);
+    vmnet_bufs_init(s);
+
+    s->packets_send_current_pos = 0;
+    s->packets_send_end_pos = 0;
+
+    vmnet_interface_set_event_callback(
+        s->vmnet_if,
+        VMNET_INTERFACE_PACKETS_AVAILABLE,
+        s->if_queue,
+        ^(interface_event_t event_id, xpc_object_t event) {
+            assert(event_id == VMNET_INTERFACE_PACKETS_AVAILABLE);
+            /*
+             * This function is being called from a non qemu thread, so
+             * we only schedule a BH, and do the rest of the io completion
+             * handling from vmnet_send_bh() which runs in a qemu context.
+             */
+            qemu_bh_schedule(s->send_bh);
+        });
+
+    return 0;
+}
+
+
+void vmnet_cleanup_common(NetClientState *nc)
+{
+    VmnetState *s = DO_UPCAST(VmnetState, nc, nc);
+    dispatch_semaphore_t if_stopped_sem;
+
+    if (s->vmnet_if == NULL) {
+        return;
+    }
+
+    if_stopped_sem = dispatch_semaphore_create(0);
+    vmnet_stop_interface(
+        s->vmnet_if,
+        s->if_queue,
+        ^(vmnet_return_t status) {
+            assert(status == VMNET_SUCCESS);
+            dispatch_semaphore_signal(if_stopped_sem);
+        });
+    dispatch_semaphore_wait(if_stopped_sem, DISPATCH_TIME_FOREVER);
+
+    qemu_purge_queued_packets(nc);
+
+    qemu_bh_delete(s->send_bh);
+    dispatch_release(if_stopped_sem);
+    dispatch_release(s->if_queue);
+
+    for (int i = 0; i < VMNET_PACKETS_LIMIT; ++i) {
+        g_free(s->iov_buf[i].iov_base);
+    }
+}
diff --git a/net/vmnet-shared.c b/net/vmnet-shared.c
index 6dfb133a1821..18cadc72bd18 100644
--- a/net/vmnet-shared.c
+++ b/net/vmnet-shared.c
@@ -10,16 +10,105 @@
 
 #include "qemu/osdep.h"
 #include "qapi/qapi-types-net.h"
+#include "qapi/error.h"
 #include "vmnet_int.h"
 #include "clients.h"
-#include "qemu/error-report.h"
-#include "qapi/error.h"
 
 #include <vmnet/vmnet.h>
 
+
+static bool validate_options(const Netdev *netdev, Error **errp)
+{
+    const NetdevVmnetSharedOptions *options = &(netdev->u.vmnet_shared);
+
+#if !defined(MAC_OS_VERSION_11_0) || \
+    MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_VERSION_11_0
+    if (options->has_isolated) {
+        error_setg(errp,
+                   "vmnet-shared.isolated feature is "
+                   "unavailable: outdated vmnet.framework API");
+        return false;
+    }
+#endif
+
+    if ((options->has_start_address ||
+         options->has_end_address ||
+         options->has_subnet_mask) &&
+        !(options->has_start_address &&
+          options->has_end_address &&
+          options->has_subnet_mask)) {
+        error_setg(errp,
+                   "'start-address', 'end-address', 'subnet-mask' "
+                   "should be provided together"
+        );
+        return false;
+    }
+
+    return true;
+}
+
+static xpc_object_t build_if_desc(const Netdev *netdev)
+{
+    const NetdevVmnetSharedOptions *options = &(netdev->u.vmnet_shared);
+    xpc_object_t if_desc = xpc_dictionary_create(NULL, NULL, 0);
+
+    xpc_dictionary_set_uint64(
+        if_desc,
+        vmnet_operation_mode_key,
+        VMNET_SHARED_MODE
+    );
+
+    if (options->has_nat66_prefix) {
+        xpc_dictionary_set_string(if_desc,
+                                  vmnet_nat66_prefix_key,
+                                  options->nat66_prefix);
+    }
+
+    if (options->has_start_address) {
+        xpc_dictionary_set_string(if_desc,
+                                  vmnet_start_address_key,
+                                  options->start_address);
+        xpc_dictionary_set_string(if_desc,
+                                  vmnet_end_address_key,
+                                  options->end_address);
+        xpc_dictionary_set_string(if_desc,
+                                  vmnet_subnet_mask_key,
+                                  options->subnet_mask);
+    }
+
+#if defined(MAC_OS_VERSION_11_0) && \
+    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
+    xpc_dictionary_set_bool(
+        if_desc,
+        vmnet_enable_isolation_key,
+        options->isolated
+    );
+#endif
+
+    return if_desc;
+}
+
+static NetClientInfo net_vmnet_shared_info = {
+    .type = NET_CLIENT_DRIVER_VMNET_SHARED,
+    .size = sizeof(VmnetState),
+    .receive = vmnet_receive_common,
+    .cleanup = vmnet_cleanup_common,
+};
+
 int net_init_vmnet_shared(const Netdev *netdev, const char *name,
                           NetClientState *peer, Error **errp)
 {
-  error_setg(errp, "vmnet-shared is not implemented yet");
-  return -1;
+    NetClientState *nc = qemu_new_net_client(&net_vmnet_shared_info,
+                                             peer, "vmnet-shared", name);
+    xpc_object_t if_desc;
+    int result = -1;
+
+    if (!validate_options(netdev, errp)) {
+        return result;
+    }
+
+    if_desc = build_if_desc(netdev);
+    result = vmnet_if_create(nc, if_desc, errp);
+    xpc_release(if_desc);
+    return result;
 }
diff --git a/net/vmnet_int.h b/net/vmnet_int.h
index c383038a1d87..adf6e8c20d5d 100644
--- a/net/vmnet_int.h
+++ b/net/vmnet_int.h
@@ -15,11 +15,49 @@
 #include "clients.h"
 
 #include <vmnet/vmnet.h>
+#include <dispatch/dispatch.h>
+
+/**
+ *  From vmnet.framework documentation
+ *
+ *  Each read/write call allows up to 200 packets to be
+ *  read or written for a maximum of 256KB.
+ *
+ *  Each packet written should be a complete
+ *  ethernet frame.
+ *
+ *  https://developer.apple.com/documentation/vmnet
+ */
+#define VMNET_PACKETS_LIMIT 200
 
 typedef struct VmnetState {
-  NetClientState nc;
+    NetClientState nc;
+    interface_ref vmnet_if;
+
+    uint64_t mtu;
+    uint64_t max_packet_size;
 
+    dispatch_queue_t if_queue;
+
+    QEMUBH *send_bh;
+
+    struct vmpktdesc packets_buf[VMNET_PACKETS_LIMIT];
+    int packets_send_current_pos;
+    int packets_send_end_pos;
+
+    struct iovec iov_buf[VMNET_PACKETS_LIMIT];
 } VmnetState;
 
+const char *vmnet_status_map_str(vmnet_return_t status);
+
+int vmnet_if_create(NetClientState *nc,
+                    xpc_object_t if_desc,
+                    Error **errp);
+
+ssize_t vmnet_receive_common(NetClientState *nc,
+                             const uint8_t *buf,
+                             size_t size);
+
+void vmnet_cleanup_common(NetClientState *nc);
 
 #endif /* VMNET_INT_H */

From 5286a192c8810c40e1deefa8faeab96978e2bad8 Mon Sep 17 00:00:00 2001
From: Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
Date: Thu, 17 Mar 2022 20:28:36 +0300
Subject: [PATCH 138/180] net/vmnet: implement host mode (vmnet-host)

Signed-off-by: Vladislav Yaroshchuk <Vladislav.Yaroshchuk@jetbrains.com>
Message-Id: <20220317172839.28984-5-Vladislav.Yaroshchuk@jetbrains.com>
---
 net/vmnet-host.c | 116 ++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 110 insertions(+), 6 deletions(-)

diff --git a/net/vmnet-host.c b/net/vmnet-host.c
index a461d507c5f7..05f8d7886440 100644
--- a/net/vmnet-host.c
+++ b/net/vmnet-host.c
@@ -9,16 +9,120 @@
  */
 
 #include "qemu/osdep.h"
+#include "qemu/uuid.h"
 #include "qapi/qapi-types-net.h"
-#include "vmnet_int.h"
-#include "clients.h"
-#include "qemu/error-report.h"
 #include "qapi/error.h"
+#include "clients.h"
+#include "vmnet_int.h"
 
 #include <vmnet/vmnet.h>
 
+
+static bool validate_options(const Netdev *netdev, Error **errp)
+{
+    const NetdevVmnetHostOptions *options = &(netdev->u.vmnet_host);
+
+#if defined(MAC_OS_VERSION_11_0) && \
+    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
+
+    QemuUUID net_uuid;
+    if (options->has_net_uuid &&
+        qemu_uuid_parse(options->net_uuid, &net_uuid) < 0) {
+        error_setg(errp, "Invalid UUID provided in 'net-uuid'");
+        return false;
+    }
+#else
+    if (options->has_isolated) {
+        error_setg(errp,
+                   "vmnet-host.isolated feature is "
+                   "unavailable: outdated vmnet.framework API");
+        return false;
+    }
+
+    if (options->has_net_uuid) {
+        error_setg(errp,
+                   "vmnet-host.net-uuid feature is "
+                   "unavailable: outdated vmnet.framework API");
+        return false;
+    }
+#endif
+
+    if ((options->has_start_address ||
+         options->has_end_address ||
+         options->has_subnet_mask) &&
+        !(options->has_start_address &&
+          options->has_end_address &&
+          options->has_subnet_mask)) {
+        error_setg(errp,
+                   "'start-address', 'end-address', 'subnet-mask' "
+                   "should be provided together");
+        return false;
+    }
+
+    return true;
+}
+
+static xpc_object_t build_if_desc(const Netdev *netdev)
+{
+    const NetdevVmnetHostOptions *options = &(netdev->u.vmnet_host);
+    xpc_object_t if_desc = xpc_dictionary_create(NULL, NULL, 0);
+
+    xpc_dictionary_set_uint64(if_desc,
+                              vmnet_operation_mode_key,
+                              VMNET_HOST_MODE);
+
+#if defined(MAC_OS_VERSION_11_0) && \
+    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
+
+    xpc_dictionary_set_bool(if_desc,
+                            vmnet_enable_isolation_key,
+                            options->isolated);
+
+    QemuUUID net_uuid;
+    if (options->has_net_uuid) {
+        qemu_uuid_parse(options->net_uuid, &net_uuid);
+        xpc_dictionary_set_uuid(if_desc,
+                                vmnet_network_identifier_key,
+                                net_uuid.data);
+    }
+#endif
+
+    if (options->has_start_address) {
+        xpc_dictionary_set_string(if_desc,
+                                  vmnet_start_address_key,
+                                  options->start_address);
+        xpc_dictionary_set_string(if_desc,
+                                  vmnet_end_address_key,
+                                  options->end_address);
+        xpc_dictionary_set_string(if_desc,
+                                  vmnet_subnet_mask_key,
+                                  options->subnet_mask);
+    }
+
+    return if_desc;
+}
+
+static NetClientInfo net_vmnet_host_info = {
+    .type = NET_CLIENT_DRIVER_VMNET_HOST,
+    .size = sizeof(VmnetState),
+    .receive = vmnet_receive_common,
+    .cleanup = vmnet_cleanup_common,
+};
+
 int net_init_vmnet_host(const Netdev *netdev, const char *name,
-                        NetClientState *peer, Error **errp) {
-  error_setg(errp, "vmnet-host is not implemented yet");
-  return -1;
+                        NetClientState *peer, Error **errp)
+{
+    NetClientState *nc = qemu_new_net_client(&net_vmnet_host_info,
+                                             peer, "vmnet-host", name);
+    xpc_object_t if_desc;
+    int result = -1;
+
+    if (!validate_options(netdev, errp)) {
+        return result;
+    }
+
+    if_desc = build_if_desc(netdev);
+    result = vmnet_if_create(nc, if_desc, errp);
+    xpc_release(if_desc);
+    return result;
 }

From ee9a9b425f1621611a1535965bc60a5780c511ca Mon Sep 17 00:00:00 2001
From: Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
Date: Thu, 17 Mar 2022 20:28:37 +0300
Subject: [PATCH 139/180] net/vmnet: implement bridged mode (vmnet-bridged)

Signed-off-by: Vladislav Yaroshchuk <Vladislav.Yaroshchuk@jetbrains.com>
Message-Id: <20220317172839.28984-6-Vladislav.Yaroshchuk@jetbrains.com>
---
 net/vmnet-bridged.m | 137 ++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 132 insertions(+), 5 deletions(-)

diff --git a/net/vmnet-bridged.m b/net/vmnet-bridged.m
index 91c1a2f2c7da..46d22828632b 100644
--- a/net/vmnet-bridged.m
+++ b/net/vmnet-bridged.m
@@ -10,16 +10,143 @@
 
 #include "qemu/osdep.h"
 #include "qapi/qapi-types-net.h"
-#include "vmnet_int.h"
-#include "clients.h"
-#include "qemu/error-report.h"
 #include "qapi/error.h"
+#include "clients.h"
+#include "vmnet_int.h"
 
 #include <vmnet/vmnet.h>
 
+
+static bool validate_ifname(const char *ifname)
+{
+    xpc_object_t shared_if_list = vmnet_copy_shared_interface_list();
+    bool match = false;
+    if (!xpc_array_get_count(shared_if_list)) {
+        goto done;
+    }
+
+    match = !xpc_array_apply(
+        shared_if_list,
+        ^bool(size_t index, xpc_object_t value) {
+            return strcmp(xpc_string_get_string_ptr(value), ifname) != 0;
+        });
+
+done:
+    xpc_release(shared_if_list);
+    return match;
+}
+
+
+static char* get_valid_ifnames()
+{
+    xpc_object_t shared_if_list = vmnet_copy_shared_interface_list();
+    __block char *if_list = NULL;
+    __block char *if_list_prev = NULL;
+
+    if (!xpc_array_get_count(shared_if_list)) {
+        goto done;
+    }
+
+    xpc_array_apply(
+        shared_if_list,
+        ^bool(size_t index, xpc_object_t value) {
+            /* build list of strings like "en0 en1 en2 " */
+            if_list = g_strconcat(xpc_string_get_string_ptr(value),
+                                  " ",
+                                  if_list_prev,
+                                  NULL);
+            g_free(if_list_prev);
+            if_list_prev = if_list;
+            return true;
+        });
+
+done:
+    xpc_release(shared_if_list);
+    return if_list;
+}
+
+
+static bool validate_options(const Netdev *netdev, Error **errp)
+{
+    const NetdevVmnetBridgedOptions *options = &(netdev->u.vmnet_bridged);
+    char* if_list;
+
+    if (!validate_ifname(options->ifname)) {
+        if_list = get_valid_ifnames();
+        if (if_list) {
+            error_setg(errp,
+                       "unsupported ifname '%s', expected one of [ %s]",
+                       options->ifname,
+                       if_list);
+            g_free(if_list);
+        } else {
+            error_setg(errp,
+                       "unsupported ifname '%s', no supported "
+                       "interfaces available",
+                       options->ifname);
+        }
+        return false;
+    }
+
+#if !defined(MAC_OS_VERSION_11_0) || \
+    MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_VERSION_11_0
+    if (options->has_isolated) {
+        error_setg(errp,
+                   "vmnet-bridged.isolated feature is "
+                   "unavailable: outdated vmnet.framework API");
+        return false;
+    }
+#endif
+    return true;
+}
+
+
+static xpc_object_t build_if_desc(const Netdev *netdev)
+{
+    const NetdevVmnetBridgedOptions *options = &(netdev->u.vmnet_bridged);
+    xpc_object_t if_desc = xpc_dictionary_create(NULL, NULL, 0);
+
+    xpc_dictionary_set_uint64(if_desc,
+                              vmnet_operation_mode_key,
+                              VMNET_BRIDGED_MODE
+    );
+
+    xpc_dictionary_set_string(if_desc,
+                              vmnet_shared_interface_name_key,
+                              options->ifname);
+
+#if defined(MAC_OS_VERSION_11_0) && \
+    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
+    xpc_dictionary_set_bool(if_desc,
+                            vmnet_enable_isolation_key,
+                            options->isolated);
+#endif
+    return if_desc;
+}
+
+
+static NetClientInfo net_vmnet_bridged_info = {
+    .type = NET_CLIENT_DRIVER_VMNET_BRIDGED,
+    .size = sizeof(VmnetState),
+    .receive = vmnet_receive_common,
+    .cleanup = vmnet_cleanup_common,
+};
+
+
 int net_init_vmnet_bridged(const Netdev *netdev, const char *name,
                            NetClientState *peer, Error **errp)
 {
-  error_setg(errp, "vmnet-bridged is not implemented yet");
-  return -1;
+    NetClientState *nc = qemu_new_net_client(&net_vmnet_bridged_info,
+                                             peer, "vmnet-bridged", name);
+    xpc_object_t if_desc;
+    int result = -1;
+
+    if (!validate_options(netdev, errp)) {
+        return result;
+    }
+
+    if_desc = build_if_desc(netdev);
+    result = vmnet_if_create(nc, if_desc, errp);
+    xpc_release(if_desc);
+    return result;
 }

From c9eb230657cfcc2d14973659c0a1be598e3944bb Mon Sep 17 00:00:00 2001
From: Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
Date: Thu, 17 Mar 2022 20:28:38 +0300
Subject: [PATCH 140/180] net/vmnet: update qemu-options.hx

Signed-off-by: Vladislav Yaroshchuk <Vladislav.Yaroshchuk@jetbrains.com>
Message-Id: <20220317172839.28984-7-Vladislav.Yaroshchuk@jetbrains.com>
---
 qemu-options.hx | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/qemu-options.hx b/qemu-options.hx
index 58f2f76775c9..dd95c0f69ad3 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -2758,6 +2758,25 @@ DEF("netdev", HAS_ARG, QEMU_OPTION_netdev,
 #ifdef __linux__
     "-netdev vhost-vdpa,id=str,vhostdev=/path/to/dev\n"
     "                configure a vhost-vdpa network,Establish a vhost-vdpa netdev\n"
+#endif
+#ifdef CONFIG_VMNET
+    "-netdev vmnet-host,id=str[,isolated=on|off][,net-uuid=uuid]\n"
+    "         [,start-address=addr,end-address=addr,subnet-mask=mask]\n"
+    "                configure a vmnet network backend in host mode with ID 'str',\n"
+    "                isolate this interface from others with 'isolated',\n"
+    "                configure the address range and choose a subnet mask,\n"
+    "                specify network UUID 'uuid' to disable DHCP and interact with\n"
+    "                vmnet-host interfaces within this isolated network\n"
+    "-netdev vmnet-shared,id=str[,isolated=on|off][,nat66-prefix=addr]\n"
+    "         [,start-address=addr,end-address=addr,subnet-mask=mask]\n"
+    "                configure a vmnet network backend in shared mode with ID 'str',\n"
+    "                configure the address range and choose a subnet mask,\n"
+    "                set IPv6 ULA prefix (of length 64) to use for internal network,\n"
+    "                isolate this interface from others with 'isolated'\n"
+    "-netdev vmnet-bridged,id=str,ifname=name[,isolated=on|off]\n"
+    "                configure a vmnet network backend in bridged mode with ID 'str',\n"
+    "                use 'ifname=name' to select a physical network interface to be bridged,\n"
+    "                isolate this interface from others with 'isolated'\n"
 #endif
     "-netdev hubport,id=str,hubid=n[,netdev=nd]\n"
     "                configure a hub port on the hub with ID 'n'\n", QEMU_ARCH_ALL)
@@ -2777,6 +2796,9 @@ DEF("nic", HAS_ARG, QEMU_OPTION_nic,
 #endif
 #ifdef CONFIG_POSIX
     "vhost-user|"
+#endif
+#ifdef CONFIG_VMNET
+    "vmnet-host|vmnet-shared|vmnet-bridged|"
 #endif
     "socket][,option][,...][mac=macaddr]\n"
     "                initialize an on-board / default host NIC (using MAC address\n"
@@ -2799,6 +2821,9 @@ DEF("net", HAS_ARG, QEMU_OPTION_net,
 #endif
 #ifdef CONFIG_NETMAP
     "netmap|"
+#endif
+#ifdef CONFIG_VMNET
+    "vmnet-host|vmnet-shared|vmnet-bridged|"
 #endif
     "socket][,option][,option][,...]\n"
     "                old way to initialize a host network interface\n"

From 7135bae71b60ba0bd93dee3f83bb41e610ee0ad6 Mon Sep 17 00:00:00 2001
From: Vladislav Yaroshchuk <vladislav.yaroshchuk@jetbrains.com>
Date: Thu, 17 Mar 2022 20:28:39 +0300
Subject: [PATCH 141/180] net/vmnet: update hmp-commands.hx

Signed-off-by: Vladislav Yaroshchuk <Vladislav.Yaroshchuk@jetbrains.com>
Message-Id: <20220317172839.28984-8-Vladislav.Yaroshchuk@jetbrains.com>
---
 hmp-commands.hx | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/hmp-commands.hx b/hmp-commands.hx
index 8476277aa9c9..8f3d78f17721 100644
--- a/hmp-commands.hx
+++ b/hmp-commands.hx
@@ -1265,7 +1265,11 @@ ERST
     {
         .name       = "netdev_add",
         .args_type  = "netdev:O",
-        .params     = "[user|tap|socket|vde|bridge|hubport|netmap|vhost-user],id=str[,prop=value][,...]",
+        .params     = "[user|tap|socket|vde|bridge|hubport|netmap|vhost-user"
+#ifdef CONFIG_VMNET
+                      "|vmnet-host|vmnet-shared|vmnet-bridged"
+#endif
+                      "],id=str[,prop=value][,...]",
         .help       = "add host network device",
         .cmd        = hmp_netdev_add,
         .command_completion = netdev_add_completion,

From c146fe809552b9e432ff7b27fb8a6af1017db8e3 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Fri, 25 Mar 2022 12:40:13 +0900
Subject: [PATCH 142/180] ui/cocoa: Initialize before setting UID and GID

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 62 +++++++++++++++++++++++++++---------------------------
 1 file changed, 31 insertions(+), 31 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 4483d5e648b4..a438d783e96b 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -1956,42 +1956,11 @@ int main(int argc, char **argv, char **envp)
          return 0;
     }
 
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-
-    // Pull this console process up to being a fully-fledged graphical
-    // app with a menubar and Dock icon
-    ProcessSerialNumber psn = { 0, kCurrentProcess };
-    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
-
-    [QemuApplication sharedApplication];
-
-    create_initial_menus();
-
-    /*
-     * Create the menu entries which depend on QEMU state (for consoles
-     * and removeable devices). These make calls back into QEMU functions,
-     * which is OK because at this point we know that the second thread
-     * holds the iothread lock and is synchronously waiting for us to
-     * finish.
-     */
-    add_console_menu_entries();
-    addRemovableDevicesMenuItems();
-
-    qemu_event_init(&cbevent, false);
-    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
-
-    // Create an Application controller
-    QemuCocoaAppController *appController = [[QemuCocoaAppController alloc] init];
-    [NSApp setDelegate:appController];
-
     // Start the main event loop
     COCOA_DEBUG("Main thread: entering OSX run loop\n");
     [NSApp run];
     COCOA_DEBUG("Main thread: left OSX run loop, exiting\n");
 
-    [appController release];
-    [pool release];
-
     return 0;
 }
 
@@ -2071,9 +2040,38 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
 
 static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 {
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    ProcessSerialNumber psn = { 0, kCurrentProcess };
+    QemuCocoaAppController *appController;
+
     COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
     have_cocoa_ui = 1;
 
+    // Pull this console process up to being a fully-fledged graphical
+    // app with a menubar and Dock icon
+    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+
+    [QemuApplication sharedApplication];
+
+    create_initial_menus();
+
+    /*
+     * Create the menu entries which depend on QEMU state (for consoles
+     * and removeable devices). These make calls back into QEMU functions,
+     * which is OK because at this point we know that the second thread
+     * holds the iothread lock and is synchronously waiting for us to
+     * finish.
+     */
+    add_console_menu_entries();
+    addRemovableDevicesMenuItems();
+
+    qemu_event_init(&cbevent, false);
+    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
+
+    // Create an Application controller
+    appController = [[QemuCocoaAppController alloc] init];
+    [NSApp setDelegate:appController];
+
     if (opts->has_full_screen && opts->full_screen) {
         full_screen = 1;
     }
@@ -2091,6 +2089,8 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
     if (opts->u.cocoa.has_left_command_key && !opts->u.cocoa.left_command_key) {
         left_command_key_enabled = 0;
     }
+
+    [pool release];
 }
 
 static QemuDisplay qemu_display_cocoa = {

From 129127242d17a98f1615b8a69618de1a3fa6a2fc Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 18 Feb 2021 12:53:25 +0900
Subject: [PATCH 143/180] virtio-gpu: Respect UI refresh rate for EDID

This change adds a new member, refresh_rate to QemuUIInfo in
include/ui/console.h. It represents the refresh rate of the
physical display backend, and it is more appropriate than
GUI update interval as the refresh rate which the emulated device
reports:
- sdl may set GUI update interval shorter than the refresh rate
  of the physical display to respond to user-generated events.
- sdl and vnc aggressively changes GUI update interval, but
  a guests is typically not designed to respond to frequent
  refresh rate changes, or frequent "display mode" changes in
  general. The frequency of refresh rate changes of the physical
  display backend matches better to the guest's expectation.

QemuUIInfo also has other members representing "display mode",
which makes it suitable for refresh rate representation. It has
a throttling of update notifications, and prevents frequent changes
of the display mode.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 hw/display/virtio-gpu-base.c   |  1 +
 hw/display/virtio-gpu.c        |  1 +
 hw/display/xenfb.c             | 14 ++++++++---
 include/hw/virtio/virtio-gpu.h |  1 +
 include/ui/console.h           |  2 +-
 include/ui/gtk.h               |  2 +-
 ui/cocoa.m                     |  6 +----
 ui/console.c                   |  6 -----
 ui/gtk-egl.c                   |  4 +--
 ui/gtk-gl-area.c               |  4 +--
 ui/gtk.c                       | 45 ++++++++++++++++++++--------------
 11 files changed, 47 insertions(+), 39 deletions(-)

diff --git a/hw/display/virtio-gpu-base.c b/hw/display/virtio-gpu-base.c
index fff0fb4a828a..db50c3f21646 100644
--- a/hw/display/virtio-gpu-base.c
+++ b/hw/display/virtio-gpu-base.c
@@ -79,6 +79,7 @@ static int virtio_gpu_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)
 
     g->req_state[idx].x = info->xoff;
     g->req_state[idx].y = info->yoff;
+    g->req_state[idx].refresh_rate = info->refresh_rate;
     g->req_state[idx].width = info->width;
     g->req_state[idx].height = info->height;
     g->req_state[idx].width_mm = info->width_mm;
diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
index c6dc818988c3..04fbbd1f8f38 100644
--- a/hw/display/virtio-gpu.c
+++ b/hw/display/virtio-gpu.c
@@ -217,6 +217,7 @@ virtio_gpu_generate_edid(VirtIOGPU *g, int scanout,
         .height_mm = b->req_state[scanout].height_mm,
         .prefx = b->req_state[scanout].width,
         .prefy = b->req_state[scanout].height,
+        .refresh_rate = b->req_state[scanout].refresh_rate,
     };
 
     edid->size = cpu_to_le32(sizeof(edid->edid));
diff --git a/hw/display/xenfb.c b/hw/display/xenfb.c
index 838260b6ad14..a53341ef673a 100644
--- a/hw/display/xenfb.c
+++ b/hw/display/xenfb.c
@@ -777,16 +777,24 @@ static void xenfb_update(void *opaque)
     xenfb->up_fullscreen = 0;
 }
 
-static void xenfb_update_interval(void *opaque, uint64_t interval)
+static void xenfb_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)
 {
     struct XenFB *xenfb = opaque;
+    uint32_t refresh_rate;
 
     if (xenfb->feature_update) {
 #ifdef XENFB_TYPE_REFRESH_PERIOD
         if (xenfb_queue_full(xenfb)) {
             return;
         }
-        xenfb_send_refresh_period(xenfb, interval);
+
+        refresh_rate = info->refresh_rate;
+        if (!refresh_rate) {
+            refresh_rate = 75;
+        }
+
+        /* T = 1 / f = 1 [s*Hz] / f = 1000*1000 [ms*mHz] / f */
+        xenfb_send_refresh_period(xenfb, 1000 * 1000 / refresh_rate);
 #endif
     }
 }
@@ -983,5 +991,5 @@ struct XenDevOps xen_framebuffer_ops = {
 static const GraphicHwOps xenfb_ops = {
     .invalidate  = xenfb_invalidate,
     .gfx_update  = xenfb_update,
-    .update_interval = xenfb_update_interval,
+    .ui_info     = xenfb_ui_info,
 };
diff --git a/include/hw/virtio/virtio-gpu.h b/include/hw/virtio/virtio-gpu.h
index 2179b757037a..09a317e1a7a1 100644
--- a/include/hw/virtio/virtio-gpu.h
+++ b/include/hw/virtio/virtio-gpu.h
@@ -81,6 +81,7 @@ struct virtio_gpu_scanout {
 struct virtio_gpu_requested_state {
     uint16_t width_mm, height_mm;
     uint32_t width, height;
+    uint32_t refresh_rate;
     int x, y;
 };
 
diff --git a/include/ui/console.h b/include/ui/console.h
index 0f84861933e1..5f02d7ec4f0a 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -139,6 +139,7 @@ typedef struct QemuUIInfo {
     int       yoff;
     uint32_t  width;
     uint32_t  height;
+    uint32_t  refresh_rate;
 } QemuUIInfo;
 
 /* cursor data format is 32bit RGBA */
@@ -431,7 +432,6 @@ typedef struct GraphicHwOps {
     void (*gfx_update)(void *opaque);
     bool gfx_update_async; /* if true, calls graphic_hw_update_done() */
     void (*text_update)(void *opaque, console_ch_t *text);
-    void (*update_interval)(void *opaque, uint64_t interval);
     int (*ui_info)(void *opaque, uint32_t head, QemuUIInfo *info);
     void (*gl_block)(void *opaque, bool block);
 } GraphicHwOps;
diff --git a/include/ui/gtk.h b/include/ui/gtk.h
index 101b147d1b98..ae0f53740d19 100644
--- a/include/ui/gtk.h
+++ b/include/ui/gtk.h
@@ -155,7 +155,7 @@ extern bool gtk_use_gl_area;
 
 /* ui/gtk.c */
 void gd_update_windowsize(VirtualConsole *vc);
-int gd_monitor_update_interval(GtkWidget *widget);
+void gd_update_monitor_refresh_rate(VirtualConsole *vc, GtkWidget *widget);
 void gd_hw_gl_flushed(void *vc);
 
 /* ui/gtk-egl.c */
diff --git a/ui/cocoa.m b/ui/cocoa.m
index a438d783e96b..2906fd0388d9 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -579,7 +579,7 @@ - (void) updateUIInfoLocked
 {
     /* Must be called with the iothread lock, i.e. via updateUIInfo */
     NSSize frameSize;
-    QemuUIInfo info;
+    QemuUIInfo info = {};
 
     if (!qemu_console_is_graphic(dcl.con)) {
         return;
@@ -596,12 +596,8 @@ - (void) updateUIInfoLocked
         info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
     } else {
         frameSize = [self frame].size;
-        info.width_mm = 0;
-        info.height_mm = 0;
     }
 
-    info.xoff = 0;
-    info.yoff = 0;
     info.width = frameSize.width;
     info.height = frameSize.height;
 
diff --git a/ui/console.c b/ui/console.c
index da434ce1b2f7..a0c054bb7aa8 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -157,7 +157,6 @@ static void gui_update(void *opaque)
     uint64_t dcl_interval;
     DisplayState *ds = opaque;
     DisplayChangeListener *dcl;
-    QemuConsole *con;
 
     ds->refreshing = true;
     dpy_refresh(ds);
@@ -172,11 +171,6 @@ static void gui_update(void *opaque)
     }
     if (ds->update_interval != interval) {
         ds->update_interval = interval;
-        QTAILQ_FOREACH(con, &consoles, next) {
-            if (con->hw_ops->update_interval) {
-                con->hw_ops->update_interval(con->hw, interval);
-            }
-        }
         trace_console_refresh(interval);
     }
     ds->last_update = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
index e3bd4bc27431..b5bffbab2522 100644
--- a/ui/gtk-egl.c
+++ b/ui/gtk-egl.c
@@ -140,8 +140,8 @@ void gd_egl_refresh(DisplayChangeListener *dcl)
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
 
-    vc->gfx.dcl.update_interval = gd_monitor_update_interval(
-            vc->window ? vc->window : vc->gfx.drawing_area);
+    gd_update_monitor_refresh_rate(
+            vc, vc->window ? vc->window : vc->gfx.drawing_area);
 
     if (!vc->gfx.esurface) {
         gd_egl_init(vc);
diff --git a/ui/gtk-gl-area.c b/ui/gtk-gl-area.c
index fc5a082eb846..0e864e6d7b43 100644
--- a/ui/gtk-gl-area.c
+++ b/ui/gtk-gl-area.c
@@ -121,8 +121,8 @@ void gd_gl_area_refresh(DisplayChangeListener *dcl)
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
 
-    vc->gfx.dcl.update_interval = gd_monitor_update_interval(
-            vc->window ? vc->window : vc->gfx.drawing_area);
+    gd_update_monitor_refresh_rate(
+            vc, vc->window ? vc->window : vc->gfx.drawing_area);
 
     if (!vc->gfx.gls) {
         if (!gtk_widget_get_realized(vc->gfx.drawing_area)) {
diff --git a/ui/gtk.c b/ui/gtk.c
index 1b24a67d7964..08f43dc3d378 100644
--- a/ui/gtk.c
+++ b/ui/gtk.c
@@ -710,11 +710,20 @@ static gboolean gd_window_close(GtkWidget *widget, GdkEvent *event,
     return TRUE;
 }
 
-static void gd_set_ui_info(VirtualConsole *vc, gint width, gint height)
+static void gd_set_ui_refresh_rate(VirtualConsole *vc, int refresh_rate)
 {
     QemuUIInfo info;
 
-    memset(&info, 0, sizeof(info));
+    info = *dpy_get_ui_info(vc->gfx.dcl.con);
+    info.refresh_rate = refresh_rate;
+    dpy_set_ui_info(vc->gfx.dcl.con, &info, true);
+}
+
+static void gd_set_ui_size(VirtualConsole *vc, gint width, gint height)
+{
+    QemuUIInfo info;
+
+    info = *dpy_get_ui_info(vc->gfx.dcl.con);
     info.width = width;
     info.height = height;
     dpy_set_ui_info(vc->gfx.dcl.con, &info, true);
@@ -738,33 +747,32 @@ static void gd_resize_event(GtkGLArea *area,
 {
     VirtualConsole *vc = (void *)opaque;
 
-    gd_set_ui_info(vc, width, height);
+    gd_set_ui_size(vc, width, height);
 }
 
 #endif
 
-/*
- * If available, return the update interval of the monitor in ms,
- * else return 0 (the default update interval).
- */
-int gd_monitor_update_interval(GtkWidget *widget)
+void gd_update_monitor_refresh_rate(VirtualConsole *vc, GtkWidget *widget)
 {
 #ifdef GDK_VERSION_3_22
     GdkWindow *win = gtk_widget_get_window(widget);
+    int refresh_rate;
 
     if (win) {
         GdkDisplay *dpy = gtk_widget_get_display(widget);
         GdkMonitor *monitor = gdk_display_get_monitor_at_window(dpy, win);
-        int refresh_rate = gdk_monitor_get_refresh_rate(monitor); /* [mHz] */
-
-        if (refresh_rate) {
-            /* T = 1 / f = 1 [s*Hz] / f = 1000*1000 [ms*mHz] / f */
-            return MIN(1000 * 1000 / refresh_rate,
-                       GUI_REFRESH_INTERVAL_DEFAULT);
-        }
+        refresh_rate = gdk_monitor_get_refresh_rate(monitor); /* [mHz] */
+    } else {
+        refresh_rate = 0;
     }
+
+    gd_set_ui_refresh_rate(vc, refresh_rate);
+
+    /* T = 1 / f = 1 [s*Hz] / f = 1000*1000 [ms*mHz] / f */
+    vc->gfx.dcl.update_interval = refresh_rate ?
+        MIN(1000 * 1000 / refresh_rate, GUI_REFRESH_INTERVAL_DEFAULT) :
+        GUI_REFRESH_INTERVAL_DEFAULT;
 #endif
-    return 0;
 }
 
 static gboolean gd_draw_event(GtkWidget *widget, cairo_t *cr, void *opaque)
@@ -801,8 +809,7 @@ static gboolean gd_draw_event(GtkWidget *widget, cairo_t *cr, void *opaque)
         return FALSE;
     }
 
-    vc->gfx.dcl.update_interval =
-        gd_monitor_update_interval(vc->window ? vc->window : s->window);
+    gd_update_monitor_refresh_rate(vc, vc->window ? vc->window : s->window);
 
     fbw = surface_width(vc->gfx.ds);
     fbh = surface_height(vc->gfx.ds);
@@ -1687,7 +1694,7 @@ static gboolean gd_configure(GtkWidget *widget,
 {
     VirtualConsole *vc = opaque;
 
-    gd_set_ui_info(vc, cfg->width, cfg->height);
+    gd_set_ui_size(vc, cfg->width, cfg->height);
     return FALSE;
 }
 

From 401a81844be8184dcdded5577effdab1e8395ee8 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sun, 14 Mar 2021 14:22:01 +0900
Subject: [PATCH 144/180] ui/cocoa: Do not raise keys before QEMU resigns
 active

ui/cocoa used to raise all keys before it resigns active to prevent a
stuck key problem caused by key up events it does not see while it is
inactive. The problem is solved by checking -[NSEvent modifierFlags] in
commit 6d73bb643aa725348aabe6a885ac5fb0b7f70252, which is better
because it handles the case that key *down* events are missed while it
is inactive.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 15 ---------------
 1 file changed, 15 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 2906fd0388d9..8f568b2a880e 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -365,7 +365,6 @@ - (BOOL) isAbsoluteEnabled;
 - (float) cdx;
 - (float) cdy;
 - (QEMUScreen) gscreen;
-- (void) raiseAllKeys;
 @end
 
 QemuCocoaView *cocoaView;
@@ -1203,19 +1202,6 @@ - (float) cdx {return cdx;}
 - (float) cdy {return cdy;}
 - (QEMUScreen) gscreen {return screen;}
 
-/*
- * Makes the target think all down keys are being released.
- * This prevents a stuck key problem, since we will not see
- * key up events for those keys after we have lost focus.
- */
-- (void) raiseAllKeys
-{
-    with_iothread_lock(^{
-        qkbd_state_lift_all_keys(kbd);
-    });
-}
-@end
-
 
 
 /*
@@ -1380,7 +1366,6 @@ - (void) applicationWillResignActive: (NSNotification *)aNotification
 {
     COCOA_DEBUG("QemuCocoaAppController: applicationWillResignActive\n");
     [cocoaView ungrabMouse];
-    [cocoaView raiseAllKeys];
 }
 
 /* We abstract the method called by the Enter Fullscreen menu item

From 4214699f965a1cf17e80a5d944d5934e75aaf994 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sat, 19 Jun 2021 14:12:11 +0900
Subject: [PATCH 145/180] coreaudio: Commit the result of init in the end

init_out_device may only commit some part of the result and leave the
state inconsistent when it encounters an error. Commit the result in
the end of the function so that it commits the result iif it sees no
error.

With this change, handle_voice_change can rely on core->outputDeviceID
to know whether the output device is initialized after calling
init_out_device.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 audio/coreaudio.m | 49 ++++++++++++++++++++++++++---------------------
 1 file changed, 27 insertions(+), 22 deletions(-)

diff --git a/audio/coreaudio.m b/audio/coreaudio.m
index 3186b68474d0..127a368ac236 100644
--- a/audio/coreaudio.m
+++ b/audio/coreaudio.m
@@ -360,7 +360,10 @@ static OSStatus audioDeviceIOProc(
 static OSStatus init_out_device(coreaudioVoiceOut *core)
 {
     OSStatus status;
+    AudioDeviceID deviceID;
     AudioValueRange frameRange;
+    UInt32 audioDevicePropertyBufferFrameSize;
+    AudioDeviceIOProcID ioprocid;
 
     AudioStreamBasicDescription streamBasicDescription = {
         .mBitsPerChannel = core->hw.info.bits,
@@ -373,20 +376,19 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
         .mSampleRate = core->hw.info.freq
     };
 
-    status = coreaudio_get_voice(&core->outputDeviceID);
+    status = coreaudio_get_voice(&deviceID);
     if (status != kAudioHardwareNoError) {
         coreaudio_playback_logerr (status,
                                    "Could not get default output Device\n");
         return status;
     }
-    if (core->outputDeviceID == kAudioDeviceUnknown) {
+    if (deviceID == kAudioDeviceUnknown) {
         dolog ("Could not initialize playback - Unknown Audiodevice\n");
         return status;
     }
 
     /* get minimum and maximum buffer frame sizes */
-    status = coreaudio_get_framesizerange(core->outputDeviceID,
-                                          &frameRange);
+    status = coreaudio_get_framesizerange(deviceID, &frameRange);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -397,31 +399,31 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
     }
 
     if (frameRange.mMinimum > core->frameSizeSetting) {
-        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMinimum;
+        audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMinimum;
         dolog ("warning: Upsizing Buffer Frames to %f\n", frameRange.mMinimum);
     } else if (frameRange.mMaximum < core->frameSizeSetting) {
-        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMaximum;
+        audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMaximum;
         dolog ("warning: Downsizing Buffer Frames to %f\n", frameRange.mMaximum);
     } else {
-        core->audioDevicePropertyBufferFrameSize = core->frameSizeSetting;
+        audioDevicePropertyBufferFrameSize = core->frameSizeSetting;
     }
 
     /* set Buffer Frame Size */
-    status = coreaudio_set_framesize(core->outputDeviceID,
-                                     &core->audioDevicePropertyBufferFrameSize);
+    status = coreaudio_set_framesize(deviceID,
+                                     &audioDevicePropertyBufferFrameSize);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
     if (status != kAudioHardwareNoError) {
         coreaudio_playback_logerr (status,
                                     "Could not set device buffer frame size %" PRIu32 "\n",
-                                    (uint32_t)core->audioDevicePropertyBufferFrameSize);
+                                    (uint32_t)audioDevicePropertyBufferFrameSize);
         return status;
     }
 
     /* get Buffer Frame Size */
-    status = coreaudio_get_framesize(core->outputDeviceID,
-                                     &core->audioDevicePropertyBufferFrameSize);
+    status = coreaudio_get_framesize(deviceID,
+                                     &audioDevicePropertyBufferFrameSize);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -430,11 +432,9 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
                                     "Could not get device buffer frame size\n");
         return status;
     }
-    core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
 
     /* set Samplerate */
-    status = coreaudio_set_streamformat(core->outputDeviceID,
-                                        &streamBasicDescription);
+    status = coreaudio_set_streamformat(deviceID, &streamBasicDescription);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -442,7 +442,6 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
         coreaudio_playback_logerr (status,
                                    "Could not set samplerate %lf\n",
                                    streamBasicDescription.mSampleRate);
-        core->outputDeviceID = kAudioDeviceUnknown;
         return status;
     }
 
@@ -456,20 +455,24 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
      * Therefore, the specified callback must be designed to avoid a deadlock
      * with the callers of AudioObjectGetPropertyData.
      */
-    core->ioprocid = NULL;
-    status = AudioDeviceCreateIOProcID(core->outputDeviceID,
+    ioprocid = NULL;
+    status = AudioDeviceCreateIOProcID(deviceID,
                                        audioDeviceIOProc,
                                        &core->hw,
-                                       &core->ioprocid);
+                                       &ioprocid);
     if (status == kAudioHardwareBadDeviceError) {
         return 0;
     }
-    if (status != kAudioHardwareNoError || core->ioprocid == NULL) {
+    if (status != kAudioHardwareNoError || ioprocid == NULL) {
         coreaudio_playback_logerr (status, "Could not set IOProc\n");
-        core->outputDeviceID = kAudioDeviceUnknown;
         return status;
     }
 
+    core->outputDeviceID = deviceID;
+    core->audioDevicePropertyBufferFrameSize = audioDevicePropertyBufferFrameSize;
+    core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
+    core->ioprocid = ioprocid;
+
     return 0;
 }
 
@@ -553,7 +556,9 @@ static OSStatus handle_voice_change(
         fini_out_device(core);
     }
 
-    if (!init_out_device(core)) {
+    init_out_device(core);
+
+    if (core->outputDeviceID) {
         update_device_playback_state(core);
     }
 

From 66553a82133ff5abfd69eca131c42b1ea50b0991 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 11 Feb 2021 16:02:52 +0900
Subject: [PATCH 146/180] ui/cocoa: Use NSWindow's ability to resize

This change brings two new features:
- The window will be resizable if "Zoom To Fit" is eanbled
- The window can be made full screen by clicking full screen button
  provided by the platform. (The left-top green button.)

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 540 ++++++++++++++++++++++++-----------------------------
 1 file changed, 249 insertions(+), 291 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 8f568b2a880e..960adb416d5c 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -96,7 +96,6 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 static DisplayChangeListener dcl = {
     .ops = &dcl_ops,
 };
-static int last_buttons;
 static int cursor_hide = 1;
 static int left_command_key_enabled = 1;
 static bool swap_opt_cmd;
@@ -104,7 +103,6 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 static bool full_grab;
 static bool have_cocoa_ui;
 
-static bool stretch_video;
 static NSTextField *pauseLabel;
 
 static bool allow_events;
@@ -333,20 +331,17 @@ static void handleAnyDeviceErrors(Error * err)
 */
 @interface QemuCocoaView : NSView
 {
+    NSTrackingArea *trackingArea;
     QEMUScreen screen;
-    NSWindow *fullScreenWindow;
-    float cx,cy,cw,ch,cdx,cdy;
     pixman_image_t *pixman_image;
     QKbdState *kbd;
     BOOL isMouseGrabbed;
-    BOOL isFullscreen;
     BOOL isAbsoluteEnabled;
     CFMachPortRef eventsTap;
 }
 - (void) switchSurface:(pixman_image_t *)image;
 - (void) grabMouse;
 - (void) ungrabMouse;
-- (void) toggleFullScreen:(id)sender;
 - (void) setFullGrab:(id)sender;
 - (void) handleMonitorInput:(NSEvent *)event;
 - (bool) handleEvent:(NSEvent *)event;
@@ -362,8 +357,6 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
  */
 - (BOOL) isMouseGrabbed;
 - (BOOL) isAbsoluteEnabled;
-- (float) cdx;
-- (float) cdy;
 - (QEMUScreen) gscreen;
 @end
 
@@ -420,46 +413,43 @@ - (BOOL) isOpaque
     return YES;
 }
 
-- (BOOL) screenContainsPoint:(NSPoint) p
+- (void) removeTrackingRect
 {
-    return (p.x > -1 && p.x < screen.width && p.y > -1 && p.y < screen.height);
+    if (trackingArea) {
+        [self removeTrackingArea:trackingArea];
+        [trackingArea release];
+        trackingArea = nil;
+    }
 }
 
-/* Get location of event and convert to virtual screen coordinate */
-- (CGPoint) screenLocationOfEvent:(NSEvent *)ev
+- (void) frameUpdated
 {
-    NSWindow *eventWindow = [ev window];
-    // XXX: Use CGRect and -convertRectFromScreen: to support macOS 10.10
-    CGRect r = CGRectZero;
-    r.origin = [ev locationInWindow];
-    if (!eventWindow) {
-        if (!isFullscreen) {
-            return [[self window] convertRectFromScreen:r].origin;
-        } else {
-            CGPoint locationInSelfWindow = [[self window] convertRectFromScreen:r].origin;
-            CGPoint loc = [self convertPoint:locationInSelfWindow fromView:nil];
-            if (stretch_video) {
-                loc.x /= cdx;
-                loc.y /= cdy;
-            }
-            return loc;
-        }
-    } else if ([[self window] isEqual:eventWindow]) {
-        if (!isFullscreen) {
-            return r.origin;
-        } else {
-            CGPoint loc = [self convertPoint:r.origin fromView:nil];
-            if (stretch_video) {
-                loc.x /= cdx;
-                loc.y /= cdy;
-            }
-            return loc;
-        }
-    } else {
-        return [[self window] convertRectFromScreen:[eventWindow convertRectToScreen:r]].origin;
+    [self removeTrackingRect];
+
+    if ([self window]) {
+        NSTrackingAreaOptions options = NSTrackingActiveInKeyWindow |
+                                        NSTrackingMouseEnteredAndExited |
+                                        NSTrackingMouseMoved;
+        trackingArea = [[NSTrackingArea alloc] initWithRect:[self frame]
+                                                    options:options
+                                                      owner:self
+                                                   userInfo:nil];
+        [self addTrackingArea:trackingArea];
+        [self updateUIInfo];
     }
 }
 
+- (void) viewDidMoveToWindow
+{
+    [self resizeWindow];
+    [self frameUpdated];
+}
+
+- (void) viewWillMoveToWindow:(NSWindow *)newWindow
+{
+    [self removeTrackingRect];
+}
+
 - (void) hideCursor
 {
     if (!cursor_hide) {
@@ -522,13 +512,14 @@ - (void) drawRect:(NSRect) rect
         int i;
         CGImageRef clipImageRef;
         CGRect clipRect;
+        CGFloat d = (CGFloat)h / [self frame].size.height;
 
         [self getRectsBeingDrawn:&rectList count:&rectCount];
         for (i = 0; i < rectCount; i++) {
-            clipRect.origin.x = rectList[i].origin.x / cdx;
-            clipRect.origin.y = (float)h - (rectList[i].origin.y + rectList[i].size.height) / cdy;
-            clipRect.size.width = rectList[i].size.width / cdx;
-            clipRect.size.height = rectList[i].size.height / cdy;
+            clipRect.origin.x = rectList[i].origin.x * d;
+            clipRect.origin.y = (float)h - (rectList[i].origin.y + rectList[i].size.height) * d;
+            clipRect.size.width = rectList[i].size.width * d;
+            clipRect.size.height = rectList[i].size.height * d;
             clipImageRef = CGImageCreateWithImageInRect(
                                                         imageRef,
                                                         clipRect
@@ -541,36 +532,34 @@ - (void) drawRect:(NSRect) rect
     }
 }
 
-- (void) setContentDimensions
+- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
 {
-    COCOA_DEBUG("QemuCocoaView: setContentDimensions\n");
+    NSSize size;
 
-    if (isFullscreen) {
-        cdx = [[NSScreen mainScreen] frame].size.width / (float)screen.width;
-        cdy = [[NSScreen mainScreen] frame].size.height / (float)screen.height;
+    size.width = (CGFloat)screen.width * proposedSize.height;
+    size.height = (CGFloat)screen.height * proposedSize.width;
 
-        /* stretches video, but keeps same aspect ratio */
-        if (stretch_video == true) {
-            /* use smallest stretch value - prevents clipping on sides */
-            if (MIN(cdx, cdy) == cdx) {
-                cdy = cdx;
-            } else {
-                cdx = cdy;
-            }
-        } else {  /* No stretching */
-            cdx = cdy = 1;
-        }
-        cw = screen.width * cdx;
-        ch = screen.height * cdy;
-        cx = ([[NSScreen mainScreen] frame].size.width - cw) / 2.0;
-        cy = ([[NSScreen mainScreen] frame].size.height - ch) / 2.0;
+    if (size.width < size.height) {
+        size.width /= screen.height;
+        size.height = proposedSize.height;
     } else {
-        cx = 0;
-        cy = 0;
-        cw = screen.width;
-        ch = screen.height;
-        cdx = 1.0;
-        cdy = 1.0;
+        size.width = proposedSize.width;
+        size.height /= screen.width;
+    }
+
+    return size;
+}
+
+- (void) resizeWindow
+{
+    [[self window] setContentAspectRatio:NSMakeSize(screen.width, screen.height)];
+
+    if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [[self window] setContentSize:NSMakeSize(screen.width, screen.height)];
+        [[self window] center];
+    } else if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
+        [[self window] setContentSize:[self fixZoomedFullScreenSize:[[[self window] screen] frame].size]];
+        [[self window] center];
     }
 }
 
@@ -590,7 +579,12 @@ - (void) updateUIInfoLocked
         NSSize screenSize = [[[self window] screen] frame].size;
         CGSize screenPhysicalSize = CGDisplayScreenSize(display);
 
-        frameSize = isFullscreen ? screenSize : [self frame].size;
+        if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) == 0) {
+            frameSize = [self frame].size;
+        } else {
+            frameSize = screenSize;
+        }
+
         info.width_mm = frameSize.width / screenSize.width * screenPhysicalSize.width;
         info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
     } else {
@@ -622,31 +616,19 @@ - (void) updateUIInfo
     });
 }
 
-- (void)viewDidMoveToWindow
-{
-    [self updateUIInfo];
-}
-
 - (void) switchSurface:(pixman_image_t *)image
 {
     COCOA_DEBUG("QemuCocoaView: switchSurface\n");
 
     int w = pixman_image_get_width(image);
     int h = pixman_image_get_height(image);
-    /* cdx == 0 means this is our very first surface, in which case we need
-     * to recalculate the content dimensions even if it happens to be the size
-     * of the initial empty window.
-     */
-    bool isResize = (w != screen.width || h != screen.height || cdx == 0.0);
 
-    int oldh = screen.height;
-    if (isResize) {
+    if (w != screen.width || h != screen.height) {
         // Resize before we trigger the redraw, or we'll redraw at the wrong size
         COCOA_DEBUG("switchSurface: new size %d x %d\n", w, h);
         screen.width = w;
         screen.height = h;
-        [self setContentDimensions];
-        [self setFrame:NSMakeRect(cx, cy, cw, ch)];
+        [self resizeWindow];
     }
 
     // update screenBuffer
@@ -655,51 +637,6 @@ - (void) switchSurface:(pixman_image_t *)image
     }
 
     pixman_image = image;
-
-    // update windows
-    if (isFullscreen) {
-        [[fullScreenWindow contentView] setFrame:[[NSScreen mainScreen] frame]];
-        [normalWindow setFrame:NSMakeRect([normalWindow frame].origin.x, [normalWindow frame].origin.y - h + oldh, w, h + [normalWindow frame].size.height - oldh) display:NO animate:NO];
-    } else {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
-        [normalWindow setFrame:NSMakeRect([normalWindow frame].origin.x, [normalWindow frame].origin.y - h + oldh, w, h + [normalWindow frame].size.height - oldh) display:YES animate:NO];
-    }
-
-    if (isResize) {
-        [normalWindow center];
-    }
-}
-
-- (void) toggleFullScreen:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaView: toggleFullScreen\n");
-
-    if (isFullscreen) { // switch from fullscreen to desktop
-        isFullscreen = FALSE;
-        [self ungrabMouse];
-        [self setContentDimensions];
-        [fullScreenWindow close];
-        [normalWindow setContentView: self];
-        [normalWindow makeKeyAndOrderFront: self];
-        [NSMenu setMenuBarVisible:YES];
-    } else { // switch from desktop to fullscreen
-        isFullscreen = TRUE;
-        [normalWindow orderOut: nil]; /* Hide the window */
-        [self grabMouse];
-        [self setContentDimensions];
-        [NSMenu setMenuBarVisible:NO];
-        fullScreenWindow = [[NSWindow alloc] initWithContentRect:[[NSScreen mainScreen] frame]
-            styleMask:NSWindowStyleMaskBorderless
-            backing:NSBackingStoreBuffered
-            defer:NO];
-        [fullScreenWindow setAcceptsMouseMovedEvents: YES];
-        [fullScreenWindow setHasShadow:NO];
-        [fullScreenWindow setBackgroundColor: [NSColor blackColor]];
-        [self setFrame:NSMakeRect(cx, cy, cw, ch)];
-        [[fullScreenWindow contentView] addSubview: self];
-        [fullScreenWindow makeKeyAndOrderFront:self];
-    }
 }
 
 - (void) setFullGrab:(id)sender
@@ -821,10 +758,6 @@ - (bool) handleEventLocked:(NSEvent *)event
     COCOA_DEBUG("QemuCocoaView: handleEvent\n");
     int buttons = 0;
     int keycode = 0;
-    bool mouse_event = false;
-    static bool switched_to_fullscreen = false;
-    // Location of event in virtual screen coordinates
-    NSPoint p = [self screenLocationOfEvent:event];
     NSUInteger modifiers = [event modifierFlags];
 
     /*
@@ -904,25 +837,25 @@ - (bool) handleEventLocked:(NSEvent *)event
                     if (!!(modifiers & NSEventModifierFlagShift)) {
                         [self toggleKey:Q_KEY_CODE_SHIFT];
                     }
-                    break;
+                    return true;
 
                 case kVK_RightShift:
                     if (!!(modifiers & NSEventModifierFlagShift)) {
                         [self toggleKey:Q_KEY_CODE_SHIFT_R];
                     }
-                    break;
+                    return true;
 
                 case kVK_Control:
                     if (!!(modifiers & NSEventModifierFlagControl)) {
                         [self toggleKey:Q_KEY_CODE_CTRL];
                     }
-                    break;
+                    return true;
 
                 case kVK_RightControl:
                     if (!!(modifiers & NSEventModifierFlagControl)) {
                         [self toggleKey:Q_KEY_CODE_CTRL_R];
                     }
-                    break;
+                    return true;
 
                 case kVK_Option:
                     if (!!(modifiers & NSEventModifierFlagOption)) {
@@ -932,7 +865,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                             [self toggleKey:Q_KEY_CODE_ALT];
                         }
                     }
-                    break;
+                    return true;
 
                 case kVK_RightOption:
                     if (!!(modifiers & NSEventModifierFlagOption)) {
@@ -942,7 +875,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                             [self toggleKey:Q_KEY_CODE_ALT_R];
                         }
                     }
-                    break;
+                    return true;
 
                 /* Don't pass command key changes to guest unless mouse is grabbed */
                 case kVK_Command:
@@ -954,7 +887,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                             [self toggleKey:Q_KEY_CODE_META_L];
                         }
                     }
-                    break;
+                    return true;
 
                 case kVK_RightCommand:
                     if (isMouseGrabbed &&
@@ -965,21 +898,16 @@ - (bool) handleEventLocked:(NSEvent *)event
                             [self toggleKey:Q_KEY_CODE_META_R];
                         }
                     }
-                    break;
+                    return true;
+
+                default:
+                    return true;
             }
-            break;
         case NSEventTypeKeyDown:
             keycode = cocoa_keycode_to_qemu([event keyCode]);
 
             // forward command key combos to the host UI unless the mouse is grabbed
             if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
-                /*
-                 * Prevent the command key from being stuck down in the guest
-                 * when using Command-F to switch to full screen mode.
-                 */
-                if (keycode == Q_KEY_CODE_F) {
-                    switched_to_fullscreen = true;
-                }
                 return false;
             }
 
@@ -1010,7 +938,7 @@ - (bool) handleEventLocked:(NSEvent *)event
             } else {
                 [self handleMonitorInput: event];
             }
-            break;
+            return true;
         case NSEventTypeKeyUp:
             keycode = cocoa_keycode_to_qemu([event keyCode]);
 
@@ -1023,67 +951,7 @@ - (bool) handleEventLocked:(NSEvent *)event
             if (qemu_console_is_graphic(NULL)) {
                 qkbd_state_key_event(kbd, keycode, false);
             }
-            break;
-        case NSEventTypeMouseMoved:
-            if (isAbsoluteEnabled) {
-                // Cursor re-entered into a window might generate events bound to screen coordinates
-                // and `nil` window property, and in full screen mode, current window might not be
-                // key window, where event location alone should suffice.
-                if (![self screenContainsPoint:p] || !([[self window] isKeyWindow] || isFullscreen)) {
-                    if (isMouseGrabbed) {
-                        [self ungrabMouse];
-                    }
-                } else {
-                    if (!isMouseGrabbed) {
-                        [self grabMouse];
-                    }
-                }
-            }
-            mouse_event = true;
-            break;
-        case NSEventTypeLeftMouseDown:
-            buttons |= MOUSE_EVENT_LBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeRightMouseDown:
-            buttons |= MOUSE_EVENT_RBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeOtherMouseDown:
-            buttons |= MOUSE_EVENT_MBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeLeftMouseDragged:
-            buttons |= MOUSE_EVENT_LBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeRightMouseDragged:
-            buttons |= MOUSE_EVENT_RBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeOtherMouseDragged:
-            buttons |= MOUSE_EVENT_MBUTTON;
-            mouse_event = true;
-            break;
-        case NSEventTypeLeftMouseUp:
-            mouse_event = true;
-            if (!isMouseGrabbed && [self screenContainsPoint:p]) {
-                /*
-                 * In fullscreen mode, the window of cocoaView may not be the
-                 * key window, therefore the position relative to the virtual
-                 * screen alone will be sufficient.
-                 */
-                if(isFullscreen || [[self window] isKeyWindow]) {
-                    [self grabMouse];
-                }
-            }
-            break;
-        case NSEventTypeRightMouseUp:
-            mouse_event = true;
-            break;
-        case NSEventTypeOtherMouseUp:
-            mouse_event = true;
-            break;
+            return true;
         case NSEventTypeScrollWheel:
             /*
              * Send wheel events to the guest regardless of window focus.
@@ -1114,62 +982,124 @@ - (bool) handleEventLocked:(NSEvent *)event
              * Since deltaX/deltaY also report scroll wheel events we prevent mouse
              * movement code from executing.
              */
-            mouse_event = false;
-            break;
+            return true;
         default:
             return false;
     }
+}
 
-    if (mouse_event) {
-        /* Don't send button events to the guest unless we've got a
-         * mouse grab or window focus. If we have neither then this event
-         * is the user clicking on the background window to activate and
-         * bring us to the front, which will be done by the sendEvent
-         * call below. We definitely don't want to pass that click through
-         * to the guest.
-         */
-        if ((isMouseGrabbed || [[self window] isKeyWindow]) &&
-            (last_buttons != buttons)) {
-            static uint32_t bmap[INPUT_BUTTON__MAX] = {
-                [INPUT_BUTTON_LEFT]       = MOUSE_EVENT_LBUTTON,
-                [INPUT_BUTTON_MIDDLE]     = MOUSE_EVENT_MBUTTON,
-                [INPUT_BUTTON_RIGHT]      = MOUSE_EVENT_RBUTTON
-            };
-            qemu_input_update_buttons(dcl.con, bmap, last_buttons, buttons);
-            last_buttons = buttons;
-        }
-        if (isMouseGrabbed) {
-            if (isAbsoluteEnabled) {
-                /* Note that the origin for Cocoa mouse coords is bottom left, not top left.
-                 * The check on screenContainsPoint is to avoid sending out of range values for
-                 * clicks in the titlebar.
-                 */
-                if ([self screenContainsPoint:p]) {
-                    qemu_input_queue_abs(dcl.con, INPUT_AXIS_X, p.x, 0, screen.width);
-                    qemu_input_queue_abs(dcl.con, INPUT_AXIS_Y, screen.height - p.y, 0, screen.height);
-                }
-            } else {
-                qemu_input_queue_rel(dcl.con, INPUT_AXIS_X, (int)[event deltaX]);
-                qemu_input_queue_rel(dcl.con, INPUT_AXIS_Y, (int)[event deltaY]);
-            }
+- (void) handleMouseEvent:(NSEvent *)event
+{
+    if (!isMouseGrabbed) {
+        return;
+    }
+
+    with_iothread_lock(^{
+        if (isAbsoluteEnabled) {
+            CGFloat d = (CGFloat)screen.height / [self frame].size.height;
+            NSPoint p = [event locationInWindow];
+            // Note that the origin for Cocoa mouse coords is bottom left, not top left.
+            qemu_input_queue_abs(dcl.con, INPUT_AXIS_X, p.x * d, 0, screen.width);
+            qemu_input_queue_abs(dcl.con, INPUT_AXIS_Y, screen.height - p.y * d, 0, screen.height);
         } else {
-            return false;
+            CGFloat d = (CGFloat)screen.height / [self convertSizeToBacking:[self frame].size].height;
+            qemu_input_queue_rel(dcl.con, INPUT_AXIS_X, [event deltaX] * d);
+            qemu_input_queue_rel(dcl.con, INPUT_AXIS_Y, [event deltaY] * d);
         }
+
         qemu_input_event_sync();
+    });
+}
+
+- (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool)down
+{
+    if (!isMouseGrabbed) {
+        return;
     }
-    return true;
+
+    with_iothread_lock(^{
+        qemu_input_queue_btn(dcl.con, button, down);
+    });
+
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseExited:(NSEvent *)event
+{
+    if (isAbsoluteEnabled && isMouseGrabbed) {
+        [self ungrabMouse];
+    }
+}
+
+- (void) mouseEntered:(NSEvent *)event
+{
+    if (isAbsoluteEnabled && !isMouseGrabbed) {
+        [self grabMouse];
+    }
+}
+
+- (void) mouseMoved:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:true];
+}
+
+- (void) rightMouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:true];
+}
+
+- (void) otherMouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:true];
+}
+
+- (void) mouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) rightMouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) otherMouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseUp:(NSEvent *)event
+{
+    if (!isMouseGrabbed) {
+        [self grabMouse];
+    }
+
+    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:false];
+}
+
+- (void) rightMouseUp:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:false];
+}
+
+- (void) otherMouseUp:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:false];
 }
 
 - (void) grabMouse
 {
     COCOA_DEBUG("QemuCocoaView: grabMouse\n");
 
-    if (!isFullscreen) {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
-        else
-            [normalWindow setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
-    }
+    if (qemu_name)
+        [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
+    else
+        [normalWindow setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
     [self hideCursor];
     CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
     isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
@@ -1179,15 +1109,14 @@ - (void) ungrabMouse
 {
     COCOA_DEBUG("QemuCocoaView: ungrabMouse\n");
 
-    if (!isFullscreen) {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
-        else
-            [normalWindow setTitle:@"QEMU"];
-    }
+    if (qemu_name)
+        [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
+    else
+        [normalWindow setTitle:@"QEMU"];
     [self unhideCursor];
     CGAssociateMouseAndMouseCursorPosition(TRUE);
     isMouseGrabbed = FALSE;
+    [self raiseAllButtons];
 }
 
 - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
@@ -1198,10 +1127,18 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
 }
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
 - (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
-- (float) cdx {return cdx;}
-- (float) cdy {return cdy;}
 - (QEMUScreen) gscreen {return screen;}
 
+- (void) raiseAllButtons
+{
+    with_iothread_lock(^{
+        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_LEFT, false);
+        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_RIGHT, false);
+        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_MIDDLE, false);
+    });
+}
+@end
+
 
 
 /*
@@ -1214,7 +1151,6 @@ @interface QemuCocoaAppController : NSObject
 {
 }
 - (void)doToggleFullScreen:(id)sender;
-- (void)toggleFullScreen:(id)sender;
 - (void)showQEMUDoc:(id)sender;
 - (void)zoomToFit:(id) sender;
 - (void)displayConsole:(id)sender;
@@ -1256,12 +1192,12 @@ - (id) init
             exit(1);
         }
         [normalWindow setAcceptsMouseMovedEvents:YES];
-        [normalWindow setTitle:@"QEMU"];
+        [normalWindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
+        [normalWindow setTitle:qemu_name ? [NSString stringWithFormat:@"QEMU %s", qemu_name] : @"QEMU"];
         [normalWindow setContentView:cocoaView];
         [normalWindow makeKeyAndOrderFront:self];
         [normalWindow center];
         [normalWindow setDelegate: self];
-        stretch_video = false;
 
         /* Used for displaying pause on the screen */
         pauseLabel = [NSTextField new];
@@ -1304,8 +1240,7 @@ - (void)applicationDidFinishLaunching: (NSNotification *) note
                        NULL, QEMU_THREAD_DETACHED);
 
     if (full_screen) {
-        [NSApp activateIgnoringOtherApps: YES];
-        [self toggleFullScreen: nil];
+        [normalWindow toggleFullScreen: nil];
     }
     if (full_grab) {
         [self setFullGrab: nil];
@@ -1343,9 +1278,20 @@ - (void)windowDidChangeScreen:(NSNotification *)notification
     [cocoaView updateUIInfo];
 }
 
+- (void)windowDidEnterFullScreen:(NSNotification *)notification
+{
+    [cocoaView grabMouse];
+}
+
+- (void)windowDidExitFullScreen:(NSNotification *)notification
+{
+    [cocoaView resizeWindow];
+    [cocoaView ungrabMouse];
+}
+
 - (void)windowDidResize:(NSNotification *)notification
 {
-    [cocoaView updateUIInfo];
+    [cocoaView frameUpdated];
 }
 
 /* Called when the user clicks on a window's close button */
@@ -1361,6 +1307,23 @@ - (BOOL)windowShouldClose:(id)sender
     return NO;
 }
 
+- (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
+{
+    if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
+        return NSMakeSize([cocoaView gscreen].width, [cocoaView gscreen].height);
+    }
+
+    return [cocoaView fixZoomedFullScreenSize:proposedSize];
+}
+
+- (NSApplicationPresentationOptions) window:(NSWindow *)window
+                                     willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions;
+
+{
+    return (proposedOptions & ~(NSApplicationPresentationAutoHideDock | NSApplicationPresentationAutoHideMenuBar)) |
+           NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar;
+}
+
 /* Called when QEMU goes into the background */
 - (void) applicationWillResignActive: (NSNotification *)aNotification
 {
@@ -1374,14 +1337,7 @@ - (void) applicationWillResignActive: (NSNotification *)aNotification
  */
 - (void) doToggleFullScreen:(id)sender
 {
-    [self toggleFullScreen:(id)sender];
-}
-
-- (void)toggleFullScreen:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: toggleFullScreen\n");
-
-    [cocoaView toggleFullScreen:sender];
+    [normalWindow toggleFullScreen:sender];
 }
 
 - (void) setFullGrab:(id)sender
@@ -1425,13 +1381,15 @@ - (void)showQEMUDoc:(id)sender
     [self openDocumentation: @"index.html"];
 }
 
-/* Stretches video to fit host monitor size */
+/* Toggles the flag which stretches video to fit host window size */
 - (void)zoomToFit:(id) sender
 {
-    stretch_video = !stretch_video;
-    if (stretch_video == true) {
+    if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [normalWindow setStyleMask:[normalWindow styleMask] | NSWindowStyleMaskResizable];
         [sender setState: NSControlStateValueOn];
     } else {
+        [normalWindow setStyleMask:[normalWindow styleMask] & ~NSWindowStyleMaskResizable];
+        [cocoaView resizeWindow];
         [sender setState: NSControlStateValueOff];
     }
 }
@@ -1439,7 +1397,9 @@ - (void)zoomToFit:(id) sender
 /* Displays the console on the screen */
 - (void)displayConsole:(id)sender
 {
-    console_select([sender tag]);
+    with_iothread_lock(^{
+        console_select([sender tag]);
+    });
 }
 
 /* Pause the guest */
@@ -1954,16 +1914,14 @@ static void cocoa_update(DisplayChangeListener *dcl,
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        NSRect rect;
-        if ([cocoaView cdx] == 1.0) {
-            rect = NSMakeRect(x, [cocoaView gscreen].height - y - h, w, h);
-        } else {
-            rect = NSMakeRect(
-                x * [cocoaView cdx],
-                ([cocoaView gscreen].height - y - h) * [cocoaView cdy],
-                w * [cocoaView cdx],
-                h * [cocoaView cdy]);
-        }
+        CGFloat d = [cocoaView frame].size.height / (CGFloat)[cocoaView gscreen].height;
+
+        NSRect rect = NSMakeRect(
+                x * d,
+                ([cocoaView gscreen].height - y - h) * d,
+                w * d,
+                h * d);
+
         [cocoaView setNeedsDisplayInRect:rect];
     });
 }

From de8f1b03d0e63b129a8d1a97881feeaa2a10f992 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 7 Jul 2021 03:31:01 +0900
Subject: [PATCH 147/180] block/file-posix: Use O_RDWR for locking on macOS

qemu_lock_fd_test always returns 0 when fd is not open for writing and
exclusive is true on macOS 11.3.1.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 block/file-posix.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/block/file-posix.c b/block/file-posix.c
index 39a3d6dbe6e2..9f8b74c8a3a3 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -131,6 +131,14 @@
 #define RAW_LOCK_PERM_BASE             100
 #define RAW_LOCK_SHARED_BASE           200
 
+/*
+ * qemu_lock_fd_test always returns 0 when fd is not open for writing and
+ * exclusive is true on macOS 11.3.1.
+ */
+#ifdef __APPLE__
+#define RAW_LOCK_WRITES
+#endif
+
 typedef struct BDRVRawState {
     int fd;
     bool use_lock;
@@ -675,7 +683,11 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
                                                false);
 
     s->open_flags = open_flags;
+#ifdef RAW_LOCK_WRITES
+    raw_parse_flags(bdrv_flags, &s->open_flags, s->use_lock);
+#else
     raw_parse_flags(bdrv_flags, &s->open_flags, false);
+#endif
 
     s->fd = -1;
     fd = qemu_open(filename, s->open_flags, errp);
@@ -1033,6 +1045,11 @@ static int raw_reconfigure_getfd(BlockDriverState *bs, int flags,
     bool has_writers = perm &
         (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED | BLK_PERM_RESIZE);
     int fcntl_flags = O_APPEND | O_NONBLOCK;
+#ifdef RAW_LOCK_WRITES
+    if (s->use_lock) {
+        has_writers = true;
+    }
+#endif
 #ifdef O_NOATIME
     fcntl_flags |= O_NOATIME;
 #endif

From 1f24abea063f0798fd3d980e34c7af36825c1cd9 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Tue, 15 Jun 2021 17:30:34 +0900
Subject: [PATCH 148/180] ui/cocoa: Use qemu_input_map_osx_to_qcode

ui/cocoa used to have a conversion table from macOS keycode to QKeyCode.
It is an unnecessary redundancy as ui/input-keymap.c already has such a
table. Worse, I added an incorrect mapping of kVK_JIS_Eisu and
kVK_JIS_Kana with commit 708b72557ff510493ab3653c7a1ebfe983009469.
According to the following documentations, the definitions in
ui/keycodemapdb/keymaps.csv, which ui/input-keymap.c uses, are correct:
https://developer.apple.com/documentation/uikit/uikeyboardhidusage/uikeyboardhidusagekeyboardlang1?language=objc
https://developer.apple.com/documentation/uikit/uikeyboardhidusage/uikeyboardhidusagekeyboardlang2?language=objc
https://docs.microsoft.com/en-us/windows-hardware/design/component-guidelines/keyboard-japan-ime

Use qemu_input_map_osx_to_qcode to eliminate the redundancy and
incorrect mappings.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 129 +----------------------------------------------------
 1 file changed, 2 insertions(+), 127 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 960adb416d5c..63e6e926b4c2 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -171,138 +171,13 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
     exit(0);
 }
 
-// Mac to QKeyCode conversion
-static const int mac_to_qkeycode_map[] = {
-    [kVK_ANSI_A] = Q_KEY_CODE_A,
-    [kVK_ANSI_B] = Q_KEY_CODE_B,
-    [kVK_ANSI_C] = Q_KEY_CODE_C,
-    [kVK_ANSI_D] = Q_KEY_CODE_D,
-    [kVK_ANSI_E] = Q_KEY_CODE_E,
-    [kVK_ANSI_F] = Q_KEY_CODE_F,
-    [kVK_ANSI_G] = Q_KEY_CODE_G,
-    [kVK_ANSI_H] = Q_KEY_CODE_H,
-    [kVK_ANSI_I] = Q_KEY_CODE_I,
-    [kVK_ANSI_J] = Q_KEY_CODE_J,
-    [kVK_ANSI_K] = Q_KEY_CODE_K,
-    [kVK_ANSI_L] = Q_KEY_CODE_L,
-    [kVK_ANSI_M] = Q_KEY_CODE_M,
-    [kVK_ANSI_N] = Q_KEY_CODE_N,
-    [kVK_ANSI_O] = Q_KEY_CODE_O,
-    [kVK_ANSI_P] = Q_KEY_CODE_P,
-    [kVK_ANSI_Q] = Q_KEY_CODE_Q,
-    [kVK_ANSI_R] = Q_KEY_CODE_R,
-    [kVK_ANSI_S] = Q_KEY_CODE_S,
-    [kVK_ANSI_T] = Q_KEY_CODE_T,
-    [kVK_ANSI_U] = Q_KEY_CODE_U,
-    [kVK_ANSI_V] = Q_KEY_CODE_V,
-    [kVK_ANSI_W] = Q_KEY_CODE_W,
-    [kVK_ANSI_X] = Q_KEY_CODE_X,
-    [kVK_ANSI_Y] = Q_KEY_CODE_Y,
-    [kVK_ANSI_Z] = Q_KEY_CODE_Z,
-
-    [kVK_ANSI_0] = Q_KEY_CODE_0,
-    [kVK_ANSI_1] = Q_KEY_CODE_1,
-    [kVK_ANSI_2] = Q_KEY_CODE_2,
-    [kVK_ANSI_3] = Q_KEY_CODE_3,
-    [kVK_ANSI_4] = Q_KEY_CODE_4,
-    [kVK_ANSI_5] = Q_KEY_CODE_5,
-    [kVK_ANSI_6] = Q_KEY_CODE_6,
-    [kVK_ANSI_7] = Q_KEY_CODE_7,
-    [kVK_ANSI_8] = Q_KEY_CODE_8,
-    [kVK_ANSI_9] = Q_KEY_CODE_9,
-
-    [kVK_ANSI_Grave] = Q_KEY_CODE_GRAVE_ACCENT,
-    [kVK_ANSI_Minus] = Q_KEY_CODE_MINUS,
-    [kVK_ANSI_Equal] = Q_KEY_CODE_EQUAL,
-    [kVK_Delete] = Q_KEY_CODE_BACKSPACE,
-    [kVK_CapsLock] = Q_KEY_CODE_CAPS_LOCK,
-    [kVK_Tab] = Q_KEY_CODE_TAB,
-    [kVK_Return] = Q_KEY_CODE_RET,
-    [kVK_ANSI_LeftBracket] = Q_KEY_CODE_BRACKET_LEFT,
-    [kVK_ANSI_RightBracket] = Q_KEY_CODE_BRACKET_RIGHT,
-    [kVK_ANSI_Backslash] = Q_KEY_CODE_BACKSLASH,
-    [kVK_ANSI_Semicolon] = Q_KEY_CODE_SEMICOLON,
-    [kVK_ANSI_Quote] = Q_KEY_CODE_APOSTROPHE,
-    [kVK_ANSI_Comma] = Q_KEY_CODE_COMMA,
-    [kVK_ANSI_Period] = Q_KEY_CODE_DOT,
-    [kVK_ANSI_Slash] = Q_KEY_CODE_SLASH,
-    [kVK_Space] = Q_KEY_CODE_SPC,
-
-    [kVK_ANSI_Keypad0] = Q_KEY_CODE_KP_0,
-    [kVK_ANSI_Keypad1] = Q_KEY_CODE_KP_1,
-    [kVK_ANSI_Keypad2] = Q_KEY_CODE_KP_2,
-    [kVK_ANSI_Keypad3] = Q_KEY_CODE_KP_3,
-    [kVK_ANSI_Keypad4] = Q_KEY_CODE_KP_4,
-    [kVK_ANSI_Keypad5] = Q_KEY_CODE_KP_5,
-    [kVK_ANSI_Keypad6] = Q_KEY_CODE_KP_6,
-    [kVK_ANSI_Keypad7] = Q_KEY_CODE_KP_7,
-    [kVK_ANSI_Keypad8] = Q_KEY_CODE_KP_8,
-    [kVK_ANSI_Keypad9] = Q_KEY_CODE_KP_9,
-    [kVK_ANSI_KeypadDecimal] = Q_KEY_CODE_KP_DECIMAL,
-    [kVK_ANSI_KeypadEnter] = Q_KEY_CODE_KP_ENTER,
-    [kVK_ANSI_KeypadPlus] = Q_KEY_CODE_KP_ADD,
-    [kVK_ANSI_KeypadMinus] = Q_KEY_CODE_KP_SUBTRACT,
-    [kVK_ANSI_KeypadMultiply] = Q_KEY_CODE_KP_MULTIPLY,
-    [kVK_ANSI_KeypadDivide] = Q_KEY_CODE_KP_DIVIDE,
-    [kVK_ANSI_KeypadEquals] = Q_KEY_CODE_KP_EQUALS,
-    [kVK_ANSI_KeypadClear] = Q_KEY_CODE_NUM_LOCK,
-
-    [kVK_UpArrow] = Q_KEY_CODE_UP,
-    [kVK_DownArrow] = Q_KEY_CODE_DOWN,
-    [kVK_LeftArrow] = Q_KEY_CODE_LEFT,
-    [kVK_RightArrow] = Q_KEY_CODE_RIGHT,
-
-    [kVK_Help] = Q_KEY_CODE_INSERT,
-    [kVK_Home] = Q_KEY_CODE_HOME,
-    [kVK_PageUp] = Q_KEY_CODE_PGUP,
-    [kVK_PageDown] = Q_KEY_CODE_PGDN,
-    [kVK_End] = Q_KEY_CODE_END,
-    [kVK_ForwardDelete] = Q_KEY_CODE_DELETE,
-
-    [kVK_Escape] = Q_KEY_CODE_ESC,
-
-    /* The Power key can't be used directly because the operating system uses
-     * it. This key can be emulated by using it in place of another key such as
-     * F1. Don't forget to disable the real key binding.
-     */
-    /* [kVK_F1] = Q_KEY_CODE_POWER, */
-
-    [kVK_F1] = Q_KEY_CODE_F1,
-    [kVK_F2] = Q_KEY_CODE_F2,
-    [kVK_F3] = Q_KEY_CODE_F3,
-    [kVK_F4] = Q_KEY_CODE_F4,
-    [kVK_F5] = Q_KEY_CODE_F5,
-    [kVK_F6] = Q_KEY_CODE_F6,
-    [kVK_F7] = Q_KEY_CODE_F7,
-    [kVK_F8] = Q_KEY_CODE_F8,
-    [kVK_F9] = Q_KEY_CODE_F9,
-    [kVK_F10] = Q_KEY_CODE_F10,
-    [kVK_F11] = Q_KEY_CODE_F11,
-    [kVK_F12] = Q_KEY_CODE_F12,
-    [kVK_F13] = Q_KEY_CODE_PRINT,
-    [kVK_F14] = Q_KEY_CODE_SCROLL_LOCK,
-    [kVK_F15] = Q_KEY_CODE_PAUSE,
-
-    // JIS keyboards only
-    [kVK_JIS_Yen] = Q_KEY_CODE_YEN,
-    [kVK_JIS_Underscore] = Q_KEY_CODE_RO,
-    [kVK_JIS_KeypadComma] = Q_KEY_CODE_KP_COMMA,
-    [kVK_JIS_Eisu] = Q_KEY_CODE_MUHENKAN,
-    [kVK_JIS_Kana] = Q_KEY_CODE_HENKAN,
-
-    /*
-     * The eject and volume keys can't be used here because they are handled at
-     * a lower level than what an Application can see.
-     */
-};
-
 static int cocoa_keycode_to_qemu(int keycode)
 {
-    if (ARRAY_SIZE(mac_to_qkeycode_map) <= keycode) {
+    if (qemu_input_map_osx_to_qcode_len <= keycode) {
         error_report("(cocoa) warning unknown keycode 0x%x", keycode);
         return 0;
     }
-    return mac_to_qkeycode_map[keycode];
+    return qemu_input_map_osx_to_qcode[keycode];
 }
 
 /* Displays an alert dialog box with the specified message */

From 781a23afc724f56becf5cf2a0475788ec51773fb Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sat, 12 Feb 2022 15:30:41 +0900
Subject: [PATCH 149/180] audio/mixeng: Do not declare unused variables

The unused variables when FLOAT_MIXENG is defined caused warnings on
Apple clang version 13.1.6 (clang-1316.0.21.2).

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 audio/mixeng.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/audio/mixeng.c b/audio/mixeng.c
index f27deb165b67..100a306d6fec 100644
--- a/audio/mixeng.c
+++ b/audio/mixeng.c
@@ -342,13 +342,13 @@ f_sample *mixeng_clip_float[2] = {
 void audio_sample_to_uint64(const void *samples, int pos,
                             uint64_t *left, uint64_t *right)
 {
-    const struct st_sample *sample = samples;
-    sample += pos;
 #ifdef FLOAT_MIXENG
     error_report(
         "Coreaudio and floating point samples are not supported by replay yet");
     abort();
 #else
+    const struct st_sample *sample = samples;
+    sample += pos;
     *left = sample->l;
     *right = sample->r;
 #endif
@@ -357,13 +357,13 @@ void audio_sample_to_uint64(const void *samples, int pos,
 void audio_sample_from_uint64(void *samples, int pos,
                             uint64_t left, uint64_t right)
 {
-    struct st_sample *sample = samples;
-    sample += pos;
 #ifdef FLOAT_MIXENG
     error_report(
         "Coreaudio and floating point samples are not supported by replay yet");
     abort();
 #else
+    struct st_sample *sample = samples;
+    sample += pos;
     sample->l = left;
     sample->r = right;
 #endif

From 67876f074e3b5f8ab21e499595e5b6ca54194e6c Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Fri, 18 Mar 2022 00:16:07 +0900
Subject: [PATCH 150/180] ui/cocoa: Respect left-command-key option

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 63e6e926b4c2..c6534e5d8a00 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -755,7 +755,8 @@ - (bool) handleEventLocked:(NSEvent *)event
                 /* Don't pass command key changes to guest unless mouse is grabbed */
                 case kVK_Command:
                     if (isMouseGrabbed &&
-                        !!(modifiers & NSEventModifierFlagCommand)) {
+                        !!(modifiers & NSEventModifierFlagCommand) &&
+                        left_command_key_enabled) {
                         if (swap_opt_cmd) {
                             [self toggleKey:Q_KEY_CODE_ALT];
                         } else {

From 99ac5e48e4351ad84c765379713aa33203e0858b Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Fri, 25 Mar 2022 16:10:09 +0900
Subject: [PATCH 151/180] ui/console: Check console before emitting GL event

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/console.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/ui/console.c b/ui/console.c
index a0c054bb7aa8..734aae3b9808 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -1880,6 +1880,9 @@ void dpy_gl_scanout_disable(QemuConsole *con)
         con->scanout.kind = SCANOUT_NONE;
     }
     QLIST_FOREACH(dcl, &s->listeners, next) {
+        if (con != (dcl->con ? dcl->con : active_console)) {
+            continue;
+        }
         if (dcl->ops->dpy_gl_scanout_disable) {
             dcl->ops->dpy_gl_scanout_disable(dcl);
         }
@@ -1903,6 +1906,9 @@ void dpy_gl_scanout_texture(QemuConsole *con,
         x, y, width, height
     };
     QLIST_FOREACH(dcl, &s->listeners, next) {
+        if (con != (dcl->con ? dcl->con : active_console)) {
+            continue;
+        }
         if (dcl->ops->dpy_gl_scanout_texture) {
             dcl->ops->dpy_gl_scanout_texture(dcl, backing_id,
                                              backing_y_0_top,
@@ -1921,6 +1927,9 @@ void dpy_gl_scanout_dmabuf(QemuConsole *con,
     con->scanout.kind = SCANOUT_DMABUF;
     con->scanout.dmabuf = dmabuf;
     QLIST_FOREACH(dcl, &s->listeners, next) {
+        if (con != (dcl->con ? dcl->con : active_console)) {
+            continue;
+        }
         if (dcl->ops->dpy_gl_scanout_dmabuf) {
             dcl->ops->dpy_gl_scanout_dmabuf(dcl, dmabuf);
         }
@@ -1934,6 +1943,9 @@ void dpy_gl_cursor_dmabuf(QemuConsole *con, QemuDmaBuf *dmabuf,
     DisplayChangeListener *dcl;
 
     QLIST_FOREACH(dcl, &s->listeners, next) {
+        if (con != (dcl->con ? dcl->con : active_console)) {
+            continue;
+        }
         if (dcl->ops->dpy_gl_cursor_dmabuf) {
             dcl->ops->dpy_gl_cursor_dmabuf(dcl, dmabuf,
                                            have_hot, hot_x, hot_y);
@@ -1948,6 +1960,9 @@ void dpy_gl_cursor_position(QemuConsole *con,
     DisplayChangeListener *dcl;
 
     QLIST_FOREACH(dcl, &s->listeners, next) {
+        if (con != (dcl->con ? dcl->con : active_console)) {
+            continue;
+        }
         if (dcl->ops->dpy_gl_cursor_position) {
             dcl->ops->dpy_gl_cursor_position(dcl, pos_x, pos_y);
         }
@@ -1961,6 +1976,9 @@ void dpy_gl_release_dmabuf(QemuConsole *con,
     DisplayChangeListener *dcl;
 
     QLIST_FOREACH(dcl, &s->listeners, next) {
+        if (con != (dcl->con ? dcl->con : active_console)) {
+            continue;
+        }
         if (dcl->ops->dpy_gl_release_dmabuf) {
             dcl->ops->dpy_gl_release_dmabuf(dcl, dmabuf);
         }
@@ -1977,6 +1995,9 @@ void dpy_gl_update(QemuConsole *con,
 
     graphic_hw_gl_block(con, true);
     QLIST_FOREACH(dcl, &s->listeners, next) {
+        if (con != (dcl->con ? dcl->con : active_console)) {
+            continue;
+        }
         if (dcl->ops->dpy_gl_update) {
             dcl->ops->dpy_gl_update(dcl, x, y, w, h);
         }

From 41eb76f5bfae034f4e71799f12dca1f231f4f919 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 16 Mar 2022 12:30:11 +0900
Subject: [PATCH 152/180] ui/vnc: Respect bound console

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/vnc.c | 61 ++++++++++++++++++++++++++++----------------------------
 1 file changed, 31 insertions(+), 30 deletions(-)

diff --git a/ui/vnc.c b/ui/vnc.c
index 3ccd33dedcc8..8cade86bd1c8 100644
--- a/ui/vnc.c
+++ b/ui/vnc.c
@@ -1882,11 +1882,12 @@ static void kbd_leds(void *opaque, int ledstate)
 static void do_key_event(VncState *vs, int down, int keycode, int sym)
 {
     QKeyCode qcode = qemu_input_key_number_to_qcode(keycode);
+    QemuConsole *con = vs->vd->dcl.con;
 
     /* QEMU console switch */
     switch (qcode) {
     case Q_KEY_CODE_1 ... Q_KEY_CODE_9: /* '1' to '9' keys */
-        if (vs->vd->dcl.con == NULL && down &&
+        if (con == NULL && down &&
             qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_CTRL) &&
             qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_ALT)) {
             /* Reset the modifiers sent to the current console */
@@ -1945,7 +1946,7 @@ static void do_key_event(VncState *vs, int down, int keycode, int sym)
     }
 
     qkbd_state_key_event(vs->vd->kbd, qcode, down);
-    if (!qemu_console_is_graphic(NULL)) {
+    if (!qemu_console_is_graphic(con)) {
         bool numlock = qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_NUMLOCK);
         bool control = qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_CTRL);
         /* QEMU console emulation */
@@ -1959,88 +1960,88 @@ static void do_key_event(VncState *vs, int down, int keycode, int sym)
             case 0xb8:                          /* Right ALT */
                 break;
             case 0xc8:
-                kbd_put_keysym(QEMU_KEY_UP);
+                kbd_put_keysym_console(con, QEMU_KEY_UP);
                 break;
             case 0xd0:
-                kbd_put_keysym(QEMU_KEY_DOWN);
+                kbd_put_keysym_console(con, QEMU_KEY_DOWN);
                 break;
             case 0xcb:
-                kbd_put_keysym(QEMU_KEY_LEFT);
+                kbd_put_keysym_console(con, QEMU_KEY_LEFT);
                 break;
             case 0xcd:
-                kbd_put_keysym(QEMU_KEY_RIGHT);
+                kbd_put_keysym_console(con, QEMU_KEY_RIGHT);
                 break;
             case 0xd3:
-                kbd_put_keysym(QEMU_KEY_DELETE);
+                kbd_put_keysym_console(con, QEMU_KEY_DELETE);
                 break;
             case 0xc7:
-                kbd_put_keysym(QEMU_KEY_HOME);
+                kbd_put_keysym_console(con, QEMU_KEY_HOME);
                 break;
             case 0xcf:
-                kbd_put_keysym(QEMU_KEY_END);
+                kbd_put_keysym_console(con, QEMU_KEY_END);
                 break;
             case 0xc9:
-                kbd_put_keysym(QEMU_KEY_PAGEUP);
+                kbd_put_keysym_console(con, QEMU_KEY_PAGEUP);
                 break;
             case 0xd1:
-                kbd_put_keysym(QEMU_KEY_PAGEDOWN);
+                kbd_put_keysym_console(con, QEMU_KEY_PAGEDOWN);
                 break;
 
             case 0x47:
-                kbd_put_keysym(numlock ? '7' : QEMU_KEY_HOME);
+                kbd_put_keysym_console(con, numlock ? '7' : QEMU_KEY_HOME);
                 break;
             case 0x48:
-                kbd_put_keysym(numlock ? '8' : QEMU_KEY_UP);
+                kbd_put_keysym_console(con, numlock ? '8' : QEMU_KEY_UP);
                 break;
             case 0x49:
-                kbd_put_keysym(numlock ? '9' : QEMU_KEY_PAGEUP);
+                kbd_put_keysym_console(con, numlock ? '9' : QEMU_KEY_PAGEUP);
                 break;
             case 0x4b:
-                kbd_put_keysym(numlock ? '4' : QEMU_KEY_LEFT);
+                kbd_put_keysym_console(con, numlock ? '4' : QEMU_KEY_LEFT);
                 break;
             case 0x4c:
-                kbd_put_keysym('5');
+                kbd_put_keysym_console(con, '5');
                 break;
             case 0x4d:
-                kbd_put_keysym(numlock ? '6' : QEMU_KEY_RIGHT);
+                kbd_put_keysym_console(con, numlock ? '6' : QEMU_KEY_RIGHT);
                 break;
             case 0x4f:
-                kbd_put_keysym(numlock ? '1' : QEMU_KEY_END);
+                kbd_put_keysym_console(con, numlock ? '1' : QEMU_KEY_END);
                 break;
             case 0x50:
-                kbd_put_keysym(numlock ? '2' : QEMU_KEY_DOWN);
+                kbd_put_keysym_console(con, numlock ? '2' : QEMU_KEY_DOWN);
                 break;
             case 0x51:
-                kbd_put_keysym(numlock ? '3' : QEMU_KEY_PAGEDOWN);
+                kbd_put_keysym_console(con, numlock ? '3' : QEMU_KEY_PAGEDOWN);
                 break;
             case 0x52:
-                kbd_put_keysym('0');
+                kbd_put_keysym_console(con, '0');
                 break;
             case 0x53:
-                kbd_put_keysym(numlock ? '.' : QEMU_KEY_DELETE);
+                kbd_put_keysym_console(con, numlock ? '.' : QEMU_KEY_DELETE);
                 break;
 
             case 0xb5:
-                kbd_put_keysym('/');
+                kbd_put_keysym_console(con, '/');
                 break;
             case 0x37:
-                kbd_put_keysym('*');
+                kbd_put_keysym_console(con, '*');
                 break;
             case 0x4a:
-                kbd_put_keysym('-');
+                kbd_put_keysym_console(con, '-');
                 break;
             case 0x4e:
-                kbd_put_keysym('+');
+                kbd_put_keysym_console(con, '+');
                 break;
             case 0x9c:
-                kbd_put_keysym('\n');
+                kbd_put_keysym_console(con, '\n');
                 break;
 
             default:
                 if (control) {
-                    kbd_put_keysym(sym & 0x1f);
+                    kbd_put_keysym_console(con, sym & 0x1f);
                 } else {
-                    kbd_put_keysym(sym);
+                    kbd_put_keysym_console(con, sym);
                 }
                 break;
             }
@@ -2058,7 +2059,7 @@ static void key_event(VncState *vs, int down, uint32_t sym)
     int keycode;
     int lsym = sym;
 
-    if (lsym >= 'A' && lsym <= 'Z' && qemu_console_is_graphic(NULL)) {
+    if (lsym >= 'A' && lsym <= 'Z' && qemu_console_is_graphic(vs->vd->dcl.con)) {
         lsym = lsym - 'A' + 'a';
     }
 

From 7dfd20c7e81469027dc348b68dd81c9b4bf355eb Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 16 Mar 2022 12:08:02 +0900
Subject: [PATCH 153/180] ui/vnc: Do not use console_select

console_select is shared by other displays and switching in one of them
triggers switching also in ui/vnc, circumventing key state
reinitialization specific to ui/vnc. Use its internal state to track
the current active console instead.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 include/ui/console.h |  1 +
 ui/console.c         | 12 ++++++++++++
 ui/vnc.c             | 15 ++++++++++-----
 3 files changed, 23 insertions(+), 5 deletions(-)

diff --git a/include/ui/console.h b/include/ui/console.h
index 5f02d7ec4f0a..6ebdd5cdcdad 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -454,6 +454,7 @@ void qemu_console_early_init(void);
 
 void qemu_console_set_display_gl_ctx(QemuConsole *con, DisplayGLCtx *ctx);
 
+QemuConsole *qemu_console_lookup_first_graphic_console(void);
 QemuConsole *qemu_console_lookup_by_index(unsigned int index);
 QemuConsole *qemu_console_lookup_by_device(DeviceState *dev, uint32_t head);
 QemuConsole *qemu_console_lookup_by_device_name(const char *device_id,
diff --git a/ui/console.c b/ui/console.c
index 734aae3b9808..fff2a6b3fbd5 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -2115,6 +2115,18 @@ void graphic_console_close(QemuConsole *con)
     dpy_gfx_replace_surface(con, surface);
 }
 
+QemuConsole *qemu_console_lookup_first_graphic_console(void)
+{
+    QemuConsole *con;
+
+    QTAILQ_FOREACH(con, &consoles, next) {
+        if (con->console_type == GRAPHIC_CONSOLE) {
+            return con;
+        }
+    }
+    return NULL;
+}
+
 QemuConsole *qemu_console_lookup_by_index(unsigned int index)
 {
     QemuConsole *con;
diff --git a/ui/vnc.c b/ui/vnc.c
index 8cade86bd1c8..95bd1dc79cbe 100644
--- a/ui/vnc.c
+++ b/ui/vnc.c
@@ -1887,12 +1887,17 @@ static void do_key_event(VncState *vs, int down, int keycode, int sym)
     /* QEMU console switch */
     switch (qcode) {
     case Q_KEY_CODE_1 ... Q_KEY_CODE_9: /* '1' to '9' keys */
-        if (con == NULL && down &&
+        if (down &&
             qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_CTRL) &&
             qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_ALT)) {
-            /* Reset the modifiers sent to the current console */
-            qkbd_state_lift_all_keys(vs->vd->kbd);
-            console_select(qcode - Q_KEY_CODE_1);
+            QemuConsole *con = qemu_console_lookup_by_index(qcode - Q_KEY_CODE_1);
+            if (con) {
+                /* Reset the modifiers sent to the current console */
+                qkbd_state_lift_all_keys(vs->vd->kbd);
+                unregister_displaychangelistener(&vs->vd->dcl);
+                vs->vd->dcl.con = con;
+                register_displaychangelistener(&vs->vd->dcl);
+            }
             return;
         }
     default:
@@ -4200,7 +4205,7 @@ void vnc_display_open(const char *id, Error **errp)
             goto fail;
         }
     } else {
-        con = NULL;
+        con = qemu_console_lookup_first_graphic_console();
     }
 
     if (con != vd->dcl.con) {

From f2098f2c306e28d593ea74c3b4017e9fccbe8182 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 16 Mar 2022 12:20:35 +0900
Subject: [PATCH 154/180] ui/cocoa: Do not use console_select

ui/cocoa needs to update the UI info when switching the console.
The behavior was implemented in cocoa_switch which was used to be called
by console_select. The function was however to switch the DisplaySurface
and overloaded. Have its own implementation of console_select and
update the UI info with it.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 29 ++++++++++++++++++++++-------
 1 file changed, 22 insertions(+), 7 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index c6534e5d8a00..048c34d319ff 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -325,6 +325,19 @@ - (void) viewWillMoveToWindow:(NSWindow *)newWindow
     [self removeTrackingRect];
 }
 
+- (void) selectConsoleLocked:(unsigned int)index
+{
+    QemuConsole *con = qemu_console_lookup_by_index(index);
+    if (!con) {
+        return;
+    }
+
+    unregister_displaychangelistener(&dcl);
+    dcl.con = con;
+    register_displaychangelistener(&dcl);
+    [self updateUIInfo];
+}
+
 - (void) hideCursor
 {
     if (!cursor_hide) {
@@ -608,7 +621,7 @@ - (void) handleMonitorInput:(NSEvent *)event
     }
 
     if (keysym) {
-        kbd_put_keysym(keysym);
+        kbd_put_keysym_console(dcl.con, keysym);
     }
 }
 
@@ -798,7 +811,7 @@ - (bool) handleEventLocked:(NSEvent *)event
 
                         // enable graphic console
                         case '1' ... '9':
-                            console_select(key - '0' - 1); /* ascii math */
+                            [self selectConsoleLocked:key - '0' - 1]; /* ascii math */
                             return true;
 
                         // release the mouse grab
@@ -809,7 +822,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                 }
             }
 
-            if (qemu_console_is_graphic(NULL)) {
+            if (qemu_console_is_graphic(dcl.con)) {
                 qkbd_state_key_event(kbd, keycode, true);
             } else {
                 [self handleMonitorInput: event];
@@ -824,7 +837,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                 return true;
             }
 
-            if (qemu_console_is_graphic(NULL)) {
+            if (qemu_console_is_graphic(dcl.con)) {
                 qkbd_state_key_event(kbd, keycode, false);
             }
             return true;
@@ -1106,8 +1119,11 @@ - (void)applicationDidFinishLaunching: (NSNotification *) note
     COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
     allow_events = true;
 
+    dcl.con = qemu_console_lookup_first_graphic_console();
+
     // register vga output callbacks
     register_displaychangelistener(&dcl);
+    [cocoaView updateUIInfo];
 
     qemu_clipboard_peer_register(&cbpeer);
 
@@ -1274,7 +1290,7 @@ - (void)zoomToFit:(id) sender
 - (void)displayConsole:(id)sender
 {
     with_iothread_lock(^{
-        console_select([sender tag]);
+        [cocoaView selectConsoleLocked:[sender tag]];
     });
 }
 
@@ -1816,7 +1832,6 @@ static void cocoa_switch(DisplayChangeListener *dcl,
     pixman_image_ref(image);
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        [cocoaView updateUIInfo];
         [cocoaView switchSurface:image];
     });
 }
@@ -1826,7 +1841,7 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
 
     COCOA_DEBUG("qemu_cocoa: cocoa_refresh\n");
-    graphic_hw_update(NULL);
+    graphic_hw_update(dcl->con);
 
     if (qemu_input_is_absolute()) {
         dispatch_async(dispatch_get_main_queue(), ^{

From 3f620296d88c4e140c110461686d84fcac50b8ec Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 16 Mar 2022 12:44:17 +0900
Subject: [PATCH 155/180] ui/curses: Do not use console_select

ui/curses is the only user of console_select. Move the implementation
to ui/curses.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 include/ui/console.h |  2 --
 ui/console.c         | 34 +++----------------------------
 ui/curses.c          | 48 +++++++++++++++++++++++++-------------------
 3 files changed, 30 insertions(+), 54 deletions(-)

diff --git a/include/ui/console.h b/include/ui/console.h
index 6ebdd5cdcdad..c8f1899b7fb4 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -93,7 +93,6 @@ void hmp_mouse_set(Monitor *mon, const QDict *qdict);
 void kbd_put_keysym_console(QemuConsole *s, int keysym);
 bool kbd_put_qcode_console(QemuConsole *s, int qcode, bool ctrl);
 void kbd_put_string_console(QemuConsole *s, const char *str, int len);
-void kbd_put_keysym(int keysym);
 
 /* consoles */
 
@@ -474,7 +473,6 @@ int qemu_console_get_window_id(QemuConsole *con);
 /* Set the low-level window id for the console */
 void qemu_console_set_window_id(QemuConsole *con, int window_id);
 
-void console_select(unsigned int index);
 void qemu_console_resize(QemuConsole *con, int width, int height);
 DisplaySurface *qemu_console_surface(QemuConsole *con);
 
diff --git a/ui/console.c b/ui/console.c
index fff2a6b3fbd5..7ba37a552ef6 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -1129,32 +1129,6 @@ static void displaychangelistener_display_console(DisplayChangeListener *dcl,
     }
 }
 
-void console_select(unsigned int index)
-{
-    DisplayChangeListener *dcl;
-    QemuConsole *s;
-
-    trace_console_select(index);
-    s = qemu_console_lookup_by_index(index);
-    if (s) {
-        DisplayState *ds = s->ds;
-
-        active_console = s;
-        if (ds->have_gfx) {
-            QLIST_FOREACH(dcl, &ds->listeners, next) {
-                if (dcl->con != NULL) {
-                    continue;
-                }
-                displaychangelistener_display_console(dcl, s, NULL);
-            }
-        }
-        if (ds->have_text) {
-            dpy_text_resize(s, s->width, s->height);
-        }
-        text_console_update_cursor(NULL);
-    }
-}
-
 struct VCChardev {
     Chardev parent;
     QemuConsole *console;
@@ -1308,11 +1282,6 @@ void kbd_put_string_console(QemuConsole *s, const char *str, int len)
     }
 }
 
-void kbd_put_keysym(int keysym)
-{
-    kbd_put_keysym_console(active_console, keysym);
-}
-
 static void text_console_invalidate(void *opaque)
 {
     QemuConsole *s = (QemuConsole *) opaque;
@@ -1564,6 +1533,9 @@ void register_displaychangelistener(DisplayChangeListener *dcl)
         con = active_console;
     }
     displaychangelistener_display_console(dcl, con, dcl->con ? &error_fatal : NULL);
+    if (dcl->ds->have_text) {
+        dpy_text_resize(dcl->con, dcl->con->width, dcl->con->height);
+    }
     text_console_update_cursor(NULL);
 }
 
diff --git a/ui/curses.c b/ui/curses.c
index 861d63244c70..ef023979b4d1 100644
--- a/ui/curses.c
+++ b/ui/curses.c
@@ -98,7 +98,7 @@ static void curses_update(DisplayChangeListener *dcl,
 
 static void curses_calc_pad(void)
 {
-    if (qemu_console_is_fixedsize(NULL)) {
+    if (qemu_console_is_fixedsize(dcl->con)) {
         width = gwidth;
         height = gheight;
     } else {
@@ -201,7 +201,7 @@ static void curses_cursor_position(DisplayChangeListener *dcl,
             curs_set(1);
             /* it seems that curs_set(1) must always be called before
              * curs_set(2) for the latter to have effect */
-            if (!qemu_console_is_graphic(NULL)) {
+            if (!qemu_console_is_graphic(dcl->con)) {
                 curs_set(2);
             }
             return;
@@ -274,11 +274,11 @@ static void curses_refresh(DisplayChangeListener *dcl)
         clear();
         refresh();
         curses_calc_pad();
-        graphic_hw_invalidate(NULL);
+        graphic_hw_invalidate(dcl->con);
         invalidate = 0;
     }
 
-    graphic_hw_text_update(NULL, screen);
+    graphic_hw_text_update(dcl->con, screen);
 
     while (1) {
         /* while there are any pending key strokes to process */
@@ -318,11 +318,16 @@ static void curses_refresh(DisplayChangeListener *dcl)
                     /* process keys reserved for qemu */
                     if (keycode >= QEMU_KEY_CONSOLE0 &&
                             keycode < QEMU_KEY_CONSOLE0 + 9) {
-                        erase();
-                        wnoutrefresh(stdscr);
-                        console_select(keycode - QEMU_KEY_CONSOLE0);
-
-                        invalidate = 1;
+                        QemuConsole *con = qemu_console_lookup_by_index(keycode - QEMU_KEY_CONSOLE0);
+                        if (con) {
+                            erase();
+                            wnoutrefresh(stdscr);
+                            unregister_displaychangelistener(dcl);
+                            dcl->con = con;
+                            register_displaychangelistener(dcl);
+
+                            invalidate = 1;
+                        }
                         continue;
                     }
                 }
@@ -354,45 +359,45 @@ static void curses_refresh(DisplayChangeListener *dcl)
         if (keycode == -1)
             continue;
 
-        if (qemu_console_is_graphic(NULL)) {
+        if (qemu_console_is_graphic(dcl->con)) {
             /* since terminals don't know about key press and release
              * events, we need to emit both for each key received */
             if (keycode & SHIFT) {
-                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);
+                qemu_input_event_send_key_number(dcl->con, SHIFT_CODE, true);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & CNTRL) {
-                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);
+                qemu_input_event_send_key_number(dcl->con, CNTRL_CODE, true);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & ALT) {
-                qemu_input_event_send_key_number(NULL, ALT_CODE, true);
+                qemu_input_event_send_key_number(dcl->con, ALT_CODE, true);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & ALTGR) {
-                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);
+                qemu_input_event_send_key_number(dcl->con, GREY | ALT_CODE, true);
                 qemu_input_event_send_key_delay(0);
             }
 
-            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);
+            qemu_input_event_send_key_number(dcl->con, keycode & KEY_MASK, true);
             qemu_input_event_send_key_delay(0);
-            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);
+            qemu_input_event_send_key_number(dcl->con, keycode & KEY_MASK, false);
             qemu_input_event_send_key_delay(0);
 
             if (keycode & ALTGR) {
-                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);
+                qemu_input_event_send_key_number(dcl->con, GREY | ALT_CODE, false);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & ALT) {
-                qemu_input_event_send_key_number(NULL, ALT_CODE, false);
+                qemu_input_event_send_key_number(dcl->con, ALT_CODE, false);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & CNTRL) {
-                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);
+                qemu_input_event_send_key_number(dcl->con, CNTRL_CODE, false);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & SHIFT) {
-                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);
+                qemu_input_event_send_key_number(dcl->con, SHIFT_CODE, false);
                 qemu_input_event_send_key_delay(0);
             }
         } else {
@@ -400,7 +405,7 @@ static void curses_refresh(DisplayChangeListener *dcl)
             if (keysym == -1)
                 keysym = chr;
 
-            kbd_put_keysym(keysym);
+            kbd_put_keysym_console(dcl->con, keysym);
         }
     }
 }
@@ -798,6 +803,7 @@ static void curses_display_init(DisplayState *ds, DisplayOptions *opts)
     curses_winch_init();
 
     dcl = g_new0(DisplayChangeListener, 1);
+    dcl->con = qemu_console_lookup_first_graphic_console();
     dcl->ops = &dcl_ops;
     register_displaychangelistener(dcl);
 

From ad2fe378fe6c76c1dbc33e55a987a62f79576fa0 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 11 Feb 2021 18:30:49 +0900
Subject: [PATCH 156/180] ui/cocoa: Do not scale UI without "Zoom To Fit"

Cocoa scales UI for high-resolution display like Retina, but we do not
need it since we now have our own "Zoom To Fit" work well also for
windows, and the guest is aware of the resolution thanks to UI
information. This change reverts the scaling.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 048c34d319ff..d0a4ef4cbc4c 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -420,6 +420,14 @@ - (void) drawRect:(NSRect) rect
     }
 }
 
+- (NSSize) computeUnzoomedSize
+{
+    CGFloat width = screen.width / [[self window] backingScaleFactor];
+    CGFloat height = screen.height / [[self window] backingScaleFactor];
+
+    return NSMakeSize(width, height);
+}
+
 - (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
 {
     NSSize size;
@@ -443,7 +451,7 @@ - (void) resizeWindow
     [[self window] setContentAspectRatio:NSMakeSize(screen.width, screen.height)];
 
     if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
-        [[self window] setContentSize:NSMakeSize(screen.width, screen.height)];
+        [[self window] setContentSize:[self computeUnzoomedSize]];
         [[self window] center];
     } else if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
         [[self window] setContentSize:[self fixZoomedFullScreenSize:[[[self window] screen] frame].size]];
@@ -479,8 +487,10 @@ - (void) updateUIInfoLocked
         frameSize = [self frame].size;
     }
 
-    info.width = frameSize.width;
-    info.height = frameSize.height;
+    NSSize frameBackingSize = [self convertSizeToBacking:frameSize];
+
+    info.width = frameBackingSize.width;
+    info.height = frameBackingSize.height;
 
     dpy_set_ui_info(dcl.con, &info, TRUE);
 }
@@ -1202,7 +1212,7 @@ - (BOOL)windowShouldClose:(id)sender
 - (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
 {
     if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
-        return NSMakeSize([cocoaView gscreen].width, [cocoaView gscreen].height);
+        return [cocoaView computeUnzoomedSize];
     }
 
     return [cocoaView fixZoomedFullScreenSize:proposedSize];

From bdf261c858a89b17d1640d6d1a15fd78ce5c8baa Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Tue, 23 Feb 2021 15:12:22 +0900
Subject: [PATCH 157/180] Support Virgil 3D renderer on macOS

Virgil 3D renderer will be available with ui/cocoa on macOS.

The OpenGL backend is NSOpenGLContext for core profile, and
EGL (in particular, ANGLE) for ES profile.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 configure                        |  25 +-
 include/ui/egl-helpers.h         |   4 +-
 include/ui/gtk.h                 |   4 +-
 include/ui/sdl2.h                |   4 +-
 include/ui/spice-display.h       |   2 +-
 qapi/ui.json                     |   4 +-
 qemu-options.hx                  |   2 +-
 ui/cocoa.m                       | 599 +++++++++++++++++++++++++------
 ui/console.c                     |   7 +-
 ui/egl-helpers.c                 | 136 +++----
 ui/gtk-egl.c                     |   2 +-
 ui/gtk.c                         |  24 +-
 ui/meson.build                   |  14 +-
 ui/sdl2.c                        |  12 +-
 ui/shader.c                      |  14 +-
 ui/shader/texture-blit-flip.vert |   3 -
 ui/shader/texture-blit.frag      |   3 -
 ui/shader/texture-blit.vert      |   3 -
 18 files changed, 630 insertions(+), 232 deletions(-)

diff --git a/configure b/configure
index cd4946b43ee8..9ab4ed30f6d3 100755
--- a/configure
+++ b/configure
@@ -323,6 +323,7 @@ pie=""
 trace_backends="log"
 trace_file="trace"
 opengl="$default_feature"
+egl="no"
 coroutine=""
 tls_priority="NORMAL"
 plugins="$default_feature"
@@ -2287,18 +2288,7 @@ esac
 # opengl probe (for sdl2, gtk)
 
 if test "$opengl" != "no" ; then
-  epoxy=no
   if $pkg_config epoxy; then
-    cat > $TMPC << EOF
-#include <epoxy/egl.h>
-int main(void) { return 0; }
-EOF
-    if compile_prog "" "" ; then
-      epoxy=yes
-    fi
-  fi
-
-  if test "$epoxy" = "yes" ; then
     opengl_cflags="$($pkg_config --cflags epoxy)"
     opengl_libs="$($pkg_config --libs epoxy)"
     opengl=yes
@@ -2312,6 +2302,16 @@ EOF
   fi
 fi
 
+if test "$opengl" = "yes"; then
+  cat > $TMPC << EOF
+#include <epoxy/egl.h>
+int main(void) { return 0; }
+EOF
+  if compile_prog "$opengl_cflags" "$opengl_libs" ; then
+    egl=yes
+  fi
+fi
+
 # check for usbfs
 have_usbfs=no
 if test "$linux_user" = "yes"; then
@@ -2942,6 +2942,9 @@ if test "$opengl" = "yes" ; then
   echo "CONFIG_OPENGL=y" >> $config_host_mak
   echo "OPENGL_CFLAGS=$opengl_cflags" >> $config_host_mak
   echo "OPENGL_LIBS=$opengl_libs" >> $config_host_mak
+  if test "$egl" = "yes" ; then
+    echo "CONFIG_EGL=y" >> $config_host_mak
+  fi
 fi
 
 # XXX: suppress that
diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
index 2fb6e0dd6b87..36834652b6d0 100644
--- a/include/ui/egl-helpers.h
+++ b/include/ui/egl-helpers.h
@@ -51,7 +51,9 @@ void egl_dmabuf_create_fence(QemuDmaBuf *dmabuf);
 
 #endif
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win);
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win);
+
+int qemu_egl_init_dpy_cocoa(DisplayGLMode mode);
 
 #if defined(CONFIG_X11) || defined(CONFIG_GBM)
 
diff --git a/include/ui/gtk.h b/include/ui/gtk.h
index ae0f53740d19..627cf2ca0f64 100644
--- a/include/ui/gtk.h
+++ b/include/ui/gtk.h
@@ -21,7 +21,7 @@
 #include "ui/clipboard.h"
 #include "ui/console.h"
 #include "ui/kbd-state.h"
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 #include "ui/egl-helpers.h"
 #include "ui/egl-context.h"
 #endif
@@ -43,7 +43,7 @@ typedef struct VirtualGfxConsole {
     cairo_surface_t *surface;
     double scale_x;
     double scale_y;
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     QemuGLShader *gls;
     EGLContext ectx;
     EGLSurface esurface;
diff --git a/include/ui/sdl2.h b/include/ui/sdl2.h
index 8fb7e0826255..8e422e26b482 100644
--- a/include/ui/sdl2.h
+++ b/include/ui/sdl2.h
@@ -22,7 +22,7 @@
 #endif
 
 #include "ui/kbd-state.h"
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 # include "ui/egl-helpers.h"
 #endif
 
@@ -44,7 +44,7 @@ struct sdl2_console {
     int ignore_hotkeys;
     SDL_GLContext winctx;
     QKbdState *kbd;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     QemuGLShader *gls;
     egl_fb guest_fb;
     egl_fb win_fb;
diff --git a/include/ui/spice-display.h b/include/ui/spice-display.h
index e271e011da1a..c0aeeeb879c6 100644
--- a/include/ui/spice-display.h
+++ b/include/ui/spice-display.h
@@ -27,7 +27,7 @@
 #include "ui/qemu-pixman.h"
 #include "ui/console.h"
 
-#if defined(CONFIG_OPENGL) && defined(CONFIG_GBM)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL) && defined(CONFIG_GBM)
 # if SPICE_SERVER_VERSION >= 0x000d01 /* release 0.13.1 */
 #  define HAVE_SPICE_GL 1
 #  include "ui/egl-helpers.h"
diff --git a/qapi/ui.json b/qapi/ui.json
index 664da9e46235..6cb8e76319c3 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -1334,7 +1334,7 @@
     { 'name': 'gtk', 'if': 'CONFIG_GTK' },
     { 'name': 'sdl', 'if': 'CONFIG_SDL' },
     { 'name': 'egl-headless',
-              'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_GBM'] } },
+              'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_EGL', 'CONFIG_GBM'] } },
     { 'name': 'curses', 'if': 'CONFIG_CURSES' },
     { 'name': 'cocoa', 'if': 'CONFIG_COCOA' },
     { 'name': 'spice-app', 'if': 'CONFIG_SPICE' },
@@ -1369,7 +1369,7 @@
       'cocoa': { 'type': 'DisplayCocoa', 'if': 'CONFIG_COCOA' },
       'curses': { 'type': 'DisplayCurses', 'if': 'CONFIG_CURSES' },
       'egl-headless': { 'type': 'DisplayEGLHeadless',
-                        'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_GBM'] } },
+                        'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_EGL', 'CONFIG_GBM'] } },
       'dbus': { 'type': 'DisplayDBus', 'if': 'CONFIG_DBUS_DISPLAY' }
   }
 }
diff --git a/qemu-options.hx b/qemu-options.hx
index dd95c0f69ad3..db1c7df43b59 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -1919,7 +1919,7 @@ DEF("display", HAS_ARG, QEMU_OPTION_display,
 #if defined(CONFIG_COCOA)
     "-display cocoa[,full-grab=on|off][,swap-opt-cmd=on|off]\n"
 #endif
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     "-display egl-headless[,rendernode=<file>]\n"
 #endif
 #if defined(CONFIG_DBUS_DISPLAY)
diff --git a/ui/cocoa.m b/ui/cocoa.m
index d0a4ef4cbc4c..e57c8ac2369e 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -22,6 +22,8 @@
  * THE SOFTWARE.
  */
 
+#define GL_SILENCE_DEPRECATION
+
 #include "qemu/osdep.h"
 
 #import <Cocoa/Cocoa.h>
@@ -47,6 +49,10 @@
 #include <Carbon/Carbon.h>
 #include "hw/core/cpu.h"
 
+#ifdef CONFIG_EGL
+#include "ui/egl-context.h"
+#endif
+
 #ifndef MAC_OS_X_VERSION_10_13
 #define MAC_OS_X_VERSION_10_13 101300
 #endif
@@ -70,6 +76,14 @@
 
 #define cgrect(nsrect) (*(CGRect *)&(nsrect))
 
+typedef struct CocoaListener {
+    DisplayChangeListener dcl;
+#ifdef CONFIG_OPENGL
+    uint32_t gl_scanout_id;
+    bool gl_scanout_y0_top;
+#endif
+} CocoaListener;
+
 typedef struct {
     int width;
     int height;
@@ -78,24 +92,16 @@
 @interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
 @end
 
-static void cocoa_update(DisplayChangeListener *dcl,
-                         int x, int y, int w, int h);
-
 static void cocoa_switch(DisplayChangeListener *dcl,
                          DisplaySurface *surface);
 
-static void cocoa_refresh(DisplayChangeListener *dcl);
-
 static NSWindow *normalWindow;
-static const DisplayChangeListenerOps dcl_ops = {
-    .dpy_name          = "cocoa",
-    .dpy_gfx_update = cocoa_update,
-    .dpy_gfx_switch = cocoa_switch,
-    .dpy_refresh = cocoa_refresh,
-};
-static DisplayChangeListener dcl = {
-    .ops = &dcl_ops,
-};
+static CocoaListener *active_listener;
+static CocoaListener *listeners;
+static size_t listeners_count;
+static DisplaySurface *surface;
+static QemuMutex surface_mutex;
+static QKbdState *kbd;
 static int cursor_hide = 1;
 static int left_command_key_enabled = 1;
 static bool swap_opt_cmd;
@@ -105,14 +111,47 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 
 static NSTextField *pauseLabel;
 
-static bool allow_events;
-
 static NSInteger cbchangecount = -1;
 static QemuClipboardInfo *cbinfo;
 static QemuClipboardPeer cbpeer;
 static QemuCocoaPasteboardTypeOwner *cbowner;
 static QemuEvent cbevent;
 
+#ifdef CONFIG_OPENGL
+
+static bool gl_surface_dirty;
+static QEMUGLContext view_ctx;
+
+#ifdef CONFIG_EGL
+static EGLSurface egl_surface;
+#endif
+
+static void cocoa_gl_switch(DisplayChangeListener *dcl,
+                            DisplaySurface *new_surface);
+
+static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
+                                       DisplayChangeListener *dcl);
+
+static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
+                                             QEMUGLParams *params);
+
+static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx);
+
+static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx);
+
+static const DisplayGLCtxOps dgc_ops = {
+    .dpy_gl_ctx_is_compatible_dcl = cocoa_gl_is_compatible_dcl,
+    .dpy_gl_ctx_create            = cocoa_gl_create_context,
+    .dpy_gl_ctx_destroy           = cocoa_gl_destroy_context,
+    .dpy_gl_ctx_make_current      = cocoa_gl_make_context_current,
+};
+
+static DisplayGLCtx dgc = {
+    .ops = &dgc_ops,
+};
+
+#endif
+
 // Utility functions to run specified code block with iothread lock held
 typedef void (^CodeBlock)(void);
 typedef bool (^BoolCodeBlock)(void);
@@ -167,7 +206,14 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
     qemu_main_loop();
     COCOA_DEBUG("Second thread: qemu_main_loop() returned, exiting\n");
     qemu_cleanup();
+    qkbd_state_free(kbd);
     [cbowner release];
+#ifdef CONFIG_OPENGL
+    qemu_gl_fini_shader(dgc.gls);
+    if (view_ctx) {
+        cocoa_gl_destroy_context(&dgc, view_ctx);
+    }
+#endif
     exit(0);
 }
 
@@ -208,13 +254,10 @@ @interface QemuCocoaView : NSView
 {
     NSTrackingArea *trackingArea;
     QEMUScreen screen;
-    pixman_image_t *pixman_image;
-    QKbdState *kbd;
     BOOL isMouseGrabbed;
     BOOL isAbsoluteEnabled;
     CFMachPortRef eventsTap;
 }
-- (void) switchSurface:(pixman_image_t *)image;
 - (void) grabMouse;
 - (void) ungrabMouse;
 - (void) setFullGrab:(id)sender;
@@ -232,7 +275,6 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
  */
 - (BOOL) isMouseGrabbed;
 - (BOOL) isAbsoluteEnabled;
-- (QEMUScreen) gscreen;
 @end
 
 QemuCocoaView *cocoaView;
@@ -260,7 +302,6 @@ - (id)initWithFrame:(NSRect)frameRect
 
         screen.width = frameRect.size.width;
         screen.height = frameRect.size.height;
-        kbd = qkbd_state_init(dcl.con);
 
     }
     return self;
@@ -270,12 +311,6 @@ - (void) dealloc
 {
     COCOA_DEBUG("QemuCocoaView: dealloc\n");
 
-    if (pixman_image) {
-        pixman_image_unref(pixman_image);
-    }
-
-    qkbd_state_free(kbd);
-
     if (eventsTap) {
         CFRelease(eventsTap);
     }
@@ -327,15 +362,29 @@ - (void) viewWillMoveToWindow:(NSWindow *)newWindow
 
 - (void) selectConsoleLocked:(unsigned int)index
 {
-    QemuConsole *con = qemu_console_lookup_by_index(index);
-    if (!con) {
+    DisplaySurface *new_surface;
+
+    if (index >= listeners_count) {
         return;
     }
 
-    unregister_displaychangelistener(&dcl);
-    dcl.con = con;
-    register_displaychangelistener(&dcl);
-    [self updateUIInfo];
+    active_listener = &listeners[index];
+    new_surface = qemu_console_surface(active_listener->dcl.con);
+    qkbd_state_lift_all_keys(kbd);
+    qkbd_state_free(kbd);
+    kbd = qkbd_state_init(active_listener->dcl.con);
+
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        cocoa_gl_switch(&active_listener->dcl, new_surface);
+#else
+        g_assert_not_reached();
+#endif
+    } else {
+        cocoa_switch(&active_listener->dcl, new_surface);
+    }
+
+    [self updateUIInfoLocked];
 }
 
 - (void) hideCursor
@@ -358,26 +407,35 @@ - (void) drawRect:(NSRect) rect
 {
     COCOA_DEBUG("QemuCocoaView: drawRect\n");
 
+#ifdef CONFIG_OPENGL
+    if (display_opengl) {
+        return;
+    }
+#endif
+
     // get CoreGraphic context
     CGContextRef viewContextRef = [[NSGraphicsContext currentContext] CGContext];
 
     CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
     CGContextSetShouldAntialias (viewContextRef, NO);
 
+    qemu_mutex_lock(&surface_mutex);
+
     // draw screen bitmap directly to Core Graphics context
-    if (!pixman_image) {
+    if (!surface) {
         // Draw request before any guest device has set up a framebuffer:
         // just draw an opaque black rectangle
         CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
         CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
     } else {
-        int w = pixman_image_get_width(pixman_image);
-        int h = pixman_image_get_height(pixman_image);
-        int bitsPerPixel = PIXMAN_FORMAT_BPP(pixman_image_get_format(pixman_image));
-        int stride = pixman_image_get_stride(pixman_image);
+        int w = surface_width(surface);
+        int h = surface_height(surface);
+        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(surface));
+        int stride = surface_stride(surface);
+
         CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
             NULL,
-            pixman_image_get_data(pixman_image),
+            surface_data(surface),
             stride * h,
             NULL
         );
@@ -418,6 +476,8 @@ - (void) drawRect:(NSRect) rect
         CGImageRelease (imageRef);
         CGDataProviderRelease(dataProviderRef);
     }
+
+    qemu_mutex_unlock(&surface_mutex);
 }
 
 - (NSSize) computeUnzoomedSize
@@ -465,10 +525,6 @@ - (void) updateUIInfoLocked
     NSSize frameSize;
     QemuUIInfo info = {};
 
-    if (!qemu_console_is_graphic(dcl.con)) {
-        return;
-    }
-
     if ([self window]) {
         NSDictionary *description = [[[self window] screen] deviceDescription];
         CGDirectDisplayID display = [[description objectForKey:@"NSScreenNumber"] unsignedIntValue];
@@ -492,12 +548,12 @@ - (void) updateUIInfoLocked
     info.width = frameBackingSize.width;
     info.height = frameBackingSize.height;
 
-    dpy_set_ui_info(dcl.con, &info, TRUE);
+    dpy_set_ui_info(active_listener->dcl.con, &info, TRUE);
 }
 
 - (void) updateUIInfo
 {
-    if (!allow_events) {
+    if (!listeners) {
         /*
          * Don't try to tell QEMU about UI information in the application
          * startup phase -- we haven't yet registered dcl with the QEMU UI
@@ -514,27 +570,16 @@ - (void) updateUIInfo
     });
 }
 
-- (void) switchSurface:(pixman_image_t *)image
+- (void) updateScreenWidth:(int)w height:(int)h
 {
-    COCOA_DEBUG("QemuCocoaView: switchSurface\n");
-
-    int w = pixman_image_get_width(image);
-    int h = pixman_image_get_height(image);
+    COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
 
     if (w != screen.width || h != screen.height) {
-        // Resize before we trigger the redraw, or we'll redraw at the wrong size
-        COCOA_DEBUG("switchSurface: new size %d x %d\n", w, h);
+        COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
         screen.width = w;
         screen.height = h;
         [self resizeWindow];
     }
-
-    // update screenBuffer
-    if (pixman_image) {
-        pixman_image_unref(pixman_image);
-    }
-
-    pixman_image = image;
 }
 
 - (void) setFullGrab:(id)sender
@@ -631,18 +676,13 @@ - (void) handleMonitorInput:(NSEvent *)event
     }
 
     if (keysym) {
-        kbd_put_keysym_console(dcl.con, keysym);
+        kbd_put_keysym_console(active_listener->dcl.con, keysym);
     }
 }
 
 - (bool) handleEvent:(NSEvent *)event
 {
-    if(!allow_events) {
-        /*
-         * Just let OSX have all events that arrive before
-         * applicationDidFinishLaunching.
-         * This may not be needed anymore?
-         */
+    if(!listeners) {
         return false;
     }
     return bool_with_iothread_lock(^{
@@ -832,7 +872,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                 }
             }
 
-            if (qemu_console_is_graphic(dcl.con)) {
+            if (qemu_console_is_graphic(active_listener->dcl.con)) {
                 qkbd_state_key_event(kbd, keycode, true);
             } else {
                 [self handleMonitorInput: event];
@@ -847,7 +887,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                 return true;
             }
 
-            if (qemu_console_is_graphic(dcl.con)) {
+            if (qemu_console_is_graphic(active_listener->dcl.con)) {
                 qkbd_state_key_event(kbd, keycode, false);
             }
             return true;
@@ -871,9 +911,9 @@ - (bool) handleEventLocked:(NSEvent *)event
                     INPUT_BUTTON_WHEEL_LEFT : INPUT_BUTTON_WHEEL_RIGHT;
                 }
 
-                qemu_input_queue_btn(dcl.con, buttons, true);
+                qemu_input_queue_btn(active_listener->dcl.con, buttons, true);
                 qemu_input_event_sync();
-                qemu_input_queue_btn(dcl.con, buttons, false);
+                qemu_input_queue_btn(active_listener->dcl.con, buttons, false);
                 qemu_input_event_sync();
             }
 
@@ -894,16 +934,18 @@ - (void) handleMouseEvent:(NSEvent *)event
     }
 
     with_iothread_lock(^{
+        QemuConsole *con = active_listener->dcl.con;
+
         if (isAbsoluteEnabled) {
             CGFloat d = (CGFloat)screen.height / [self frame].size.height;
             NSPoint p = [event locationInWindow];
             // Note that the origin for Cocoa mouse coords is bottom left, not top left.
-            qemu_input_queue_abs(dcl.con, INPUT_AXIS_X, p.x * d, 0, screen.width);
-            qemu_input_queue_abs(dcl.con, INPUT_AXIS_Y, screen.height - p.y * d, 0, screen.height);
+            qemu_input_queue_abs(con, INPUT_AXIS_X, p.x * d, 0, screen.width);
+            qemu_input_queue_abs(con, INPUT_AXIS_Y, screen.height - p.y * d, 0, screen.height);
         } else {
             CGFloat d = (CGFloat)screen.height / [self convertSizeToBacking:[self frame].size].height;
-            qemu_input_queue_rel(dcl.con, INPUT_AXIS_X, [event deltaX] * d);
-            qemu_input_queue_rel(dcl.con, INPUT_AXIS_Y, [event deltaY] * d);
+            qemu_input_queue_rel(con, INPUT_AXIS_X, [event deltaX] * d);
+            qemu_input_queue_rel(con, INPUT_AXIS_Y, [event deltaY] * d);
         }
 
         qemu_input_event_sync();
@@ -917,7 +959,7 @@ - (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool
     }
 
     with_iothread_lock(^{
-        qemu_input_queue_btn(dcl.con, button, down);
+        qemu_input_queue_btn(active_listener->dcl.con, button, down);
     });
 
     [self handleMouseEvent:event];
@@ -995,6 +1037,10 @@ - (void) grabMouse
 {
     COCOA_DEBUG("QemuCocoaView: grabMouse\n");
 
+    if (!listeners) {
+        return;
+    }
+
     if (qemu_name)
         [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
     else
@@ -1026,14 +1072,13 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
 }
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
 - (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
-- (QEMUScreen) gscreen {return screen;}
 
 - (void) raiseAllButtons
 {
     with_iothread_lock(^{
-        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_LEFT, false);
-        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_RIGHT, false);
-        qemu_input_queue_btn(dcl.con, INPUT_BUTTON_MIDDLE, false);
+        qemu_input_queue_btn(active_listener->dcl.con, INPUT_BUTTON_LEFT, false);
+        qemu_input_queue_btn(active_listener->dcl.con, INPUT_BUTTON_RIGHT, false);
+        qemu_input_queue_btn(active_listener->dcl.con, INPUT_BUTTON_MIDDLE, false);
     });
 }
 @end
@@ -1127,12 +1172,7 @@ - (void)applicationDidFinishLaunching: (NSNotification *) note
     QemuThread main_thread;
 
     COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
-    allow_events = true;
 
-    dcl.con = qemu_console_lookup_first_graphic_console();
-
-    // register vga output callbacks
-    register_displaychangelistener(&dcl);
     [cocoaView updateUIInfo];
 
     qemu_clipboard_peer_register(&cbpeer);
@@ -1617,18 +1657,17 @@ static void add_console_menu_entries(void)
 {
     NSMenu *menu;
     NSMenuItem *menuItem;
-    int index = 0;
+    size_t index;
 
     menu = [[[NSApp mainMenu] itemWithTitle:@"View"] submenu];
 
     [menu addItem:[NSMenuItem separatorItem]];
 
-    while (qemu_console_lookup_by_index(index) != NULL) {
-        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(qemu_console_lookup_by_index(index))
+    for (index = 0; index < listeners_count; index++) {
+        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(listeners[index].dcl.con)
                                                action: @selector(displayConsole:) keyEquivalent: @""] autorelease];
         [menuItem setTag: index];
         [menu addItem: menuItem];
-        index++;
     }
 }
 
@@ -1813,36 +1852,49 @@ int main(int argc, char **argv, char **envp)
 static void cocoa_update(DisplayChangeListener *dcl,
                          int x, int y, int w, int h)
 {
+    DisplaySurface *updated = surface;
+
+    if (container_of(dcl, CocoaListener, dcl) != active_listener) {
+        return;
+    }
+
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        CGFloat d = [cocoaView frame].size.height / (CGFloat)[cocoaView gscreen].height;
-
-        NSRect rect = NSMakeRect(
-                x * d,
-                ([cocoaView gscreen].height - y - h) * d,
-                w * d,
-                h * d);
+        qemu_mutex_lock(&surface_mutex);
+        if (updated != surface) {
+            qemu_mutex_unlock(&surface_mutex);
+            return;
+        }
+        int full_height = surface_height(surface);
+        qemu_mutex_unlock(&surface_mutex);
 
+        CGFloat d = [cocoaView frame].size.height / full_height;
+        NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
         [cocoaView setNeedsDisplayInRect:rect];
     });
 }
 
 static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *surface)
+                         DisplaySurface *new_surface)
 {
-    pixman_image_t *image = surface->image;
-
     COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
 
-    // The DisplaySurface will be freed as soon as this callback returns.
-    // We take a reference to the underlying pixman image here so it does
-    // not disappear from under our feet; the switchSurface method will
-    // deref the old image when it is done with it.
-    pixman_image_ref(image);
+    if (container_of(dcl, CocoaListener, dcl) != active_listener) {
+        return;
+    }
+
+    qemu_mutex_lock(&surface_mutex);
+    surface = new_surface;
+    qemu_mutex_unlock(&surface_mutex);
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        [cocoaView switchSurface:image];
+        qemu_mutex_lock(&surface_mutex);
+        int w = surface_width(surface);
+        int h = surface_height(surface);
+        qemu_mutex_unlock(&surface_mutex);
+
+        [cocoaView updateScreenWidth:w height:h];
     });
 }
 
@@ -1851,6 +1903,11 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
 
     COCOA_DEBUG("qemu_cocoa: cocoa_refresh\n");
+
+    if (container_of(dcl, CocoaListener, dcl) != active_listener) {
+        return;
+    }
+
     graphic_hw_update(dcl->con);
 
     if (qemu_input_is_absolute()) {
@@ -1878,11 +1935,258 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
     [pool release];
 }
 
+static const DisplayChangeListenerOps dcl_ops = {
+    .dpy_name          = "cocoa",
+    .dpy_gfx_update = cocoa_update,
+    .dpy_gfx_switch = cocoa_switch,
+    .dpy_refresh = cocoa_refresh,
+};
+
+#ifdef CONFIG_OPENGL
+
+static void with_view_ctx(CodeBlock block)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
+        block();
+        return;
+    }
+#endif
+
+    [(NSOpenGLContext *)view_ctx lock];
+    [(NSOpenGLContext *)view_ctx makeCurrentContext];
+    block();
+    [(NSOpenGLContext *)view_ctx unlock];
+}
+
+static NSOpenGLPixelFormat *cocoa_gl_create_ns_pixel_format(int bpp)
+{
+    NSOpenGLPixelFormatAttribute attributes[] = {
+        NSOpenGLPFAOpenGLProfile,
+        NSOpenGLProfileVersion4_1Core,
+        NSOpenGLPFAColorSize,
+        bpp,
+        NSOpenGLPFADoubleBuffer,
+        0,
+    };
+
+    return [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
+}
+
+static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        EGLSurface current_surface = ctx == EGL_NO_CONTEXT ? EGL_NO_SURFACE : egl_surface;
+        return eglMakeCurrent(qemu_egl_display, current_surface, current_surface, ctx);
+    }
+#endif
+
+    if (ctx) {
+        [(NSOpenGLContext *)ctx makeCurrentContext];
+    } else {
+        [NSOpenGLContext clearCurrentContext];
+    }
+
+    return 0;
+}
+
+static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
+                                             QEMUGLParams *params)
+{
+    NSOpenGLPixelFormat *format;
+    NSOpenGLContext *ctx;
+    int bpp;
+
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
+        return qemu_egl_create_context(dgc, params);
+    }
+#endif
+
+    bpp = PIXMAN_FORMAT_BPP(surface_format(surface));
+    format = cocoa_gl_create_ns_pixel_format(bpp);
+    ctx = [[NSOpenGLContext alloc] initWithFormat:format shareContext:view_ctx];
+    [format release];
+
+    return (QEMUGLContext)ctx;
+}
+
+static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglDestroyContext(qemu_egl_display, ctx);
+        return;
+    }
+#endif
+
+    [(NSOpenGLContext *)ctx release];
+}
+
+static void cocoa_gl_flush()
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglSwapBuffers(qemu_egl_display, egl_surface);
+        return;
+    }
+#endif
+
+    [[NSOpenGLContext currentContext] flushBuffer];
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [(NSOpenGLContext *)view_ctx update];
+    });
+}
+
+static void cocoa_gl_update(DisplayChangeListener *dcl,
+                            int x, int y, int w, int h)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    if (listener != active_listener || listener->gl_scanout_id) {
+        return;
+    }
+
+    with_view_ctx(^{
+        surface_gl_update_texture(dgc.gls, surface, x, y, w, h);
+        gl_surface_dirty = true;
+    });
+}
+
+static void cocoa_gl_switch(DisplayChangeListener *dcl,
+                            DisplaySurface *new_surface)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    if (listener != active_listener) {
+        return;
+    }
+
+    with_view_ctx(^{
+        surface_gl_destroy_texture(dgc.gls, surface);
+        surface_gl_create_texture(dgc.gls, new_surface);
+    });
+
+    cocoa_switch(dcl, new_surface);
+    gl_surface_dirty = true;
+}
+
+static void cocoa_gl_refresh(DisplayChangeListener *dcl)
+{
+    cocoa_refresh(dcl);
+
+    if (gl_surface_dirty) {
+        gl_surface_dirty = false;
+
+        with_view_ctx(^{
+            NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+
+            surface_gl_setup_viewport(dgc.gls, surface, size.width, size.height);
+            surface_gl_render_texture(dgc.gls, surface);
+            cocoa_gl_flush();
+        });
+    }
+}
+
+static void cocoa_gl_scanout_disable(DisplayChangeListener *dcl)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->gl_scanout_id = 0;
+
+    if (listener == active_listener && surface) {
+        with_view_ctx(^{
+            surface_gl_destroy_texture(dgc.gls, surface);
+            surface_gl_create_texture(dgc.gls, surface);
+        });
+
+        gl_surface_dirty = true;
+    }
+}
+
+static void cocoa_gl_scanout_texture(DisplayChangeListener *dcl,
+                                     uint32_t backing_id,
+                                     bool backing_y_0_top,
+                                     uint32_t backing_width,
+                                     uint32_t backing_height,
+                                     uint32_t x, uint32_t y,
+                                     uint32_t w, uint32_t h)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->gl_scanout_id = backing_id;
+    listener->gl_scanout_y0_top = backing_y_0_top;
+
+    if (listener == active_listener) {
+        gl_surface_dirty = false;
+    }
+}
+
+static void cocoa_gl_scanout_flush()
+{
+    if (!active_listener->gl_scanout_id) {
+        return;
+    }
+
+    with_view_ctx(^{
+        NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+
+        glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+        glViewport(0, 0, size.width, size.height);
+        glBindTexture(GL_TEXTURE_2D, active_listener->gl_scanout_id);
+        qemu_gl_run_texture_blit(dgc.gls, active_listener->gl_scanout_y0_top);
+        cocoa_gl_flush();
+    });
+}
+
+static void cocoa_gl_scanout_flush_proxy(DisplayChangeListener *dcl,
+                                         uint32_t x, uint32_t y,
+                                         uint32_t w, uint32_t h)
+{
+    if (container_of(dcl, CocoaListener, dcl) == active_listener) {
+        cocoa_gl_scanout_flush();
+    }
+}
+
+static const DisplayChangeListenerOps dcl_gl_ops = {
+    .dpy_name               = "cocoa-gl",
+    .dpy_gfx_update         = cocoa_gl_update,
+    .dpy_gfx_switch         = cocoa_gl_switch,
+    .dpy_gfx_check_format   = console_gl_check_format,
+    .dpy_refresh            = cocoa_gl_refresh,
+
+    .dpy_gl_scanout_disable = cocoa_gl_scanout_disable,
+    .dpy_gl_scanout_texture = cocoa_gl_scanout_texture,
+    .dpy_gl_update          = cocoa_gl_scanout_flush_proxy,
+};
+
+static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
+                                       DisplayChangeListener *dcl)
+{
+    return dcl->ops == &dcl_gl_ops;
+}
+
+#endif
+
+static void cocoa_display_early_init(DisplayOptions *o)
+{
+    assert(o->type == DISPLAY_TYPE_COCOA);
+    if (o->has_gl && o->gl) {
+        display_opengl = 1;
+    }
+}
+
 static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 {
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
     ProcessSerialNumber psn = { 0, kCurrentProcess };
     QemuCocoaAppController *appController;
+    const DisplayChangeListenerOps *ops;
+    size_t index;
 
     COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
     have_cocoa_ui = 1;
@@ -1893,6 +2197,84 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 
     [QemuApplication sharedApplication];
 
+    // Create an Application controller
+    appController = [[QemuCocoaAppController alloc] init];
+    [NSApp setDelegate:appController];
+
+    qemu_mutex_init(&surface_mutex);
+
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        if (opts->gl == DISPLAYGL_MODE_ES) {
+#ifdef CONFIG_EGL
+            if (qemu_egl_init_dpy_cocoa(DISPLAYGL_MODE_ES)) {
+                exit(1);
+            }
+            view_ctx = qemu_egl_init_ctx();
+            if (!view_ctx) {
+                exit(1);
+            }
+            [cocoaView setWantsLayer:YES];
+            egl_surface = qemu_egl_init_surface(view_ctx, [cocoaView layer]);
+            if (!egl_surface) {
+                exit(1);
+            }
+#else
+            error_report("OpenGLES without EGL is not supported - exiting");
+            exit(1);
+#endif
+        } else {
+            NSOpenGLPixelFormat *format = cocoa_gl_create_ns_pixel_format(32);
+            NSOpenGLView *view = [[NSOpenGLView alloc] initWithFrame:[cocoaView frame]
+                                                         pixelFormat:format];
+            [format release];
+            [cocoaView addSubview:view];
+            view_ctx = [view openGLContext];
+            [view release];
+#ifdef CONFIG_EGL
+            egl_surface = EGL_NO_SURFACE;
+#endif
+            cocoa_gl_make_context_current(&dgc, view_ctx);
+        }
+
+        dgc.gls = qemu_gl_init_shader();
+
+        // register vga output callbacks
+        ops = &dcl_gl_ops;
+#else
+        error_report("OpenGL is not enabled - exiting");
+        exit(1);
+#endif
+    } else {
+        // register vga output callbacks
+        ops = &dcl_ops;
+    }
+
+    while (qemu_console_lookup_by_index(listeners_count)) {
+        listeners_count++;
+    }
+
+    if (listeners_count) {
+        QemuConsole *con = qemu_console_lookup_first_graphic_console();
+        listeners = g_new0(CocoaListener, listeners_count);
+        active_listener = listeners + qemu_console_get_index(con);
+
+        for (index = 0; index < listeners_count; index++) {
+            listeners[index].dcl.con = qemu_console_lookup_by_index(index);
+            listeners[index].dcl.ops = ops;
+
+            if (display_opengl) {
+                qemu_console_set_display_gl_ctx(listeners[index].dcl.con,
+                                                &dgc);
+            }
+
+            // register vga output callbacks
+            register_displaychangelistener(&listeners[index].dcl);
+        }
+
+        kbd = qkbd_state_init(active_listener->dcl.con);
+    }
+
     create_initial_menus();
 
     /*
@@ -1908,10 +2290,6 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
     qemu_event_init(&cbevent, false);
     cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
 
-    // Create an Application controller
-    appController = [[QemuCocoaAppController alloc] init];
-    [NSApp setDelegate:appController];
-
     if (opts->has_full_screen && opts->full_screen) {
         full_screen = 1;
     }
@@ -1935,6 +2313,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 
 static QemuDisplay qemu_display_cocoa = {
     .type       = DISPLAY_TYPE_COCOA,
+    .early_init = cocoa_display_early_init,
     .init       = cocoa_display_init,
 };
 
@@ -1944,3 +2323,7 @@ static void register_cocoa(void)
 }
 
 type_init(register_cocoa);
+
+#ifdef CONFIG_OPENGL
+module_dep("ui-opengl");
+#endif
diff --git a/ui/console.c b/ui/console.c
index 7ba37a552ef6..d69f799e4db4 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -2440,12 +2440,7 @@ void qemu_console_resize(QemuConsole *s, int width, int height)
 
 DisplaySurface *qemu_console_surface(QemuConsole *console)
 {
-    switch (console->scanout.kind) {
-    case SCANOUT_SURFACE:
-        return console->surface;
-    default:
-        return NULL;
-    }
+    return console->surface;
 }
 
 PixelFormat qemu_default_pixelformat(int bpp)
diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index 3a88245b6780..f5d9370a9603 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -334,7 +334,7 @@ void egl_dmabuf_create_fence(QemuDmaBuf *dmabuf)
 
 /* ---------------------------------------------------------------------- */
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win)
 {
     EGLSurface esurface;
     EGLBoolean b;
@@ -358,6 +358,70 @@ EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
 
 /* ---------------------------------------------------------------------- */
 
+static int qemu_egl_init_dpy(EGLDisplay dpy, DisplayGLMode mode)
+{
+    static const EGLint conf_att_core[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
+        EGL_RED_SIZE,   5,
+        EGL_GREEN_SIZE, 5,
+        EGL_BLUE_SIZE,  5,
+        EGL_ALPHA_SIZE, 0,
+        EGL_NONE,
+    };
+    static const EGLint conf_att_gles[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_RED_SIZE,   5,
+        EGL_GREEN_SIZE, 5,
+        EGL_BLUE_SIZE,  5,
+        EGL_ALPHA_SIZE, 0,
+        EGL_NONE,
+    };
+    EGLint major, minor;
+    EGLBoolean b;
+    EGLint n;
+    bool gles = (mode == DISPLAYGL_MODE_ES);
+
+    qemu_egl_display = dpy;
+
+    b = eglInitialize(qemu_egl_display, &major, &minor);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglInitialize failed");
+        return -1;
+    }
+
+    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglBindAPI failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    b = eglChooseConfig(qemu_egl_display,
+                        gles ? conf_att_gles : conf_att_core,
+                        &qemu_egl_config, 1, &n);
+    if (b == EGL_FALSE || n != 1) {
+        error_report("egl: eglChooseConfig failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    qemu_egl_mode = gles ? DISPLAYGL_MODE_ES : DISPLAYGL_MODE_CORE;
+    return 0;
+}
+
+int qemu_egl_init_dpy_cocoa(DisplayGLMode mode)
+{
+    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (dpy == EGL_NO_DISPLAY) {
+        error_report("egl: eglGetDisplay failed");
+        return -1;
+    }
+
+    return qemu_egl_init_dpy(dpy, mode);
+}
+
 #if defined(CONFIG_X11) || defined(CONFIG_GBM)
 
 /*
@@ -388,8 +452,9 @@ EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
  * platform extensions (EGL_KHR_platform_gbm and friends) yet it doesn't seem
  * like mesa will be able to advertise these (even though it can do EGL 1.5).
  */
-static EGLDisplay qemu_egl_get_display(EGLNativeDisplayType native,
-                                       EGLenum platform)
+static int qemu_egl_init_dpy_platform(EGLNativeDisplayType native,
+                                      EGLenum platform,
+                                      DisplayGLMode mode)
 {
     EGLDisplay dpy = EGL_NO_DISPLAY;
 
@@ -406,83 +471,30 @@ static EGLDisplay qemu_egl_get_display(EGLNativeDisplayType native,
         /* fallback */
         dpy = eglGetDisplay(native);
     }
-    return dpy;
-}
 
-static int qemu_egl_init_dpy(EGLNativeDisplayType dpy,
-                             EGLenum platform,
-                             DisplayGLMode mode)
-{
-    static const EGLint conf_att_core[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
-        EGL_RED_SIZE,   5,
-        EGL_GREEN_SIZE, 5,
-        EGL_BLUE_SIZE,  5,
-        EGL_ALPHA_SIZE, 0,
-        EGL_NONE,
-    };
-    static const EGLint conf_att_gles[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE,   5,
-        EGL_GREEN_SIZE, 5,
-        EGL_BLUE_SIZE,  5,
-        EGL_ALPHA_SIZE, 0,
-        EGL_NONE,
-    };
-    EGLint major, minor;
-    EGLBoolean b;
-    EGLint n;
-    bool gles = (mode == DISPLAYGL_MODE_ES);
-
-    qemu_egl_display = qemu_egl_get_display(dpy, platform);
-    if (qemu_egl_display == EGL_NO_DISPLAY) {
+    if (dpy == EGL_NO_DISPLAY) {
         error_report("egl: eglGetDisplay failed");
         return -1;
     }
 
-    b = eglInitialize(qemu_egl_display, &major, &minor);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglInitialize failed");
-        return -1;
-    }
-
-    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglBindAPI failed (%s mode)",
-                     gles ? "gles" : "core");
-        return -1;
-    }
-
-    b = eglChooseConfig(qemu_egl_display,
-                        gles ? conf_att_gles : conf_att_core,
-                        &qemu_egl_config, 1, &n);
-    if (b == EGL_FALSE || n != 1) {
-        error_report("egl: eglChooseConfig failed (%s mode)",
-                     gles ? "gles" : "core");
-        return -1;
-    }
-
-    qemu_egl_mode = gles ? DISPLAYGL_MODE_ES : DISPLAYGL_MODE_CORE;
-    return 0;
+    return qemu_egl_init_dpy(dpy, mode);
 }
 
 int qemu_egl_init_dpy_x11(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_KHR_platform_x11
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_X11_KHR, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_X11_KHR, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 
 int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_MESA_platform_gbm
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_GBM_MESA, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_GBM_MESA, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 
diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
index b5bffbab2522..d187cc6009a9 100644
--- a/ui/gtk-egl.c
+++ b/ui/gtk-egl.c
@@ -54,7 +54,7 @@ void gd_egl_init(VirtualConsole *vc)
     }
 
     vc->gfx.ectx = qemu_egl_init_ctx();
-    vc->gfx.esurface = qemu_egl_init_surface_x11
+    vc->gfx.esurface = qemu_egl_init_surface
         (vc->gfx.ectx, (EGLNativeWindowType)x11_window);
 
     assert(vc->gfx.esurface);
diff --git a/ui/gtk.c b/ui/gtk.c
index 08f43dc3d378..e8aef1db48f0 100644
--- a/ui/gtk.c
+++ b/ui/gtk.c
@@ -342,7 +342,7 @@ static void gd_update_full_redraw(VirtualConsole *vc)
     int ww, wh;
     ww = gdk_window_get_width(gtk_widget_get_window(area));
     wh = gdk_window_get_height(gtk_widget_get_window(area));
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.gls && gtk_use_gl_area) {
         gtk_gl_area_queue_render(GTK_GL_AREA(vc->gfx.drawing_area));
         return;
@@ -561,7 +561,7 @@ static const DisplayChangeListenerOps dcl_ops = {
 };
 
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 
 static bool gd_has_dmabuf(DisplayChangeListener *dcl)
 {
@@ -663,7 +663,7 @@ static const DisplayGLCtxOps egl_ctx_ops = {
 };
 #endif
 
-#endif /* CONFIG_OPENGL */
+#endif /* defined(CONFIG_OPENGL) && defined(CONFIG_EGL) */
 
 /** QEMU Events **/
 
@@ -729,7 +729,7 @@ static void gd_set_ui_size(VirtualConsole *vc, gint width, gint height)
     dpy_set_ui_info(vc->gfx.dcl.con, &info, true);
 }
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 
 static gboolean gd_render_event(GtkGLArea *area, GdkGLContext *context,
                                 void *opaque)
@@ -783,7 +783,7 @@ static gboolean gd_draw_event(GtkWidget *widget, cairo_t *cr, void *opaque)
     int ww, wh;
     int fbw, fbh;
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.gls) {
         if (gtk_use_gl_area) {
             /* invoke render callback please */
@@ -1304,7 +1304,7 @@ static gboolean gd_tab_window_close(GtkWidget *widget, GdkEvent *event,
                                     vc->tab_item, vc->label);
     gtk_widget_destroy(vc->window);
     vc->window = NULL;
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.esurface) {
         eglDestroySurface(qemu_egl_display, vc->gfx.esurface);
         vc->gfx.esurface = NULL;
@@ -1343,7 +1343,7 @@ static void gd_menu_untabify(GtkMenuItem *item, void *opaque)
     if (!vc->window) {
         gtk_widget_set_sensitive(vc->menu_item, false);
         vc->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         if (vc->gfx.esurface) {
             eglDestroySurface(qemu_egl_display, vc->gfx.esurface);
             vc->gfx.esurface = NULL;
@@ -1947,7 +1947,7 @@ static void gd_connect_vc_gfx_signals(VirtualConsole *vc)
 {
     g_signal_connect(vc->gfx.drawing_area, "draw",
                      G_CALLBACK(gd_draw_event), vc);
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (gtk_use_gl_area) {
         /* wire up GtkGlArea events */
         g_signal_connect(vc->gfx.drawing_area, "render",
@@ -2061,7 +2061,7 @@ static GtkWidget *gd_create_menu_machine(GtkDisplayState *s)
     return machine_menu;
 }
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 static void gl_area_realize(GtkGLArea *area, VirtualConsole *vc)
 {
     gtk_gl_area_make_current(area);
@@ -2084,7 +2084,7 @@ static GSList *gd_vc_gfx_init(GtkDisplayState *s, VirtualConsole *vc,
     vc->gfx.scale_x = 1.0;
     vc->gfx.scale_y = 1.0;
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (display_opengl) {
         if (gtk_use_gl_area) {
             vc->gfx.drawing_area = gtk_gl_area_new();
@@ -2417,7 +2417,7 @@ static void early_gtk_display_init(DisplayOptions *opts)
 
     assert(opts->type == DISPLAY_TYPE_GTK);
     if (opts->has_gl && opts->gl != DISPLAYGL_MODE_OFF) {
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 #if defined(GDK_WINDOWING_WAYLAND)
         if (GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
             gtk_use_gl_area = true;
@@ -2453,6 +2453,6 @@ static void register_gtk(void)
 
 type_init(register_gtk);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 module_dep("ui-opengl");
 #endif
diff --git a/ui/meson.build b/ui/meson.build
index 64286ba1503a..0b702e701673 100644
--- a/ui/meson.build
+++ b/ui/meson.build
@@ -57,13 +57,15 @@ if config_host.has_key('CONFIG_OPENGL')
   opengl_ss = ss.source_set()
   opengl_ss.add(gbm)
   opengl_ss.add(when: [opengl, pixman, 'CONFIG_OPENGL'],
-               if_true: files('shader.c', 'console-gl.c', 'egl-helpers.c', 'egl-context.c'))
+               if_true: files('shader.c', 'console-gl.c'))
+  opengl_ss.add(when: [opengl, pixman, 'CONFIG_OPENGL', 'CONFIG_EGL'],
+               if_true: files('egl-helpers.c', 'egl-context.c'))
   ui_modules += {'opengl' : opengl_ss}
 endif
 
 if config_host.has_key('CONFIG_OPENGL') and gbm.found()
   egl_headless_ss = ss.source_set()
-  egl_headless_ss.add(when: [opengl, gbm, pixman, 'CONFIG_OPENGL'],
+  egl_headless_ss.add(when: [opengl, gbm, pixman, 'CONFIG_OPENGL', 'CONFIG_EGL'],
                       if_true: files('egl-headless.c'))
   ui_modules += {'egl-headless' : egl_headless_ss}
 endif
@@ -98,8 +100,10 @@ if gtk.found()
   gtk_ss = ss.source_set()
   gtk_ss.add(gtk, vte, pixman, files('gtk.c', 'gtk-clipboard.c'))
   gtk_ss.add(when: x11, if_true: files('x_keymap.c'))
-  gtk_ss.add(when: [opengl, 'CONFIG_OPENGL'], if_true: files('gtk-gl-area.c'))
-  gtk_ss.add(when: [x11, opengl, 'CONFIG_OPENGL'], if_true: files('gtk-egl.c'))
+  gtk_ss.add(when: [opengl, 'CONFIG_OPENGL', 'CONFIG_EGL'],
+             if_true: files('gtk-gl-area.c'))
+  gtk_ss.add(when: [x11, opengl, 'CONFIG_OPENGL', 'CONFIG_EGL'],
+             if_true: files('gtk-egl.c'))
   ui_modules += {'gtk' : gtk_ss}
 endif
 
@@ -112,7 +116,7 @@ if sdl.found()
     'sdl2-input.c',
     'sdl2.c',
   ))
-  sdl_ss.add(when: [opengl, 'CONFIG_OPENGL'], if_true: files('sdl2-gl.c'))
+  sdl_ss.add(when: [opengl, 'CONFIG_OPENGL', 'CONFIG_EGL'], if_true: files('sdl2-gl.c'))
   sdl_ss.add(when: x11, if_true: files('x_keymap.c'))
   ui_modules += {'sdl' : sdl_ss}
 endif
diff --git a/ui/sdl2.c b/ui/sdl2.c
index d3741f9b754d..3ccb50fd6ee0 100644
--- a/ui/sdl2.c
+++ b/ui/sdl2.c
@@ -86,7 +86,7 @@ void sdl2_window_create(struct sdl2_console *scon)
     if (scon->hidden) {
         flags |= SDL_WINDOW_HIDDEN;
     }
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (scon->opengl) {
         flags |= SDL_WINDOW_OPENGL;
     }
@@ -130,7 +130,7 @@ void sdl2_window_resize(struct sdl2_console *scon)
 static void sdl2_redraw(struct sdl2_console *scon)
 {
     if (scon->opengl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         sdl2_gl_redraw(scon);
 #endif
     } else {
@@ -773,7 +773,7 @@ static const DisplayChangeListenerOps dcl_2d_ops = {
     .dpy_cursor_define    = sdl_mouse_define,
 };
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 static const DisplayChangeListenerOps dcl_gl_ops = {
     .dpy_name                = "sdl2-gl",
     .dpy_gfx_update          = sdl2_gl_update,
@@ -807,7 +807,7 @@ static void sdl2_display_early_init(DisplayOptions *o)
 {
     assert(o->type == DISPLAY_TYPE_SDL);
     if (o->has_gl && o->gl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         display_opengl = 1;
 #endif
     }
@@ -873,7 +873,7 @@ static void sdl2_display_init(DisplayState *ds, DisplayOptions *o)
         }
         sdl2_console[i].idx = i;
         sdl2_console[i].opts = o;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         sdl2_console[i].opengl = display_opengl;
         sdl2_console[i].dcl.ops = display_opengl ? &dcl_gl_ops : &dcl_2d_ops;
         sdl2_console[i].dgc.ops = display_opengl ? &gl_ctx_ops : NULL;
@@ -942,6 +942,6 @@ static void register_sdl1(void)
 
 type_init(register_sdl1);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 module_dep("ui-opengl");
 #endif
diff --git a/ui/shader.c b/ui/shader.c
index ab448c41d4c6..c5c9f754cc8f 100644
--- a/ui/shader.c
+++ b/ui/shader.c
@@ -152,11 +152,19 @@ static GLuint qemu_gl_create_compile_link_program(const GLchar *vert_src,
 QemuGLShader *qemu_gl_init_shader(void)
 {
     QemuGLShader *gls = g_new0(QemuGLShader, 1);
-
+    const char *header = epoxy_is_desktop_gl() ? "#version 140\n" : "#version 300 es\n";
+    char vert_src[256];
+    char frag_src[256];
+    char *vert_src_body = stpcpy(vert_src, header);
+    char *frag_src_body = stpcpy(frag_src, header);
+
+    strcpy(vert_src_body, texture_blit_vert_src);
+    strcpy(frag_src_body, texture_blit_frag_src);
     gls->texture_blit_prog = qemu_gl_create_compile_link_program
-        (texture_blit_vert_src, texture_blit_frag_src);
+        (vert_src, frag_src);
+    strcpy(vert_src_body, texture_blit_flip_vert_src);
     gls->texture_blit_flip_prog = qemu_gl_create_compile_link_program
-        (texture_blit_flip_vert_src, texture_blit_frag_src);
+        (vert_src, frag_src);
     if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog) {
         exit(1);
     }
diff --git a/ui/shader/texture-blit-flip.vert b/ui/shader/texture-blit-flip.vert
index ba081fa5a6c3..1e4ac4c94747 100644
--- a/ui/shader/texture-blit-flip.vert
+++ b/ui/shader/texture-blit-flip.vert
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 in vec2  in_position;
 out vec2 ex_tex_coord;
 
diff --git a/ui/shader/texture-blit.frag b/ui/shader/texture-blit.frag
index bfa202c22b01..bd296a2ffbf5 100644
--- a/ui/shader/texture-blit.frag
+++ b/ui/shader/texture-blit.frag
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 uniform sampler2D image;
 in  mediump vec2 ex_tex_coord;
 out mediump vec4 out_frag_color;
diff --git a/ui/shader/texture-blit.vert b/ui/shader/texture-blit.vert
index 6fe2744d6849..ae205f637782 100644
--- a/ui/shader/texture-blit.vert
+++ b/ui/shader/texture-blit.vert
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 in vec2  in_position;
 out vec2 ex_tex_coord;
 

From 9e453756020f264844d88b9b6b1043320ed63a35 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 18 Feb 2021 12:57:48 +0900
Subject: [PATCH 158/180] ui/cocoa: Take refresh rate into account

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 meson.build |  3 ++-
 ui/cocoa.m  | 11 +++++++++++
 2 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/meson.build b/meson.build
index bacb0093e8b1..eb518cabefb6 100644
--- a/meson.build
+++ b/meson.build
@@ -517,7 +517,8 @@ if get_option('attr').allowed()
   endif
 endif
 
-cocoa = dependency('appleframeworks', modules: 'Cocoa', required: get_option('cocoa'))
+cocoa = dependency('appleframeworks', modules: ['Cocoa', 'CoreVideo'],
+                   required: get_option('cocoa'))
 if cocoa.found() and get_option('sdl').enabled()
   error('Cocoa and SDL cannot be enabled at the same time')
 endif
diff --git a/ui/cocoa.m b/ui/cocoa.m
index e57c8ac2369e..d8fc09954f51 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -530,6 +530,7 @@ - (void) updateUIInfoLocked
         CGDirectDisplayID display = [[description objectForKey:@"NSScreenNumber"] unsignedIntValue];
         NSSize screenSize = [[[self window] screen] frame].size;
         CGSize screenPhysicalSize = CGDisplayScreenSize(display);
+        CVDisplayLinkRef displayLink;
 
         if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) == 0) {
             frameSize = [self frame].size;
@@ -537,6 +538,16 @@ - (void) updateUIInfoLocked
             frameSize = screenSize;
         }
 
+        if (!CVDisplayLinkCreateWithCGDisplay(display, &displayLink)) {
+            CVTime period = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink);
+            CVDisplayLinkRelease(displayLink);
+            if (!(period.flags & kCVTimeIsIndefinite)) {
+                update_displaychangelistener(&active_listener->dcl,
+                                             1000 * period.timeValue / period.timeScale);
+                info.refresh_rate = (int64_t)1000 * period.timeScale / period.timeValue;
+            }
+        }
+
         info.width_mm = frameSize.width / screenSize.width * screenPhysicalSize.width;
         info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
     } else {

From b3ebe68e23f69dc80682ad0b4fe61acfed3ecfba Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 18 Feb 2021 18:37:15 +0900
Subject: [PATCH 159/180] ui/cocoa: Update cursor

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa.m | 342 ++++++++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 296 insertions(+), 46 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index d8fc09954f51..6ab7f8c1820c 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -78,6 +78,10 @@
 
 typedef struct CocoaListener {
     DisplayChangeListener dcl;
+    QEMUCursor *cursor;
+    int mouse_x;
+    int mouse_y;
+    int mouse_on;
 #ifdef CONFIG_OPENGL
     uint32_t gl_scanout_id;
     bool gl_scanout_y0_top;
@@ -95,12 +99,15 @@ @interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
 static void cocoa_switch(DisplayChangeListener *dcl,
                          DisplaySurface *surface);
 
+static void cocoa_cursor_update(void);
+
 static NSWindow *normalWindow;
 static CocoaListener *active_listener;
 static CocoaListener *listeners;
 static size_t listeners_count;
 static DisplaySurface *surface;
-static QemuMutex surface_mutex;
+static QemuMutex draw_mutex;
+static CGImageRef cursor_cgimage;
 static QKbdState *kbd;
 static int cursor_hide = 1;
 static int left_command_key_enabled = 1;
@@ -119,7 +126,8 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 
 #ifdef CONFIG_OPENGL
 
-static bool gl_surface_dirty;
+static GLuint cursor_texture;
+static bool gl_dirty;
 static QEMUGLContext view_ctx;
 
 #ifdef CONFIG_EGL
@@ -129,6 +137,8 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 static void cocoa_gl_switch(DisplayChangeListener *dcl,
                             DisplaySurface *new_surface);
 
+static void cocoa_gl_cursor_update(void);
+
 static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
                                        DisplayChangeListener *dcl);
 
@@ -208,6 +218,7 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
     qemu_cleanup();
     qkbd_state_free(kbd);
     [cbowner release];
+    CGImageRelease(cursor_cgimage);
 #ifdef CONFIG_OPENGL
     qemu_gl_fini_shader(dgc.gls);
     if (view_ctx) {
@@ -245,6 +256,20 @@ static void handleAnyDeviceErrors(Error * err)
     }
 }
 
+static CGRect compute_cursor_clip_rect(int screen_height,
+                                       int given_mouse_x, int given_mouse_y,
+                                       int cursor_width, int cursor_height)
+{
+    CGRect rect;
+
+    rect.origin.x = MAX(0, -given_mouse_x);
+    rect.origin.y = 0;
+    rect.size.width = MIN(cursor_width, cursor_width + given_mouse_x);
+    rect.size.height = cursor_height - rect.origin.x;
+
+    return rect;
+}
+
 /*
  ------------------------------------------------------
     QemuCocoaView
@@ -376,11 +401,13 @@ - (void) selectConsoleLocked:(unsigned int)index
 
     if (display_opengl) {
 #ifdef CONFIG_OPENGL
+        cocoa_gl_cursor_update();
         cocoa_gl_switch(&active_listener->dcl, new_surface);
 #else
         g_assert_not_reached();
 #endif
     } else {
+        cocoa_cursor_update();
         cocoa_switch(&active_listener->dcl, new_surface);
     }
 
@@ -403,6 +430,21 @@ - (void) unhideCursor
     [NSCursor unhide];
 }
 
+- (CGRect) convertCursorClipRectToDraw:(CGRect)rect
+                          screenHeight:(int)screen_height
+                                mouseX:(int)given_mouse_x
+                                mouseY:(int)given_mouse_y
+{
+    CGFloat d = [self frame].size.height / (CGFloat)screen_height;
+
+    rect.origin.x = (rect.origin.x + given_mouse_x) * d;
+    rect.origin.y = (screen_height - rect.origin.y - given_mouse_y - rect.size.height) * d;
+    rect.size.width *= d;
+    rect.size.height *= d;
+
+    return rect;
+}
+
 - (void) drawRect:(NSRect) rect
 {
     COCOA_DEBUG("QemuCocoaView: drawRect\n");
@@ -419,7 +461,7 @@ - (void) drawRect:(NSRect) rect
     CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
     CGContextSetShouldAntialias (viewContextRef, NO);
 
-    qemu_mutex_lock(&surface_mutex);
+    qemu_mutex_lock(&draw_mutex);
 
     // draw screen bitmap directly to Core Graphics context
     if (!surface) {
@@ -475,9 +517,29 @@ - (void) drawRect:(NSRect) rect
         }
         CGImageRelease (imageRef);
         CGDataProviderRelease(dataProviderRef);
+
+        if (active_listener->mouse_on) {
+            size_t cursor_width = CGImageGetWidth(cursor_cgimage);
+            size_t cursor_height = CGImageGetHeight(cursor_cgimage);
+            int mouse_x = active_listener->mouse_x;
+            int mouse_y = active_listener->mouse_y;
+            clipRect = compute_cursor_clip_rect(h, mouse_x, mouse_y,
+                                                cursor_width,
+                                                cursor_height);
+            CGRect drawRect = [self convertCursorClipRectToDraw:clipRect
+                                                   screenHeight:h
+                                                         mouseX:mouse_x
+                                                         mouseY:mouse_y];
+            clipImageRef = CGImageCreateWithImageInRect(
+                                                        cursor_cgimage,
+                                                        clipRect
+                                                        );
+            CGContextDrawImage(viewContextRef, drawRect, clipImageRef);
+            CGImageRelease (clipImageRef);
+        }
     }
 
-    qemu_mutex_unlock(&surface_mutex);
+    qemu_mutex_unlock(&draw_mutex);
 }
 
 - (NSSize) computeUnzoomedSize
@@ -1872,13 +1934,13 @@ static void cocoa_update(DisplayChangeListener *dcl,
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&surface_mutex);
+        qemu_mutex_lock(&draw_mutex);
         if (updated != surface) {
-            qemu_mutex_unlock(&surface_mutex);
+            qemu_mutex_unlock(&draw_mutex);
             return;
         }
         int full_height = surface_height(surface);
-        qemu_mutex_unlock(&surface_mutex);
+        qemu_mutex_unlock(&draw_mutex);
 
         CGFloat d = [cocoaView frame].size.height / full_height;
         NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
@@ -1895,15 +1957,15 @@ static void cocoa_switch(DisplayChangeListener *dcl,
         return;
     }
 
-    qemu_mutex_lock(&surface_mutex);
+    qemu_mutex_lock(&draw_mutex);
     surface = new_surface;
-    qemu_mutex_unlock(&surface_mutex);
+    qemu_mutex_unlock(&draw_mutex);
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&surface_mutex);
+        qemu_mutex_lock(&draw_mutex);
         int w = surface_width(surface);
         int h = surface_height(surface);
-        qemu_mutex_unlock(&surface_mutex);
+        qemu_mutex_unlock(&draw_mutex);
 
         [cocoaView updateScreenWidth:w height:h];
     });
@@ -1946,11 +2008,136 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
     [pool release];
 }
 
+static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    qemu_mutex_lock(&draw_mutex);
+    int full_height = surface_height(surface);
+    int old_x = listener->mouse_x;
+    int old_y = listener->mouse_y;
+    listener->mouse_x = x;
+    listener->mouse_y = y;
+    listener->mouse_on = on;
+    qemu_mutex_unlock(&draw_mutex);
+
+    if (listener == active_listener && cursor_cgimage) {
+        size_t cursor_width = CGImageGetWidth(cursor_cgimage);
+        size_t cursor_height = CGImageGetHeight(cursor_cgimage);
+
+        dispatch_async(dispatch_get_main_queue(), ^{
+            CGRect clip_rect = compute_cursor_clip_rect(full_height,
+                                                        old_x, old_y,
+                                                        cursor_width,
+                                                        cursor_height);
+            CGRect draw_rect =
+                [cocoaView convertCursorClipRectToDraw:clip_rect
+                                          screenHeight:full_height
+                                                mouseX:old_x
+                                                mouseY:old_y];
+            [cocoaView setNeedsDisplayInRect:draw_rect];
+
+            clip_rect = compute_cursor_clip_rect(full_height, x, y,
+                                                        cursor_width,
+                                                        cursor_height);
+            draw_rect =
+                [cocoaView convertCursorClipRectToDraw:clip_rect
+                                          screenHeight:full_height
+                                                mouseX:x
+                                                mouseY:y];
+            [cocoaView setNeedsDisplayInRect:draw_rect];
+        });
+    }
+}
+
+static void cocoa_cursor_update()
+{
+    CGImageRef old_image = cursor_cgimage;
+    CGImageRef new_image;
+
+    if (active_listener->cursor) {
+        CGDataProviderRef provider = CGDataProviderCreateWithData(
+            NULL,
+            active_listener->cursor->data,
+            active_listener->cursor->width * active_listener->cursor->height * 4,
+            NULL
+        );
+
+        new_image = CGImageCreate(
+            active_listener->cursor->width, //width
+            active_listener->cursor->height, //height
+            8, //bitsPerComponent
+            32, //bitsPerPixel
+            active_listener->cursor->width * 4, //bytesPerRow
+            CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
+            kCGBitmapByteOrder32Little | kCGImageAlphaFirst, //bitmapInfo
+            provider, //provider
+            NULL, //decode
+            0, //interpolate
+            kCGRenderingIntentDefault //intent
+        );
+
+        CGDataProviderRelease(provider);
+    } else {
+        new_image = NULL;
+    }
+
+    qemu_mutex_lock(&draw_mutex);
+    cursor_cgimage = new_image;
+    qemu_mutex_unlock(&draw_mutex);
+
+    CGImageRelease(old_image);
+}
+
+static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->cursor = cursor;
+
+    if (listener == active_listener) {
+        int full_height = surface_height(surface);
+        int width = cursor->width;
+        int height = cursor->height;
+        int x = listener->mouse_x;
+        int y = listener->mouse_y;
+        size_t old_width;
+        size_t old_height;
+
+        if (cursor_cgimage) {
+            old_width = CGImageGetWidth(cursor_cgimage);
+            old_height = CGImageGetHeight(cursor_cgimage);
+        } else {
+            old_width = 0;
+            old_height = 0;
+        }
+
+        cocoa_cursor_update();
+
+        dispatch_async(dispatch_get_main_queue(), ^{
+            CGFloat d = [cocoaView frame].size.height / full_height;
+            NSRect rect;
+
+            rect.origin.x = d * x;
+            rect.origin.y = d * (full_height - y - old_height);
+            rect.size.width = d * old_width;
+            rect.size.height = d * old_height;
+            [cocoaView setNeedsDisplayInRect:rect];
+
+            rect.size.width = d * width;
+            rect.size.height = d * height;
+            [cocoaView setNeedsDisplayInRect:rect];
+        });
+    }
+}
+
 static const DisplayChangeListenerOps dcl_ops = {
     .dpy_name          = "cocoa",
     .dpy_gfx_update = cocoa_update,
     .dpy_gfx_switch = cocoa_switch,
     .dpy_refresh = cocoa_refresh,
+    .dpy_mouse_set = cocoa_mouse_set,
+    .dpy_cursor_define = cocoa_cursor_define,
 };
 
 #ifdef CONFIG_OPENGL
@@ -2058,16 +2245,38 @@ static void cocoa_gl_update(DisplayChangeListener *dcl,
 {
     CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
 
-    if (listener != active_listener || listener->gl_scanout_id) {
+    if (listener != active_listener) {
         return;
     }
 
     with_view_ctx(^{
         surface_gl_update_texture(dgc.gls, surface, x, y, w, h);
-        gl_surface_dirty = true;
+        gl_dirty = true;
     });
 }
 
+static void cocoa_gl_cursor_render()
+{
+    if (!active_listener->mouse_on) {
+        return;
+    }
+
+    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+    CGFloat d = size.height / surface_height(surface);
+
+    glViewport(
+        d * active_listener->mouse_x,
+        size.height - d * (active_listener->mouse_y + active_listener->cursor->height),
+        d * active_listener->cursor->width,
+        d * active_listener->cursor->height
+    );
+    glBindTexture(GL_TEXTURE_2D, cursor_texture);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    qemu_gl_run_texture_blit(dgc.gls, false);
+    glDisable(GL_BLEND);
+}
+
 static void cocoa_gl_switch(DisplayChangeListener *dcl,
                             DisplaySurface *new_surface)
 {
@@ -2083,21 +2292,39 @@ static void cocoa_gl_switch(DisplayChangeListener *dcl,
     });
 
     cocoa_switch(dcl, new_surface);
-    gl_surface_dirty = true;
+    gl_dirty = true;
 }
 
 static void cocoa_gl_refresh(DisplayChangeListener *dcl)
 {
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    if (listener != active_listener) {
+        return;
+    }
+
     cocoa_refresh(dcl);
 
-    if (gl_surface_dirty) {
-        gl_surface_dirty = false;
+    if (gl_dirty) {
+        gl_dirty = false;
 
         with_view_ctx(^{
             NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
 
-            surface_gl_setup_viewport(dgc.gls, surface, size.width, size.height);
-            surface_gl_render_texture(dgc.gls, surface);
+            if (listener->gl_scanout_id) {
+                glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+                glViewport(0, 0, size.width, size.height);
+                glBindTexture(GL_TEXTURE_2D, active_listener->gl_scanout_id);
+                qemu_gl_run_texture_blit(dgc.gls,
+                                         active_listener->gl_scanout_y0_top);
+            } else {
+                surface_gl_setup_viewport(dgc.gls, surface,
+                                          size.width, size.height);
+                glBindTexture(GL_TEXTURE_2D, surface->texture);
+                surface_gl_render_texture(dgc.gls, surface);
+            }
+
+            cocoa_gl_cursor_render();
             cocoa_gl_flush();
         });
     }
@@ -2109,13 +2336,40 @@ static void cocoa_gl_scanout_disable(DisplayChangeListener *dcl)
 
     listener->gl_scanout_id = 0;
 
-    if (listener == active_listener && surface) {
+    if (listener == active_listener) {
+        gl_dirty = surface != NULL;
+    }
+}
+
+static void cocoa_gl_cursor_update()
+{
+    if (active_listener->cursor) {
         with_view_ctx(^{
-            surface_gl_destroy_texture(dgc.gls, surface);
-            surface_gl_create_texture(dgc.gls, surface);
+            glBindTexture(GL_TEXTURE_2D, cursor_texture);
+            glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT,
+                          active_listener->cursor->width);
+            glTexImage2D(GL_TEXTURE_2D, 0,
+                         epoxy_is_desktop_gl() ? GL_RGBA : GL_BGRA,
+                         active_listener->cursor->width,
+                         active_listener->cursor->height,
+                         0, GL_BGRA, GL_UNSIGNED_BYTE,
+                         active_listener->cursor->data);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
         });
+    }
+
+    gl_dirty = true;
+}
 
-        gl_surface_dirty = true;
+static void cocoa_gl_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->cursor = cursor;
+
+    if (listener == active_listener) {
+        cocoa_gl_cursor_update();
     }
 }
 
@@ -2131,35 +2385,28 @@ static void cocoa_gl_scanout_texture(DisplayChangeListener *dcl,
 
     listener->gl_scanout_id = backing_id;
     listener->gl_scanout_y0_top = backing_y_0_top;
-
-    if (listener == active_listener) {
-        gl_surface_dirty = false;
-    }
+    gl_dirty = true;
 }
 
-static void cocoa_gl_scanout_flush()
+static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
+                                   uint32_t x, uint32_t y,
+                                   uint32_t w, uint32_t h)
 {
-    if (!active_listener->gl_scanout_id) {
-        return;
+    if (container_of(dcl, CocoaListener, dcl) == active_listener) {
+        gl_dirty = true;
     }
-
-    with_view_ctx(^{
-        NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
-
-        glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
-        glViewport(0, 0, size.width, size.height);
-        glBindTexture(GL_TEXTURE_2D, active_listener->gl_scanout_id);
-        qemu_gl_run_texture_blit(dgc.gls, active_listener->gl_scanout_y0_top);
-        cocoa_gl_flush();
-    });
 }
 
-static void cocoa_gl_scanout_flush_proxy(DisplayChangeListener *dcl,
-                                         uint32_t x, uint32_t y,
-                                         uint32_t w, uint32_t h)
+static void cocoa_gl_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
 {
-    if (container_of(dcl, CocoaListener, dcl) == active_listener) {
-        cocoa_gl_scanout_flush();
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->mouse_x = x;
+    listener->mouse_y = y;
+    listener->mouse_on = on;
+
+    if (listener == active_listener) {
+        gl_dirty = true;
     }
 }
 
@@ -2169,10 +2416,12 @@ static void cocoa_gl_scanout_flush_proxy(DisplayChangeListener *dcl,
     .dpy_gfx_switch         = cocoa_gl_switch,
     .dpy_gfx_check_format   = console_gl_check_format,
     .dpy_refresh            = cocoa_gl_refresh,
+    .dpy_mouse_set          = cocoa_gl_mouse_set,
+    .dpy_cursor_define      = cocoa_gl_cursor_define,
 
     .dpy_gl_scanout_disable = cocoa_gl_scanout_disable,
     .dpy_gl_scanout_texture = cocoa_gl_scanout_texture,
-    .dpy_gl_update          = cocoa_gl_scanout_flush_proxy,
+    .dpy_gl_update          = cocoa_gl_scanout_flush,
 };
 
 static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
@@ -2212,7 +2461,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
     appController = [[QemuCocoaAppController alloc] init];
     [NSApp setDelegate:appController];
 
-    qemu_mutex_init(&surface_mutex);
+    qemu_mutex_init(&draw_mutex);
 
     if (display_opengl) {
 #ifdef CONFIG_OPENGL
@@ -2249,6 +2498,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
         }
 
         dgc.gls = qemu_gl_init_shader();
+        glGenTextures(1, &cursor_texture);
 
         // register vga output callbacks
         ops = &dcl_gl_ops;

From e0af80866ac52fd2e12fd5e5adf39466aaf388eb Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 18 Feb 2021 13:06:30 +0900
Subject: [PATCH 160/180] Use virgl_renderer_borrow_texture_for_scanout

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 contrib/vhost-user-gpu/virgl.c |  4 +--
 hw/display/virtio-gpu-virgl.c  | 46 +++++++++++++++++++++++-----------
 include/ui/console.h           | 17 ++++++-------
 include/ui/gtk.h               |  8 ++----
 include/ui/sdl2.h              |  4 +--
 ui/cocoa.m                     | 21 +++++++++-------
 ui/console.c                   | 14 +++--------
 ui/dbus-listener.c             | 32 ++++++++++++++++-------
 ui/egl-headless.c              | 38 ++++++++++++++++++----------
 ui/gtk-egl.c                   | 40 ++++++++++++++++++++---------
 ui/gtk-gl-area.c               | 43 +++++++++++++++++++++----------
 ui/sdl2-gl.c                   | 13 +++++++---
 ui/spice-display.c             | 11 +++++---
 13 files changed, 182 insertions(+), 109 deletions(-)

diff --git a/contrib/vhost-user-gpu/virgl.c b/contrib/vhost-user-gpu/virgl.c
index 3e45e1bd3360..33930b18473f 100644
--- a/contrib/vhost-user-gpu/virgl.c
+++ b/contrib/vhost-user-gpu/virgl.c
@@ -323,7 +323,7 @@ virgl_cmd_set_scanout(VuGpu *g,
                       struct virtio_gpu_ctrl_command *cmd)
 {
     struct virtio_gpu_set_scanout ss;
-    struct virgl_renderer_resource_info info;
+    struct virgl_renderer_texture_info info;
     int ret;
 
     VUGPU_FILL_CMD(ss);
@@ -338,7 +338,7 @@ virgl_cmd_set_scanout(VuGpu *g,
     memset(&info, 0, sizeof(info));
 
     if (ss.resource_id && ss.r.width && ss.r.height) {
-        ret = virgl_renderer_resource_get_info(ss.resource_id, &info);
+        ret = virgl_renderer_borrow_texture_for_scanout(ss.resource_id, &info);
         if (ret == -1) {
             g_critical("%s: illegal resource specified %d\n",
                        __func__, ss.resource_id);
diff --git a/hw/display/virtio-gpu-virgl.c b/hw/display/virtio-gpu-virgl.c
index 73cb92c8d5c6..a52874a257a8 100644
--- a/hw/display/virtio-gpu-virgl.c
+++ b/hw/display/virtio-gpu-virgl.c
@@ -140,12 +140,39 @@ static void virgl_cmd_resource_flush(VirtIOGPU *g,
     }
 }
 
+static GLuint virgl_borrow_texture_for_scanout(uint32_t id, bool *y_0_top,
+                                               uint32_t *width,
+                                               uint32_t *height)
+{
+    struct virgl_renderer_texture_info info;
+    int ret;
+
+    memset(&info, 0, sizeof(info));
+
+    ret = virgl_renderer_borrow_texture_for_scanout(id, &info);
+    if (ret == -1) {
+        return 0;
+    }
+
+    if (y_0_top) {
+        *y_0_top = info.flags & VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP;
+    }
+
+    if (width) {
+        *width = info.width;
+    }
+
+    if (height) {
+        *height = info.height;
+    }
+
+    return info.tex_id;
+}
+
 static void virgl_cmd_set_scanout(VirtIOGPU *g,
                                   struct virtio_gpu_ctrl_command *cmd)
 {
     struct virtio_gpu_set_scanout ss;
-    struct virgl_renderer_resource_info info;
-    int ret;
 
     VIRTIO_GPU_FILL_CMD(ss);
     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,
@@ -159,24 +186,13 @@ static void virgl_cmd_set_scanout(VirtIOGPU *g,
     }
     g->parent_obj.enable = 1;
 
-    memset(&info, 0, sizeof(info));
-
     if (ss.resource_id && ss.r.width && ss.r.height) {
-        ret = virgl_renderer_resource_get_info(ss.resource_id, &info);
-        if (ret == -1) {
-            qemu_log_mask(LOG_GUEST_ERROR,
-                          "%s: illegal resource specified %d\n",
-                          __func__, ss.resource_id);
-            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-            return;
-        }
         qemu_console_resize(g->parent_obj.scanout[ss.scanout_id].con,
                             ss.r.width, ss.r.height);
         virgl_renderer_force_ctx_0();
         dpy_gl_scanout_texture(
-            g->parent_obj.scanout[ss.scanout_id].con, info.tex_id,
-            info.flags & VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP,
-            info.width, info.height,
+            g->parent_obj.scanout[ss.scanout_id].con, ss.resource_id,
+            virgl_borrow_texture_for_scanout,
             ss.r.x, ss.r.y, ss.r.width, ss.r.height);
     } else {
         dpy_gfx_replace_surface(
diff --git a/include/ui/console.h b/include/ui/console.h
index c8f1899b7fb4..10064e640ee5 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -107,11 +107,13 @@ struct QemuConsoleClass {
 #define QEMU_ALLOCATED_FLAG     0x01
 #define QEMU_PLACEHOLDER_FLAG   0x02
 
+typedef uint32_t (* DisplayGLTextureBorrower)(uint32_t id, bool *y_0_top,
+                                              uint32_t *width,
+                                              uint32_t *height);
+
 typedef struct ScanoutTexture {
     uint32_t backing_id;
-    bool backing_y_0_top;
-    uint32_t backing_width;
-    uint32_t backing_height;
+    DisplayGLTextureBorrower backing_borrow;
     uint32_t x;
     uint32_t y;
     uint32_t width;
@@ -246,9 +248,7 @@ typedef struct DisplayChangeListenerOps {
     /* required if GL */
     void (*dpy_gl_scanout_texture)(DisplayChangeListener *dcl,
                                    uint32_t backing_id,
-                                   bool backing_y_0_top,
-                                   uint32_t backing_width,
-                                   uint32_t backing_height,
+                                   DisplayGLTextureBorrower backing_borrow,
                                    uint32_t x, uint32_t y,
                                    uint32_t w, uint32_t h);
     /* optional (default to true if has dpy_gl_scanout_dmabuf) */
@@ -351,9 +351,8 @@ bool dpy_gfx_check_format(QemuConsole *con,
                           pixman_format_code_t format);
 
 void dpy_gl_scanout_disable(QemuConsole *con);
-void dpy_gl_scanout_texture(QemuConsole *con,
-                            uint32_t backing_id, bool backing_y_0_top,
-                            uint32_t backing_width, uint32_t backing_height,
+void dpy_gl_scanout_texture(QemuConsole *con, uint32_t backing_id,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 void dpy_gl_scanout_dmabuf(QemuConsole *con,
                            QemuDmaBuf *dmabuf);
diff --git a/include/ui/gtk.h b/include/ui/gtk.h
index 627cf2ca0f64..94e9a69a24c6 100644
--- a/include/ui/gtk.h
+++ b/include/ui/gtk.h
@@ -171,9 +171,7 @@ QEMUGLContext gd_egl_create_context(DisplayGLCtx *dgc,
 void gd_egl_scanout_disable(DisplayChangeListener *dcl);
 void gd_egl_scanout_texture(DisplayChangeListener *dcl,
                             uint32_t backing_id,
-                            bool backing_y_0_top,
-                            uint32_t backing_width,
-                            uint32_t backing_height,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y,
                             uint32_t w, uint32_t h);
 void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
@@ -207,9 +205,7 @@ void gd_gl_area_scanout_dmabuf(DisplayChangeListener *dcl,
                                QemuDmaBuf *dmabuf);
 void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
                                 uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
+                                DisplayGLTextureBorrower backing_borrow,
                                 uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h);
 void gd_gl_area_scanout_disable(DisplayChangeListener *dcl);
diff --git a/include/ui/sdl2.h b/include/ui/sdl2.h
index 8e422e26b482..96af2f6826af 100644
--- a/include/ui/sdl2.h
+++ b/include/ui/sdl2.h
@@ -86,9 +86,7 @@ int sdl2_gl_make_context_current(DisplayGLCtx *dgc,
 void sdl2_gl_scanout_disable(DisplayChangeListener *dcl);
 void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
                              uint32_t backing_id,
-                             bool backing_y_0_top,
-                             uint32_t backing_width,
-                             uint32_t backing_height,
+                             DisplayGLTextureBorrower backing_borrow,
                              uint32_t x, uint32_t y,
                              uint32_t w, uint32_t h);
 void sdl2_gl_scanout_flush(DisplayChangeListener *dcl,
diff --git a/ui/cocoa.m b/ui/cocoa.m
index 6ab7f8c1820c..786deab6c460 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -84,6 +84,7 @@
     int mouse_on;
 #ifdef CONFIG_OPENGL
     uint32_t gl_scanout_id;
+    DisplayGLTextureBorrower gl_scanout_borrow;
     bool gl_scanout_y0_top;
 #endif
 } CocoaListener;
@@ -2311,12 +2312,16 @@ static void cocoa_gl_refresh(DisplayChangeListener *dcl)
         with_view_ctx(^{
             NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
 
-            if (listener->gl_scanout_id) {
+            if (listener->gl_scanout_borrow) {
+                bool y0_top;
+                GLint texture =
+                    listener->gl_scanout_borrow(listener->gl_scanout_id,
+                                                &y0_top, NULL, NULL);
+
                 glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
                 glViewport(0, 0, size.width, size.height);
-                glBindTexture(GL_TEXTURE_2D, active_listener->gl_scanout_id);
-                qemu_gl_run_texture_blit(dgc.gls,
-                                         active_listener->gl_scanout_y0_top);
+                glBindTexture(GL_TEXTURE_2D, texture);
+                qemu_gl_run_texture_blit(dgc.gls, y0_top);
             } else {
                 surface_gl_setup_viewport(dgc.gls, surface,
                                           size.width, size.height);
@@ -2334,7 +2339,7 @@ static void cocoa_gl_scanout_disable(DisplayChangeListener *dcl)
 {
     CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
 
-    listener->gl_scanout_id = 0;
+    listener->gl_scanout_borrow = NULL;
 
     if (listener == active_listener) {
         gl_dirty = surface != NULL;
@@ -2375,16 +2380,14 @@ static void cocoa_gl_cursor_define(DisplayChangeListener *dcl, QEMUCursor *curso
 
 static void cocoa_gl_scanout_texture(DisplayChangeListener *dcl,
                                      uint32_t backing_id,
-                                     bool backing_y_0_top,
-                                     uint32_t backing_width,
-                                     uint32_t backing_height,
+                                     DisplayGLTextureBorrower backing_borrow,
                                      uint32_t x, uint32_t y,
                                      uint32_t w, uint32_t h)
 {
     CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
 
     listener->gl_scanout_id = backing_id;
-    listener->gl_scanout_y0_top = backing_y_0_top;
+    listener->gl_scanout_borrow = backing_borrow;
     gl_dirty = true;
 }
 
diff --git a/ui/console.c b/ui/console.c
index d69f799e4db4..93efc19067af 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -1119,9 +1119,7 @@ static void displaychangelistener_display_console(DisplayChangeListener *dcl,
                dcl->ops->dpy_gl_scanout_texture) {
         dcl->ops->dpy_gl_scanout_texture(dcl,
                                          con->scanout.texture.backing_id,
-                                         con->scanout.texture.backing_y_0_top,
-                                         con->scanout.texture.backing_width,
-                                         con->scanout.texture.backing_height,
+                                         con->scanout.texture.backing_borrow,
                                          con->scanout.texture.x,
                                          con->scanout.texture.y,
                                          con->scanout.texture.width,
@@ -1863,9 +1861,7 @@ void dpy_gl_scanout_disable(QemuConsole *con)
 
 void dpy_gl_scanout_texture(QemuConsole *con,
                             uint32_t backing_id,
-                            bool backing_y_0_top,
-                            uint32_t backing_width,
-                            uint32_t backing_height,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y,
                             uint32_t width, uint32_t height)
 {
@@ -1874,7 +1870,7 @@ void dpy_gl_scanout_texture(QemuConsole *con,
 
     con->scanout.kind = SCANOUT_TEXTURE;
     con->scanout.texture = (ScanoutTexture) {
-        backing_id, backing_y_0_top, backing_width, backing_height,
+        backing_id, backing_borrow,
         x, y, width, height
     };
     QLIST_FOREACH(dcl, &s->listeners, next) {
@@ -1882,9 +1878,7 @@ void dpy_gl_scanout_texture(QemuConsole *con,
             continue;
         }
         if (dcl->ops->dpy_gl_scanout_texture) {
-            dcl->ops->dpy_gl_scanout_texture(dcl, backing_id,
-                                             backing_y_0_top,
-                                             backing_width, backing_height,
+            dcl->ops->dpy_gl_scanout_texture(dcl, backing_id, backing_borrow,
                                              x, y, width, height);
         }
     }
diff --git a/ui/dbus-listener.c b/ui/dbus-listener.c
index f9fc8eda519a..025931f6e7f0 100644
--- a/ui/dbus-listener.c
+++ b/ui/dbus-listener.c
@@ -113,13 +113,11 @@ static void dbus_scanout_dmabuf(DisplayChangeListener *dcl,
         NULL, NULL, NULL);
 }
 
-static void dbus_scanout_texture(DisplayChangeListener *dcl,
-                                 uint32_t tex_id,
-                                 bool backing_y_0_top,
-                                 uint32_t backing_width,
-                                 uint32_t backing_height,
-                                 uint32_t x, uint32_t y,
-                                 uint32_t w, uint32_t h)
+static void dbus_scanout_borrowed_texture(DisplayChangeListener *dcl,
+                                          uint32_t tex_id,
+                                          bool backing_y_0_top,
+                                          uint32_t backing_width,
+                                          uint32_t backing_height)
 {
     QemuDmaBuf dmabuf = {
         .width = backing_width,
@@ -141,6 +139,22 @@ static void dbus_scanout_texture(DisplayChangeListener *dcl,
     close(dmabuf.fd);
 }
 
+static void dbus_scanout_texture(DisplayChangeListener *dcl,
+                                 uint32_t backing_id,
+                                 DisplayGLTextureBorrower backing_borrow,
+                                 uint32_t x, uint32_t y,
+                                 uint32_t w, uint32_t h)
+{
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+    uint32_t tex_id = backing_borrow(backing_id, &backing_y_0_top,
+                                     &backing_width, &backing_height);
+
+    dbus_scanout_borrowed_texture(dcl, tex_id, backing_y_0_top,
+                                  backing_width, backing_height);
+}
+
 static void dbus_cursor_dmabuf(DisplayChangeListener *dcl,
                                QemuDmaBuf *dmabuf, bool have_hot,
                                uint32_t hot_x, uint32_t hot_y)
@@ -306,8 +320,8 @@ static void dbus_gl_gfx_switch(DisplayChangeListener *dcl,
         int height = surface_height(ddl->ds);
 
         /* TODO: lazy send dmabuf (there are unnecessary sent otherwise) */
-        dbus_scanout_texture(&ddl->dcl, ddl->ds->texture, false,
-                             width, height, 0, 0, width, height);
+        dbus_scanout_borrowed_texture(&ddl->dcl, ddl->ds->texture, false,
+                                      width, height);
     }
 }
 
diff --git a/ui/egl-headless.c b/ui/egl-headless.c
index 7a30fd977765..7bb1ef014cdc 100644
--- a/ui/egl-headless.c
+++ b/ui/egl-headless.c
@@ -54,13 +54,11 @@ static void egl_scanout_disable(DisplayChangeListener *dcl)
     egl_fb_destroy(&edpy->blit_fb);
 }
 
-static void egl_scanout_texture(DisplayChangeListener *dcl,
-                                uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
-                                uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h)
+static void egl_scanout_imported_texture(DisplayChangeListener *dcl,
+                                         uint32_t backing_texture,
+                                         bool backing_y_0_top,
+                                         uint32_t backing_width,
+                                         uint32_t backing_height)
 {
     egl_dpy *edpy = container_of(dcl, egl_dpy, dcl);
 
@@ -68,7 +66,7 @@ static void egl_scanout_texture(DisplayChangeListener *dcl,
 
     /* source framebuffer */
     egl_fb_setup_for_tex(&edpy->guest_fb,
-                         backing_width, backing_height, backing_id, false);
+                         backing_width, backing_height, backing_texture, false);
 
     /* dest framebuffer */
     if (edpy->blit_fb.width  != backing_width ||
@@ -78,17 +76,31 @@ static void egl_scanout_texture(DisplayChangeListener *dcl,
     }
 }
 
-static void egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                               QemuDmaBuf *dmabuf)
+static void egl_scanout_texture(DisplayChangeListener *dcl,
+                                uint32_t backing_id,
+                                DisplayGLTextureBorrower backing_borrow,
+                                uint32_t x, uint32_t y,
+                                uint32_t w, uint32_t h)
+{
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    egl_scanout_imported_texture(dcl, backing_texture, backing_y_0_top,
+                                 backing_width, backing_height);
+}
+
+static void egl_scanout_dmabuf(DisplayChangeListener *dcl, QemuDmaBuf *dmabuf)
 {
     egl_dmabuf_import_texture(dmabuf);
     if (!dmabuf->texture) {
         return;
     }
 
-    egl_scanout_texture(dcl, dmabuf->texture,
-                        false, dmabuf->width, dmabuf->height,
-                        0, 0, dmabuf->width, dmabuf->height);
+    egl_scanout_imported_texture(dcl, dmabuf->texture,
+                                 false, dmabuf->width, dmabuf->height);
 }
 
 static void egl_cursor_dmabuf(DisplayChangeListener *dcl,
diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
index d187cc6009a9..e2ee5b519ebb 100644
--- a/ui/gtk-egl.c
+++ b/ui/gtk-egl.c
@@ -216,14 +216,14 @@ void gd_egl_scanout_disable(DisplayChangeListener *dcl)
     gtk_egl_set_scanout_mode(vc, false);
 }
 
-void gd_egl_scanout_texture(DisplayChangeListener *dcl,
-                            uint32_t backing_id, bool backing_y_0_top,
-                            uint32_t backing_width, uint32_t backing_height,
-                            uint32_t x, uint32_t y,
-                            uint32_t w, uint32_t h)
+static void gd_egl_scanout_borrowed_texture(VirtualConsole *vc,
+                                            uint32_t backing_id,
+                                            bool backing_y_0_top,
+                                            uint32_t backing_width,
+                                            uint32_t backing_height,
+                                            uint32_t x, uint32_t y,
+                                            uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-
     vc->gfx.x = x;
     vc->gfx.y = y;
     vc->gfx.w = w;
@@ -238,8 +238,24 @@ void gd_egl_scanout_texture(DisplayChangeListener *dcl,
                          backing_id, false);
 }
 
-void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                           QemuDmaBuf *dmabuf)
+void gd_egl_scanout_texture(DisplayChangeListener *dcl, uint32_t backing_id,
+                            DisplayGLTextureBorrower backing_borrow,
+                            uint32_t x, uint32_t y,
+                            uint32_t w, uint32_t h)
+{
+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    gd_egl_scanout_borrowed_texture(vc, backing_texture, backing_y_0_top,
+                                    backing_width, backing_height,
+                                    x, y, w, h);
+}
+
+void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl, QemuDmaBuf *dmabuf)
 {
 #ifdef CONFIG_GBM
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
@@ -252,9 +268,9 @@ void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
         return;
     }
 
-    gd_egl_scanout_texture(dcl, dmabuf->texture,
-                           false, dmabuf->width, dmabuf->height,
-                           0, 0, dmabuf->width, dmabuf->height);
+    gd_egl_scanout_borrowed_texture(vc, dmabuf->texture,
+                                    false, dmabuf->width, dmabuf->height,
+                                    0, 0, dmabuf->width, dmabuf->height);
 
     if (dmabuf->allow_fences) {
         vc->gfx.guest_fb.dmabuf = dmabuf;
diff --git a/ui/gtk-gl-area.c b/ui/gtk-gl-area.c
index 0e864e6d7b43..103e995c7fad 100644
--- a/ui/gtk-gl-area.c
+++ b/ui/gtk-gl-area.c
@@ -204,16 +204,14 @@ void gd_gl_area_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx)
     /* FIXME */
 }
 
-void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
-                                uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
-                                uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h)
+static void gd_gl_area_scanout_borrowed_texture(VirtualConsole *vc,
+                                                uint32_t backing_id,
+                                                bool backing_y_0_top,
+                                                uint32_t backing_width,
+                                                uint32_t backing_height,
+                                                uint32_t x, uint32_t y,
+                                                uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-
     vc->gfx.x = x;
     vc->gfx.y = y;
     vc->gfx.w = w;
@@ -222,7 +220,7 @@ void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
 
     gtk_gl_area_make_current(GTK_GL_AREA(vc->gfx.drawing_area));
 
-    if (backing_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0) {
+    if (vc->gfx.w == 0 || vc->gfx.h == 0) {
         gtk_gl_area_set_scanout_mode(vc, false);
         return;
     }
@@ -232,6 +230,25 @@ void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
                          backing_id, false);
 }
 
+void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
+                                uint32_t backing_id,
+                                DisplayGLTextureBorrower backing_borrow,
+                                uint32_t x, uint32_t y,
+                                uint32_t w, uint32_t h)
+{
+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    gd_gl_area_scanout_borrowed_texture(vc, backing_texture,
+                                        backing_y_0_top,
+                                        backing_width, backing_height,
+                                        x, y, w, h);
+}
+
 void gd_gl_area_scanout_disable(DisplayChangeListener *dcl)
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
@@ -263,9 +280,9 @@ void gd_gl_area_scanout_dmabuf(DisplayChangeListener *dcl,
         return;
     }
 
-    gd_gl_area_scanout_texture(dcl, dmabuf->texture,
-                               false, dmabuf->width, dmabuf->height,
-                               0, 0, dmabuf->width, dmabuf->height);
+    gd_gl_area_scanout_borrowed_texture(vc, dmabuf->texture,
+                                        false, dmabuf->width, dmabuf->height,
+                                        0, 0, dmabuf->width, dmabuf->height);
 
     if (dmabuf->allow_fences) {
         vc->gfx.guest_fb.dmabuf = dmabuf;
diff --git a/ui/sdl2-gl.c b/ui/sdl2-gl.c
index 39cab8cde737..63784a7412fe 100644
--- a/ui/sdl2-gl.c
+++ b/ui/sdl2-gl.c
@@ -197,15 +197,20 @@ void sdl2_gl_scanout_disable(DisplayChangeListener *dcl)
 
 void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
                              uint32_t backing_id,
-                             bool backing_y_0_top,
-                             uint32_t backing_width,
-                             uint32_t backing_height,
+                             DisplayGLTextureBorrower backing_borrow,
                              uint32_t x, uint32_t y,
                              uint32_t w, uint32_t h)
 {
     struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
 
     assert(scon->opengl);
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+
     scon->x = x;
     scon->y = y;
     scon->w = w;
@@ -216,7 +221,7 @@ void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
 
     sdl2_set_scanout_mode(scon, true);
     egl_fb_setup_for_tex(&scon->guest_fb, backing_width, backing_height,
-                         backing_id, false);
+                         backing_texture, false);
 }
 
 void sdl2_gl_scanout_flush(DisplayChangeListener *dcl,
diff --git a/ui/spice-display.c b/ui/spice-display.c
index 494168e7fe75..746f1b5b3e9f 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -939,17 +939,20 @@ static void qemu_spice_gl_scanout_disable(DisplayChangeListener *dcl)
 }
 
 static void qemu_spice_gl_scanout_texture(DisplayChangeListener *dcl,
-                                          uint32_t tex_id,
-                                          bool y_0_top,
-                                          uint32_t backing_width,
-                                          uint32_t backing_height,
+                                          uint32_t backing_id,
+                                          DisplayGLTextureBorrower backing_borrow,
                                           uint32_t x, uint32_t y,
                                           uint32_t w, uint32_t h)
 {
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
     EGLint stride = 0, fourcc = 0;
     int fd = -1;
+    bool y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
 
+    GLuint tex_id = backing_borrow(backing_id, &y_0_top,
+                                   &backing_width, &backing_height);
     assert(tex_id);
     fd = egl_get_fd_for_texture(tex_id, &stride, &fourcc, NULL);
     if (fd < 0) {

From 3acd8e70ba23d906a980fc464e7b6ac321f4d9df Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sun, 14 Mar 2021 13:51:55 +0900
Subject: [PATCH 161/180] ui/cocoa: Define types early

---
 ui/cocoa.m | 114 ++++++++++++++++++++++++-----------------------------
 1 file changed, 52 insertions(+), 62 deletions(-)

diff --git a/ui/cocoa.m b/ui/cocoa.m
index 786deab6c460..c049e0447c74 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -94,6 +94,55 @@
     int height;
 } QEMUScreen;
 
+@interface QemuCocoaView : NSView
+{
+    NSTrackingArea *trackingArea;
+    QEMUScreen screen;
+    BOOL isMouseGrabbed;
+    BOOL isAbsoluteEnabled;
+    CFMachPortRef eventsTap;
+}
+- (void) grabMouse;
+- (void) ungrabMouse;
+- (void) setFullGrab:(id)sender;
+- (void) handleMonitorInput:(NSEvent *)event;
+- (bool) handleEvent:(NSEvent *)event;
+- (bool) handleEventLocked:(NSEvent *)event;
+- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
+/* The state surrounding mouse grabbing is potentially confusing.
+ * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
+ *   pointing device an absolute-position one?"], but is only updated on
+ *   next refresh.
+ * isMouseGrabbed tracks whether GUI events are directed to the guest;
+ *   it controls whether special keys like Cmd get sent to the guest,
+ *   and whether we capture the mouse when in non-absolute mode.
+ */
+- (BOOL) isMouseGrabbed;
+- (BOOL) isAbsoluteEnabled;
+@end
+
+@interface QemuCocoaAppController : NSObject
+                                       <NSWindowDelegate, NSApplicationDelegate>
+{
+}
+- (void)doToggleFullScreen:(id)sender;
+- (void)showQEMUDoc:(id)sender;
+- (void)zoomToFit:(id) sender;
+- (void)displayConsole:(id)sender;
+- (void)pauseQEMU:(id)sender;
+- (void)resumeQEMU:(id)sender;
+- (void)displayPause;
+- (void)removePause;
+- (void)restartQEMU:(id)sender;
+- (void)powerDownQEMU:(id)sender;
+- (void)ejectDeviceMedia:(id)sender;
+- (void)changeDeviceMedia:(id)sender;
+- (BOOL)verifyQuit;
+- (void)openDocumentation:(NSString *)filename;
+- (IBAction) do_about_menu_item: (id) sender;
+- (void)adjustSpeed:(id)sender;
+@end
+
 @interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
 @end
 
@@ -102,6 +151,9 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 
 static void cocoa_cursor_update(void);
 
+typedef void (^CodeBlock)(void);
+typedef bool (^BoolCodeBlock)(void);
+
 static NSWindow *normalWindow;
 static CocoaListener *active_listener;
 static CocoaListener *listeners;
@@ -164,9 +216,6 @@ static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
 #endif
 
 // Utility functions to run specified code block with iothread lock held
-typedef void (^CodeBlock)(void);
-typedef bool (^BoolCodeBlock)(void);
-
 static void with_iothread_lock(CodeBlock block)
 {
     bool locked = qemu_mutex_iothread_locked();
@@ -271,38 +320,6 @@ static CGRect compute_cursor_clip_rect(int screen_height,
     return rect;
 }
 
-/*
- ------------------------------------------------------
-    QemuCocoaView
- ------------------------------------------------------
-*/
-@interface QemuCocoaView : NSView
-{
-    NSTrackingArea *trackingArea;
-    QEMUScreen screen;
-    BOOL isMouseGrabbed;
-    BOOL isAbsoluteEnabled;
-    CFMachPortRef eventsTap;
-}
-- (void) grabMouse;
-- (void) ungrabMouse;
-- (void) setFullGrab:(id)sender;
-- (void) handleMonitorInput:(NSEvent *)event;
-- (bool) handleEvent:(NSEvent *)event;
-- (bool) handleEventLocked:(NSEvent *)event;
-- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
-/* The state surrounding mouse grabbing is potentially confusing.
- * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
- *   pointing device an absolute-position one?"], but is only updated on
- *   next refresh.
- * isMouseGrabbed tracks whether GUI events are directed to the guest;
- *   it controls whether special keys like Cmd get sent to the guest,
- *   and whether we capture the mouse when in non-absolute mode.
- */
-- (BOOL) isMouseGrabbed;
-- (BOOL) isAbsoluteEnabled;
-@end
-
 QemuCocoaView *cocoaView;
 
 static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
@@ -1159,33 +1176,6 @@ - (void) raiseAllButtons
 
 
 
-/*
- ------------------------------------------------------
-    QemuCocoaAppController
- ------------------------------------------------------
-*/
-@interface QemuCocoaAppController : NSObject
-                                       <NSWindowDelegate, NSApplicationDelegate>
-{
-}
-- (void)doToggleFullScreen:(id)sender;
-- (void)showQEMUDoc:(id)sender;
-- (void)zoomToFit:(id) sender;
-- (void)displayConsole:(id)sender;
-- (void)pauseQEMU:(id)sender;
-- (void)resumeQEMU:(id)sender;
-- (void)displayPause;
-- (void)removePause;
-- (void)restartQEMU:(id)sender;
-- (void)powerDownQEMU:(id)sender;
-- (void)ejectDeviceMedia:(id)sender;
-- (void)changeDeviceMedia:(id)sender;
-- (BOOL)verifyQuit;
-- (void)openDocumentation:(NSString *)filename;
-- (IBAction) do_about_menu_item: (id) sender;
-- (void)adjustSpeed:(id)sender;
-@end
-
 @implementation QemuCocoaAppController
 - (id) init
 {

From a0167d013f72952b1212a30e53d3c3546e0a4336 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Thu, 25 Feb 2021 17:01:14 +0900
Subject: [PATCH 162/180] ui/cocoa: Isolate fragments with preprocessor

---
 ui/cocoa.m => include/ui/cocoa.h | 915 +++++++++++++++++--------------
 ui/cocoa/app_controller.m        |  26 +
 ui/cocoa/main.m                  |  26 +
 ui/cocoa/pasteboard_type_owner.m |  26 +
 ui/cocoa/view.m                  |  27 +
 ui/meson.build                   |   4 +-
 6 files changed, 604 insertions(+), 420 deletions(-)
 rename ui/cocoa.m => include/ui/cocoa.h (77%)
 create mode 100644 ui/cocoa/app_controller.m
 create mode 100644 ui/cocoa/main.m
 create mode 100644 ui/cocoa/pasteboard_type_owner.m
 create mode 100644 ui/cocoa/view.m

diff --git a/ui/cocoa.m b/include/ui/cocoa.h
similarity index 77%
rename from ui/cocoa.m
rename to include/ui/cocoa.h
index c049e0447c74..06dd9e7d8935 100644
--- a/ui/cocoa.m
+++ b/include/ui/cocoa.h
@@ -22,37 +22,69 @@
  * THE SOFTWARE.
  */
 
+#ifndef UI_COCOA_H
+#define UI_COCOA_H
+
+#ifdef UI_COCOA_MAIN
 #define GL_SILENCE_DEPRECATION
+#endif
 
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_PASTEBOARD_TYPE_OWNER) || defined(UI_COCOA_VIEW)
 #include "qemu/osdep.h"
+#endif
 
 #import <Cocoa/Cocoa.h>
+#ifdef UI_COCOA_MAIN
 #include <crt_externs.h>
+#endif
 
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER)
 #include "qemu-common.h"
+#endif
 #include "ui/clipboard.h"
 #include "ui/console.h"
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_VIEW)
 #include "ui/input.h"
+#endif
 #include "ui/kbd-state.h"
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_VIEW)
 #include "sysemu/sysemu.h"
+#endif
+#ifdef UI_COCOA_APP_CONTROLLER
 #include "sysemu/runstate.h"
 #include "sysemu/cpu-throttle.h"
 #include "qapi/error.h"
+#endif
+#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER)
 #include "qapi/qapi-commands-block.h"
+#endif
+#ifdef UI_COCOA_APP_CONTROLLER
 #include "qapi/qapi-commands-machine.h"
 #include "qapi/qapi-commands-misc.h"
 #include "sysemu/blockdev.h"
 #include "qemu-version.h"
 #include "qemu/cutils.h"
+#endif
 #include "qemu/main-loop.h"
+#ifdef UI_COCOA_APP_CONTROLLER
 #include "qemu/module.h"
+#endif
+#ifdef UI_COCOA_VIEW
+#include "qemu/error-report.h"
 #include <Carbon/Carbon.h>
+#endif
+#include "qemu/thread.h"
+#ifdef UI_COCOA_APP_CONTROLLER
 #include "hw/core/cpu.h"
+#endif
 
+#ifdef UI_COCOA_MAIN
 #ifdef CONFIG_EGL
 #include "ui/egl-context.h"
 #endif
+#endif
 
+#ifdef UI_COCOA_APP_CONTROLLER
 #ifndef MAC_OS_X_VERSION_10_13
 #define MAC_OS_X_VERSION_10_13 101300
 #endif
@@ -65,6 +97,7 @@
 #define NSControlStateValueOn NSOnState
 #define NSControlStateValueOff NSOffState
 #endif
+#endif
 
 //#define DEBUG
 
@@ -74,7 +107,9 @@
 #define COCOA_DEBUG(...)  ((void) 0)
 #endif
 
+#ifdef UI_COCOA_VIEW
 #define cgrect(nsrect) (*(CGRect *)&(nsrect))
+#endif
 
 typedef struct CocoaListener {
     DisplayChangeListener dcl;
@@ -90,24 +125,48 @@
 } CocoaListener;
 
 typedef struct {
-    int width;
-    int height;
+    CocoaListener *active_listener;
+    CocoaListener *listeners;
+    size_t listeners_count;
+    DisplaySurface *surface;
+    QemuMutex draw_mutex;
+    QKbdState *kbd;
+    CGImageRef cursor_cgimage;
+    int cursor_show;
+    bool left_command_key_disabled;
+    bool swap_opt_cmd;
+    bool inited;
 } QEMUScreen;
 
+typedef struct {
+    QemuClipboardInfo *info;
+    QemuEvent event;
+} QemuCocoaClipboard;
+
 @interface QemuCocoaView : NSView
 {
+    NSTextField *pauseLabel;
     NSTrackingArea *trackingArea;
-    QEMUScreen screen;
+    QEMUScreen *screen;
+    int screen_width;
+    int screen_height;
     BOOL isMouseGrabbed;
     BOOL isAbsoluteEnabled;
     CFMachPortRef eventsTap;
 }
+- (id)initWithFrame:(NSRect)frameRect
+             screen:(QEMUScreen *)given_screen;
+- (void) frameUpdated;
+- (void) selectConsoleLocked:(unsigned int)index;
+- (NSSize) computeUnzoomedSize;
+- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize;
+- (void) resizeWindow;
+- (void) updateUIInfo;
+- (void) updateScreenWidth:(int)w height:(int)h;
 - (void) grabMouse;
 - (void) ungrabMouse;
 - (void) setFullGrab:(id)sender;
-- (void) handleMonitorInput:(NSEvent *)event;
 - (bool) handleEvent:(NSEvent *)event;
-- (bool) handleEventLocked:(NSEvent *)event;
 - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
 /* The state surrounding mouse grabbing is potentially confusing.
  * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
@@ -119,63 +178,45 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
  */
 - (BOOL) isMouseGrabbed;
 - (BOOL) isAbsoluteEnabled;
+- (void) setNeedsDisplayForCursorX:(int)x
+                                 y:(int)y
+                             width:(int)width
+                            height:(int)height
+                      screenHeight:(int)screen_height;
+- (void)displayPause;
+- (void)removePause;
 @end
 
 @interface QemuCocoaAppController : NSObject
                                        <NSWindowDelegate, NSApplicationDelegate>
 {
+    QemuCocoaView *cocoaView;
 }
-- (void)doToggleFullScreen:(id)sender;
-- (void)showQEMUDoc:(id)sender;
-- (void)zoomToFit:(id) sender;
-- (void)displayConsole:(id)sender;
-- (void)pauseQEMU:(id)sender;
-- (void)resumeQEMU:(id)sender;
-- (void)displayPause;
-- (void)removePause;
-- (void)restartQEMU:(id)sender;
-- (void)powerDownQEMU:(id)sender;
-- (void)ejectDeviceMedia:(id)sender;
-- (void)changeDeviceMedia:(id)sender;
-- (BOOL)verifyQuit;
-- (void)openDocumentation:(NSString *)filename;
-- (IBAction) do_about_menu_item: (id) sender;
-- (void)adjustSpeed:(id)sender;
+- (id) initWithScreen:(QEMUScreen *)screen;
+- (QemuCocoaView *)cocoaView;
 @end
 
 @interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
+{
+    QemuCocoaClipboard *cb;
+}
+- (id) initWith:(QemuCocoaClipboard *)aCb;
 @end
 
-static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *surface);
-
-static void cocoa_cursor_update(void);
+void cocoa_listener_select(size_t index);
 
 typedef void (^CodeBlock)(void);
 typedef bool (^BoolCodeBlock)(void);
 
-static NSWindow *normalWindow;
-static CocoaListener *active_listener;
-static CocoaListener *listeners;
-static size_t listeners_count;
-static DisplaySurface *surface;
-static QemuMutex draw_mutex;
-static CGImageRef cursor_cgimage;
-static QKbdState *kbd;
-static int cursor_hide = 1;
-static int left_command_key_enabled = 1;
-static bool swap_opt_cmd;
-static bool full_screen;
-static bool full_grab;
+#ifdef UI_COCOA_MAIN
+static QEMUScreen screen;
+static QemuCocoaAppController *appController;
 static bool have_cocoa_ui;
 
-static NSTextField *pauseLabel;
-
 static NSInteger cbchangecount = -1;
-static QemuClipboardInfo *cbinfo;
 static QemuClipboardPeer cbpeer;
+static QemuCocoaClipboard qemucb;
 static QemuCocoaPasteboardTypeOwner *cbowner;
-static QemuEvent cbevent;
 
 #ifdef CONFIG_OPENGL
 
@@ -187,11 +228,6 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 static EGLSurface egl_surface;
 #endif
 
-static void cocoa_gl_switch(DisplayChangeListener *dcl,
-                            DisplaySurface *new_surface);
-
-static void cocoa_gl_cursor_update(void);
-
 static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
                                        DisplayChangeListener *dcl);
 
@@ -213,8 +249,10 @@ static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
     .ops = &dgc_ops,
 };
 
+#endif
 #endif
 
+#ifdef UI_COCOA_VIEW
 // Utility functions to run specified code block with iothread lock held
 static void with_iothread_lock(CodeBlock block)
 {
@@ -242,7 +280,9 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
     }
     return val;
 }
+#endif
 
+#ifdef UI_COCOA_MAIN
 /*
  * The startup process for the OSX/Cocoa UI is complicated, because
  * OSX insists that the UI runs on the initial main thread, and so we
@@ -251,12 +291,8 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
  * Initial thread:                    2nd thread:
  * in main():
  *  qemu_init()
- *  create application, menus, etc
- *  enter OSX run loop
- * in applicationDidFinishLaunching:
- *  fullscreen if needed
  *  create main loop thread
- *                                    call qemu_main_loop()
+ *  enter OSX run loop                call qemu_main_loop()
  */
 
 static void *call_qemu_main_loop(void *opaque)
@@ -266,9 +302,9 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
     qemu_main_loop();
     COCOA_DEBUG("Second thread: qemu_main_loop() returned, exiting\n");
     qemu_cleanup();
-    qkbd_state_free(kbd);
+    qkbd_state_free(screen.kbd);
     [cbowner release];
-    CGImageRelease(cursor_cgimage);
+    CGImageRelease(screen.cursor_cgimage);
 #ifdef CONFIG_OPENGL
     qemu_gl_fini_shader(dgc.gls);
     if (view_ctx) {
@@ -277,7 +313,9 @@ static bool bool_with_iothread_lock(BoolCodeBlock block)
 #endif
     exit(0);
 }
+#endif
 
+#ifdef UI_COCOA_VIEW
 static int cocoa_keycode_to_qemu(int keycode)
 {
     if (qemu_input_map_osx_to_qcode_len <= keycode) {
@@ -286,7 +324,9 @@ static int cocoa_keycode_to_qemu(int keycode)
     }
     return qemu_input_map_osx_to_qcode[keycode];
 }
+#endif
 
+#ifdef UI_COCOA_APP_CONTROLLER
 /* Displays an alert dialog box with the specified message */
 static void QEMU_Alert(NSString *message)
 {
@@ -305,7 +345,9 @@ static void handleAnyDeviceErrors(Error * err)
         error_free(err);
     }
 }
+#endif
 
+#ifdef UI_COCOA_VIEW
 static CGRect compute_cursor_clip_rect(int screen_height,
                                        int given_mouse_x, int given_mouse_y,
                                        int cursor_width, int cursor_height)
@@ -320,8 +362,6 @@ static CGRect compute_cursor_clip_rect(int screen_height,
     return rect;
 }
 
-QemuCocoaView *cocoaView;
-
 static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
 {
     QemuCocoaView *cocoaView = userInfo;
@@ -337,14 +377,28 @@ static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEven
 
 @implementation QemuCocoaView
 - (id)initWithFrame:(NSRect)frameRect
+             screen:(QEMUScreen *)given_screen
 {
     COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
 
     self = [super initWithFrame:frameRect];
     if (self) {
 
-        screen.width = frameRect.size.width;
-        screen.height = frameRect.size.height;
+        screen = given_screen;
+        screen_width = frameRect.size.width;
+        screen_height = frameRect.size.height;
+
+        /* Used for displaying pause on the screen */
+        pauseLabel = [NSTextField new];
+        [pauseLabel setBezeled:YES];
+        [pauseLabel setDrawsBackground:YES];
+        [pauseLabel setBackgroundColor: [NSColor whiteColor]];
+        [pauseLabel setEditable:NO];
+        [pauseLabel setSelectable:NO];
+        [pauseLabel setStringValue: @"Paused"];
+        [pauseLabel setFont: [NSFont fontWithName: @"Helvetica" size: 90]];
+        [pauseLabel setTextColor: [NSColor blackColor]];
+        [pauseLabel sizeToFit];
 
     }
     return self;
@@ -354,6 +408,10 @@ - (void) dealloc
 {
     COCOA_DEBUG("QemuCocoaView: dealloc\n");
 
+    if (pauseLabel) {
+        [pauseLabel release];
+    }
+
     if (eventsTap) {
         CFRelease(eventsTap);
     }
@@ -405,36 +463,13 @@ - (void) viewWillMoveToWindow:(NSWindow *)newWindow
 
 - (void) selectConsoleLocked:(unsigned int)index
 {
-    DisplaySurface *new_surface;
-
-    if (index >= listeners_count) {
-        return;
-    }
-
-    active_listener = &listeners[index];
-    new_surface = qemu_console_surface(active_listener->dcl.con);
-    qkbd_state_lift_all_keys(kbd);
-    qkbd_state_free(kbd);
-    kbd = qkbd_state_init(active_listener->dcl.con);
-
-    if (display_opengl) {
-#ifdef CONFIG_OPENGL
-        cocoa_gl_cursor_update();
-        cocoa_gl_switch(&active_listener->dcl, new_surface);
-#else
-        g_assert_not_reached();
-#endif
-    } else {
-        cocoa_cursor_update();
-        cocoa_switch(&active_listener->dcl, new_surface);
-    }
-
-    [self updateUIInfoLocked];
+    cocoa_listener_select(index);
+    [self updateUIInfo];
 }
 
 - (void) hideCursor
 {
-    if (!cursor_hide) {
+    if (screen->cursor_show) {
         return;
     }
     [NSCursor hide];
@@ -442,21 +477,21 @@ - (void) hideCursor
 
 - (void) unhideCursor
 {
-    if (!cursor_hide) {
+    if (screen->cursor_show) {
         return;
     }
     [NSCursor unhide];
 }
 
 - (CGRect) convertCursorClipRectToDraw:(CGRect)rect
-                          screenHeight:(int)screen_height
-                                mouseX:(int)given_mouse_x
-                                mouseY:(int)given_mouse_y
+                          screenHeight:(int)given_screen_height
+                                mouseX:(int)mouse_x
+                                mouseY:(int)mouse_y
 {
-    CGFloat d = [self frame].size.height / (CGFloat)screen_height;
+    CGFloat d = [self frame].size.height / (CGFloat)given_screen_height;
 
-    rect.origin.x = (rect.origin.x + given_mouse_x) * d;
-    rect.origin.y = (screen_height - rect.origin.y - given_mouse_y - rect.size.height) * d;
+    rect.origin.x = (rect.origin.x + mouse_x) * d;
+    rect.origin.y = (given_screen_height - rect.origin.y - mouse_y - rect.size.height) * d;
     rect.size.width *= d;
     rect.size.height *= d;
 
@@ -479,23 +514,23 @@ - (void) drawRect:(NSRect) rect
     CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
     CGContextSetShouldAntialias (viewContextRef, NO);
 
-    qemu_mutex_lock(&draw_mutex);
+    qemu_mutex_lock(&screen->draw_mutex);
 
     // draw screen bitmap directly to Core Graphics context
-    if (!surface) {
+    if (!screen->surface) {
         // Draw request before any guest device has set up a framebuffer:
         // just draw an opaque black rectangle
         CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
         CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
     } else {
-        int w = surface_width(surface);
-        int h = surface_height(surface);
-        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(surface));
-        int stride = surface_stride(surface);
+        int w = surface_width(screen->surface);
+        int h = surface_height(screen->surface);
+        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(screen->surface));
+        int stride = surface_stride(screen->surface);
 
         CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
             NULL,
-            surface_data(surface),
+            surface_data(screen->surface),
             stride * h,
             NULL
         );
@@ -536,11 +571,11 @@ - (void) drawRect:(NSRect) rect
         CGImageRelease (imageRef);
         CGDataProviderRelease(dataProviderRef);
 
-        if (active_listener->mouse_on) {
-            size_t cursor_width = CGImageGetWidth(cursor_cgimage);
-            size_t cursor_height = CGImageGetHeight(cursor_cgimage);
-            int mouse_x = active_listener->mouse_x;
-            int mouse_y = active_listener->mouse_y;
+        if (screen->active_listener->mouse_on) {
+            size_t cursor_width = CGImageGetWidth(screen->cursor_cgimage);
+            size_t cursor_height = CGImageGetHeight(screen->cursor_cgimage);
+            int mouse_x = screen->active_listener->mouse_x;
+            int mouse_y = screen->active_listener->mouse_y;
             clipRect = compute_cursor_clip_rect(h, mouse_x, mouse_y,
                                                 cursor_width,
                                                 cursor_height);
@@ -549,7 +584,7 @@ - (void) drawRect:(NSRect) rect
                                                          mouseX:mouse_x
                                                          mouseY:mouse_y];
             clipImageRef = CGImageCreateWithImageInRect(
-                                                        cursor_cgimage,
+                                                        screen->cursor_cgimage,
                                                         clipRect
                                                         );
             CGContextDrawImage(viewContextRef, drawRect, clipImageRef);
@@ -557,13 +592,13 @@ - (void) drawRect:(NSRect) rect
         }
     }
 
-    qemu_mutex_unlock(&draw_mutex);
+    qemu_mutex_unlock(&screen->draw_mutex);
 }
 
 - (NSSize) computeUnzoomedSize
 {
-    CGFloat width = screen.width / [[self window] backingScaleFactor];
-    CGFloat height = screen.height / [[self window] backingScaleFactor];
+    CGFloat width = screen_width / [[self window] backingScaleFactor];
+    CGFloat height = screen_height / [[self window] backingScaleFactor];
 
     return NSMakeSize(width, height);
 }
@@ -572,15 +607,15 @@ - (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
 {
     NSSize size;
 
-    size.width = (CGFloat)screen.width * proposedSize.height;
-    size.height = (CGFloat)screen.height * proposedSize.width;
+    size.width = (CGFloat)screen_width * proposedSize.height;
+    size.height = (CGFloat)screen_height * proposedSize.width;
 
     if (size.width < size.height) {
-        size.width /= screen.height;
+        size.width /= screen_height;
         size.height = proposedSize.height;
     } else {
         size.width = proposedSize.width;
-        size.height /= screen.width;
+        size.height /= screen_width;
     }
 
     return size;
@@ -588,7 +623,7 @@ - (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
 
 - (void) resizeWindow
 {
-    [[self window] setContentAspectRatio:NSMakeSize(screen.width, screen.height)];
+    [[self window] setContentAspectRatio:NSMakeSize(screen_width, screen_height)];
 
     if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
         [[self window] setContentSize:[self computeUnzoomedSize]];
@@ -622,7 +657,7 @@ - (void) updateUIInfoLocked
             CVTime period = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink);
             CVDisplayLinkRelease(displayLink);
             if (!(period.flags & kCVTimeIsIndefinite)) {
-                update_displaychangelistener(&active_listener->dcl,
+                update_displaychangelistener(&screen->active_listener->dcl,
                                              1000 * period.timeValue / period.timeScale);
                 info.refresh_rate = (int64_t)1000 * period.timeScale / period.timeValue;
             }
@@ -639,19 +674,19 @@ - (void) updateUIInfoLocked
     info.width = frameBackingSize.width;
     info.height = frameBackingSize.height;
 
-    dpy_set_ui_info(active_listener->dcl.con, &info, TRUE);
+    dpy_set_ui_info(screen->active_listener->dcl.con, &info, TRUE);
 }
 
 - (void) updateUIInfo
 {
-    if (!listeners) {
+    if (!screen->listeners) {
         /*
          * Don't try to tell QEMU about UI information in the application
          * startup phase -- we haven't yet registered dcl with the QEMU UI
          * layer, and also trying to take the iothread lock would deadlock.
-         * When applicationDidFinishLaunching() does register the dcl, the
-         * UI layer will call cocoa_switch(), which will call updateUIInfo,
-         * so we don't lose any information here.
+         * When cocoa_display_init() does register the dcl, the UI layer
+         * will call cocoa_switch(), which will call updateUIInfo, so
+         * we don't lose any information here.
          */
         return;
     }
@@ -665,10 +700,10 @@ - (void) updateScreenWidth:(int)w height:(int)h
 {
     COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
 
-    if (w != screen.width || h != screen.height) {
+    if (w != screen_width || h != screen_height) {
         COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
-        screen.width = w;
-        screen.height = h;
+        screen_width = w;
+        screen_height = h;
         [self resizeWindow];
     }
 }
@@ -704,7 +739,7 @@ - (void) setFullGrab:(id)sender
 }
 
 - (void) toggleKey: (int)keycode {
-    qkbd_state_key_event(kbd, keycode, !qkbd_state_key_get(kbd, keycode));
+    qkbd_state_key_event(screen->kbd, keycode, !qkbd_state_key_get(screen->kbd, keycode));
 }
 
 // Does the work of sending input to the monitor
@@ -767,15 +802,16 @@ - (void) handleMonitorInput:(NSEvent *)event
     }
 
     if (keysym) {
-        kbd_put_keysym_console(active_listener->dcl.con, keysym);
+        kbd_put_keysym_console(screen->active_listener->dcl.con, keysym);
     }
 }
 
 - (bool) handleEvent:(NSEvent *)event
 {
-    if(!listeners) {
+    if(!screen->listeners) {
         return false;
     }
+
     return bool_with_iothread_lock(^{
         return [self handleEventLocked:event];
     });
@@ -827,35 +863,35 @@ - (bool) handleEventLocked:(NSEvent *)event
      *   this implementation usable enough.
      */
     if (!!(modifiers & NSEventModifierFlagCapsLock) !=
-        qkbd_state_modifier_get(kbd, QKBD_MOD_CAPSLOCK)) {
-        qkbd_state_key_event(kbd, Q_KEY_CODE_CAPS_LOCK, true);
-        qkbd_state_key_event(kbd, Q_KEY_CODE_CAPS_LOCK, false);
+        qkbd_state_modifier_get(screen->kbd, QKBD_MOD_CAPSLOCK)) {
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CAPS_LOCK, true);
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CAPS_LOCK, false);
     }
 
     if (!(modifiers & NSEventModifierFlagShift)) {
-        qkbd_state_key_event(kbd, Q_KEY_CODE_SHIFT, false);
-        qkbd_state_key_event(kbd, Q_KEY_CODE_SHIFT_R, false);
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_SHIFT, false);
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_SHIFT_R, false);
     }
     if (!(modifiers & NSEventModifierFlagControl)) {
-        qkbd_state_key_event(kbd, Q_KEY_CODE_CTRL, false);
-        qkbd_state_key_event(kbd, Q_KEY_CODE_CTRL_R, false);
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CTRL, false);
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CTRL_R, false);
     }
     if (!(modifiers & NSEventModifierFlagOption)) {
-        if (swap_opt_cmd) {
-            qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
-            qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
+        if (screen->swap_opt_cmd) {
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_L, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_R, false);
         } else {
-            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
-            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT_R, false);
         }
     }
     if (!(modifiers & NSEventModifierFlagCommand)) {
-        if (swap_opt_cmd) {
-            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT, false);
-            qkbd_state_key_event(kbd, Q_KEY_CODE_ALT_R, false);
+        if (screen->swap_opt_cmd) {
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT_R, false);
         } else {
-            qkbd_state_key_event(kbd, Q_KEY_CODE_META_L, false);
-            qkbd_state_key_event(kbd, Q_KEY_CODE_META_R, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_L, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_R, false);
         }
     }
 
@@ -888,7 +924,7 @@ - (bool) handleEventLocked:(NSEvent *)event
 
                 case kVK_Option:
                     if (!!(modifiers & NSEventModifierFlagOption)) {
-                        if (swap_opt_cmd) {
+                        if (screen->swap_opt_cmd) {
                             [self toggleKey:Q_KEY_CODE_META_L];
                         } else {
                             [self toggleKey:Q_KEY_CODE_ALT];
@@ -898,7 +934,7 @@ - (bool) handleEventLocked:(NSEvent *)event
 
                 case kVK_RightOption:
                     if (!!(modifiers & NSEventModifierFlagOption)) {
-                        if (swap_opt_cmd) {
+                        if (screen->swap_opt_cmd) {
                             [self toggleKey:Q_KEY_CODE_META_R];
                         } else {
                             [self toggleKey:Q_KEY_CODE_ALT_R];
@@ -910,8 +946,8 @@ - (bool) handleEventLocked:(NSEvent *)event
                 case kVK_Command:
                     if (isMouseGrabbed &&
                         !!(modifiers & NSEventModifierFlagCommand) &&
-                        left_command_key_enabled) {
-                        if (swap_opt_cmd) {
+                        !screen->left_command_key_disabled) {
+                        if (screen->swap_opt_cmd) {
                             [self toggleKey:Q_KEY_CODE_ALT];
                         } else {
                             [self toggleKey:Q_KEY_CODE_META_L];
@@ -922,7 +958,7 @@ - (bool) handleEventLocked:(NSEvent *)event
                 case kVK_RightCommand:
                     if (isMouseGrabbed &&
                         !!(modifiers & NSEventModifierFlagCommand)) {
-                        if (swap_opt_cmd) {
+                        if (screen->swap_opt_cmd) {
                             [self toggleKey:Q_KEY_CODE_ALT_R];
                         } else {
                             [self toggleKey:Q_KEY_CODE_META_R];
@@ -957,14 +993,14 @@ - (bool) handleEventLocked:(NSEvent *)event
 
                         // release the mouse grab
                         case 'g':
-                            [self ungrabMouse];
+                            [self ungrabMouseLocked];
                             return true;
                     }
                 }
             }
 
-            if (qemu_console_is_graphic(active_listener->dcl.con)) {
-                qkbd_state_key_event(kbd, keycode, true);
+            if (qemu_console_is_graphic(screen->active_listener->dcl.con)) {
+                qkbd_state_key_event(screen->kbd, keycode, true);
             } else {
                 [self handleMonitorInput: event];
             }
@@ -978,8 +1014,8 @@ - (bool) handleEventLocked:(NSEvent *)event
                 return true;
             }
 
-            if (qemu_console_is_graphic(active_listener->dcl.con)) {
-                qkbd_state_key_event(kbd, keycode, false);
+            if (qemu_console_is_graphic(screen->active_listener->dcl.con)) {
+                qkbd_state_key_event(screen->kbd, keycode, false);
             }
             return true;
         case NSEventTypeScrollWheel:
@@ -1002,9 +1038,9 @@ - (bool) handleEventLocked:(NSEvent *)event
                     INPUT_BUTTON_WHEEL_LEFT : INPUT_BUTTON_WHEEL_RIGHT;
                 }
 
-                qemu_input_queue_btn(active_listener->dcl.con, buttons, true);
+                qemu_input_queue_btn(screen->active_listener->dcl.con, buttons, true);
                 qemu_input_event_sync();
-                qemu_input_queue_btn(active_listener->dcl.con, buttons, false);
+                qemu_input_queue_btn(screen->active_listener->dcl.con, buttons, false);
                 qemu_input_event_sync();
             }
 
@@ -1025,16 +1061,16 @@ - (void) handleMouseEvent:(NSEvent *)event
     }
 
     with_iothread_lock(^{
-        QemuConsole *con = active_listener->dcl.con;
+        QemuConsole *con = screen->active_listener->dcl.con;
 
         if (isAbsoluteEnabled) {
-            CGFloat d = (CGFloat)screen.height / [self frame].size.height;
+            CGFloat d = (CGFloat)screen_height / [self frame].size.height;
             NSPoint p = [event locationInWindow];
             // Note that the origin for Cocoa mouse coords is bottom left, not top left.
-            qemu_input_queue_abs(con, INPUT_AXIS_X, p.x * d, 0, screen.width);
-            qemu_input_queue_abs(con, INPUT_AXIS_Y, screen.height - p.y * d, 0, screen.height);
+            qemu_input_queue_abs(con, INPUT_AXIS_X, p.x * d, 0, screen_width);
+            qemu_input_queue_abs(con, INPUT_AXIS_Y, screen_height - p.y * d, 0, screen_height);
         } else {
-            CGFloat d = (CGFloat)screen.height / [self convertSizeToBacking:[self frame].size].height;
+            CGFloat d = (CGFloat)screen_height / [self convertSizeToBacking:[self frame].size].height;
             qemu_input_queue_rel(con, INPUT_AXIS_X, [event deltaX] * d);
             qemu_input_queue_rel(con, INPUT_AXIS_Y, [event deltaY] * d);
         }
@@ -1050,7 +1086,7 @@ - (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool
     }
 
     with_iothread_lock(^{
-        qemu_input_queue_btn(active_listener->dcl.con, button, down);
+        qemu_input_queue_btn(screen->active_listener->dcl.con, button, down);
     });
 
     [self handleMouseEvent:event];
@@ -1128,14 +1164,14 @@ - (void) grabMouse
 {
     COCOA_DEBUG("QemuCocoaView: grabMouse\n");
 
-    if (!listeners) {
+    if (!screen->listeners) {
         return;
     }
 
     if (qemu_name)
-        [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
+        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
     else
-        [normalWindow setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
+        [[self window] setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
     [self hideCursor];
     CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
     isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
@@ -1143,16 +1179,23 @@ - (void) grabMouse
 
 - (void) ungrabMouse
 {
-    COCOA_DEBUG("QemuCocoaView: ungrabMouse\n");
+    with_iothread_lock(^{
+        [self ungrabMouseLocked];
+    });
+}
+
+- (void) ungrabMouseLocked
+{
+    COCOA_DEBUG("QemuCocoaView: ungrabMouseLocked\n");
 
     if (qemu_name)
-        [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
+        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
     else
-        [normalWindow setTitle:@"QEMU"];
+        [[self window] setTitle:@"QEMU"];
     [self unhideCursor];
     CGAssociateMouseAndMouseCursorPosition(TRUE);
     isMouseGrabbed = FALSE;
-    [self raiseAllButtons];
+    [self raiseAllButtonsLocked];
 }
 
 - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
@@ -1164,35 +1207,69 @@ - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
 - (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
 
-- (void) raiseAllButtons
+- (void) raiseAllButtonsLocked
 {
-    with_iothread_lock(^{
-        qemu_input_queue_btn(active_listener->dcl.con, INPUT_BUTTON_LEFT, false);
-        qemu_input_queue_btn(active_listener->dcl.con, INPUT_BUTTON_RIGHT, false);
-        qemu_input_queue_btn(active_listener->dcl.con, INPUT_BUTTON_MIDDLE, false);
-    });
+    QemuConsole *con = screen->active_listener->dcl.con;
+
+    qemu_input_queue_btn(con, INPUT_BUTTON_LEFT, false);
+    qemu_input_queue_btn(con, INPUT_BUTTON_RIGHT, false);
+    qemu_input_queue_btn(con, INPUT_BUTTON_MIDDLE, false);
 }
-@end
 
+- (void) setNeedsDisplayForCursorX:(int)x
+                                 y:(int)y
+                             width:(int)width
+                            height:(int)height
+                      screenHeight:(int)given_screen_height
+{
+    CGRect clip_rect = compute_cursor_clip_rect(given_screen_height, x, y,
+                                                width, height);
+    CGRect draw_rect = [self convertCursorClipRectToDraw:clip_rect
+                                            screenHeight:given_screen_height
+                                                  mouseX:x
+                                                  mouseY:y];
+    [self setNeedsDisplayInRect:draw_rect];
+}
 
+/* Displays the word pause on the screen */
+- (void)displayPause
+{
+    /* Coordinates have to be calculated each time because the window can change its size */
+    int xCoord, yCoord, width, height;
+    xCoord = ([[self window] frame].size.width - [pauseLabel frame].size.width)/2;
+    yCoord = [[self window] frame].size.height - [pauseLabel frame].size.height - ([pauseLabel frame].size.height * .5);
+    width = [pauseLabel frame].size.width;
+    height = [pauseLabel frame].size.height;
+    [pauseLabel setFrame: NSMakeRect(xCoord, yCoord, width, height)];
+    [self addSubview: pauseLabel];
+}
 
+/* Removes the word pause from the screen */
+- (void)removePause
+{
+    [pauseLabel removeFromSuperview];
+}
+@end
+#endif
+
+#ifdef UI_COCOA_APP_CONTROLLER
 @implementation QemuCocoaAppController
-- (id) init
+- (id) initWithScreen:(QEMUScreen *)screen
 {
-    COCOA_DEBUG("QemuCocoaAppController: init\n");
+    COCOA_DEBUG("%s\n", __func__);
 
     self = [super init];
     if (self) {
-
         // create a view and add it to the window
-        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)];
+        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)
+                                                  screen:screen];
         if(!cocoaView) {
             error_report("(cocoa) can't create a view");
             exit(1);
         }
 
         // create a window
-        normalWindow = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
+        NSWindow *normalWindow = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
             styleMask:NSWindowStyleMaskTitled|NSWindowStyleMaskMiniaturizable|NSWindowStyleMaskClosable
             backing:NSBackingStoreBuffered defer:NO];
         if(!normalWindow) {
@@ -1206,18 +1283,7 @@ - (id) init
         [normalWindow makeKeyAndOrderFront:self];
         [normalWindow center];
         [normalWindow setDelegate: self];
-
-        /* Used for displaying pause on the screen */
-        pauseLabel = [NSTextField new];
-        [pauseLabel setBezeled:YES];
-        [pauseLabel setDrawsBackground:YES];
-        [pauseLabel setBackgroundColor: [NSColor whiteColor]];
-        [pauseLabel setEditable:NO];
-        [pauseLabel setSelectable:NO];
-        [pauseLabel setStringValue: @"Paused"];
-        [pauseLabel setFont: [NSFont fontWithName: @"Helvetica" size: 90]];
-        [pauseLabel setTextColor: [NSColor blackColor]];
-        [pauseLabel sizeToFit];
+        [normalWindow release];
     }
     return self;
 }
@@ -1231,28 +1297,6 @@ - (void) dealloc
     [super dealloc];
 }
 
-- (void)applicationDidFinishLaunching: (NSNotification *) note
-{
-    QemuThread main_thread;
-
-    COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
-
-    [cocoaView updateUIInfo];
-
-    qemu_clipboard_peer_register(&cbpeer);
-
-    qemu_mutex_unlock_iothread();
-    qemu_thread_create(&main_thread, "qemu_main_loop", call_qemu_main_loop,
-                       NULL, QEMU_THREAD_DETACHED);
-
-    if (full_screen) {
-        [normalWindow toggleFullScreen: nil];
-    }
-    if (full_grab) {
-        [self setFullGrab: nil];
-    }
-}
-
 - (void)applicationWillTerminate:(NSNotification *)aNotification
 {
     COCOA_DEBUG("QemuCocoaAppController: applicationWillTerminate\n");
@@ -1315,7 +1359,7 @@ - (BOOL)windowShouldClose:(id)sender
 
 - (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
 {
-    if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
         return [cocoaView computeUnzoomedSize];
     }
 
@@ -1343,14 +1387,7 @@ - (void) applicationWillResignActive: (NSNotification *)aNotification
  */
 - (void) doToggleFullScreen:(id)sender
 {
-    [normalWindow toggleFullScreen:sender];
-}
-
-- (void) setFullGrab:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: setFullGrab\n");
-
-    [cocoaView setFullGrab:sender];
+    [[cocoaView window] toggleFullScreen:sender];
 }
 
 /* Tries to find then open the specified filename */
@@ -1390,11 +1427,11 @@ - (void)showQEMUDoc:(id)sender
 /* Toggles the flag which stretches video to fit host window size */
 - (void)zoomToFit:(id) sender
 {
-    if (([normalWindow styleMask] & NSWindowStyleMaskResizable) == 0) {
-        [normalWindow setStyleMask:[normalWindow styleMask] | NSWindowStyleMaskResizable];
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] | NSWindowStyleMaskResizable];
         [sender setState: NSControlStateValueOn];
     } else {
-        [normalWindow setStyleMask:[normalWindow styleMask] & ~NSWindowStyleMaskResizable];
+        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] & ~NSWindowStyleMaskResizable];
         [cocoaView resizeWindow];
         [sender setState: NSControlStateValueOff];
     }
@@ -1403,66 +1440,47 @@ - (void)zoomToFit:(id) sender
 /* Displays the console on the screen */
 - (void)displayConsole:(id)sender
 {
-    with_iothread_lock(^{
-        [cocoaView selectConsoleLocked:[sender tag]];
-    });
+    qemu_mutex_lock_iothread();
+    [cocoaView selectConsoleLocked:[sender tag]];
+    qemu_mutex_unlock_iothread();
 }
 
 /* Pause the guest */
 - (void)pauseQEMU:(id)sender
 {
-    with_iothread_lock(^{
-        qmp_stop(NULL);
-    });
+    qemu_mutex_lock_iothread();
+    qmp_stop(NULL);
+    qemu_mutex_unlock_iothread();
     [sender setEnabled: NO];
     [[[sender menu] itemWithTitle: @"Resume"] setEnabled: YES];
-    [self displayPause];
+    [cocoaView displayPause];
 }
 
 /* Resume running the guest operating system */
 - (void)resumeQEMU:(id) sender
 {
-    with_iothread_lock(^{
-        qmp_cont(NULL);
-    });
+    qemu_mutex_lock_iothread();
+    qmp_cont(NULL);
+    qemu_mutex_unlock_iothread();
     [sender setEnabled: NO];
     [[[sender menu] itemWithTitle: @"Pause"] setEnabled: YES];
-    [self removePause];
-}
-
-/* Displays the word pause on the screen */
-- (void)displayPause
-{
-    /* Coordinates have to be calculated each time because the window can change its size */
-    int xCoord, yCoord, width, height;
-    xCoord = ([normalWindow frame].size.width - [pauseLabel frame].size.width)/2;
-    yCoord = [normalWindow frame].size.height - [pauseLabel frame].size.height - ([pauseLabel frame].size.height * .5);
-    width = [pauseLabel frame].size.width;
-    height = [pauseLabel frame].size.height;
-    [pauseLabel setFrame: NSMakeRect(xCoord, yCoord, width, height)];
-    [cocoaView addSubview: pauseLabel];
-}
-
-/* Removes the word pause from the screen */
-- (void)removePause
-{
-    [pauseLabel removeFromSuperview];
+    [cocoaView removePause];
 }
 
 /* Restarts QEMU */
 - (void)restartQEMU:(id)sender
 {
-    with_iothread_lock(^{
-        qmp_system_reset(NULL);
-    });
+    qemu_mutex_lock_iothread();
+    qmp_system_reset(NULL);
+    qemu_mutex_unlock_iothread();
 }
 
 /* Powers down QEMU */
 - (void)powerDownQEMU:(id)sender
 {
-    with_iothread_lock(^{
-        qmp_system_powerdown(NULL);
-    });
+    qemu_mutex_lock_iothread();
+    qmp_system_powerdown(NULL);
+    qemu_mutex_unlock_iothread();
 }
 
 /* Ejects the media.
@@ -1478,11 +1496,11 @@ - (void)ejectDeviceMedia:(id)sender
         return;
     }
 
-    __block Error *err = NULL;
-    with_iothread_lock(^{
-        qmp_eject(true, [drive cStringUsingEncoding: NSASCIIStringEncoding],
-                  false, NULL, false, false, &err);
-    });
+    Error *err = NULL;
+    qemu_mutex_lock_iothread();
+    qmp_eject(true, [drive cStringUsingEncoding: NSASCIIStringEncoding],
+              false, NULL, false, false, &err);
+    qemu_mutex_unlock_iothread();
     handleAnyDeviceErrors(err);
 }
 
@@ -1513,18 +1531,16 @@ - (void)changeDeviceMedia:(id)sender
             return;
         }
 
-        __block Error *err = NULL;
-        with_iothread_lock(^{
-            qmp_blockdev_change_medium(true,
-                                       [drive cStringUsingEncoding:
-                                                  NSASCIIStringEncoding],
-                                       false, NULL,
-                                       [file cStringUsingEncoding:
-                                                 NSASCIIStringEncoding],
-                                       true, "raw",
-                                       false, 0,
-                                       &err);
-        });
+        Error *err = NULL;
+        qemu_mutex_lock_iothread();
+        qmp_blockdev_change_medium(true,
+                                   [drive cStringUsingEncoding:NSASCIIStringEncoding],
+                                   false, NULL,
+                                   [file cStringUsingEncoding:NSASCIIStringEncoding],
+                                   true, "raw",
+                                   false, 0,
+                                   &err);
+        qemu_mutex_unlock_iothread();
         handleAnyDeviceErrors(err);
     }
 }
@@ -1596,14 +1612,21 @@ - (void)adjustSpeed:(id)sender
     // get the throttle percentage
     throttle_pct = [sender tag];
 
-    with_iothread_lock(^{
-        cpu_throttle_set(throttle_pct);
-    });
+    qemu_mutex_lock_iothread();
+    cpu_throttle_set(throttle_pct);
+    qemu_mutex_unlock_iothread();
     COCOA_DEBUG("cpu throttling at %d%c\n", cpu_throttle_get_percentage(), '%');
 }
 
+- (QemuCocoaView *)cocoaView
+{
+    return cocoaView;
+}
+
 @end
+#endif
 
+#ifdef UI_COCOA_MAIN
 @interface QemuApplication : NSApplication
 @end
 
@@ -1611,7 +1634,7 @@ @implementation QemuApplication
 - (void)sendEvent:(NSEvent *)event
 {
     COCOA_DEBUG("QemuApplication: sendEvent\n");
-    if (![cocoaView handleEvent:event]) {
+    if (![[appController cocoaView] handleEvent:event]) {
         [super sendEvent: event];
     }
 }
@@ -1727,8 +1750,8 @@ static void add_console_menu_entries(void)
 
     [menu addItem:[NSMenuItem separatorItem]];
 
-    for (index = 0; index < listeners_count; index++) {
-        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(listeners[index].dcl.con)
+    for (index = 0; index < screen.listeners_count; index++) {
+        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(screen.listeners[index].dcl.con)
                                                action: @selector(displayConsole:) keyEquivalent: @""] autorelease];
         [menuItem setTag: index];
         [menu addItem: menuItem];
@@ -1795,41 +1818,58 @@ static void addRemovableDevicesMenuItems(void)
     }
     qapi_free_BlockInfoList(pointerToFree);
 }
+#endif
 
+#ifdef UI_COCOA_PASTEBOARD_TYPE_OWNER
 @implementation QemuCocoaPasteboardTypeOwner
 
+- (id)initWith:(QemuCocoaClipboard *)aCb
+{
+    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
+
+    self = [super init];
+    if (self) {
+        cb = aCb;
+    }
+    return self;
+}
+
 - (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
 {
     if (type != NSPasteboardTypeString) {
         return;
     }
 
-    with_iothread_lock(^{
-        QemuClipboardInfo *info = qemu_clipboard_info_ref(cbinfo);
-        qemu_event_reset(&cbevent);
-        qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
-
-        while (info == cbinfo &&
-               info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
-               info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
-            qemu_mutex_unlock_iothread();
-            qemu_event_wait(&cbevent);
-            qemu_mutex_lock_iothread();
-        }
+    qemu_mutex_lock_iothread();
 
-        if (info == cbinfo) {
-            NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
-                                           length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
-            [sender setData:data forType:NSPasteboardTypeString];
-            [data release];
-        }
+    QemuClipboardInfo *info = qemu_clipboard_info_ref(cb->info);
+    qemu_event_reset(&cb->event);
+    qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
 
-        qemu_clipboard_info_unref(info);
-    });
+    while (info == cb->info &&
+           info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
+           info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
+        qemu_mutex_unlock_iothread();
+        qemu_event_wait(&cb->event);
+        qemu_mutex_lock_iothread();
+    }
+
+    if (info == cb->info) {
+        NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
+                                       length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
+        [sender setData:data forType:NSPasteboardTypeString];
+        [data release];
+    }
+
+    qemu_clipboard_info_unref(info);
+
+    qemu_mutex_unlock_iothread();
 }
 
 @end
+#endif
 
+#ifdef UI_COCOA_MAIN
 static void cocoa_clipboard_notify(Notifier *notifier, void *data);
 static void cocoa_clipboard_request(QemuClipboardInfo *info,
                                     QemuClipboardType type);
@@ -1846,15 +1886,15 @@ static void cocoa_clipboard_update_info(QemuClipboardInfo *info)
         return;
     }
 
-    if (info != cbinfo) {
+    if (info != qemucb.info) {
         NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-        qemu_clipboard_info_unref(cbinfo);
-        cbinfo = qemu_clipboard_info_ref(info);
+        qemu_clipboard_info_unref(qemucb.info);
+        qemucb.info = qemu_clipboard_info_ref(info);
         cbchangecount = [[NSPasteboard generalPasteboard] declareTypes:@[NSPasteboardTypeString] owner:cbowner];
         [pool release];
     }
 
-    qemu_event_set(&cbevent);
+    qemu_event_set(&qemucb.event);
 }
 
 static void cocoa_clipboard_notify(Notifier *notifier, void *data)
@@ -1892,9 +1932,11 @@ static void cocoa_clipboard_request(QemuClipboardInfo *info,
 
 int main(int argc, char **argv, char **envp)
 {
+    QemuThread main_thread;
+
     COCOA_DEBUG("Entered main()\n");
 
-    /* Takes iothread lock, released in applicationDidFinishLaunching:.  */
+    /* Takes iothread lock.  */
     qemu_init(argc, argv, envp);
     if (!have_cocoa_ui) {
          qemu_main_loop();
@@ -1902,6 +1944,10 @@ int main(int argc, char **argv, char **envp)
          return 0;
     }
 
+    qemu_mutex_unlock_iothread();
+    qemu_thread_create(&main_thread, "qemu_main_loop", call_qemu_main_loop,
+                       NULL, QEMU_THREAD_DETACHED);
+
     // Start the main event loop
     COCOA_DEBUG("Main thread: entering OSX run loop\n");
     [NSApp run];
@@ -1916,26 +1962,26 @@ int main(int argc, char **argv, char **envp)
 static void cocoa_update(DisplayChangeListener *dcl,
                          int x, int y, int w, int h)
 {
-    DisplaySurface *updated = surface;
+    DisplaySurface *updated = screen.surface;
 
-    if (container_of(dcl, CocoaListener, dcl) != active_listener) {
+    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
         return;
     }
 
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&draw_mutex);
-        if (updated != surface) {
-            qemu_mutex_unlock(&draw_mutex);
+        qemu_mutex_lock(&screen.draw_mutex);
+        if (updated != screen.surface) {
+            qemu_mutex_unlock(&screen.draw_mutex);
             return;
         }
-        int full_height = surface_height(surface);
-        qemu_mutex_unlock(&draw_mutex);
+        int full_height = surface_height(screen.surface);
+        qemu_mutex_unlock(&screen.draw_mutex);
 
-        CGFloat d = [cocoaView frame].size.height / full_height;
+        CGFloat d = [[appController cocoaView] frame].size.height / full_height;
         NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
-        [cocoaView setNeedsDisplayInRect:rect];
+        [[appController cocoaView] setNeedsDisplayInRect:rect];
     });
 }
 
@@ -1944,21 +1990,21 @@ static void cocoa_switch(DisplayChangeListener *dcl,
 {
     COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
 
-    if (container_of(dcl, CocoaListener, dcl) != active_listener) {
+    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
         return;
     }
 
-    qemu_mutex_lock(&draw_mutex);
-    surface = new_surface;
-    qemu_mutex_unlock(&draw_mutex);
+    qemu_mutex_lock(&screen.draw_mutex);
+    screen.surface = new_surface;
+    qemu_mutex_unlock(&screen.draw_mutex);
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&draw_mutex);
-        int w = surface_width(surface);
-        int h = surface_height(surface);
-        qemu_mutex_unlock(&draw_mutex);
+        qemu_mutex_lock(&screen.draw_mutex);
+        int w = surface_width(screen.surface);
+        int h = surface_height(screen.surface);
+        qemu_mutex_unlock(&screen.draw_mutex);
 
-        [cocoaView updateScreenWidth:w height:h];
+        [[appController cocoaView] updateScreenWidth:w height:h];
     });
 }
 
@@ -1968,7 +2014,7 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
 
     COCOA_DEBUG("qemu_cocoa: cocoa_refresh\n");
 
-    if (container_of(dcl, CocoaListener, dcl) != active_listener) {
+    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
         return;
     }
 
@@ -1976,24 +2022,24 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
 
     if (qemu_input_is_absolute()) {
         dispatch_async(dispatch_get_main_queue(), ^{
-            if (![cocoaView isAbsoluteEnabled]) {
-                if ([cocoaView isMouseGrabbed]) {
-                    [cocoaView ungrabMouse];
+            if (![[appController cocoaView] isAbsoluteEnabled]) {
+                if ([[appController cocoaView] isMouseGrabbed]) {
+                    [[appController cocoaView] ungrabMouse];
                 }
             }
-            [cocoaView setAbsoluteEnabled:YES];
+            [[appController cocoaView] setAbsoluteEnabled:YES];
         });
     }
 
     if (cbchangecount != [[NSPasteboard generalPasteboard] changeCount]) {
-        qemu_clipboard_info_unref(cbinfo);
-        cbinfo = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
+        qemu_clipboard_info_unref(qemucb.info);
+        qemucb.info = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
         if ([[NSPasteboard generalPasteboard] availableTypeFromArray:@[NSPasteboardTypeString]]) {
-            cbinfo->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
+            qemucb.info->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
         }
-        qemu_clipboard_update(cbinfo);
+        qemu_clipboard_update(qemucb.info);
         cbchangecount = [[NSPasteboard generalPasteboard] changeCount];
-        qemu_event_set(&cbevent);
+        qemu_event_set(&qemucb.event);
     }
 
     [pool release];
@@ -2003,48 +2049,40 @@ static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
 {
     CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
 
-    qemu_mutex_lock(&draw_mutex);
-    int full_height = surface_height(surface);
+    qemu_mutex_lock(&screen.draw_mutex);
+    int full_height = surface_height(screen.surface);
     int old_x = listener->mouse_x;
     int old_y = listener->mouse_y;
     listener->mouse_x = x;
     listener->mouse_y = y;
     listener->mouse_on = on;
-    qemu_mutex_unlock(&draw_mutex);
+    qemu_mutex_unlock(&screen.draw_mutex);
 
-    if (listener == active_listener && cursor_cgimage) {
-        size_t cursor_width = CGImageGetWidth(cursor_cgimage);
-        size_t cursor_height = CGImageGetHeight(cursor_cgimage);
+    if (listener == screen.active_listener && screen.cursor_cgimage) {
+        size_t cursor_width = CGImageGetWidth(screen.cursor_cgimage);
+        size_t cursor_height = CGImageGetHeight(screen.cursor_cgimage);
 
         dispatch_async(dispatch_get_main_queue(), ^{
-            CGRect clip_rect = compute_cursor_clip_rect(full_height,
-                                                        old_x, old_y,
-                                                        cursor_width,
-                                                        cursor_height);
-            CGRect draw_rect =
-                [cocoaView convertCursorClipRectToDraw:clip_rect
-                                          screenHeight:full_height
-                                                mouseX:old_x
-                                                mouseY:old_y];
-            [cocoaView setNeedsDisplayInRect:draw_rect];
-
-            clip_rect = compute_cursor_clip_rect(full_height, x, y,
-                                                        cursor_width,
-                                                        cursor_height);
-            draw_rect =
-                [cocoaView convertCursorClipRectToDraw:clip_rect
-                                          screenHeight:full_height
-                                                mouseX:x
-                                                mouseY:y];
-            [cocoaView setNeedsDisplayInRect:draw_rect];
+            [[appController cocoaView] setNeedsDisplayForCursorX:old_x
+                                                               y:old_y
+                                                           width:cursor_width
+                                                          height:cursor_height
+                                                    screenHeight:full_height];
+
+            [[appController cocoaView] setNeedsDisplayForCursorX:x
+                                                               y:y
+                                                           width:cursor_width
+                                                          height:cursor_height
+                                                    screenHeight:full_height];
         });
     }
 }
 
 static void cocoa_cursor_update()
 {
-    CGImageRef old_image = cursor_cgimage;
+    CGImageRef old_image = screen.cursor_cgimage;
     CGImageRef new_image;
+    CocoaListener *active_listener = screen.active_listener;
 
     if (active_listener->cursor) {
         CGDataProviderRef provider = CGDataProviderCreateWithData(
@@ -2073,9 +2111,9 @@ static void cocoa_cursor_update()
         new_image = NULL;
     }
 
-    qemu_mutex_lock(&draw_mutex);
-    cursor_cgimage = new_image;
-    qemu_mutex_unlock(&draw_mutex);
+    qemu_mutex_lock(&screen.draw_mutex);
+    screen.cursor_cgimage = new_image;
+    qemu_mutex_unlock(&screen.draw_mutex);
 
     CGImageRelease(old_image);
 }
@@ -2086,8 +2124,8 @@ static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
 
     listener->cursor = cursor;
 
-    if (listener == active_listener) {
-        int full_height = surface_height(surface);
+    if (listener == screen.active_listener) {
+        int full_height = surface_height(screen.surface);
         int width = cursor->width;
         int height = cursor->height;
         int x = listener->mouse_x;
@@ -2095,9 +2133,9 @@ static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
         size_t old_width;
         size_t old_height;
 
-        if (cursor_cgimage) {
-            old_width = CGImageGetWidth(cursor_cgimage);
-            old_height = CGImageGetHeight(cursor_cgimage);
+        if (screen.cursor_cgimage) {
+            old_width = CGImageGetWidth(screen.cursor_cgimage);
+            old_height = CGImageGetHeight(screen.cursor_cgimage);
         } else {
             old_width = 0;
             old_height = 0;
@@ -2106,18 +2144,18 @@ static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
         cocoa_cursor_update();
 
         dispatch_async(dispatch_get_main_queue(), ^{
-            CGFloat d = [cocoaView frame].size.height / full_height;
+            CGFloat d = [[appController cocoaView] frame].size.height / full_height;
             NSRect rect;
 
             rect.origin.x = d * x;
             rect.origin.y = d * (full_height - y - old_height);
             rect.size.width = d * old_width;
             rect.size.height = d * old_height;
-            [cocoaView setNeedsDisplayInRect:rect];
+            [[appController cocoaView] setNeedsDisplayInRect:rect];
 
             rect.size.width = d * width;
             rect.size.height = d * height;
-            [cocoaView setNeedsDisplayInRect:rect];
+            [[appController cocoaView] setNeedsDisplayInRect:rect];
         });
     }
 }
@@ -2195,7 +2233,7 @@ static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
     }
 #endif
 
-    bpp = PIXMAN_FORMAT_BPP(surface_format(surface));
+    bpp = PIXMAN_FORMAT_BPP(surface_format(screen.surface));
     format = cocoa_gl_create_ns_pixel_format(bpp);
     ctx = [[NSOpenGLContext alloc] initWithFormat:format shareContext:view_ctx];
     [format release];
@@ -2236,24 +2274,26 @@ static void cocoa_gl_update(DisplayChangeListener *dcl,
 {
     CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
 
-    if (listener != active_listener) {
+    if (listener != screen.active_listener) {
         return;
     }
 
     with_view_ctx(^{
-        surface_gl_update_texture(dgc.gls, surface, x, y, w, h);
+        surface_gl_update_texture(dgc.gls, screen.surface, x, y, w, h);
         gl_dirty = true;
     });
 }
 
 static void cocoa_gl_cursor_render()
 {
-    if (!active_listener->mouse_on) {
+    if (!screen.active_listener->mouse_on) {
         return;
     }
 
+    QemuCocoaView *cocoaView = [appController cocoaView];
     NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
-    CGFloat d = size.height / surface_height(surface);
+    CGFloat d = size.height / surface_height(screen.surface);
+    CocoaListener *active_listener = screen.active_listener;
 
     glViewport(
         d * active_listener->mouse_x,
@@ -2273,12 +2313,12 @@ static void cocoa_gl_switch(DisplayChangeListener *dcl,
 {
     CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
 
-    if (listener != active_listener) {
+    if (listener != screen.active_listener) {
         return;
     }
 
     with_view_ctx(^{
-        surface_gl_destroy_texture(dgc.gls, surface);
+        surface_gl_destroy_texture(dgc.gls, screen.surface);
         surface_gl_create_texture(dgc.gls, new_surface);
     });
 
@@ -2290,7 +2330,7 @@ static void cocoa_gl_refresh(DisplayChangeListener *dcl)
 {
     CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
 
-    if (listener != active_listener) {
+    if (listener != screen.active_listener) {
         return;
     }
 
@@ -2300,7 +2340,8 @@ static void cocoa_gl_refresh(DisplayChangeListener *dcl)
         gl_dirty = false;
 
         with_view_ctx(^{
-            NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+            QemuCocoaView *view = [appController cocoaView];
+            NSSize size = [view convertSizeToBacking:[view frame].size];
 
             if (listener->gl_scanout_borrow) {
                 bool y0_top;
@@ -2313,10 +2354,10 @@ static void cocoa_gl_refresh(DisplayChangeListener *dcl)
                 glBindTexture(GL_TEXTURE_2D, texture);
                 qemu_gl_run_texture_blit(dgc.gls, y0_top);
             } else {
-                surface_gl_setup_viewport(dgc.gls, surface,
+                surface_gl_setup_viewport(dgc.gls, screen.surface,
                                           size.width, size.height);
-                glBindTexture(GL_TEXTURE_2D, surface->texture);
-                surface_gl_render_texture(dgc.gls, surface);
+                glBindTexture(GL_TEXTURE_2D, screen.surface->texture);
+                surface_gl_render_texture(dgc.gls, screen.surface);
             }
 
             cocoa_gl_cursor_render();
@@ -2331,24 +2372,24 @@ static void cocoa_gl_scanout_disable(DisplayChangeListener *dcl)
 
     listener->gl_scanout_borrow = NULL;
 
-    if (listener == active_listener) {
-        gl_dirty = surface != NULL;
+    if (listener == screen.active_listener) {
+        gl_dirty = screen.surface != NULL;
     }
 }
 
 static void cocoa_gl_cursor_update()
 {
-    if (active_listener->cursor) {
+    if (screen.active_listener->cursor) {
         with_view_ctx(^{
             glBindTexture(GL_TEXTURE_2D, cursor_texture);
             glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT,
-                          active_listener->cursor->width);
+                          screen.active_listener->cursor->width);
             glTexImage2D(GL_TEXTURE_2D, 0,
                          epoxy_is_desktop_gl() ? GL_RGBA : GL_BGRA,
-                         active_listener->cursor->width,
-                         active_listener->cursor->height,
+                         screen.active_listener->cursor->width,
+                         screen.active_listener->cursor->height,
                          0, GL_BGRA, GL_UNSIGNED_BYTE,
-                         active_listener->cursor->data);
+                         screen.active_listener->cursor->data);
             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
         });
@@ -2363,7 +2404,7 @@ static void cocoa_gl_cursor_define(DisplayChangeListener *dcl, QEMUCursor *curso
 
     listener->cursor = cursor;
 
-    if (listener == active_listener) {
+    if (listener == screen.active_listener) {
         cocoa_gl_cursor_update();
     }
 }
@@ -2385,7 +2426,7 @@ static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
                                    uint32_t x, uint32_t y,
                                    uint32_t w, uint32_t h)
 {
-    if (container_of(dcl, CocoaListener, dcl) == active_listener) {
+    if (container_of(dcl, CocoaListener, dcl) == screen.active_listener) {
         gl_dirty = true;
     }
 }
@@ -2398,7 +2439,7 @@ static void cocoa_gl_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
     listener->mouse_y = y;
     listener->mouse_on = on;
 
-    if (listener == active_listener) {
+    if (listener == screen.active_listener) {
         gl_dirty = true;
     }
 }
@@ -2425,6 +2466,36 @@ static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
 
 #endif
 
+void cocoa_listener_select(size_t index)
+{
+    DisplaySurface *new_surface;
+
+    if (index >= screen.listeners_count) {
+        return;
+    }
+
+    qemu_mutex_lock(&screen.draw_mutex);
+    screen.active_listener = &screen.listeners[index];
+    qemu_mutex_unlock(&screen.draw_mutex);
+
+    new_surface = qemu_console_surface(screen.active_listener->dcl.con);
+    qkbd_state_lift_all_keys(screen.kbd);
+    qkbd_state_free(screen.kbd);
+    screen.kbd = qkbd_state_init(screen.active_listener->dcl.con);
+
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        cocoa_gl_cursor_update();
+        cocoa_gl_switch(&screen.active_listener->dcl, new_surface);
+#else
+        g_assert_not_reached();
+#endif
+    } else {
+        cocoa_cursor_update();
+        cocoa_switch(&screen.active_listener->dcl, new_surface);
+    }
+}
+
 static void cocoa_display_early_init(DisplayOptions *o)
 {
     assert(o->type == DISPLAY_TYPE_COCOA);
@@ -2437,7 +2508,7 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 {
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
     ProcessSerialNumber psn = { 0, kCurrentProcess };
-    QemuCocoaAppController *appController;
+    QemuCocoaView *cocoaView;
     const DisplayChangeListenerOps *ops;
     size_t index;
 
@@ -2451,10 +2522,11 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
     [QemuApplication sharedApplication];
 
     // Create an Application controller
-    appController = [[QemuCocoaAppController alloc] init];
+    appController = [[QemuCocoaAppController alloc] initWithScreen:&screen];
+    cocoaView = [appController cocoaView];
     [NSApp setDelegate:appController];
 
-    qemu_mutex_init(&draw_mutex);
+    qemu_mutex_init(&screen.draw_mutex);
 
     if (display_opengl) {
 #ifdef CONFIG_OPENGL
@@ -2504,29 +2576,29 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
         ops = &dcl_ops;
     }
 
-    while (qemu_console_lookup_by_index(listeners_count)) {
-        listeners_count++;
+    while (qemu_console_lookup_by_index(screen.listeners_count)) {
+        screen.listeners_count++;
     }
 
-    if (listeners_count) {
+    if (screen.listeners_count) {
         QemuConsole *con = qemu_console_lookup_first_graphic_console();
-        listeners = g_new0(CocoaListener, listeners_count);
-        active_listener = listeners + qemu_console_get_index(con);
+        screen.listeners = g_new0(CocoaListener, screen.listeners_count);
+        screen.active_listener = screen.listeners + qemu_console_get_index(con);
 
-        for (index = 0; index < listeners_count; index++) {
-            listeners[index].dcl.con = qemu_console_lookup_by_index(index);
-            listeners[index].dcl.ops = ops;
+        for (index = 0; index < screen.listeners_count; index++) {
+            screen.listeners[index].dcl.con = qemu_console_lookup_by_index(index);
+            screen.listeners[index].dcl.ops = ops;
 
             if (display_opengl) {
-                qemu_console_set_display_gl_ctx(listeners[index].dcl.con,
+                qemu_console_set_display_gl_ctx(screen.listeners[index].dcl.con,
                                                 &dgc);
             }
 
             // register vga output callbacks
-            register_displaychangelistener(&listeners[index].dcl);
+            register_displaychangelistener(&screen.listeners[index].dcl);
         }
 
-        kbd = qkbd_state_init(active_listener->dcl.con);
+        screen.kbd = qkbd_state_init(screen.active_listener->dcl.con);
     }
 
     create_initial_menus();
@@ -2541,27 +2613,29 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
     add_console_menu_entries();
     addRemovableDevicesMenuItems();
 
-    qemu_event_init(&cbevent, false);
-    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
+    qemu_event_init(&qemucb.event, false);
+    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] initWith:&qemucb];
 
     if (opts->has_full_screen && opts->full_screen) {
-        full_screen = 1;
+        [[cocoaView window] toggleFullScreen: nil];
     }
     if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {
-        full_grab = 1;
+        [cocoaView setFullGrab: nil];
     }
 
-    if (opts->has_show_cursor && opts->show_cursor) {
-        cursor_hide = 0;
+    if (opts->has_show_cursor) {
+        screen.cursor_show = opts->show_cursor;
     }
     if (opts->u.cocoa.has_swap_opt_cmd) {
-        swap_opt_cmd = opts->u.cocoa.swap_opt_cmd;
+        screen.swap_opt_cmd = opts->u.cocoa.swap_opt_cmd;
     }
 
-    if (opts->u.cocoa.has_left_command_key && !opts->u.cocoa.left_command_key) {
-        left_command_key_enabled = 0;
+    if (opts->u.cocoa.has_left_command_key) {
+        screen.left_command_key_disabled = opts->u.cocoa.left_command_key;
     }
 
+    [cocoaView updateUIInfo];
+    qemu_clipboard_peer_register(&cbpeer);
     [pool release];
 }
 
@@ -2581,3 +2655,6 @@ static void register_cocoa(void)
 #ifdef CONFIG_OPENGL
 module_dep("ui-opengl");
 #endif
+#endif
+
+#endif
diff --git a/ui/cocoa/app_controller.m b/ui/cocoa/app_controller.m
new file mode 100644
index 000000000000..5d1df04d2c3a
--- /dev/null
+++ b/ui/cocoa/app_controller.m
@@ -0,0 +1,26 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define UI_COCOA_APP_CONTROLLER
+#include "ui/cocoa.h"
diff --git a/ui/cocoa/main.m b/ui/cocoa/main.m
new file mode 100644
index 000000000000..e6d8fdeb4efb
--- /dev/null
+++ b/ui/cocoa/main.m
@@ -0,0 +1,26 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define UI_COCOA_MAIN
+#include "ui/cocoa.h"
diff --git a/ui/cocoa/pasteboard_type_owner.m b/ui/cocoa/pasteboard_type_owner.m
new file mode 100644
index 000000000000..691366755682
--- /dev/null
+++ b/ui/cocoa/pasteboard_type_owner.m
@@ -0,0 +1,26 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define UI_COCOA_PASTEBOARD_TYPE_OWNER
+#include "ui/cocoa.h"
diff --git a/ui/cocoa/view.m b/ui/cocoa/view.m
new file mode 100644
index 000000000000..31f195d224d0
--- /dev/null
+++ b/ui/cocoa/view.m
@@ -0,0 +1,27 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define UI_COCOA_VIEW
+#include "ui/cocoa.h"
+
diff --git a/ui/meson.build b/ui/meson.build
index 0b702e701673..eda12af962a0 100644
--- a/ui/meson.build
+++ b/ui/meson.build
@@ -24,7 +24,9 @@ softmmu_ss.add(when: 'CONFIG_LINUX', if_true: files(
   'input-linux.c',
   'udmabuf.c',
 ))
-softmmu_ss.add(when: cocoa, if_true: files('cocoa.m'))
+softmmu_ss.add(when: cocoa,
+               if_true: files('cocoa/main.m', 'cocoa/pasteboard_type_owner.m',
+                              'cocoa/view.m', 'cocoa/app_controller.m'))
 
 vnc_ss = ss.source_set()
 vnc_ss.add(files(

From 85af43269174b6310e5d5d516eea47e4f932134c Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Wed, 14 Jul 2021 13:04:55 +0900
Subject: [PATCH 163/180] ui/cocoa: Divide ui/cocoa.m

---
 include/ui/cocoa.h               | 2519 ------------------------------
 ui/cocoa/app_controller.m        |  421 ++++-
 ui/cocoa/main.m                  | 1066 ++++++++++++-
 ui/cocoa/pasteboard_type_owner.m |   51 +-
 ui/cocoa/view.m                  |  949 ++++++++++-
 5 files changed, 2483 insertions(+), 2523 deletions(-)

diff --git a/include/ui/cocoa.h b/include/ui/cocoa.h
index 06dd9e7d8935..c711290006f8 100644
--- a/include/ui/cocoa.h
+++ b/include/ui/cocoa.h
@@ -25,79 +25,13 @@
 #ifndef UI_COCOA_H
 #define UI_COCOA_H
 
-#ifdef UI_COCOA_MAIN
-#define GL_SILENCE_DEPRECATION
-#endif
-
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_PASTEBOARD_TYPE_OWNER) || defined(UI_COCOA_VIEW)
-#include "qemu/osdep.h"
-#endif
-
 #import <Cocoa/Cocoa.h>
-#ifdef UI_COCOA_MAIN
-#include <crt_externs.h>
-#endif
 
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER)
-#include "qemu-common.h"
-#endif
 #include "ui/clipboard.h"
 #include "ui/console.h"
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_VIEW)
-#include "ui/input.h"
-#endif
 #include "ui/kbd-state.h"
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER) || defined(UI_COCOA_VIEW)
-#include "sysemu/sysemu.h"
-#endif
-#ifdef UI_COCOA_APP_CONTROLLER
-#include "sysemu/runstate.h"
-#include "sysemu/cpu-throttle.h"
-#include "qapi/error.h"
-#endif
-#if defined(UI_COCOA_MAIN) || defined(UI_COCOA_APP_CONTROLLER)
-#include "qapi/qapi-commands-block.h"
-#endif
-#ifdef UI_COCOA_APP_CONTROLLER
-#include "qapi/qapi-commands-machine.h"
-#include "qapi/qapi-commands-misc.h"
-#include "sysemu/blockdev.h"
-#include "qemu-version.h"
-#include "qemu/cutils.h"
-#endif
 #include "qemu/main-loop.h"
-#ifdef UI_COCOA_APP_CONTROLLER
-#include "qemu/module.h"
-#endif
-#ifdef UI_COCOA_VIEW
-#include "qemu/error-report.h"
-#include <Carbon/Carbon.h>
-#endif
 #include "qemu/thread.h"
-#ifdef UI_COCOA_APP_CONTROLLER
-#include "hw/core/cpu.h"
-#endif
-
-#ifdef UI_COCOA_MAIN
-#ifdef CONFIG_EGL
-#include "ui/egl-context.h"
-#endif
-#endif
-
-#ifdef UI_COCOA_APP_CONTROLLER
-#ifndef MAC_OS_X_VERSION_10_13
-#define MAC_OS_X_VERSION_10_13 101300
-#endif
-
-/* 10.14 deprecates NSOnState and NSOffState in favor of
- * NSControlStateValueOn/Off, which were introduced in 10.13.
- * Define for older versions
- */
-#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_13
-#define NSControlStateValueOn NSOnState
-#define NSControlStateValueOff NSOffState
-#endif
-#endif
 
 //#define DEBUG
 
@@ -107,10 +41,6 @@
 #define COCOA_DEBUG(...)  ((void) 0)
 #endif
 
-#ifdef UI_COCOA_VIEW
-#define cgrect(nsrect) (*(CGRect *)&(nsrect))
-#endif
-
 typedef struct CocoaListener {
     DisplayChangeListener dcl;
     QEMUCursor *cursor;
@@ -208,2453 +138,4 @@ void cocoa_listener_select(size_t index);
 typedef void (^CodeBlock)(void);
 typedef bool (^BoolCodeBlock)(void);
 
-#ifdef UI_COCOA_MAIN
-static QEMUScreen screen;
-static QemuCocoaAppController *appController;
-static bool have_cocoa_ui;
-
-static NSInteger cbchangecount = -1;
-static QemuClipboardPeer cbpeer;
-static QemuCocoaClipboard qemucb;
-static QemuCocoaPasteboardTypeOwner *cbowner;
-
-#ifdef CONFIG_OPENGL
-
-static GLuint cursor_texture;
-static bool gl_dirty;
-static QEMUGLContext view_ctx;
-
-#ifdef CONFIG_EGL
-static EGLSurface egl_surface;
-#endif
-
-static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
-                                       DisplayChangeListener *dcl);
-
-static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
-                                             QEMUGLParams *params);
-
-static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx);
-
-static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx);
-
-static const DisplayGLCtxOps dgc_ops = {
-    .dpy_gl_ctx_is_compatible_dcl = cocoa_gl_is_compatible_dcl,
-    .dpy_gl_ctx_create            = cocoa_gl_create_context,
-    .dpy_gl_ctx_destroy           = cocoa_gl_destroy_context,
-    .dpy_gl_ctx_make_current      = cocoa_gl_make_context_current,
-};
-
-static DisplayGLCtx dgc = {
-    .ops = &dgc_ops,
-};
-
-#endif
-#endif
-
-#ifdef UI_COCOA_VIEW
-// Utility functions to run specified code block with iothread lock held
-static void with_iothread_lock(CodeBlock block)
-{
-    bool locked = qemu_mutex_iothread_locked();
-    if (!locked) {
-        qemu_mutex_lock_iothread();
-    }
-    block();
-    if (!locked) {
-        qemu_mutex_unlock_iothread();
-    }
-}
-
-static bool bool_with_iothread_lock(BoolCodeBlock block)
-{
-    bool locked = qemu_mutex_iothread_locked();
-    bool val;
-
-    if (!locked) {
-        qemu_mutex_lock_iothread();
-    }
-    val = block();
-    if (!locked) {
-        qemu_mutex_unlock_iothread();
-    }
-    return val;
-}
-#endif
-
-#ifdef UI_COCOA_MAIN
-/*
- * The startup process for the OSX/Cocoa UI is complicated, because
- * OSX insists that the UI runs on the initial main thread, and so we
- * need to start a second thread which runs qemu_main_loop():
- *
- * Initial thread:                    2nd thread:
- * in main():
- *  qemu_init()
- *  create main loop thread
- *  enter OSX run loop                call qemu_main_loop()
- */
-
-static void *call_qemu_main_loop(void *opaque)
-{
-    COCOA_DEBUG("Second thread: calling qemu_main_loop()\n");
-    qemu_mutex_lock_iothread();
-    qemu_main_loop();
-    COCOA_DEBUG("Second thread: qemu_main_loop() returned, exiting\n");
-    qemu_cleanup();
-    qkbd_state_free(screen.kbd);
-    [cbowner release];
-    CGImageRelease(screen.cursor_cgimage);
-#ifdef CONFIG_OPENGL
-    qemu_gl_fini_shader(dgc.gls);
-    if (view_ctx) {
-        cocoa_gl_destroy_context(&dgc, view_ctx);
-    }
-#endif
-    exit(0);
-}
-#endif
-
-#ifdef UI_COCOA_VIEW
-static int cocoa_keycode_to_qemu(int keycode)
-{
-    if (qemu_input_map_osx_to_qcode_len <= keycode) {
-        error_report("(cocoa) warning unknown keycode 0x%x", keycode);
-        return 0;
-    }
-    return qemu_input_map_osx_to_qcode[keycode];
-}
-#endif
-
-#ifdef UI_COCOA_APP_CONTROLLER
-/* Displays an alert dialog box with the specified message */
-static void QEMU_Alert(NSString *message)
-{
-    NSAlert *alert;
-    alert = [NSAlert new];
-    [alert setMessageText: message];
-    [alert runModal];
-}
-
-/* Handles any errors that happen with a device transaction */
-static void handleAnyDeviceErrors(Error * err)
-{
-    if (err) {
-        QEMU_Alert([NSString stringWithCString: error_get_pretty(err)
-                                      encoding: NSASCIIStringEncoding]);
-        error_free(err);
-    }
-}
-#endif
-
-#ifdef UI_COCOA_VIEW
-static CGRect compute_cursor_clip_rect(int screen_height,
-                                       int given_mouse_x, int given_mouse_y,
-                                       int cursor_width, int cursor_height)
-{
-    CGRect rect;
-
-    rect.origin.x = MAX(0, -given_mouse_x);
-    rect.origin.y = 0;
-    rect.size.width = MIN(cursor_width, cursor_width + given_mouse_x);
-    rect.size.height = cursor_height - rect.origin.x;
-
-    return rect;
-}
-
-static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
-{
-    QemuCocoaView *cocoaView = userInfo;
-    NSEvent *event = [NSEvent eventWithCGEvent:cgEvent];
-    if ([cocoaView isMouseGrabbed] && [cocoaView handleEvent:event]) {
-        COCOA_DEBUG("Global events tap: qemu handled the event, capturing!\n");
-        return NULL;
-    }
-    COCOA_DEBUG("Global events tap: qemu did not handle the event, letting it through...\n");
-
-    return cgEvent;
-}
-
-@implementation QemuCocoaView
-- (id)initWithFrame:(NSRect)frameRect
-             screen:(QEMUScreen *)given_screen
-{
-    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
-
-    self = [super initWithFrame:frameRect];
-    if (self) {
-
-        screen = given_screen;
-        screen_width = frameRect.size.width;
-        screen_height = frameRect.size.height;
-
-        /* Used for displaying pause on the screen */
-        pauseLabel = [NSTextField new];
-        [pauseLabel setBezeled:YES];
-        [pauseLabel setDrawsBackground:YES];
-        [pauseLabel setBackgroundColor: [NSColor whiteColor]];
-        [pauseLabel setEditable:NO];
-        [pauseLabel setSelectable:NO];
-        [pauseLabel setStringValue: @"Paused"];
-        [pauseLabel setFont: [NSFont fontWithName: @"Helvetica" size: 90]];
-        [pauseLabel setTextColor: [NSColor blackColor]];
-        [pauseLabel sizeToFit];
-
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-    COCOA_DEBUG("QemuCocoaView: dealloc\n");
-
-    if (pauseLabel) {
-        [pauseLabel release];
-    }
-
-    if (eventsTap) {
-        CFRelease(eventsTap);
-    }
-
-    [super dealloc];
-}
-
-- (BOOL) isOpaque
-{
-    return YES;
-}
-
-- (void) removeTrackingRect
-{
-    if (trackingArea) {
-        [self removeTrackingArea:trackingArea];
-        [trackingArea release];
-        trackingArea = nil;
-    }
-}
-
-- (void) frameUpdated
-{
-    [self removeTrackingRect];
-
-    if ([self window]) {
-        NSTrackingAreaOptions options = NSTrackingActiveInKeyWindow |
-                                        NSTrackingMouseEnteredAndExited |
-                                        NSTrackingMouseMoved;
-        trackingArea = [[NSTrackingArea alloc] initWithRect:[self frame]
-                                                    options:options
-                                                      owner:self
-                                                   userInfo:nil];
-        [self addTrackingArea:trackingArea];
-        [self updateUIInfo];
-    }
-}
-
-- (void) viewDidMoveToWindow
-{
-    [self resizeWindow];
-    [self frameUpdated];
-}
-
-- (void) viewWillMoveToWindow:(NSWindow *)newWindow
-{
-    [self removeTrackingRect];
-}
-
-- (void) selectConsoleLocked:(unsigned int)index
-{
-    cocoa_listener_select(index);
-    [self updateUIInfo];
-}
-
-- (void) hideCursor
-{
-    if (screen->cursor_show) {
-        return;
-    }
-    [NSCursor hide];
-}
-
-- (void) unhideCursor
-{
-    if (screen->cursor_show) {
-        return;
-    }
-    [NSCursor unhide];
-}
-
-- (CGRect) convertCursorClipRectToDraw:(CGRect)rect
-                          screenHeight:(int)given_screen_height
-                                mouseX:(int)mouse_x
-                                mouseY:(int)mouse_y
-{
-    CGFloat d = [self frame].size.height / (CGFloat)given_screen_height;
-
-    rect.origin.x = (rect.origin.x + mouse_x) * d;
-    rect.origin.y = (given_screen_height - rect.origin.y - mouse_y - rect.size.height) * d;
-    rect.size.width *= d;
-    rect.size.height *= d;
-
-    return rect;
-}
-
-- (void) drawRect:(NSRect) rect
-{
-    COCOA_DEBUG("QemuCocoaView: drawRect\n");
-
-#ifdef CONFIG_OPENGL
-    if (display_opengl) {
-        return;
-    }
-#endif
-
-    // get CoreGraphic context
-    CGContextRef viewContextRef = [[NSGraphicsContext currentContext] CGContext];
-
-    CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
-    CGContextSetShouldAntialias (viewContextRef, NO);
-
-    qemu_mutex_lock(&screen->draw_mutex);
-
-    // draw screen bitmap directly to Core Graphics context
-    if (!screen->surface) {
-        // Draw request before any guest device has set up a framebuffer:
-        // just draw an opaque black rectangle
-        CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
-        CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
-    } else {
-        int w = surface_width(screen->surface);
-        int h = surface_height(screen->surface);
-        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(screen->surface));
-        int stride = surface_stride(screen->surface);
-
-        CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
-            NULL,
-            surface_data(screen->surface),
-            stride * h,
-            NULL
-        );
-        CGImageRef imageRef = CGImageCreate(
-            w, //width
-            h, //height
-            DIV_ROUND_UP(bitsPerPixel, 8) * 2, //bitsPerComponent
-            bitsPerPixel, //bitsPerPixel
-            stride, //bytesPerRow
-            CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
-            kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipFirst, //bitmapInfo
-            dataProviderRef, //provider
-            NULL, //decode
-            0, //interpolate
-            kCGRenderingIntentDefault //intent
-        );
-        // selective drawing code (draws only dirty rectangles) (OS X >= 10.4)
-        const NSRect *rectList;
-        NSInteger rectCount;
-        int i;
-        CGImageRef clipImageRef;
-        CGRect clipRect;
-        CGFloat d = (CGFloat)h / [self frame].size.height;
-
-        [self getRectsBeingDrawn:&rectList count:&rectCount];
-        for (i = 0; i < rectCount; i++) {
-            clipRect.origin.x = rectList[i].origin.x * d;
-            clipRect.origin.y = (float)h - (rectList[i].origin.y + rectList[i].size.height) * d;
-            clipRect.size.width = rectList[i].size.width * d;
-            clipRect.size.height = rectList[i].size.height * d;
-            clipImageRef = CGImageCreateWithImageInRect(
-                                                        imageRef,
-                                                        clipRect
-                                                        );
-            CGContextDrawImage (viewContextRef, cgrect(rectList[i]), clipImageRef);
-            CGImageRelease (clipImageRef);
-        }
-        CGImageRelease (imageRef);
-        CGDataProviderRelease(dataProviderRef);
-
-        if (screen->active_listener->mouse_on) {
-            size_t cursor_width = CGImageGetWidth(screen->cursor_cgimage);
-            size_t cursor_height = CGImageGetHeight(screen->cursor_cgimage);
-            int mouse_x = screen->active_listener->mouse_x;
-            int mouse_y = screen->active_listener->mouse_y;
-            clipRect = compute_cursor_clip_rect(h, mouse_x, mouse_y,
-                                                cursor_width,
-                                                cursor_height);
-            CGRect drawRect = [self convertCursorClipRectToDraw:clipRect
-                                                   screenHeight:h
-                                                         mouseX:mouse_x
-                                                         mouseY:mouse_y];
-            clipImageRef = CGImageCreateWithImageInRect(
-                                                        screen->cursor_cgimage,
-                                                        clipRect
-                                                        );
-            CGContextDrawImage(viewContextRef, drawRect, clipImageRef);
-            CGImageRelease (clipImageRef);
-        }
-    }
-
-    qemu_mutex_unlock(&screen->draw_mutex);
-}
-
-- (NSSize) computeUnzoomedSize
-{
-    CGFloat width = screen_width / [[self window] backingScaleFactor];
-    CGFloat height = screen_height / [[self window] backingScaleFactor];
-
-    return NSMakeSize(width, height);
-}
-
-- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
-{
-    NSSize size;
-
-    size.width = (CGFloat)screen_width * proposedSize.height;
-    size.height = (CGFloat)screen_height * proposedSize.width;
-
-    if (size.width < size.height) {
-        size.width /= screen_height;
-        size.height = proposedSize.height;
-    } else {
-        size.width = proposedSize.width;
-        size.height /= screen_width;
-    }
-
-    return size;
-}
-
-- (void) resizeWindow
-{
-    [[self window] setContentAspectRatio:NSMakeSize(screen_width, screen_height)];
-
-    if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
-        [[self window] setContentSize:[self computeUnzoomedSize]];
-        [[self window] center];
-    } else if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
-        [[self window] setContentSize:[self fixZoomedFullScreenSize:[[[self window] screen] frame].size]];
-        [[self window] center];
-    }
-}
-
-- (void) updateUIInfoLocked
-{
-    /* Must be called with the iothread lock, i.e. via updateUIInfo */
-    NSSize frameSize;
-    QemuUIInfo info = {};
-
-    if ([self window]) {
-        NSDictionary *description = [[[self window] screen] deviceDescription];
-        CGDirectDisplayID display = [[description objectForKey:@"NSScreenNumber"] unsignedIntValue];
-        NSSize screenSize = [[[self window] screen] frame].size;
-        CGSize screenPhysicalSize = CGDisplayScreenSize(display);
-        CVDisplayLinkRef displayLink;
-
-        if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) == 0) {
-            frameSize = [self frame].size;
-        } else {
-            frameSize = screenSize;
-        }
-
-        if (!CVDisplayLinkCreateWithCGDisplay(display, &displayLink)) {
-            CVTime period = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink);
-            CVDisplayLinkRelease(displayLink);
-            if (!(period.flags & kCVTimeIsIndefinite)) {
-                update_displaychangelistener(&screen->active_listener->dcl,
-                                             1000 * period.timeValue / period.timeScale);
-                info.refresh_rate = (int64_t)1000 * period.timeScale / period.timeValue;
-            }
-        }
-
-        info.width_mm = frameSize.width / screenSize.width * screenPhysicalSize.width;
-        info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
-    } else {
-        frameSize = [self frame].size;
-    }
-
-    NSSize frameBackingSize = [self convertSizeToBacking:frameSize];
-
-    info.width = frameBackingSize.width;
-    info.height = frameBackingSize.height;
-
-    dpy_set_ui_info(screen->active_listener->dcl.con, &info, TRUE);
-}
-
-- (void) updateUIInfo
-{
-    if (!screen->listeners) {
-        /*
-         * Don't try to tell QEMU about UI information in the application
-         * startup phase -- we haven't yet registered dcl with the QEMU UI
-         * layer, and also trying to take the iothread lock would deadlock.
-         * When cocoa_display_init() does register the dcl, the UI layer
-         * will call cocoa_switch(), which will call updateUIInfo, so
-         * we don't lose any information here.
-         */
-        return;
-    }
-
-    with_iothread_lock(^{
-        [self updateUIInfoLocked];
-    });
-}
-
-- (void) updateScreenWidth:(int)w height:(int)h
-{
-    COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
-
-    if (w != screen_width || h != screen_height) {
-        COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
-        screen_width = w;
-        screen_height = h;
-        [self resizeWindow];
-    }
-}
-
-- (void) setFullGrab:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaView: setFullGrab\n");
-
-    CGEventMask mask = CGEventMaskBit(kCGEventKeyDown) | CGEventMaskBit(kCGEventKeyUp) | CGEventMaskBit(kCGEventFlagsChanged);
-    eventsTap = CGEventTapCreate(kCGHIDEventTap, kCGHeadInsertEventTap, kCGEventTapOptionDefault,
-                                 mask, handleTapEvent, self);
-    if (!eventsTap) {
-        warn_report("Could not create event tap, system key combos will not be captured.\n");
-        return;
-    } else {
-        COCOA_DEBUG("Global events tap created! Will capture system key combos.\n");
-    }
-
-    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
-    if (!runLoop) {
-        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
-        return;
-    }
-
-    CFRunLoopSourceRef tapEventsSrc = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventsTap, 0);
-    if (!tapEventsSrc ) {
-        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
-        return;
-    }
-
-    CFRunLoopAddSource(runLoop, tapEventsSrc, kCFRunLoopDefaultMode);
-    CFRelease(tapEventsSrc);
-}
-
-- (void) toggleKey: (int)keycode {
-    qkbd_state_key_event(screen->kbd, keycode, !qkbd_state_key_get(screen->kbd, keycode));
-}
-
-// Does the work of sending input to the monitor
-- (void) handleMonitorInput:(NSEvent *)event
-{
-    int keysym = 0;
-    int control_key = 0;
-
-    // if the control key is down
-    if ([event modifierFlags] & NSEventModifierFlagControl) {
-        control_key = 1;
-    }
-
-    /* translates Macintosh keycodes to QEMU's keysym */
-
-    static const int without_control_translation[] = {
-        [0 ... 0xff] = 0,   // invalid key
-
-        [kVK_UpArrow]       = QEMU_KEY_UP,
-        [kVK_DownArrow]     = QEMU_KEY_DOWN,
-        [kVK_RightArrow]    = QEMU_KEY_RIGHT,
-        [kVK_LeftArrow]     = QEMU_KEY_LEFT,
-        [kVK_Home]          = QEMU_KEY_HOME,
-        [kVK_End]           = QEMU_KEY_END,
-        [kVK_PageUp]        = QEMU_KEY_PAGEUP,
-        [kVK_PageDown]      = QEMU_KEY_PAGEDOWN,
-        [kVK_ForwardDelete] = QEMU_KEY_DELETE,
-        [kVK_Delete]        = QEMU_KEY_BACKSPACE,
-    };
-
-    static const int with_control_translation[] = {
-        [0 ... 0xff] = 0,   // invalid key
-
-        [kVK_UpArrow]       = QEMU_KEY_CTRL_UP,
-        [kVK_DownArrow]     = QEMU_KEY_CTRL_DOWN,
-        [kVK_RightArrow]    = QEMU_KEY_CTRL_RIGHT,
-        [kVK_LeftArrow]     = QEMU_KEY_CTRL_LEFT,
-        [kVK_Home]          = QEMU_KEY_CTRL_HOME,
-        [kVK_End]           = QEMU_KEY_CTRL_END,
-        [kVK_PageUp]        = QEMU_KEY_CTRL_PAGEUP,
-        [kVK_PageDown]      = QEMU_KEY_CTRL_PAGEDOWN,
-    };
-
-    if (control_key != 0) { /* If the control key is being used */
-        if ([event keyCode] < ARRAY_SIZE(with_control_translation)) {
-            keysym = with_control_translation[[event keyCode]];
-        }
-    } else {
-        if ([event keyCode] < ARRAY_SIZE(without_control_translation)) {
-            keysym = without_control_translation[[event keyCode]];
-        }
-    }
-
-    // if not a key that needs translating
-    if (keysym == 0) {
-        NSString *ks = [event characters];
-        if ([ks length] > 0) {
-            keysym = [ks characterAtIndex:0];
-        }
-    }
-
-    if (keysym) {
-        kbd_put_keysym_console(screen->active_listener->dcl.con, keysym);
-    }
-}
-
-- (bool) handleEvent:(NSEvent *)event
-{
-    if(!screen->listeners) {
-        return false;
-    }
-
-    return bool_with_iothread_lock(^{
-        return [self handleEventLocked:event];
-    });
-}
-
-- (bool) handleEventLocked:(NSEvent *)event
-{
-    /* Return true if we handled the event, false if it should be given to OSX */
-    COCOA_DEBUG("QemuCocoaView: handleEvent\n");
-    int buttons = 0;
-    int keycode = 0;
-    NSUInteger modifiers = [event modifierFlags];
-
-    /*
-     * Check -[NSEvent modifierFlags] here.
-     *
-     * There is a NSEventType for an event notifying the change of
-     * -[NSEvent modifierFlags], NSEventTypeFlagsChanged but these operations
-     * are performed for any events because a modifier state may change while
-     * the application is inactive (i.e. no events fire) and we don't want to
-     * wait for another modifier state change to detect such a change.
-     *
-     * NSEventModifierFlagCapsLock requires a special treatment. The other flags
-     * are handled in similar manners.
-     *
-     * NSEventModifierFlagCapsLock
-     * ---------------------------
-     *
-     * If CapsLock state is changed, "up" and "down" events will be fired in
-     * sequence, effectively updates CapsLock state on the guest.
-     *
-     * The other flags
-     * ---------------
-     *
-     * If a flag is not set, fire "up" events for all keys which correspond to
-     * the flag. Note that "down" events are not fired here because the flags
-     * checked here do not tell what exact keys are down.
-     *
-     * If one of the keys corresponding to a flag is down, we rely on
-     * -[NSEvent keyCode] of an event whose -[NSEvent type] is
-     * NSEventTypeFlagsChanged to know the exact key which is down, which has
-     * the following two downsides:
-     * - It does not work when the application is inactive as described above.
-     * - It malfactions *after* the modifier state is changed while the
-     *   application is inactive. It is because -[NSEvent keyCode] does not tell
-     *   if the key is up or down, and requires to infer the current state from
-     *   the previous state. It is still possible to fix such a malfanction by
-     *   completely leaving your hands from the keyboard, which hopefully makes
-     *   this implementation usable enough.
-     */
-    if (!!(modifiers & NSEventModifierFlagCapsLock) !=
-        qkbd_state_modifier_get(screen->kbd, QKBD_MOD_CAPSLOCK)) {
-        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CAPS_LOCK, true);
-        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CAPS_LOCK, false);
-    }
-
-    if (!(modifiers & NSEventModifierFlagShift)) {
-        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_SHIFT, false);
-        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_SHIFT_R, false);
-    }
-    if (!(modifiers & NSEventModifierFlagControl)) {
-        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CTRL, false);
-        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CTRL_R, false);
-    }
-    if (!(modifiers & NSEventModifierFlagOption)) {
-        if (screen->swap_opt_cmd) {
-            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_L, false);
-            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_R, false);
-        } else {
-            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT, false);
-            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT_R, false);
-        }
-    }
-    if (!(modifiers & NSEventModifierFlagCommand)) {
-        if (screen->swap_opt_cmd) {
-            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT, false);
-            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT_R, false);
-        } else {
-            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_L, false);
-            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_R, false);
-        }
-    }
-
-    switch ([event type]) {
-        case NSEventTypeFlagsChanged:
-            switch ([event keyCode]) {
-                case kVK_Shift:
-                    if (!!(modifiers & NSEventModifierFlagShift)) {
-                        [self toggleKey:Q_KEY_CODE_SHIFT];
-                    }
-                    return true;
-
-                case kVK_RightShift:
-                    if (!!(modifiers & NSEventModifierFlagShift)) {
-                        [self toggleKey:Q_KEY_CODE_SHIFT_R];
-                    }
-                    return true;
-
-                case kVK_Control:
-                    if (!!(modifiers & NSEventModifierFlagControl)) {
-                        [self toggleKey:Q_KEY_CODE_CTRL];
-                    }
-                    return true;
-
-                case kVK_RightControl:
-                    if (!!(modifiers & NSEventModifierFlagControl)) {
-                        [self toggleKey:Q_KEY_CODE_CTRL_R];
-                    }
-                    return true;
-
-                case kVK_Option:
-                    if (!!(modifiers & NSEventModifierFlagOption)) {
-                        if (screen->swap_opt_cmd) {
-                            [self toggleKey:Q_KEY_CODE_META_L];
-                        } else {
-                            [self toggleKey:Q_KEY_CODE_ALT];
-                        }
-                    }
-                    return true;
-
-                case kVK_RightOption:
-                    if (!!(modifiers & NSEventModifierFlagOption)) {
-                        if (screen->swap_opt_cmd) {
-                            [self toggleKey:Q_KEY_CODE_META_R];
-                        } else {
-                            [self toggleKey:Q_KEY_CODE_ALT_R];
-                        }
-                    }
-                    return true;
-
-                /* Don't pass command key changes to guest unless mouse is grabbed */
-                case kVK_Command:
-                    if (isMouseGrabbed &&
-                        !!(modifiers & NSEventModifierFlagCommand) &&
-                        !screen->left_command_key_disabled) {
-                        if (screen->swap_opt_cmd) {
-                            [self toggleKey:Q_KEY_CODE_ALT];
-                        } else {
-                            [self toggleKey:Q_KEY_CODE_META_L];
-                        }
-                    }
-                    return true;
-
-                case kVK_RightCommand:
-                    if (isMouseGrabbed &&
-                        !!(modifiers & NSEventModifierFlagCommand)) {
-                        if (screen->swap_opt_cmd) {
-                            [self toggleKey:Q_KEY_CODE_ALT_R];
-                        } else {
-                            [self toggleKey:Q_KEY_CODE_META_R];
-                        }
-                    }
-                    return true;
-
-                default:
-                    return true;
-            }
-        case NSEventTypeKeyDown:
-            keycode = cocoa_keycode_to_qemu([event keyCode]);
-
-            // forward command key combos to the host UI unless the mouse is grabbed
-            if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
-                return false;
-            }
-
-            // default
-
-            // handle control + alt Key Combos (ctrl+alt+[1..9,g] is reserved for QEMU)
-            if (([event modifierFlags] & NSEventModifierFlagControl) && ([event modifierFlags] & NSEventModifierFlagOption)) {
-                NSString *keychar = [event charactersIgnoringModifiers];
-                if ([keychar length] == 1) {
-                    char key = [keychar characterAtIndex:0];
-                    switch (key) {
-
-                        // enable graphic console
-                        case '1' ... '9':
-                            [self selectConsoleLocked:key - '0' - 1]; /* ascii math */
-                            return true;
-
-                        // release the mouse grab
-                        case 'g':
-                            [self ungrabMouseLocked];
-                            return true;
-                    }
-                }
-            }
-
-            if (qemu_console_is_graphic(screen->active_listener->dcl.con)) {
-                qkbd_state_key_event(screen->kbd, keycode, true);
-            } else {
-                [self handleMonitorInput: event];
-            }
-            return true;
-        case NSEventTypeKeyUp:
-            keycode = cocoa_keycode_to_qemu([event keyCode]);
-
-            // don't pass the guest a spurious key-up if we treated this
-            // command-key combo as a host UI action
-            if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
-                return true;
-            }
-
-            if (qemu_console_is_graphic(screen->active_listener->dcl.con)) {
-                qkbd_state_key_event(screen->kbd, keycode, false);
-            }
-            return true;
-        case NSEventTypeScrollWheel:
-            /*
-             * Send wheel events to the guest regardless of window focus.
-             * This is in-line with standard Mac OS X UI behaviour.
-             */
-
-            /*
-             * We shouldn't have got a scroll event when deltaY and delta Y
-             * are zero, hence no harm in dropping the event
-             */
-            if ([event deltaY] != 0 || [event deltaX] != 0) {
-            /* Determine if this is a scroll up or scroll down event */
-                if ([event deltaY] != 0) {
-                  buttons = ([event deltaY] > 0) ?
-                    INPUT_BUTTON_WHEEL_UP : INPUT_BUTTON_WHEEL_DOWN;
-                } else if ([event deltaX] != 0) {
-                  buttons = ([event deltaX] > 0) ?
-                    INPUT_BUTTON_WHEEL_LEFT : INPUT_BUTTON_WHEEL_RIGHT;
-                }
-
-                qemu_input_queue_btn(screen->active_listener->dcl.con, buttons, true);
-                qemu_input_event_sync();
-                qemu_input_queue_btn(screen->active_listener->dcl.con, buttons, false);
-                qemu_input_event_sync();
-            }
-
-            /*
-             * Since deltaX/deltaY also report scroll wheel events we prevent mouse
-             * movement code from executing.
-             */
-            return true;
-        default:
-            return false;
-    }
-}
-
-- (void) handleMouseEvent:(NSEvent *)event
-{
-    if (!isMouseGrabbed) {
-        return;
-    }
-
-    with_iothread_lock(^{
-        QemuConsole *con = screen->active_listener->dcl.con;
-
-        if (isAbsoluteEnabled) {
-            CGFloat d = (CGFloat)screen_height / [self frame].size.height;
-            NSPoint p = [event locationInWindow];
-            // Note that the origin for Cocoa mouse coords is bottom left, not top left.
-            qemu_input_queue_abs(con, INPUT_AXIS_X, p.x * d, 0, screen_width);
-            qemu_input_queue_abs(con, INPUT_AXIS_Y, screen_height - p.y * d, 0, screen_height);
-        } else {
-            CGFloat d = (CGFloat)screen_height / [self convertSizeToBacking:[self frame].size].height;
-            qemu_input_queue_rel(con, INPUT_AXIS_X, [event deltaX] * d);
-            qemu_input_queue_rel(con, INPUT_AXIS_Y, [event deltaY] * d);
-        }
-
-        qemu_input_event_sync();
-    });
-}
-
-- (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool)down
-{
-    if (!isMouseGrabbed) {
-        return;
-    }
-
-    with_iothread_lock(^{
-        qemu_input_queue_btn(screen->active_listener->dcl.con, button, down);
-    });
-
-    [self handleMouseEvent:event];
-}
-
-- (void) mouseExited:(NSEvent *)event
-{
-    if (isAbsoluteEnabled && isMouseGrabbed) {
-        [self ungrabMouse];
-    }
-}
-
-- (void) mouseEntered:(NSEvent *)event
-{
-    if (isAbsoluteEnabled && !isMouseGrabbed) {
-        [self grabMouse];
-    }
-}
-
-- (void) mouseMoved:(NSEvent *)event
-{
-    [self handleMouseEvent:event];
-}
-
-- (void) mouseDown:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:true];
-}
-
-- (void) rightMouseDown:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:true];
-}
-
-- (void) otherMouseDown:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:true];
-}
-
-- (void) mouseDragged:(NSEvent *)event
-{
-    [self handleMouseEvent:event];
-}
-
-- (void) rightMouseDragged:(NSEvent *)event
-{
-    [self handleMouseEvent:event];
-}
-
-- (void) otherMouseDragged:(NSEvent *)event
-{
-    [self handleMouseEvent:event];
-}
-
-- (void) mouseUp:(NSEvent *)event
-{
-    if (!isMouseGrabbed) {
-        [self grabMouse];
-    }
-
-    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:false];
-}
-
-- (void) rightMouseUp:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:false];
-}
-
-- (void) otherMouseUp:(NSEvent *)event
-{
-    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:false];
-}
-
-- (void) grabMouse
-{
-    COCOA_DEBUG("QemuCocoaView: grabMouse\n");
-
-    if (!screen->listeners) {
-        return;
-    }
-
-    if (qemu_name)
-        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
-    else
-        [[self window] setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
-    [self hideCursor];
-    CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
-    isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
-}
-
-- (void) ungrabMouse
-{
-    with_iothread_lock(^{
-        [self ungrabMouseLocked];
-    });
-}
-
-- (void) ungrabMouseLocked
-{
-    COCOA_DEBUG("QemuCocoaView: ungrabMouseLocked\n");
-
-    if (qemu_name)
-        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
-    else
-        [[self window] setTitle:@"QEMU"];
-    [self unhideCursor];
-    CGAssociateMouseAndMouseCursorPosition(TRUE);
-    isMouseGrabbed = FALSE;
-    [self raiseAllButtonsLocked];
-}
-
-- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
-    isAbsoluteEnabled = tIsAbsoluteEnabled;
-    if (isMouseGrabbed) {
-        CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
-    }
-}
-- (BOOL) isMouseGrabbed {return isMouseGrabbed;}
-- (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
-
-- (void) raiseAllButtonsLocked
-{
-    QemuConsole *con = screen->active_listener->dcl.con;
-
-    qemu_input_queue_btn(con, INPUT_BUTTON_LEFT, false);
-    qemu_input_queue_btn(con, INPUT_BUTTON_RIGHT, false);
-    qemu_input_queue_btn(con, INPUT_BUTTON_MIDDLE, false);
-}
-
-- (void) setNeedsDisplayForCursorX:(int)x
-                                 y:(int)y
-                             width:(int)width
-                            height:(int)height
-                      screenHeight:(int)given_screen_height
-{
-    CGRect clip_rect = compute_cursor_clip_rect(given_screen_height, x, y,
-                                                width, height);
-    CGRect draw_rect = [self convertCursorClipRectToDraw:clip_rect
-                                            screenHeight:given_screen_height
-                                                  mouseX:x
-                                                  mouseY:y];
-    [self setNeedsDisplayInRect:draw_rect];
-}
-
-/* Displays the word pause on the screen */
-- (void)displayPause
-{
-    /* Coordinates have to be calculated each time because the window can change its size */
-    int xCoord, yCoord, width, height;
-    xCoord = ([[self window] frame].size.width - [pauseLabel frame].size.width)/2;
-    yCoord = [[self window] frame].size.height - [pauseLabel frame].size.height - ([pauseLabel frame].size.height * .5);
-    width = [pauseLabel frame].size.width;
-    height = [pauseLabel frame].size.height;
-    [pauseLabel setFrame: NSMakeRect(xCoord, yCoord, width, height)];
-    [self addSubview: pauseLabel];
-}
-
-/* Removes the word pause from the screen */
-- (void)removePause
-{
-    [pauseLabel removeFromSuperview];
-}
-@end
-#endif
-
-#ifdef UI_COCOA_APP_CONTROLLER
-@implementation QemuCocoaAppController
-- (id) initWithScreen:(QEMUScreen *)screen
-{
-    COCOA_DEBUG("%s\n", __func__);
-
-    self = [super init];
-    if (self) {
-        // create a view and add it to the window
-        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)
-                                                  screen:screen];
-        if(!cocoaView) {
-            error_report("(cocoa) can't create a view");
-            exit(1);
-        }
-
-        // create a window
-        NSWindow *normalWindow = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
-            styleMask:NSWindowStyleMaskTitled|NSWindowStyleMaskMiniaturizable|NSWindowStyleMaskClosable
-            backing:NSBackingStoreBuffered defer:NO];
-        if(!normalWindow) {
-            error_report("(cocoa) can't create window");
-            exit(1);
-        }
-        [normalWindow setAcceptsMouseMovedEvents:YES];
-        [normalWindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
-        [normalWindow setTitle:qemu_name ? [NSString stringWithFormat:@"QEMU %s", qemu_name] : @"QEMU"];
-        [normalWindow setContentView:cocoaView];
-        [normalWindow makeKeyAndOrderFront:self];
-        [normalWindow center];
-        [normalWindow setDelegate: self];
-        [normalWindow release];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-    COCOA_DEBUG("QemuCocoaAppController: dealloc\n");
-
-    if (cocoaView)
-        [cocoaView release];
-    [super dealloc];
-}
-
-- (void)applicationWillTerminate:(NSNotification *)aNotification
-{
-    COCOA_DEBUG("QemuCocoaAppController: applicationWillTerminate\n");
-
-    qemu_system_shutdown_request(SHUTDOWN_CAUSE_HOST_UI);
-
-    /*
-     * Sleep here, because returning will cause OSX to kill us
-     * immediately; the QEMU main loop will handle the shutdown
-     * request and terminate the process.
-     */
-    [NSThread sleepForTimeInterval:INFINITY];
-}
-
-- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)theApplication
-{
-    return YES;
-}
-
-- (NSApplicationTerminateReply)applicationShouldTerminate:
-                                                         (NSApplication *)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: applicationShouldTerminate\n");
-    return [self verifyQuit];
-}
-
-- (void)windowDidChangeScreen:(NSNotification *)notification
-{
-    [cocoaView updateUIInfo];
-}
-
-- (void)windowDidEnterFullScreen:(NSNotification *)notification
-{
-    [cocoaView grabMouse];
-}
-
-- (void)windowDidExitFullScreen:(NSNotification *)notification
-{
-    [cocoaView resizeWindow];
-    [cocoaView ungrabMouse];
-}
-
-- (void)windowDidResize:(NSNotification *)notification
-{
-    [cocoaView frameUpdated];
-}
-
-/* Called when the user clicks on a window's close button */
-- (BOOL)windowShouldClose:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: windowShouldClose\n");
-    [NSApp terminate: sender];
-    /* If the user allows the application to quit then the call to
-     * NSApp terminate will never return. If we get here then the user
-     * cancelled the quit, so we should return NO to not permit the
-     * closing of this window.
-     */
-    return NO;
-}
-
-- (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
-{
-    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
-        return [cocoaView computeUnzoomedSize];
-    }
-
-    return [cocoaView fixZoomedFullScreenSize:proposedSize];
-}
-
-- (NSApplicationPresentationOptions) window:(NSWindow *)window
-                                     willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions;
-
-{
-    return (proposedOptions & ~(NSApplicationPresentationAutoHideDock | NSApplicationPresentationAutoHideMenuBar)) |
-           NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar;
-}
-
-/* Called when QEMU goes into the background */
-- (void) applicationWillResignActive: (NSNotification *)aNotification
-{
-    COCOA_DEBUG("QemuCocoaAppController: applicationWillResignActive\n");
-    [cocoaView ungrabMouse];
-}
-
-/* We abstract the method called by the Enter Fullscreen menu item
- * because Mac OS 10.7 and higher disables it. This is because of the
- * menu item's old selector's name toggleFullScreen:
- */
-- (void) doToggleFullScreen:(id)sender
-{
-    [[cocoaView window] toggleFullScreen:sender];
-}
-
-/* Tries to find then open the specified filename */
-- (void) openDocumentation: (NSString *) filename
-{
-    /* Where to look for local files */
-    NSString *path_array[] = {@"../share/doc/qemu/", @"../doc/qemu/", @"docs/"};
-    NSString *full_file_path;
-    NSURL *full_file_url;
-
-    /* iterate thru the possible paths until the file is found */
-    int index;
-    for (index = 0; index < ARRAY_SIZE(path_array); index++) {
-        full_file_path = [[NSBundle mainBundle] executablePath];
-        full_file_path = [full_file_path stringByDeletingLastPathComponent];
-        full_file_path = [NSString stringWithFormat: @"%@/%@%@", full_file_path,
-                          path_array[index], filename];
-        full_file_url = [NSURL fileURLWithPath: full_file_path
-                                   isDirectory: false];
-        if ([[NSWorkspace sharedWorkspace] openURL: full_file_url] == YES) {
-            return;
-        }
-    }
-
-    /* If none of the paths opened a file */
-    NSBeep();
-    QEMU_Alert(@"Failed to open file");
-}
-
-- (void)showQEMUDoc:(id)sender
-{
-    COCOA_DEBUG("QemuCocoaAppController: showQEMUDoc\n");
-
-    [self openDocumentation: @"index.html"];
-}
-
-/* Toggles the flag which stretches video to fit host window size */
-- (void)zoomToFit:(id) sender
-{
-    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
-        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] | NSWindowStyleMaskResizable];
-        [sender setState: NSControlStateValueOn];
-    } else {
-        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] & ~NSWindowStyleMaskResizable];
-        [cocoaView resizeWindow];
-        [sender setState: NSControlStateValueOff];
-    }
-}
-
-/* Displays the console on the screen */
-- (void)displayConsole:(id)sender
-{
-    qemu_mutex_lock_iothread();
-    [cocoaView selectConsoleLocked:[sender tag]];
-    qemu_mutex_unlock_iothread();
-}
-
-/* Pause the guest */
-- (void)pauseQEMU:(id)sender
-{
-    qemu_mutex_lock_iothread();
-    qmp_stop(NULL);
-    qemu_mutex_unlock_iothread();
-    [sender setEnabled: NO];
-    [[[sender menu] itemWithTitle: @"Resume"] setEnabled: YES];
-    [cocoaView displayPause];
-}
-
-/* Resume running the guest operating system */
-- (void)resumeQEMU:(id) sender
-{
-    qemu_mutex_lock_iothread();
-    qmp_cont(NULL);
-    qemu_mutex_unlock_iothread();
-    [sender setEnabled: NO];
-    [[[sender menu] itemWithTitle: @"Pause"] setEnabled: YES];
-    [cocoaView removePause];
-}
-
-/* Restarts QEMU */
-- (void)restartQEMU:(id)sender
-{
-    qemu_mutex_lock_iothread();
-    qmp_system_reset(NULL);
-    qemu_mutex_unlock_iothread();
-}
-
-/* Powers down QEMU */
-- (void)powerDownQEMU:(id)sender
-{
-    qemu_mutex_lock_iothread();
-    qmp_system_powerdown(NULL);
-    qemu_mutex_unlock_iothread();
-}
-
-/* Ejects the media.
- * Uses sender's tag to figure out the device to eject.
- */
-- (void)ejectDeviceMedia:(id)sender
-{
-    NSString * drive;
-    drive = [sender representedObject];
-    if(drive == nil) {
-        NSBeep();
-        QEMU_Alert(@"Failed to find drive to eject!");
-        return;
-    }
-
-    Error *err = NULL;
-    qemu_mutex_lock_iothread();
-    qmp_eject(true, [drive cStringUsingEncoding: NSASCIIStringEncoding],
-              false, NULL, false, false, &err);
-    qemu_mutex_unlock_iothread();
-    handleAnyDeviceErrors(err);
-}
-
-/* Displays a dialog box asking the user to select an image file to load.
- * Uses sender's represented object value to figure out which drive to use.
- */
-- (void)changeDeviceMedia:(id)sender
-{
-    /* Find the drive name */
-    NSString * drive;
-    drive = [sender representedObject];
-    if(drive == nil) {
-        NSBeep();
-        QEMU_Alert(@"Could not find drive!");
-        return;
-    }
-
-    /* Display the file open dialog */
-    NSOpenPanel * openPanel;
-    openPanel = [NSOpenPanel openPanel];
-    [openPanel setCanChooseFiles: YES];
-    [openPanel setAllowsMultipleSelection: NO];
-    if([openPanel runModal] == NSModalResponseOK) {
-        NSString * file = [[[openPanel URLs] objectAtIndex: 0] path];
-        if(file == nil) {
-            NSBeep();
-            QEMU_Alert(@"Failed to convert URL to file path!");
-            return;
-        }
-
-        Error *err = NULL;
-        qemu_mutex_lock_iothread();
-        qmp_blockdev_change_medium(true,
-                                   [drive cStringUsingEncoding:NSASCIIStringEncoding],
-                                   false, NULL,
-                                   [file cStringUsingEncoding:NSASCIIStringEncoding],
-                                   true, "raw",
-                                   false, 0,
-                                   &err);
-        qemu_mutex_unlock_iothread();
-        handleAnyDeviceErrors(err);
-    }
-}
-
-/* Verifies if the user really wants to quit */
-- (BOOL)verifyQuit
-{
-    NSAlert *alert = [NSAlert new];
-    [alert autorelease];
-    [alert setMessageText: @"Are you sure you want to quit QEMU?"];
-    [alert addButtonWithTitle: @"Cancel"];
-    [alert addButtonWithTitle: @"Quit"];
-    if([alert runModal] == NSAlertSecondButtonReturn) {
-        return YES;
-    } else {
-        return NO;
-    }
-}
-
-/* The action method for the About menu item */
-- (IBAction) do_about_menu_item: (id) sender
-{
-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-    char *icon_path_c = get_relocated_path(CONFIG_QEMU_ICONDIR "/hicolor/512x512/apps/qemu.png");
-    NSString *icon_path = [NSString stringWithUTF8String:icon_path_c];
-    g_free(icon_path_c);
-    NSImage *icon = [[NSImage alloc] initWithContentsOfFile:icon_path];
-    NSString *version = @"QEMU emulator version " QEMU_FULL_VERSION;
-    NSString *copyright = @QEMU_COPYRIGHT;
-    NSDictionary *options;
-    if (icon) {
-        options = @{
-            NSAboutPanelOptionApplicationIcon : icon,
-            NSAboutPanelOptionApplicationVersion : version,
-            @"Copyright" : copyright,
-        };
-        [icon release];
-    } else {
-        options = @{
-            NSAboutPanelOptionApplicationVersion : version,
-            @"Copyright" : copyright,
-        };
-    }
-    [NSApp orderFrontStandardAboutPanelWithOptions:options];
-    [pool release];
-}
-
-/* Used by the Speed menu items */
-- (void)adjustSpeed:(id)sender
-{
-    int throttle_pct; /* throttle percentage */
-    NSMenu *menu;
-
-    menu = [sender menu];
-    if (menu != nil)
-    {
-        /* Unselect the currently selected item */
-        for (NSMenuItem *item in [menu itemArray]) {
-            if (item.state == NSControlStateValueOn) {
-                [item setState: NSControlStateValueOff];
-                break;
-            }
-        }
-    }
-
-    // check the menu item
-    [sender setState: NSControlStateValueOn];
-
-    // get the throttle percentage
-    throttle_pct = [sender tag];
-
-    qemu_mutex_lock_iothread();
-    cpu_throttle_set(throttle_pct);
-    qemu_mutex_unlock_iothread();
-    COCOA_DEBUG("cpu throttling at %d%c\n", cpu_throttle_get_percentage(), '%');
-}
-
-- (QemuCocoaView *)cocoaView
-{
-    return cocoaView;
-}
-
-@end
-#endif
-
-#ifdef UI_COCOA_MAIN
-@interface QemuApplication : NSApplication
-@end
-
-@implementation QemuApplication
-- (void)sendEvent:(NSEvent *)event
-{
-    COCOA_DEBUG("QemuApplication: sendEvent\n");
-    if (![[appController cocoaView] handleEvent:event]) {
-        [super sendEvent: event];
-    }
-}
-@end
-
-static void create_initial_menus(void)
-{
-    // Add menus
-    NSMenu      *menu;
-    NSMenuItem  *menuItem;
-
-    [NSApp setMainMenu:[[NSMenu alloc] init]];
-    [NSApp setServicesMenu:[[NSMenu alloc] initWithTitle:@"Services"]];
-
-    // Application menu
-    menu = [[NSMenu alloc] initWithTitle:@""];
-    [menu addItemWithTitle:@"About QEMU" action:@selector(do_about_menu_item:) keyEquivalent:@""]; // About QEMU
-    [menu addItem:[NSMenuItem separatorItem]]; //Separator
-    menuItem = [menu addItemWithTitle:@"Services" action:nil keyEquivalent:@""];
-    [menuItem setSubmenu:[NSApp servicesMenu]];
-    [menu addItem:[NSMenuItem separatorItem]];
-    [menu addItemWithTitle:@"Hide QEMU" action:@selector(hide:) keyEquivalent:@"h"]; //Hide QEMU
-    menuItem = (NSMenuItem *)[menu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"]; // Hide Others
-    [menuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];
-    [menu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""]; // Show All
-    [menu addItem:[NSMenuItem separatorItem]]; //Separator
-    [menu addItemWithTitle:@"Quit QEMU" action:@selector(terminate:) keyEquivalent:@"q"];
-    menuItem = [[NSMenuItem alloc] initWithTitle:@"Apple" action:nil keyEquivalent:@""];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-    [NSApp performSelector:@selector(setAppleMenu:) withObject:menu]; // Workaround (this method is private since 10.4+)
-
-    // Machine menu
-    menu = [[NSMenu alloc] initWithTitle: @"Machine"];
-    [menu setAutoenablesItems: NO];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Pause" action: @selector(pauseQEMU:) keyEquivalent: @""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Resume" action: @selector(resumeQEMU:) keyEquivalent: @""] autorelease];
-    [menu addItem: menuItem];
-    [menuItem setEnabled: NO];
-    [menu addItem: [NSMenuItem separatorItem]];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Reset" action: @selector(restartQEMU:) keyEquivalent: @""] autorelease]];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Power Down" action: @selector(powerDownQEMU:) keyEquivalent: @""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Machine" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // View menu
-    menu = [[NSMenu alloc] initWithTitle:@"View"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Enter Fullscreen" action:@selector(doToggleFullScreen:) keyEquivalent:@"f"] autorelease]]; // Fullscreen
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Zoom To Fit" action:@selector(zoomToFit:) keyEquivalent:@""] autorelease]];
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"View" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // Speed menu
-    menu = [[NSMenu alloc] initWithTitle:@"Speed"];
-
-    // Add the rest of the Speed menu items
-    int p, percentage, throttle_pct;
-    for (p = 10; p >= 0; p--)
-    {
-        percentage = p * 10 > 1 ? p * 10 : 1; // prevent a 0% menu item
-
-        menuItem = [[[NSMenuItem alloc]
-                   initWithTitle: [NSString stringWithFormat: @"%d%%", percentage] action:@selector(adjustSpeed:) keyEquivalent:@""] autorelease];
-
-        if (percentage == 100) {
-            [menuItem setState: NSControlStateValueOn];
-        }
-
-        /* Calculate the throttle percentage */
-        throttle_pct = -1 * percentage + 100;
-
-        [menuItem setTag: throttle_pct];
-        [menu addItem: menuItem];
-    }
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Speed" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-
-    // Window menu
-    menu = [[NSMenu alloc] initWithTitle:@"Window"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"] autorelease]]; // Miniaturize
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-    [NSApp setWindowsMenu:menu];
-
-    // Help menu
-    menu = [[NSMenu alloc] initWithTitle:@"Help"];
-    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"QEMU Documentation" action:@selector(showQEMUDoc:) keyEquivalent:@"?"] autorelease]]; // QEMU Help
-    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
-    [menuItem setSubmenu:menu];
-    [[NSApp mainMenu] addItem:menuItem];
-}
-
-/* Returns a name for a given console */
-static NSString * getConsoleName(QemuConsole * console)
-{
-    g_autofree char *label = qemu_console_get_label(console);
-
-    return [NSString stringWithUTF8String:label];
-}
-
-/* Add an entry to the View menu for each console */
-static void add_console_menu_entries(void)
-{
-    NSMenu *menu;
-    NSMenuItem *menuItem;
-    size_t index;
-
-    menu = [[[NSApp mainMenu] itemWithTitle:@"View"] submenu];
-
-    [menu addItem:[NSMenuItem separatorItem]];
-
-    for (index = 0; index < screen.listeners_count; index++) {
-        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(screen.listeners[index].dcl.con)
-                                               action: @selector(displayConsole:) keyEquivalent: @""] autorelease];
-        [menuItem setTag: index];
-        [menu addItem: menuItem];
-    }
-}
-
-/* Make menu items for all removable devices.
- * Each device is given an 'Eject' and 'Change' menu item.
- */
-static void addRemovableDevicesMenuItems(void)
-{
-    NSMenu *menu;
-    NSMenuItem *menuItem;
-    BlockInfoList *currentDevice, *pointerToFree;
-    NSString *deviceName;
-
-    currentDevice = qmp_query_block(NULL);
-    pointerToFree = currentDevice;
-
-    menu = [[[NSApp mainMenu] itemWithTitle:@"Machine"] submenu];
-
-    // Add a separator between related groups of menu items
-    [menu addItem:[NSMenuItem separatorItem]];
-
-    // Set the attributes to the "Removable Media" menu item
-    NSString *titleString = @"Removable Media";
-    NSMutableAttributedString *attString=[[NSMutableAttributedString alloc] initWithString:titleString];
-    NSColor *newColor = [NSColor blackColor];
-    NSFontManager *fontManager = [NSFontManager sharedFontManager];
-    NSFont *font = [fontManager fontWithFamily:@"Helvetica"
-                                          traits:NSBoldFontMask|NSItalicFontMask
-                                          weight:0
-                                            size:14];
-    [attString addAttribute:NSFontAttributeName value:font range:NSMakeRange(0, [titleString length])];
-    [attString addAttribute:NSForegroundColorAttributeName value:newColor range:NSMakeRange(0, [titleString length])];
-    [attString addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInt: 1] range:NSMakeRange(0, [titleString length])];
-
-    // Add the "Removable Media" menu item
-    menuItem = [NSMenuItem new];
-    [menuItem setAttributedTitle: attString];
-    [menuItem setEnabled: NO];
-    [menu addItem: menuItem];
-
-    /* Loop through all the block devices in the emulator */
-    while (currentDevice) {
-        deviceName = [[NSString stringWithFormat: @"%s", currentDevice->value->device] retain];
-
-        if(currentDevice->value->removable) {
-            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Change %s...", currentDevice->value->device]
-                                                  action: @selector(changeDeviceMedia:)
-                                           keyEquivalent: @""];
-            [menu addItem: menuItem];
-            [menuItem setRepresentedObject: deviceName];
-            [menuItem autorelease];
-
-            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Eject %s", currentDevice->value->device]
-                                                  action: @selector(ejectDeviceMedia:)
-                                           keyEquivalent: @""];
-            [menu addItem: menuItem];
-            [menuItem setRepresentedObject: deviceName];
-            [menuItem autorelease];
-        }
-        currentDevice = currentDevice->next;
-    }
-    qapi_free_BlockInfoList(pointerToFree);
-}
-#endif
-
-#ifdef UI_COCOA_PASTEBOARD_TYPE_OWNER
-@implementation QemuCocoaPasteboardTypeOwner
-
-- (id)initWith:(QemuCocoaClipboard *)aCb
-{
-    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
-
-    self = [super init];
-    if (self) {
-        cb = aCb;
-    }
-    return self;
-}
-
-- (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
-{
-    if (type != NSPasteboardTypeString) {
-        return;
-    }
-
-    qemu_mutex_lock_iothread();
-
-    QemuClipboardInfo *info = qemu_clipboard_info_ref(cb->info);
-    qemu_event_reset(&cb->event);
-    qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
-
-    while (info == cb->info &&
-           info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
-           info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
-        qemu_mutex_unlock_iothread();
-        qemu_event_wait(&cb->event);
-        qemu_mutex_lock_iothread();
-    }
-
-    if (info == cb->info) {
-        NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
-                                       length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
-        [sender setData:data forType:NSPasteboardTypeString];
-        [data release];
-    }
-
-    qemu_clipboard_info_unref(info);
-
-    qemu_mutex_unlock_iothread();
-}
-
-@end
-#endif
-
-#ifdef UI_COCOA_MAIN
-static void cocoa_clipboard_notify(Notifier *notifier, void *data);
-static void cocoa_clipboard_request(QemuClipboardInfo *info,
-                                    QemuClipboardType type);
-
-static QemuClipboardPeer cbpeer = {
-    .name = "cocoa",
-    .notifier = { .notify = cocoa_clipboard_notify },
-    .request = cocoa_clipboard_request
-};
-
-static void cocoa_clipboard_update_info(QemuClipboardInfo *info)
-{
-    if (info->owner == &cbpeer || info->selection != QEMU_CLIPBOARD_SELECTION_CLIPBOARD) {
-        return;
-    }
-
-    if (info != qemucb.info) {
-        NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-        qemu_clipboard_info_unref(qemucb.info);
-        qemucb.info = qemu_clipboard_info_ref(info);
-        cbchangecount = [[NSPasteboard generalPasteboard] declareTypes:@[NSPasteboardTypeString] owner:cbowner];
-        [pool release];
-    }
-
-    qemu_event_set(&qemucb.event);
-}
-
-static void cocoa_clipboard_notify(Notifier *notifier, void *data)
-{
-    QemuClipboardNotify *notify = data;
-
-    switch (notify->type) {
-    case QEMU_CLIPBOARD_UPDATE_INFO:
-        cocoa_clipboard_update_info(notify->info);
-        return;
-    case QEMU_CLIPBOARD_RESET_SERIAL:
-        /* ignore */
-        return;
-    }
-}
-
-static void cocoa_clipboard_request(QemuClipboardInfo *info,
-                                    QemuClipboardType type)
-{
-    NSData *text;
-
-    switch (type) {
-    case QEMU_CLIPBOARD_TYPE_TEXT:
-        text = [[NSPasteboard generalPasteboard] dataForType:NSPasteboardTypeString];
-        if (text) {
-            qemu_clipboard_set_data(&cbpeer, info, type,
-                                    [text length], [text bytes], true);
-            [text release];
-        }
-        break;
-    default:
-        break;
-    }
-}
-
-int main(int argc, char **argv, char **envp)
-{
-    QemuThread main_thread;
-
-    COCOA_DEBUG("Entered main()\n");
-
-    /* Takes iothread lock.  */
-    qemu_init(argc, argv, envp);
-    if (!have_cocoa_ui) {
-         qemu_main_loop();
-         qemu_cleanup();
-         return 0;
-    }
-
-    qemu_mutex_unlock_iothread();
-    qemu_thread_create(&main_thread, "qemu_main_loop", call_qemu_main_loop,
-                       NULL, QEMU_THREAD_DETACHED);
-
-    // Start the main event loop
-    COCOA_DEBUG("Main thread: entering OSX run loop\n");
-    [NSApp run];
-    COCOA_DEBUG("Main thread: left OSX run loop, exiting\n");
-
-    return 0;
-}
-
-
-
-#pragma mark qemu
-static void cocoa_update(DisplayChangeListener *dcl,
-                         int x, int y, int w, int h)
-{
-    DisplaySurface *updated = screen.surface;
-
-    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
-        return;
-    }
-
-    COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
-
-    dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&screen.draw_mutex);
-        if (updated != screen.surface) {
-            qemu_mutex_unlock(&screen.draw_mutex);
-            return;
-        }
-        int full_height = surface_height(screen.surface);
-        qemu_mutex_unlock(&screen.draw_mutex);
-
-        CGFloat d = [[appController cocoaView] frame].size.height / full_height;
-        NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
-        [[appController cocoaView] setNeedsDisplayInRect:rect];
-    });
-}
-
-static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *new_surface)
-{
-    COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
-
-    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
-        return;
-    }
-
-    qemu_mutex_lock(&screen.draw_mutex);
-    screen.surface = new_surface;
-    qemu_mutex_unlock(&screen.draw_mutex);
-
-    dispatch_async(dispatch_get_main_queue(), ^{
-        qemu_mutex_lock(&screen.draw_mutex);
-        int w = surface_width(screen.surface);
-        int h = surface_height(screen.surface);
-        qemu_mutex_unlock(&screen.draw_mutex);
-
-        [[appController cocoaView] updateScreenWidth:w height:h];
-    });
-}
-
-static void cocoa_refresh(DisplayChangeListener *dcl)
-{
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-
-    COCOA_DEBUG("qemu_cocoa: cocoa_refresh\n");
-
-    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
-        return;
-    }
-
-    graphic_hw_update(dcl->con);
-
-    if (qemu_input_is_absolute()) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            if (![[appController cocoaView] isAbsoluteEnabled]) {
-                if ([[appController cocoaView] isMouseGrabbed]) {
-                    [[appController cocoaView] ungrabMouse];
-                }
-            }
-            [[appController cocoaView] setAbsoluteEnabled:YES];
-        });
-    }
-
-    if (cbchangecount != [[NSPasteboard generalPasteboard] changeCount]) {
-        qemu_clipboard_info_unref(qemucb.info);
-        qemucb.info = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
-        if ([[NSPasteboard generalPasteboard] availableTypeFromArray:@[NSPasteboardTypeString]]) {
-            qemucb.info->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
-        }
-        qemu_clipboard_update(qemucb.info);
-        cbchangecount = [[NSPasteboard generalPasteboard] changeCount];
-        qemu_event_set(&qemucb.event);
-    }
-
-    [pool release];
-}
-
-static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    qemu_mutex_lock(&screen.draw_mutex);
-    int full_height = surface_height(screen.surface);
-    int old_x = listener->mouse_x;
-    int old_y = listener->mouse_y;
-    listener->mouse_x = x;
-    listener->mouse_y = y;
-    listener->mouse_on = on;
-    qemu_mutex_unlock(&screen.draw_mutex);
-
-    if (listener == screen.active_listener && screen.cursor_cgimage) {
-        size_t cursor_width = CGImageGetWidth(screen.cursor_cgimage);
-        size_t cursor_height = CGImageGetHeight(screen.cursor_cgimage);
-
-        dispatch_async(dispatch_get_main_queue(), ^{
-            [[appController cocoaView] setNeedsDisplayForCursorX:old_x
-                                                               y:old_y
-                                                           width:cursor_width
-                                                          height:cursor_height
-                                                    screenHeight:full_height];
-
-            [[appController cocoaView] setNeedsDisplayForCursorX:x
-                                                               y:y
-                                                           width:cursor_width
-                                                          height:cursor_height
-                                                    screenHeight:full_height];
-        });
-    }
-}
-
-static void cocoa_cursor_update()
-{
-    CGImageRef old_image = screen.cursor_cgimage;
-    CGImageRef new_image;
-    CocoaListener *active_listener = screen.active_listener;
-
-    if (active_listener->cursor) {
-        CGDataProviderRef provider = CGDataProviderCreateWithData(
-            NULL,
-            active_listener->cursor->data,
-            active_listener->cursor->width * active_listener->cursor->height * 4,
-            NULL
-        );
-
-        new_image = CGImageCreate(
-            active_listener->cursor->width, //width
-            active_listener->cursor->height, //height
-            8, //bitsPerComponent
-            32, //bitsPerPixel
-            active_listener->cursor->width * 4, //bytesPerRow
-            CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
-            kCGBitmapByteOrder32Little | kCGImageAlphaFirst, //bitmapInfo
-            provider, //provider
-            NULL, //decode
-            0, //interpolate
-            kCGRenderingIntentDefault //intent
-        );
-
-        CGDataProviderRelease(provider);
-    } else {
-        new_image = NULL;
-    }
-
-    qemu_mutex_lock(&screen.draw_mutex);
-    screen.cursor_cgimage = new_image;
-    qemu_mutex_unlock(&screen.draw_mutex);
-
-    CGImageRelease(old_image);
-}
-
-static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    listener->cursor = cursor;
-
-    if (listener == screen.active_listener) {
-        int full_height = surface_height(screen.surface);
-        int width = cursor->width;
-        int height = cursor->height;
-        int x = listener->mouse_x;
-        int y = listener->mouse_y;
-        size_t old_width;
-        size_t old_height;
-
-        if (screen.cursor_cgimage) {
-            old_width = CGImageGetWidth(screen.cursor_cgimage);
-            old_height = CGImageGetHeight(screen.cursor_cgimage);
-        } else {
-            old_width = 0;
-            old_height = 0;
-        }
-
-        cocoa_cursor_update();
-
-        dispatch_async(dispatch_get_main_queue(), ^{
-            CGFloat d = [[appController cocoaView] frame].size.height / full_height;
-            NSRect rect;
-
-            rect.origin.x = d * x;
-            rect.origin.y = d * (full_height - y - old_height);
-            rect.size.width = d * old_width;
-            rect.size.height = d * old_height;
-            [[appController cocoaView] setNeedsDisplayInRect:rect];
-
-            rect.size.width = d * width;
-            rect.size.height = d * height;
-            [[appController cocoaView] setNeedsDisplayInRect:rect];
-        });
-    }
-}
-
-static const DisplayChangeListenerOps dcl_ops = {
-    .dpy_name          = "cocoa",
-    .dpy_gfx_update = cocoa_update,
-    .dpy_gfx_switch = cocoa_switch,
-    .dpy_refresh = cocoa_refresh,
-    .dpy_mouse_set = cocoa_mouse_set,
-    .dpy_cursor_define = cocoa_cursor_define,
-};
-
-#ifdef CONFIG_OPENGL
-
-static void with_view_ctx(CodeBlock block)
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
-        block();
-        return;
-    }
-#endif
-
-    [(NSOpenGLContext *)view_ctx lock];
-    [(NSOpenGLContext *)view_ctx makeCurrentContext];
-    block();
-    [(NSOpenGLContext *)view_ctx unlock];
-}
-
-static NSOpenGLPixelFormat *cocoa_gl_create_ns_pixel_format(int bpp)
-{
-    NSOpenGLPixelFormatAttribute attributes[] = {
-        NSOpenGLPFAOpenGLProfile,
-        NSOpenGLProfileVersion4_1Core,
-        NSOpenGLPFAColorSize,
-        bpp,
-        NSOpenGLPFADoubleBuffer,
-        0,
-    };
-
-    return [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
-}
-
-static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx)
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        EGLSurface current_surface = ctx == EGL_NO_CONTEXT ? EGL_NO_SURFACE : egl_surface;
-        return eglMakeCurrent(qemu_egl_display, current_surface, current_surface, ctx);
-    }
-#endif
-
-    if (ctx) {
-        [(NSOpenGLContext *)ctx makeCurrentContext];
-    } else {
-        [NSOpenGLContext clearCurrentContext];
-    }
-
-    return 0;
-}
-
-static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
-                                             QEMUGLParams *params)
-{
-    NSOpenGLPixelFormat *format;
-    NSOpenGLContext *ctx;
-    int bpp;
-
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
-        return qemu_egl_create_context(dgc, params);
-    }
-#endif
-
-    bpp = PIXMAN_FORMAT_BPP(surface_format(screen.surface));
-    format = cocoa_gl_create_ns_pixel_format(bpp);
-    ctx = [[NSOpenGLContext alloc] initWithFormat:format shareContext:view_ctx];
-    [format release];
-
-    return (QEMUGLContext)ctx;
-}
-
-static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx)
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        eglDestroyContext(qemu_egl_display, ctx);
-        return;
-    }
-#endif
-
-    [(NSOpenGLContext *)ctx release];
-}
-
-static void cocoa_gl_flush()
-{
-#ifdef CONFIG_EGL
-    if (egl_surface) {
-        eglSwapBuffers(qemu_egl_display, egl_surface);
-        return;
-    }
-#endif
-
-    [[NSOpenGLContext currentContext] flushBuffer];
-
-    dispatch_async(dispatch_get_main_queue(), ^{
-        [(NSOpenGLContext *)view_ctx update];
-    });
-}
-
-static void cocoa_gl_update(DisplayChangeListener *dcl,
-                            int x, int y, int w, int h)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    if (listener != screen.active_listener) {
-        return;
-    }
-
-    with_view_ctx(^{
-        surface_gl_update_texture(dgc.gls, screen.surface, x, y, w, h);
-        gl_dirty = true;
-    });
-}
-
-static void cocoa_gl_cursor_render()
-{
-    if (!screen.active_listener->mouse_on) {
-        return;
-    }
-
-    QemuCocoaView *cocoaView = [appController cocoaView];
-    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
-    CGFloat d = size.height / surface_height(screen.surface);
-    CocoaListener *active_listener = screen.active_listener;
-
-    glViewport(
-        d * active_listener->mouse_x,
-        size.height - d * (active_listener->mouse_y + active_listener->cursor->height),
-        d * active_listener->cursor->width,
-        d * active_listener->cursor->height
-    );
-    glBindTexture(GL_TEXTURE_2D, cursor_texture);
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    qemu_gl_run_texture_blit(dgc.gls, false);
-    glDisable(GL_BLEND);
-}
-
-static void cocoa_gl_switch(DisplayChangeListener *dcl,
-                            DisplaySurface *new_surface)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    if (listener != screen.active_listener) {
-        return;
-    }
-
-    with_view_ctx(^{
-        surface_gl_destroy_texture(dgc.gls, screen.surface);
-        surface_gl_create_texture(dgc.gls, new_surface);
-    });
-
-    cocoa_switch(dcl, new_surface);
-    gl_dirty = true;
-}
-
-static void cocoa_gl_refresh(DisplayChangeListener *dcl)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    if (listener != screen.active_listener) {
-        return;
-    }
-
-    cocoa_refresh(dcl);
-
-    if (gl_dirty) {
-        gl_dirty = false;
-
-        with_view_ctx(^{
-            QemuCocoaView *view = [appController cocoaView];
-            NSSize size = [view convertSizeToBacking:[view frame].size];
-
-            if (listener->gl_scanout_borrow) {
-                bool y0_top;
-                GLint texture =
-                    listener->gl_scanout_borrow(listener->gl_scanout_id,
-                                                &y0_top, NULL, NULL);
-
-                glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
-                glViewport(0, 0, size.width, size.height);
-                glBindTexture(GL_TEXTURE_2D, texture);
-                qemu_gl_run_texture_blit(dgc.gls, y0_top);
-            } else {
-                surface_gl_setup_viewport(dgc.gls, screen.surface,
-                                          size.width, size.height);
-                glBindTexture(GL_TEXTURE_2D, screen.surface->texture);
-                surface_gl_render_texture(dgc.gls, screen.surface);
-            }
-
-            cocoa_gl_cursor_render();
-            cocoa_gl_flush();
-        });
-    }
-}
-
-static void cocoa_gl_scanout_disable(DisplayChangeListener *dcl)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    listener->gl_scanout_borrow = NULL;
-
-    if (listener == screen.active_listener) {
-        gl_dirty = screen.surface != NULL;
-    }
-}
-
-static void cocoa_gl_cursor_update()
-{
-    if (screen.active_listener->cursor) {
-        with_view_ctx(^{
-            glBindTexture(GL_TEXTURE_2D, cursor_texture);
-            glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT,
-                          screen.active_listener->cursor->width);
-            glTexImage2D(GL_TEXTURE_2D, 0,
-                         epoxy_is_desktop_gl() ? GL_RGBA : GL_BGRA,
-                         screen.active_listener->cursor->width,
-                         screen.active_listener->cursor->height,
-                         0, GL_BGRA, GL_UNSIGNED_BYTE,
-                         screen.active_listener->cursor->data);
-            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-        });
-    }
-
-    gl_dirty = true;
-}
-
-static void cocoa_gl_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    listener->cursor = cursor;
-
-    if (listener == screen.active_listener) {
-        cocoa_gl_cursor_update();
-    }
-}
-
-static void cocoa_gl_scanout_texture(DisplayChangeListener *dcl,
-                                     uint32_t backing_id,
-                                     DisplayGLTextureBorrower backing_borrow,
-                                     uint32_t x, uint32_t y,
-                                     uint32_t w, uint32_t h)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    listener->gl_scanout_id = backing_id;
-    listener->gl_scanout_borrow = backing_borrow;
-    gl_dirty = true;
-}
-
-static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
-                                   uint32_t x, uint32_t y,
-                                   uint32_t w, uint32_t h)
-{
-    if (container_of(dcl, CocoaListener, dcl) == screen.active_listener) {
-        gl_dirty = true;
-    }
-}
-
-static void cocoa_gl_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
-{
-    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
-
-    listener->mouse_x = x;
-    listener->mouse_y = y;
-    listener->mouse_on = on;
-
-    if (listener == screen.active_listener) {
-        gl_dirty = true;
-    }
-}
-
-static const DisplayChangeListenerOps dcl_gl_ops = {
-    .dpy_name               = "cocoa-gl",
-    .dpy_gfx_update         = cocoa_gl_update,
-    .dpy_gfx_switch         = cocoa_gl_switch,
-    .dpy_gfx_check_format   = console_gl_check_format,
-    .dpy_refresh            = cocoa_gl_refresh,
-    .dpy_mouse_set          = cocoa_gl_mouse_set,
-    .dpy_cursor_define      = cocoa_gl_cursor_define,
-
-    .dpy_gl_scanout_disable = cocoa_gl_scanout_disable,
-    .dpy_gl_scanout_texture = cocoa_gl_scanout_texture,
-    .dpy_gl_update          = cocoa_gl_scanout_flush,
-};
-
-static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
-                                       DisplayChangeListener *dcl)
-{
-    return dcl->ops == &dcl_gl_ops;
-}
-
-#endif
-
-void cocoa_listener_select(size_t index)
-{
-    DisplaySurface *new_surface;
-
-    if (index >= screen.listeners_count) {
-        return;
-    }
-
-    qemu_mutex_lock(&screen.draw_mutex);
-    screen.active_listener = &screen.listeners[index];
-    qemu_mutex_unlock(&screen.draw_mutex);
-
-    new_surface = qemu_console_surface(screen.active_listener->dcl.con);
-    qkbd_state_lift_all_keys(screen.kbd);
-    qkbd_state_free(screen.kbd);
-    screen.kbd = qkbd_state_init(screen.active_listener->dcl.con);
-
-    if (display_opengl) {
-#ifdef CONFIG_OPENGL
-        cocoa_gl_cursor_update();
-        cocoa_gl_switch(&screen.active_listener->dcl, new_surface);
-#else
-        g_assert_not_reached();
-#endif
-    } else {
-        cocoa_cursor_update();
-        cocoa_switch(&screen.active_listener->dcl, new_surface);
-    }
-}
-
-static void cocoa_display_early_init(DisplayOptions *o)
-{
-    assert(o->type == DISPLAY_TYPE_COCOA);
-    if (o->has_gl && o->gl) {
-        display_opengl = 1;
-    }
-}
-
-static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
-{
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-    ProcessSerialNumber psn = { 0, kCurrentProcess };
-    QemuCocoaView *cocoaView;
-    const DisplayChangeListenerOps *ops;
-    size_t index;
-
-    COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
-    have_cocoa_ui = 1;
-
-    // Pull this console process up to being a fully-fledged graphical
-    // app with a menubar and Dock icon
-    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
-
-    [QemuApplication sharedApplication];
-
-    // Create an Application controller
-    appController = [[QemuCocoaAppController alloc] initWithScreen:&screen];
-    cocoaView = [appController cocoaView];
-    [NSApp setDelegate:appController];
-
-    qemu_mutex_init(&screen.draw_mutex);
-
-    if (display_opengl) {
-#ifdef CONFIG_OPENGL
-        if (opts->gl == DISPLAYGL_MODE_ES) {
-#ifdef CONFIG_EGL
-            if (qemu_egl_init_dpy_cocoa(DISPLAYGL_MODE_ES)) {
-                exit(1);
-            }
-            view_ctx = qemu_egl_init_ctx();
-            if (!view_ctx) {
-                exit(1);
-            }
-            [cocoaView setWantsLayer:YES];
-            egl_surface = qemu_egl_init_surface(view_ctx, [cocoaView layer]);
-            if (!egl_surface) {
-                exit(1);
-            }
-#else
-            error_report("OpenGLES without EGL is not supported - exiting");
-            exit(1);
-#endif
-        } else {
-            NSOpenGLPixelFormat *format = cocoa_gl_create_ns_pixel_format(32);
-            NSOpenGLView *view = [[NSOpenGLView alloc] initWithFrame:[cocoaView frame]
-                                                         pixelFormat:format];
-            [format release];
-            [cocoaView addSubview:view];
-            view_ctx = [view openGLContext];
-            [view release];
-#ifdef CONFIG_EGL
-            egl_surface = EGL_NO_SURFACE;
-#endif
-            cocoa_gl_make_context_current(&dgc, view_ctx);
-        }
-
-        dgc.gls = qemu_gl_init_shader();
-        glGenTextures(1, &cursor_texture);
-
-        // register vga output callbacks
-        ops = &dcl_gl_ops;
-#else
-        error_report("OpenGL is not enabled - exiting");
-        exit(1);
-#endif
-    } else {
-        // register vga output callbacks
-        ops = &dcl_ops;
-    }
-
-    while (qemu_console_lookup_by_index(screen.listeners_count)) {
-        screen.listeners_count++;
-    }
-
-    if (screen.listeners_count) {
-        QemuConsole *con = qemu_console_lookup_first_graphic_console();
-        screen.listeners = g_new0(CocoaListener, screen.listeners_count);
-        screen.active_listener = screen.listeners + qemu_console_get_index(con);
-
-        for (index = 0; index < screen.listeners_count; index++) {
-            screen.listeners[index].dcl.con = qemu_console_lookup_by_index(index);
-            screen.listeners[index].dcl.ops = ops;
-
-            if (display_opengl) {
-                qemu_console_set_display_gl_ctx(screen.listeners[index].dcl.con,
-                                                &dgc);
-            }
-
-            // register vga output callbacks
-            register_displaychangelistener(&screen.listeners[index].dcl);
-        }
-
-        screen.kbd = qkbd_state_init(screen.active_listener->dcl.con);
-    }
-
-    create_initial_menus();
-
-    /*
-     * Create the menu entries which depend on QEMU state (for consoles
-     * and removeable devices). These make calls back into QEMU functions,
-     * which is OK because at this point we know that the second thread
-     * holds the iothread lock and is synchronously waiting for us to
-     * finish.
-     */
-    add_console_menu_entries();
-    addRemovableDevicesMenuItems();
-
-    qemu_event_init(&qemucb.event, false);
-    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] initWith:&qemucb];
-
-    if (opts->has_full_screen && opts->full_screen) {
-        [[cocoaView window] toggleFullScreen: nil];
-    }
-    if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {
-        [cocoaView setFullGrab: nil];
-    }
-
-    if (opts->has_show_cursor) {
-        screen.cursor_show = opts->show_cursor;
-    }
-    if (opts->u.cocoa.has_swap_opt_cmd) {
-        screen.swap_opt_cmd = opts->u.cocoa.swap_opt_cmd;
-    }
-
-    if (opts->u.cocoa.has_left_command_key) {
-        screen.left_command_key_disabled = opts->u.cocoa.left_command_key;
-    }
-
-    [cocoaView updateUIInfo];
-    qemu_clipboard_peer_register(&cbpeer);
-    [pool release];
-}
-
-static QemuDisplay qemu_display_cocoa = {
-    .type       = DISPLAY_TYPE_COCOA,
-    .early_init = cocoa_display_early_init,
-    .init       = cocoa_display_init,
-};
-
-static void register_cocoa(void)
-{
-    qemu_display_register(&qemu_display_cocoa);
-}
-
-type_init(register_cocoa);
-
-#ifdef CONFIG_OPENGL
-module_dep("ui-opengl");
-#endif
-#endif
-
 #endif
diff --git a/ui/cocoa/app_controller.m b/ui/cocoa/app_controller.m
index 5d1df04d2c3a..0165d041bf0a 100644
--- a/ui/cocoa/app_controller.m
+++ b/ui/cocoa/app_controller.m
@@ -22,5 +22,424 @@
  * THE SOFTWARE.
  */
 
-#define UI_COCOA_APP_CONTROLLER
+#include "qemu/osdep.h"
+
+#include "qemu-common.h"
 #include "ui/cocoa.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/runstate.h"
+#include "sysemu/cpu-throttle.h"
+#include "qapi/error.h"
+#include "qapi/qapi-commands-block.h"
+#include "qapi/qapi-commands-machine.h"
+#include "qapi/qapi-commands-misc.h"
+#include "sysemu/blockdev.h"
+#include "qemu-version.h"
+#include "qemu/cutils.h"
+#include "qemu/main-loop.h"
+#include "qemu/module.h"
+#include "hw/core/cpu.h"
+
+#ifndef MAC_OS_X_VERSION_10_13
+#define MAC_OS_X_VERSION_10_13 101300
+#endif
+
+/* 10.14 deprecates NSOnState and NSOffState in favor of
+ * NSControlStateValueOn/Off, which were introduced in 10.13.
+ * Define for older versions
+ */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_13
+#define NSControlStateValueOn NSOnState
+#define NSControlStateValueOff NSOffState
+#endif
+
+/* Displays an alert dialog box with the specified message */
+static void QEMU_Alert(NSString *message)
+{
+    NSAlert *alert;
+    alert = [NSAlert new];
+    [alert setMessageText: message];
+    [alert runModal];
+}
+
+/* Handles any errors that happen with a device transaction */
+static void handleAnyDeviceErrors(Error * err)
+{
+    if (err) {
+        QEMU_Alert([NSString stringWithCString: error_get_pretty(err)
+                                      encoding: NSASCIIStringEncoding]);
+        error_free(err);
+    }
+}
+
+@implementation QemuCocoaAppController
+- (id) initWithScreen:(QEMUScreen *)screen
+{
+    COCOA_DEBUG("%s\n", __func__);
+
+    self = [super init];
+    if (self) {
+        // create a view and add it to the window
+        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)
+                                                  screen:screen];
+        if(!cocoaView) {
+            error_report("(cocoa) can't create a view");
+            exit(1);
+        }
+
+        // create a window
+        NSWindow *normalWindow = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
+            styleMask:NSWindowStyleMaskTitled|NSWindowStyleMaskMiniaturizable|NSWindowStyleMaskClosable
+            backing:NSBackingStoreBuffered defer:NO];
+        if(!normalWindow) {
+            error_report("(cocoa) can't create window");
+            exit(1);
+        }
+        [normalWindow setAcceptsMouseMovedEvents:YES];
+        [normalWindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
+        [normalWindow setTitle:qemu_name ? [NSString stringWithFormat:@"QEMU %s", qemu_name] : @"QEMU"];
+        [normalWindow setContentView:cocoaView];
+        [normalWindow makeKeyAndOrderFront:self];
+        [normalWindow center];
+        [normalWindow setDelegate: self];
+        [normalWindow release];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+    COCOA_DEBUG("QemuCocoaAppController: dealloc\n");
+
+    if (cocoaView)
+        [cocoaView release];
+    [super dealloc];
+}
+
+- (void)applicationWillTerminate:(NSNotification *)aNotification
+{
+    COCOA_DEBUG("QemuCocoaAppController: applicationWillTerminate\n");
+
+    qemu_system_shutdown_request(SHUTDOWN_CAUSE_HOST_UI);
+
+    /*
+     * Sleep here, because returning will cause OSX to kill us
+     * immediately; the QEMU main loop will handle the shutdown
+     * request and terminate the process.
+     */
+    [NSThread sleepForTimeInterval:INFINITY];
+}
+
+- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)theApplication
+{
+    return YES;
+}
+
+- (NSApplicationTerminateReply)applicationShouldTerminate:
+                                                         (NSApplication *)sender
+{
+    COCOA_DEBUG("QemuCocoaAppController: applicationShouldTerminate\n");
+    return [self verifyQuit];
+}
+
+- (void)windowDidChangeScreen:(NSNotification *)notification
+{
+    [cocoaView updateUIInfo];
+}
+
+- (void)windowDidEnterFullScreen:(NSNotification *)notification
+{
+    [cocoaView grabMouse];
+}
+
+- (void)windowDidExitFullScreen:(NSNotification *)notification
+{
+    [cocoaView resizeWindow];
+    [cocoaView ungrabMouse];
+}
+
+- (void)windowDidResize:(NSNotification *)notification
+{
+    [cocoaView frameUpdated];
+}
+
+/* Called when the user clicks on a window's close button */
+- (BOOL)windowShouldClose:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaAppController: windowShouldClose\n");
+    [NSApp terminate: sender];
+    /* If the user allows the application to quit then the call to
+     * NSApp terminate will never return. If we get here then the user
+     * cancelled the quit, so we should return NO to not permit the
+     * closing of this window.
+     */
+    return NO;
+}
+
+- (NSSize) window:(NSWindow *)window willUseFullScreenContentSize:(NSSize)proposedSize
+{
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        return [cocoaView computeUnzoomedSize];
+    }
+
+    return [cocoaView fixZoomedFullScreenSize:proposedSize];
+}
+
+- (NSApplicationPresentationOptions) window:(NSWindow *)window
+                                     willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions;
+
+{
+    return (proposedOptions & ~(NSApplicationPresentationAutoHideDock | NSApplicationPresentationAutoHideMenuBar)) |
+           NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar;
+}
+
+/* Called when QEMU goes into the background */
+- (void) applicationWillResignActive: (NSNotification *)aNotification
+{
+    COCOA_DEBUG("QemuCocoaAppController: applicationWillResignActive\n");
+    [cocoaView ungrabMouse];
+}
+
+/* We abstract the method called by the Enter Fullscreen menu item
+ * because Mac OS 10.7 and higher disables it. This is because of the
+ * menu item's old selector's name toggleFullScreen:
+ */
+- (void) doToggleFullScreen:(id)sender
+{
+    [[cocoaView window] toggleFullScreen:sender];
+}
+
+/* Tries to find then open the specified filename */
+- (void) openDocumentation: (NSString *) filename
+{
+    /* Where to look for local files */
+    NSString *path_array[] = {@"../share/doc/qemu/", @"../doc/qemu/", @"docs/"};
+    NSString *full_file_path;
+    NSURL *full_file_url;
+
+    /* iterate thru the possible paths until the file is found */
+    int index;
+    for (index = 0; index < ARRAY_SIZE(path_array); index++) {
+        full_file_path = [[NSBundle mainBundle] executablePath];
+        full_file_path = [full_file_path stringByDeletingLastPathComponent];
+        full_file_path = [NSString stringWithFormat: @"%@/%@%@", full_file_path,
+                          path_array[index], filename];
+        full_file_url = [NSURL fileURLWithPath: full_file_path
+                                   isDirectory: false];
+        if ([[NSWorkspace sharedWorkspace] openURL: full_file_url] == YES) {
+            return;
+        }
+    }
+
+    /* If none of the paths opened a file */
+    NSBeep();
+    QEMU_Alert(@"Failed to open file");
+}
+
+- (void)showQEMUDoc:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaAppController: showQEMUDoc\n");
+
+    [self openDocumentation: @"index.html"];
+}
+
+/* Toggles the flag which stretches video to fit host window size */
+- (void)zoomToFit:(id) sender
+{
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] | NSWindowStyleMaskResizable];
+        [sender setState: NSControlStateValueOn];
+    } else {
+        [[cocoaView window] setStyleMask:[[cocoaView window] styleMask] & ~NSWindowStyleMaskResizable];
+        [cocoaView resizeWindow];
+        [sender setState: NSControlStateValueOff];
+    }
+}
+
+/* Displays the console on the screen */
+- (void)displayConsole:(id)sender
+{
+    qemu_mutex_lock_iothread();
+    [cocoaView selectConsoleLocked:[sender tag]];
+    qemu_mutex_unlock_iothread();
+}
+
+/* Pause the guest */
+- (void)pauseQEMU:(id)sender
+{
+    qemu_mutex_lock_iothread();
+    qmp_stop(NULL);
+    qemu_mutex_unlock_iothread();
+    [sender setEnabled: NO];
+    [[[sender menu] itemWithTitle: @"Resume"] setEnabled: YES];
+    [cocoaView displayPause];
+}
+
+/* Resume running the guest operating system */
+- (void)resumeQEMU:(id) sender
+{
+    qemu_mutex_lock_iothread();
+    qmp_cont(NULL);
+    qemu_mutex_unlock_iothread();
+    [sender setEnabled: NO];
+    [[[sender menu] itemWithTitle: @"Pause"] setEnabled: YES];
+    [cocoaView removePause];
+}
+
+/* Restarts QEMU */
+- (void)restartQEMU:(id)sender
+{
+    qemu_mutex_lock_iothread();
+    qmp_system_reset(NULL);
+    qemu_mutex_unlock_iothread();
+}
+
+/* Powers down QEMU */
+- (void)powerDownQEMU:(id)sender
+{
+    qemu_mutex_lock_iothread();
+    qmp_system_powerdown(NULL);
+    qemu_mutex_unlock_iothread();
+}
+
+/* Ejects the media.
+ * Uses sender's tag to figure out the device to eject.
+ */
+- (void)ejectDeviceMedia:(id)sender
+{
+    NSString * drive;
+    drive = [sender representedObject];
+    if(drive == nil) {
+        NSBeep();
+        QEMU_Alert(@"Failed to find drive to eject!");
+        return;
+    }
+
+    Error *err = NULL;
+    qemu_mutex_lock_iothread();
+    qmp_eject(true, [drive cStringUsingEncoding: NSASCIIStringEncoding],
+              false, NULL, false, false, &err);
+    qemu_mutex_unlock_iothread();
+    handleAnyDeviceErrors(err);
+}
+
+/* Displays a dialog box asking the user to select an image file to load.
+ * Uses sender's represented object value to figure out which drive to use.
+ */
+- (void)changeDeviceMedia:(id)sender
+{
+    /* Find the drive name */
+    NSString * drive;
+    drive = [sender representedObject];
+    if(drive == nil) {
+        NSBeep();
+        QEMU_Alert(@"Could not find drive!");
+        return;
+    }
+
+    /* Display the file open dialog */
+    NSOpenPanel * openPanel;
+    openPanel = [NSOpenPanel openPanel];
+    [openPanel setCanChooseFiles: YES];
+    [openPanel setAllowsMultipleSelection: NO];
+    if([openPanel runModal] == NSModalResponseOK) {
+        NSString * file = [[[openPanel URLs] objectAtIndex: 0] path];
+        if(file == nil) {
+            NSBeep();
+            QEMU_Alert(@"Failed to convert URL to file path!");
+            return;
+        }
+
+        Error *err = NULL;
+        qemu_mutex_lock_iothread();
+        qmp_blockdev_change_medium(true,
+                                   [drive cStringUsingEncoding:NSASCIIStringEncoding],
+                                   false, NULL,
+                                   [file cStringUsingEncoding:NSASCIIStringEncoding],
+                                   true, "raw",
+                                   false, 0,
+                                   &err);
+        qemu_mutex_unlock_iothread();
+        handleAnyDeviceErrors(err);
+    }
+}
+
+/* Verifies if the user really wants to quit */
+- (BOOL)verifyQuit
+{
+    NSAlert *alert = [NSAlert new];
+    [alert autorelease];
+    [alert setMessageText: @"Are you sure you want to quit QEMU?"];
+    [alert addButtonWithTitle: @"Cancel"];
+    [alert addButtonWithTitle: @"Quit"];
+    if([alert runModal] == NSAlertSecondButtonReturn) {
+        return YES;
+    } else {
+        return NO;
+    }
+}
+
+/* The action method for the About menu item */
+- (IBAction) do_about_menu_item: (id) sender
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+    char *icon_path_c = get_relocated_path(CONFIG_QEMU_ICONDIR "/hicolor/512x512/apps/qemu.png");
+    NSString *icon_path = [NSString stringWithUTF8String:icon_path_c];
+    g_free(icon_path_c);
+    NSImage *icon = [[NSImage alloc] initWithContentsOfFile:icon_path];
+    NSString *version = @"QEMU emulator version " QEMU_FULL_VERSION;
+    NSString *copyright = @QEMU_COPYRIGHT;
+    NSDictionary *options;
+    if (icon) {
+        options = @{
+            NSAboutPanelOptionApplicationIcon : icon,
+            NSAboutPanelOptionApplicationVersion : version,
+            @"Copyright" : copyright,
+        };
+        [icon release];
+    } else {
+        options = @{
+            NSAboutPanelOptionApplicationVersion : version,
+            @"Copyright" : copyright,
+        };
+    }
+    [NSApp orderFrontStandardAboutPanelWithOptions:options];
+    [pool release];
+}
+
+/* Used by the Speed menu items */
+- (void)adjustSpeed:(id)sender
+{
+    int throttle_pct; /* throttle percentage */
+    NSMenu *menu;
+
+    menu = [sender menu];
+    if (menu != nil)
+    {
+        /* Unselect the currently selected item */
+        for (NSMenuItem *item in [menu itemArray]) {
+            if (item.state == NSControlStateValueOn) {
+                [item setState: NSControlStateValueOff];
+                break;
+            }
+        }
+    }
+
+    // check the menu item
+    [sender setState: NSControlStateValueOn];
+
+    // get the throttle percentage
+    throttle_pct = [sender tag];
+
+    qemu_mutex_lock_iothread();
+    cpu_throttle_set(throttle_pct);
+    qemu_mutex_unlock_iothread();
+    COCOA_DEBUG("cpu throttling at %d%c\n", cpu_throttle_get_percentage(), '%');
+}
+
+- (QemuCocoaView *)cocoaView
+{
+    return cocoaView;
+}
+
+@end
diff --git a/ui/cocoa/main.m b/ui/cocoa/main.m
index e6d8fdeb4efb..754e32a82f0a 100644
--- a/ui/cocoa/main.m
+++ b/ui/cocoa/main.m
@@ -22,5 +22,1069 @@
  * THE SOFTWARE.
  */
 
-#define UI_COCOA_MAIN
+#define GL_SILENCE_DEPRECATION
+
+#include "qemu/osdep.h"
+
+#include <crt_externs.h>
+
+#include "qemu-common.h"
 #include "ui/cocoa.h"
+#include "ui/input.h"
+#include "sysemu/sysemu.h"
+#include "qapi/qapi-commands-block.h"
+
+#ifdef CONFIG_EGL
+#include "ui/egl-context.h"
+#endif
+
+static QEMUScreen screen;
+static QemuCocoaAppController *appController;
+static bool have_cocoa_ui;
+
+static NSInteger cbchangecount = -1;
+static QemuClipboardPeer cbpeer;
+static QemuCocoaClipboard qemucb;
+static QemuCocoaPasteboardTypeOwner *cbowner;
+
+#ifdef CONFIG_OPENGL
+
+static GLuint cursor_texture;
+static bool gl_dirty;
+static QEMUGLContext view_ctx;
+
+#ifdef CONFIG_EGL
+static EGLSurface egl_surface;
+#endif
+
+static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
+                                       DisplayChangeListener *dcl);
+
+static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
+                                             QEMUGLParams *params);
+
+static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx);
+
+static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx);
+
+static const DisplayGLCtxOps dgc_ops = {
+    .dpy_gl_ctx_is_compatible_dcl = cocoa_gl_is_compatible_dcl,
+    .dpy_gl_ctx_create            = cocoa_gl_create_context,
+    .dpy_gl_ctx_destroy           = cocoa_gl_destroy_context,
+    .dpy_gl_ctx_make_current      = cocoa_gl_make_context_current,
+};
+
+static DisplayGLCtx dgc = {
+    .ops = &dgc_ops,
+};
+
+#endif
+
+/*
+ * The startup process for the OSX/Cocoa UI is complicated, because
+ * OSX insists that the UI runs on the initial main thread, and so we
+ * need to start a second thread which runs qemu_main_loop():
+ *
+ * Initial thread:                    2nd thread:
+ * in main():
+ *  qemu_init()
+ *  create main loop thread
+ *  enter OSX run loop                call qemu_main_loop()
+ */
+
+static void *call_qemu_main_loop(void *opaque)
+{
+    COCOA_DEBUG("Second thread: calling qemu_main_loop()\n");
+    qemu_mutex_lock_iothread();
+    qemu_main_loop();
+    COCOA_DEBUG("Second thread: qemu_main_loop() returned, exiting\n");
+    qemu_cleanup();
+    qkbd_state_free(screen.kbd);
+    [cbowner release];
+    CGImageRelease(screen.cursor_cgimage);
+#ifdef CONFIG_OPENGL
+    qemu_gl_fini_shader(dgc.gls);
+    if (view_ctx) {
+        cocoa_gl_destroy_context(&dgc, view_ctx);
+    }
+#endif
+    exit(0);
+}
+
+@interface QemuApplication : NSApplication
+@end
+
+@implementation QemuApplication
+- (void)sendEvent:(NSEvent *)event
+{
+    COCOA_DEBUG("QemuApplication: sendEvent\n");
+    if (![[appController cocoaView] handleEvent:event]) {
+        [super sendEvent: event];
+    }
+}
+@end
+
+static void create_initial_menus(void)
+{
+    // Add menus
+    NSMenu      *menu;
+    NSMenuItem  *menuItem;
+
+    [NSApp setMainMenu:[[NSMenu alloc] init]];
+    [NSApp setServicesMenu:[[NSMenu alloc] initWithTitle:@"Services"]];
+
+    // Application menu
+    menu = [[NSMenu alloc] initWithTitle:@""];
+    [menu addItemWithTitle:@"About QEMU" action:@selector(do_about_menu_item:) keyEquivalent:@""]; // About QEMU
+    [menu addItem:[NSMenuItem separatorItem]]; //Separator
+    menuItem = [menu addItemWithTitle:@"Services" action:nil keyEquivalent:@""];
+    [menuItem setSubmenu:[NSApp servicesMenu]];
+    [menu addItem:[NSMenuItem separatorItem]];
+    [menu addItemWithTitle:@"Hide QEMU" action:@selector(hide:) keyEquivalent:@"h"]; //Hide QEMU
+    menuItem = (NSMenuItem *)[menu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"]; // Hide Others
+    [menuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];
+    [menu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""]; // Show All
+    [menu addItem:[NSMenuItem separatorItem]]; //Separator
+    [menu addItemWithTitle:@"Quit QEMU" action:@selector(terminate:) keyEquivalent:@"q"];
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Apple" action:nil keyEquivalent:@""];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+    [NSApp performSelector:@selector(setAppleMenu:) withObject:menu]; // Workaround (this method is private since 10.4+)
+
+    // Machine menu
+    menu = [[NSMenu alloc] initWithTitle: @"Machine"];
+    [menu setAutoenablesItems: NO];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Pause" action: @selector(pauseQEMU:) keyEquivalent: @""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Resume" action: @selector(resumeQEMU:) keyEquivalent: @""] autorelease];
+    [menu addItem: menuItem];
+    [menuItem setEnabled: NO];
+    [menu addItem: [NSMenuItem separatorItem]];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Reset" action: @selector(restartQEMU:) keyEquivalent: @""] autorelease]];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Power Down" action: @selector(powerDownQEMU:) keyEquivalent: @""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle: @"Machine" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // View menu
+    menu = [[NSMenu alloc] initWithTitle:@"View"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Enter Fullscreen" action:@selector(doToggleFullScreen:) keyEquivalent:@"f"] autorelease]]; // Fullscreen
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Zoom To Fit" action:@selector(zoomToFit:) keyEquivalent:@""] autorelease]];
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"View" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // Speed menu
+    menu = [[NSMenu alloc] initWithTitle:@"Speed"];
+
+    // Add the rest of the Speed menu items
+    int p, percentage, throttle_pct;
+    for (p = 10; p >= 0; p--)
+    {
+        percentage = p * 10 > 1 ? p * 10 : 1; // prevent a 0% menu item
+
+        menuItem = [[[NSMenuItem alloc]
+                   initWithTitle: [NSString stringWithFormat: @"%d%%", percentage] action:@selector(adjustSpeed:) keyEquivalent:@""] autorelease];
+
+        if (percentage == 100) {
+            [menuItem setState: NSControlStateValueOn];
+        }
+
+        /* Calculate the throttle percentage */
+        throttle_pct = -1 * percentage + 100;
+
+        [menuItem setTag: throttle_pct];
+        [menu addItem: menuItem];
+    }
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Speed" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    // Window menu
+    menu = [[NSMenu alloc] initWithTitle:@"Window"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"] autorelease]]; // Miniaturize
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+    [NSApp setWindowsMenu:menu];
+
+    // Help menu
+    menu = [[NSMenu alloc] initWithTitle:@"Help"];
+    [menu addItem: [[[NSMenuItem alloc] initWithTitle:@"QEMU Documentation" action:@selector(showQEMUDoc:) keyEquivalent:@"?"] autorelease]]; // QEMU Help
+    menuItem = [[[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""] autorelease];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+}
+
+/* Returns a name for a given console */
+static NSString * getConsoleName(QemuConsole * console)
+{
+    g_autofree char *label = qemu_console_get_label(console);
+
+    return [NSString stringWithUTF8String:label];
+}
+
+/* Add an entry to the View menu for each console */
+static void add_console_menu_entries(void)
+{
+    NSMenu *menu;
+    NSMenuItem *menuItem;
+    size_t index;
+
+    menu = [[[NSApp mainMenu] itemWithTitle:@"View"] submenu];
+
+    [menu addItem:[NSMenuItem separatorItem]];
+
+    for (index = 0; index < screen.listeners_count; index++) {
+        menuItem = [[[NSMenuItem alloc] initWithTitle: getConsoleName(screen.listeners[index].dcl.con)
+                                               action: @selector(displayConsole:) keyEquivalent: @""] autorelease];
+        [menuItem setTag: index];
+        [menu addItem: menuItem];
+    }
+}
+
+/* Make menu items for all removable devices.
+ * Each device is given an 'Eject' and 'Change' menu item.
+ */
+static void addRemovableDevicesMenuItems(void)
+{
+    NSMenu *menu;
+    NSMenuItem *menuItem;
+    BlockInfoList *currentDevice, *pointerToFree;
+    NSString *deviceName;
+
+    currentDevice = qmp_query_block(NULL);
+    pointerToFree = currentDevice;
+
+    menu = [[[NSApp mainMenu] itemWithTitle:@"Machine"] submenu];
+
+    // Add a separator between related groups of menu items
+    [menu addItem:[NSMenuItem separatorItem]];
+
+    // Set the attributes to the "Removable Media" menu item
+    NSString *titleString = @"Removable Media";
+    NSMutableAttributedString *attString=[[NSMutableAttributedString alloc] initWithString:titleString];
+    NSColor *newColor = [NSColor blackColor];
+    NSFontManager *fontManager = [NSFontManager sharedFontManager];
+    NSFont *font = [fontManager fontWithFamily:@"Helvetica"
+                                          traits:NSBoldFontMask|NSItalicFontMask
+                                          weight:0
+                                            size:14];
+    [attString addAttribute:NSFontAttributeName value:font range:NSMakeRange(0, [titleString length])];
+    [attString addAttribute:NSForegroundColorAttributeName value:newColor range:NSMakeRange(0, [titleString length])];
+    [attString addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInt: 1] range:NSMakeRange(0, [titleString length])];
+
+    // Add the "Removable Media" menu item
+    menuItem = [NSMenuItem new];
+    [menuItem setAttributedTitle: attString];
+    [menuItem setEnabled: NO];
+    [menu addItem: menuItem];
+
+    /* Loop through all the block devices in the emulator */
+    while (currentDevice) {
+        deviceName = [[NSString stringWithFormat: @"%s", currentDevice->value->device] retain];
+
+        if(currentDevice->value->removable) {
+            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Change %s...", currentDevice->value->device]
+                                                  action: @selector(changeDeviceMedia:)
+                                           keyEquivalent: @""];
+            [menu addItem: menuItem];
+            [menuItem setRepresentedObject: deviceName];
+            [menuItem autorelease];
+
+            menuItem = [[NSMenuItem alloc] initWithTitle: [NSString stringWithFormat: @"Eject %s", currentDevice->value->device]
+                                                  action: @selector(ejectDeviceMedia:)
+                                           keyEquivalent: @""];
+            [menu addItem: menuItem];
+            [menuItem setRepresentedObject: deviceName];
+            [menuItem autorelease];
+        }
+        currentDevice = currentDevice->next;
+    }
+    qapi_free_BlockInfoList(pointerToFree);
+}
+
+static void cocoa_clipboard_notify(Notifier *notifier, void *data);
+static void cocoa_clipboard_request(QemuClipboardInfo *info,
+                                    QemuClipboardType type);
+
+static QemuClipboardPeer cbpeer = {
+    .name = "cocoa",
+    .notifier = { .notify = cocoa_clipboard_notify },
+    .request = cocoa_clipboard_request
+};
+
+static void cocoa_clipboard_update_info(QemuClipboardInfo *info)
+{
+    if (info->owner == &cbpeer || info->selection != QEMU_CLIPBOARD_SELECTION_CLIPBOARD) {
+        return;
+    }
+
+    if (info != qemucb.info) {
+        NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+        qemu_clipboard_info_unref(qemucb.info);
+        qemucb.info = qemu_clipboard_info_ref(info);
+        cbchangecount = [[NSPasteboard generalPasteboard] declareTypes:@[NSPasteboardTypeString] owner:cbowner];
+        [pool release];
+    }
+
+    qemu_event_set(&qemucb.event);
+}
+
+static void cocoa_clipboard_notify(Notifier *notifier, void *data)
+{
+    QemuClipboardNotify *notify = data;
+
+    switch (notify->type) {
+    case QEMU_CLIPBOARD_UPDATE_INFO:
+        cocoa_clipboard_update_info(notify->info);
+        return;
+    case QEMU_CLIPBOARD_RESET_SERIAL:
+        /* ignore */
+        return;
+    }
+}
+
+static void cocoa_clipboard_request(QemuClipboardInfo *info,
+                                    QemuClipboardType type)
+{
+    NSData *text;
+
+    switch (type) {
+    case QEMU_CLIPBOARD_TYPE_TEXT:
+        text = [[NSPasteboard generalPasteboard] dataForType:NSPasteboardTypeString];
+        if (text) {
+            qemu_clipboard_set_data(&cbpeer, info, type,
+                                    [text length], [text bytes], true);
+            [text release];
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+int main(int argc, char **argv, char **envp)
+{
+    QemuThread main_thread;
+
+    COCOA_DEBUG("Entered main()\n");
+
+    /* Takes iothread lock.  */
+    qemu_init(argc, argv, envp);
+    if (!have_cocoa_ui) {
+         qemu_main_loop();
+         qemu_cleanup();
+         return 0;
+    }
+
+    qemu_mutex_unlock_iothread();
+    qemu_thread_create(&main_thread, "qemu_main_loop", call_qemu_main_loop,
+                       NULL, QEMU_THREAD_DETACHED);
+
+    // Start the main event loop
+    COCOA_DEBUG("Main thread: entering OSX run loop\n");
+    [NSApp run];
+    COCOA_DEBUG("Main thread: left OSX run loop, exiting\n");
+
+    return 0;
+}
+
+
+
+#pragma mark qemu
+static void cocoa_update(DisplayChangeListener *dcl,
+                         int x, int y, int w, int h)
+{
+    DisplaySurface *updated = screen.surface;
+
+    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
+        return;
+    }
+
+    COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        qemu_mutex_lock(&screen.draw_mutex);
+        if (updated != screen.surface) {
+            qemu_mutex_unlock(&screen.draw_mutex);
+            return;
+        }
+        int full_height = surface_height(screen.surface);
+        qemu_mutex_unlock(&screen.draw_mutex);
+
+        CGFloat d = [[appController cocoaView] frame].size.height / full_height;
+        NSRect rect = NSMakeRect(x * d, (full_height - y - h) * d, w * d, h * d);
+        [[appController cocoaView] setNeedsDisplayInRect:rect];
+    });
+}
+
+static void cocoa_switch(DisplayChangeListener *dcl,
+                         DisplaySurface *new_surface)
+{
+    COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
+
+    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
+        return;
+    }
+
+    qemu_mutex_lock(&screen.draw_mutex);
+    screen.surface = new_surface;
+    qemu_mutex_unlock(&screen.draw_mutex);
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        qemu_mutex_lock(&screen.draw_mutex);
+        int w = surface_width(screen.surface);
+        int h = surface_height(screen.surface);
+        qemu_mutex_unlock(&screen.draw_mutex);
+
+        [[appController cocoaView] updateScreenWidth:w height:h];
+    });
+}
+
+static void cocoa_refresh(DisplayChangeListener *dcl)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    COCOA_DEBUG("qemu_cocoa: cocoa_refresh\n");
+
+    if (container_of(dcl, CocoaListener, dcl) != screen.active_listener) {
+        return;
+    }
+
+    graphic_hw_update(dcl->con);
+
+    if (qemu_input_is_absolute()) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            if (![[appController cocoaView] isAbsoluteEnabled]) {
+                if ([[appController cocoaView] isMouseGrabbed]) {
+                    [[appController cocoaView] ungrabMouse];
+                }
+            }
+            [[appController cocoaView] setAbsoluteEnabled:YES];
+        });
+    }
+
+    if (cbchangecount != [[NSPasteboard generalPasteboard] changeCount]) {
+        qemu_clipboard_info_unref(qemucb.info);
+        qemucb.info = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
+        if ([[NSPasteboard generalPasteboard] availableTypeFromArray:@[NSPasteboardTypeString]]) {
+            qemucb.info->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
+        }
+        qemu_clipboard_update(qemucb.info);
+        cbchangecount = [[NSPasteboard generalPasteboard] changeCount];
+        qemu_event_set(&qemucb.event);
+    }
+
+    [pool release];
+}
+
+static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    qemu_mutex_lock(&screen.draw_mutex);
+    int full_height = surface_height(screen.surface);
+    int old_x = listener->mouse_x;
+    int old_y = listener->mouse_y;
+    listener->mouse_x = x;
+    listener->mouse_y = y;
+    listener->mouse_on = on;
+    qemu_mutex_unlock(&screen.draw_mutex);
+
+    if (listener == screen.active_listener && screen.cursor_cgimage) {
+        size_t cursor_width = CGImageGetWidth(screen.cursor_cgimage);
+        size_t cursor_height = CGImageGetHeight(screen.cursor_cgimage);
+
+        dispatch_async(dispatch_get_main_queue(), ^{
+            [[appController cocoaView] setNeedsDisplayForCursorX:old_x
+                                                               y:old_y
+                                                           width:cursor_width
+                                                          height:cursor_height
+                                                    screenHeight:full_height];
+
+            [[appController cocoaView] setNeedsDisplayForCursorX:x
+                                                               y:y
+                                                           width:cursor_width
+                                                          height:cursor_height
+                                                    screenHeight:full_height];
+        });
+    }
+}
+
+static void cocoa_cursor_update()
+{
+    CGImageRef old_image = screen.cursor_cgimage;
+    CGImageRef new_image;
+    CocoaListener *active_listener = screen.active_listener;
+
+    if (active_listener->cursor) {
+        CGDataProviderRef provider = CGDataProviderCreateWithData(
+            NULL,
+            active_listener->cursor->data,
+            active_listener->cursor->width * active_listener->cursor->height * 4,
+            NULL
+        );
+
+        new_image = CGImageCreate(
+            active_listener->cursor->width, //width
+            active_listener->cursor->height, //height
+            8, //bitsPerComponent
+            32, //bitsPerPixel
+            active_listener->cursor->width * 4, //bytesPerRow
+            CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
+            kCGBitmapByteOrder32Little | kCGImageAlphaFirst, //bitmapInfo
+            provider, //provider
+            NULL, //decode
+            0, //interpolate
+            kCGRenderingIntentDefault //intent
+        );
+
+        CGDataProviderRelease(provider);
+    } else {
+        new_image = NULL;
+    }
+
+    qemu_mutex_lock(&screen.draw_mutex);
+    screen.cursor_cgimage = new_image;
+    qemu_mutex_unlock(&screen.draw_mutex);
+
+    CGImageRelease(old_image);
+}
+
+static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->cursor = cursor;
+
+    if (listener == screen.active_listener) {
+        int full_height = surface_height(screen.surface);
+        int width = cursor->width;
+        int height = cursor->height;
+        int x = listener->mouse_x;
+        int y = listener->mouse_y;
+        size_t old_width;
+        size_t old_height;
+
+        if (screen.cursor_cgimage) {
+            old_width = CGImageGetWidth(screen.cursor_cgimage);
+            old_height = CGImageGetHeight(screen.cursor_cgimage);
+        } else {
+            old_width = 0;
+            old_height = 0;
+        }
+
+        cocoa_cursor_update();
+
+        dispatch_async(dispatch_get_main_queue(), ^{
+            CGFloat d = [[appController cocoaView] frame].size.height / full_height;
+            NSRect rect;
+
+            rect.origin.x = d * x;
+            rect.origin.y = d * (full_height - y - old_height);
+            rect.size.width = d * old_width;
+            rect.size.height = d * old_height;
+            [[appController cocoaView] setNeedsDisplayInRect:rect];
+
+            rect.size.width = d * width;
+            rect.size.height = d * height;
+            [[appController cocoaView] setNeedsDisplayInRect:rect];
+        });
+    }
+}
+
+static const DisplayChangeListenerOps dcl_ops = {
+    .dpy_name          = "cocoa",
+    .dpy_gfx_update = cocoa_update,
+    .dpy_gfx_switch = cocoa_switch,
+    .dpy_refresh = cocoa_refresh,
+    .dpy_mouse_set = cocoa_mouse_set,
+    .dpy_cursor_define = cocoa_cursor_define,
+};
+
+#ifdef CONFIG_OPENGL
+
+static void with_view_ctx(CodeBlock block)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
+        block();
+        return;
+    }
+#endif
+
+    [(NSOpenGLContext *)view_ctx lock];
+    [(NSOpenGLContext *)view_ctx makeCurrentContext];
+    block();
+    [(NSOpenGLContext *)view_ctx unlock];
+}
+
+static NSOpenGLPixelFormat *cocoa_gl_create_ns_pixel_format(int bpp)
+{
+    NSOpenGLPixelFormatAttribute attributes[] = {
+        NSOpenGLPFAOpenGLProfile,
+        NSOpenGLProfileVersion4_1Core,
+        NSOpenGLPFAColorSize,
+        bpp,
+        NSOpenGLPFADoubleBuffer,
+        0,
+    };
+
+    return [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
+}
+
+static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        EGLSurface current_surface = ctx == EGL_NO_CONTEXT ? EGL_NO_SURFACE : egl_surface;
+        return eglMakeCurrent(qemu_egl_display, current_surface, current_surface, ctx);
+    }
+#endif
+
+    if (ctx) {
+        [(NSOpenGLContext *)ctx makeCurrentContext];
+    } else {
+        [NSOpenGLContext clearCurrentContext];
+    }
+
+    return 0;
+}
+
+static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
+                                             QEMUGLParams *params)
+{
+    NSOpenGLPixelFormat *format;
+    NSOpenGLContext *ctx;
+    int bpp;
+
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface, egl_surface, view_ctx);
+        return qemu_egl_create_context(dgc, params);
+    }
+#endif
+
+    bpp = PIXMAN_FORMAT_BPP(surface_format(screen.surface));
+    format = cocoa_gl_create_ns_pixel_format(bpp);
+    ctx = [[NSOpenGLContext alloc] initWithFormat:format shareContext:view_ctx];
+    [format release];
+
+    return (QEMUGLContext)ctx;
+}
+
+static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglDestroyContext(qemu_egl_display, ctx);
+        return;
+    }
+#endif
+
+    [(NSOpenGLContext *)ctx release];
+}
+
+static void cocoa_gl_flush()
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglSwapBuffers(qemu_egl_display, egl_surface);
+        return;
+    }
+#endif
+
+    [[NSOpenGLContext currentContext] flushBuffer];
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [(NSOpenGLContext *)view_ctx update];
+    });
+}
+
+static void cocoa_gl_update(DisplayChangeListener *dcl,
+                            int x, int y, int w, int h)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    if (listener != screen.active_listener) {
+        return;
+    }
+
+    with_view_ctx(^{
+        surface_gl_update_texture(dgc.gls, screen.surface, x, y, w, h);
+        gl_dirty = true;
+    });
+}
+
+static void cocoa_gl_cursor_render()
+{
+    if (!screen.active_listener->mouse_on) {
+        return;
+    }
+
+    QemuCocoaView *cocoaView = [appController cocoaView];
+    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+    CGFloat d = size.height / surface_height(screen.surface);
+    CocoaListener *active_listener = screen.active_listener;
+
+    glViewport(
+        d * active_listener->mouse_x,
+        size.height - d * (active_listener->mouse_y + active_listener->cursor->height),
+        d * active_listener->cursor->width,
+        d * active_listener->cursor->height
+    );
+    glBindTexture(GL_TEXTURE_2D, cursor_texture);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    qemu_gl_run_texture_blit(dgc.gls, false);
+    glDisable(GL_BLEND);
+}
+
+static void cocoa_gl_switch(DisplayChangeListener *dcl,
+                            DisplaySurface *new_surface)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    if (listener != screen.active_listener) {
+        return;
+    }
+
+    with_view_ctx(^{
+        surface_gl_destroy_texture(dgc.gls, screen.surface);
+        surface_gl_create_texture(dgc.gls, new_surface);
+    });
+
+    cocoa_switch(dcl, new_surface);
+    gl_dirty = true;
+}
+
+static void cocoa_gl_refresh(DisplayChangeListener *dcl)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    if (listener != screen.active_listener) {
+        return;
+    }
+
+    cocoa_refresh(dcl);
+
+    if (gl_dirty) {
+        gl_dirty = false;
+
+        with_view_ctx(^{
+            QemuCocoaView *view = [appController cocoaView];
+            NSSize size = [view convertSizeToBacking:[view frame].size];
+
+            if (listener->gl_scanout_borrow) {
+                bool y0_top;
+                GLint texture =
+                    listener->gl_scanout_borrow(listener->gl_scanout_id,
+                                                &y0_top, NULL, NULL);
+
+                glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+                glViewport(0, 0, size.width, size.height);
+                glBindTexture(GL_TEXTURE_2D, texture);
+                qemu_gl_run_texture_blit(dgc.gls, y0_top);
+            } else {
+                surface_gl_setup_viewport(dgc.gls, screen.surface,
+                                          size.width, size.height);
+                glBindTexture(GL_TEXTURE_2D, screen.surface->texture);
+                surface_gl_render_texture(dgc.gls, screen.surface);
+            }
+
+            cocoa_gl_cursor_render();
+            cocoa_gl_flush();
+        });
+    }
+}
+
+static void cocoa_gl_scanout_disable(DisplayChangeListener *dcl)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->gl_scanout_borrow = NULL;
+
+    if (listener == screen.active_listener) {
+        gl_dirty = screen.surface != NULL;
+    }
+}
+
+static void cocoa_gl_cursor_update()
+{
+    if (screen.active_listener->cursor) {
+        with_view_ctx(^{
+            glBindTexture(GL_TEXTURE_2D, cursor_texture);
+            glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT,
+                          screen.active_listener->cursor->width);
+            glTexImage2D(GL_TEXTURE_2D, 0,
+                         epoxy_is_desktop_gl() ? GL_RGBA : GL_BGRA,
+                         screen.active_listener->cursor->width,
+                         screen.active_listener->cursor->height,
+                         0, GL_BGRA, GL_UNSIGNED_BYTE,
+                         screen.active_listener->cursor->data);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        });
+    }
+
+    gl_dirty = true;
+}
+
+static void cocoa_gl_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->cursor = cursor;
+
+    if (listener == screen.active_listener) {
+        cocoa_gl_cursor_update();
+    }
+}
+
+static void cocoa_gl_scanout_texture(DisplayChangeListener *dcl,
+                                     uint32_t backing_id,
+                                     DisplayGLTextureBorrower backing_borrow,
+                                     uint32_t x, uint32_t y,
+                                     uint32_t w, uint32_t h)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->gl_scanout_id = backing_id;
+    listener->gl_scanout_borrow = backing_borrow;
+    gl_dirty = true;
+}
+
+static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
+                                   uint32_t x, uint32_t y,
+                                   uint32_t w, uint32_t h)
+{
+    if (container_of(dcl, CocoaListener, dcl) == screen.active_listener) {
+        gl_dirty = true;
+    }
+}
+
+static void cocoa_gl_mouse_set(DisplayChangeListener *dcl, int x, int y, int on)
+{
+    CocoaListener *listener = container_of(dcl, CocoaListener, dcl);
+
+    listener->mouse_x = x;
+    listener->mouse_y = y;
+    listener->mouse_on = on;
+
+    if (listener == screen.active_listener) {
+        gl_dirty = true;
+    }
+}
+
+static const DisplayChangeListenerOps dcl_gl_ops = {
+    .dpy_name               = "cocoa-gl",
+    .dpy_gfx_update         = cocoa_gl_update,
+    .dpy_gfx_switch         = cocoa_gl_switch,
+    .dpy_gfx_check_format   = console_gl_check_format,
+    .dpy_refresh            = cocoa_gl_refresh,
+    .dpy_mouse_set          = cocoa_gl_mouse_set,
+    .dpy_cursor_define      = cocoa_gl_cursor_define,
+
+    .dpy_gl_scanout_disable = cocoa_gl_scanout_disable,
+    .dpy_gl_scanout_texture = cocoa_gl_scanout_texture,
+    .dpy_gl_update          = cocoa_gl_scanout_flush,
+};
+
+static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
+                                       DisplayChangeListener *dcl)
+{
+    return dcl->ops == &dcl_gl_ops;
+}
+
+#endif
+
+void cocoa_listener_select(size_t index)
+{
+    DisplaySurface *new_surface;
+
+    if (index >= screen.listeners_count) {
+        return;
+    }
+
+    qemu_mutex_lock(&screen.draw_mutex);
+    screen.active_listener = &screen.listeners[index];
+    qemu_mutex_unlock(&screen.draw_mutex);
+
+    new_surface = qemu_console_surface(screen.active_listener->dcl.con);
+    qkbd_state_lift_all_keys(screen.kbd);
+    qkbd_state_free(screen.kbd);
+    screen.kbd = qkbd_state_init(screen.active_listener->dcl.con);
+
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        cocoa_gl_cursor_update();
+        cocoa_gl_switch(&screen.active_listener->dcl, new_surface);
+#else
+        g_assert_not_reached();
+#endif
+    } else {
+        cocoa_cursor_update();
+        cocoa_switch(&screen.active_listener->dcl, new_surface);
+    }
+}
+
+static void cocoa_display_early_init(DisplayOptions *o)
+{
+    assert(o->type == DISPLAY_TYPE_COCOA);
+    if (o->has_gl && o->gl) {
+        display_opengl = 1;
+    }
+}
+
+static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    ProcessSerialNumber psn = { 0, kCurrentProcess };
+    QemuCocoaView *cocoaView;
+    const DisplayChangeListenerOps *ops;
+    size_t index;
+
+    COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
+    have_cocoa_ui = 1;
+
+    // Pull this console process up to being a fully-fledged graphical
+    // app with a menubar and Dock icon
+    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+
+    [QemuApplication sharedApplication];
+
+    // Create an Application controller
+    appController = [[QemuCocoaAppController alloc] initWithScreen:&screen];
+    cocoaView = [appController cocoaView];
+    [NSApp setDelegate:appController];
+
+    qemu_mutex_init(&screen.draw_mutex);
+
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        if (opts->gl == DISPLAYGL_MODE_ES) {
+#ifdef CONFIG_EGL
+            if (qemu_egl_init_dpy_cocoa(DISPLAYGL_MODE_ES)) {
+                exit(1);
+            }
+            view_ctx = qemu_egl_init_ctx();
+            if (!view_ctx) {
+                exit(1);
+            }
+            [cocoaView setWantsLayer:YES];
+            egl_surface = qemu_egl_init_surface(view_ctx, [cocoaView layer]);
+            if (!egl_surface) {
+                exit(1);
+            }
+#else
+            error_report("OpenGLES without EGL is not supported - exiting");
+            exit(1);
+#endif
+        } else {
+            NSOpenGLPixelFormat *format = cocoa_gl_create_ns_pixel_format(32);
+            NSOpenGLView *view = [[NSOpenGLView alloc] initWithFrame:[cocoaView frame]
+                                                         pixelFormat:format];
+            [format release];
+            [cocoaView addSubview:view];
+            view_ctx = [view openGLContext];
+            [view release];
+#ifdef CONFIG_EGL
+            egl_surface = EGL_NO_SURFACE;
+#endif
+            cocoa_gl_make_context_current(&dgc, view_ctx);
+        }
+
+        dgc.gls = qemu_gl_init_shader();
+        glGenTextures(1, &cursor_texture);
+
+        // register vga output callbacks
+        ops = &dcl_gl_ops;
+#else
+        error_report("OpenGL is not enabled - exiting");
+        exit(1);
+#endif
+    } else {
+        // register vga output callbacks
+        ops = &dcl_ops;
+    }
+
+    while (qemu_console_lookup_by_index(screen.listeners_count)) {
+        screen.listeners_count++;
+    }
+
+    if (screen.listeners_count) {
+        QemuConsole *con = qemu_console_lookup_first_graphic_console();
+        screen.listeners = g_new0(CocoaListener, screen.listeners_count);
+        screen.active_listener = screen.listeners + qemu_console_get_index(con);
+
+        for (index = 0; index < screen.listeners_count; index++) {
+            screen.listeners[index].dcl.con = qemu_console_lookup_by_index(index);
+            screen.listeners[index].dcl.ops = ops;
+
+            if (display_opengl) {
+                qemu_console_set_display_gl_ctx(screen.listeners[index].dcl.con,
+                                                &dgc);
+            }
+
+            // register vga output callbacks
+            register_displaychangelistener(&screen.listeners[index].dcl);
+        }
+
+        screen.kbd = qkbd_state_init(screen.active_listener->dcl.con);
+    }
+
+    create_initial_menus();
+
+    /*
+     * Create the menu entries which depend on QEMU state (for consoles
+     * and removeable devices). These make calls back into QEMU functions,
+     * which is OK because at this point we know that the second thread
+     * holds the iothread lock and is synchronously waiting for us to
+     * finish.
+     */
+    add_console_menu_entries();
+    addRemovableDevicesMenuItems();
+
+    qemu_event_init(&qemucb.event, false);
+    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] initWith:&qemucb];
+
+    if (opts->has_full_screen && opts->full_screen) {
+        [[cocoaView window] toggleFullScreen: nil];
+    }
+    if (opts->u.cocoa.has_full_grab && opts->u.cocoa.full_grab) {
+        [cocoaView setFullGrab: nil];
+    }
+
+    if (opts->has_show_cursor) {
+        screen.cursor_show = opts->show_cursor;
+    }
+    if (opts->u.cocoa.has_swap_opt_cmd) {
+        screen.swap_opt_cmd = opts->u.cocoa.swap_opt_cmd;
+    }
+
+    if (opts->u.cocoa.has_left_command_key) {
+        screen.left_command_key_disabled = opts->u.cocoa.left_command_key;
+    }
+
+    [cocoaView updateUIInfo];
+    qemu_clipboard_peer_register(&cbpeer);
+    [pool release];
+}
+
+static QemuDisplay qemu_display_cocoa = {
+    .type       = DISPLAY_TYPE_COCOA,
+    .early_init = cocoa_display_early_init,
+    .init       = cocoa_display_init,
+};
+
+static void register_cocoa(void)
+{
+    qemu_display_register(&qemu_display_cocoa);
+}
+
+type_init(register_cocoa);
+
+#ifdef CONFIG_OPENGL
+module_dep("ui-opengl");
+#endif
diff --git a/ui/cocoa/pasteboard_type_owner.m b/ui/cocoa/pasteboard_type_owner.m
index 691366755682..1dd1e987d7dc 100644
--- a/ui/cocoa/pasteboard_type_owner.m
+++ b/ui/cocoa/pasteboard_type_owner.m
@@ -22,5 +22,54 @@
  * THE SOFTWARE.
  */
 
-#define UI_COCOA_PASTEBOARD_TYPE_OWNER
+#include "qemu/osdep.h"
+
 #include "ui/cocoa.h"
+#include "qemu/main-loop.h"
+
+@implementation QemuCocoaPasteboardTypeOwner
+
+- (id)initWith:(QemuCocoaClipboard *)aCb
+{
+    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
+
+    self = [super init];
+    if (self) {
+        cb = aCb;
+    }
+    return self;
+}
+
+- (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
+{
+    if (type != NSPasteboardTypeString) {
+        return;
+    }
+
+    qemu_mutex_lock_iothread();
+
+    QemuClipboardInfo *info = qemu_clipboard_info_ref(cb->info);
+    qemu_event_reset(&cb->event);
+    qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
+
+    while (info == cb->info &&
+           info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
+           info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
+        qemu_mutex_unlock_iothread();
+        qemu_event_wait(&cb->event);
+        qemu_mutex_lock_iothread();
+    }
+
+    if (info == cb->info) {
+        NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
+                                       length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
+        [sender setData:data forType:NSPasteboardTypeString];
+        [data release];
+    }
+
+    qemu_clipboard_info_unref(info);
+
+    qemu_mutex_unlock_iothread();
+}
+
+@end
diff --git a/ui/cocoa/view.m b/ui/cocoa/view.m
index 31f195d224d0..85c0c926b37c 100644
--- a/ui/cocoa/view.m
+++ b/ui/cocoa/view.m
@@ -22,6 +22,953 @@
  * THE SOFTWARE.
  */
 
-#define UI_COCOA_VIEW
+#include "qemu/osdep.h"
+
 #include "ui/cocoa.h"
+#include "ui/input.h"
+#include "sysemu/sysemu.h"
+#include "qemu/main-loop.h"
+#include "qemu/error-report.h"
+#include <Carbon/Carbon.h>
+
+#define cgrect(nsrect) (*(CGRect *)&(nsrect))
+
+// Utility functions to run specified code block with iothread lock held
+static void with_iothread_lock(CodeBlock block)
+{
+    bool locked = qemu_mutex_iothread_locked();
+    if (!locked) {
+        qemu_mutex_lock_iothread();
+    }
+    block();
+    if (!locked) {
+        qemu_mutex_unlock_iothread();
+    }
+}
+
+static bool bool_with_iothread_lock(BoolCodeBlock block)
+{
+    bool locked = qemu_mutex_iothread_locked();
+    bool val;
+
+    if (!locked) {
+        qemu_mutex_lock_iothread();
+    }
+    val = block();
+    if (!locked) {
+        qemu_mutex_unlock_iothread();
+    }
+    return val;
+}
+
+static int cocoa_keycode_to_qemu(int keycode)
+{
+    if (qemu_input_map_osx_to_qcode_len <= keycode) {
+        error_report("(cocoa) warning unknown keycode 0x%x", keycode);
+        return 0;
+    }
+    return qemu_input_map_osx_to_qcode[keycode];
+}
+
+static CGRect compute_cursor_clip_rect(int screen_height,
+                                       int given_mouse_x, int given_mouse_y,
+                                       int cursor_width, int cursor_height)
+{
+    CGRect rect;
+
+    rect.origin.x = MAX(0, -given_mouse_x);
+    rect.origin.y = 0;
+    rect.size.width = MIN(cursor_width, cursor_width + given_mouse_x);
+    rect.size.height = cursor_height - rect.origin.x;
+
+    return rect;
+}
+
+static CGEventRef handleTapEvent(CGEventTapProxy proxy, CGEventType type, CGEventRef cgEvent, void *userInfo)
+{
+    QemuCocoaView *cocoaView = userInfo;
+    NSEvent *event = [NSEvent eventWithCGEvent:cgEvent];
+    if ([cocoaView isMouseGrabbed] && [cocoaView handleEvent:event]) {
+        COCOA_DEBUG("Global events tap: qemu handled the event, capturing!\n");
+        return NULL;
+    }
+    COCOA_DEBUG("Global events tap: qemu did not handle the event, letting it through...\n");
+
+    return cgEvent;
+}
+
+@implementation QemuCocoaView
+- (id)initWithFrame:(NSRect)frameRect
+             screen:(QEMUScreen *)given_screen
+{
+    COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
+
+    self = [super initWithFrame:frameRect];
+    if (self) {
+
+        screen = given_screen;
+        screen_width = frameRect.size.width;
+        screen_height = frameRect.size.height;
+
+        /* Used for displaying pause on the screen */
+        pauseLabel = [NSTextField new];
+        [pauseLabel setBezeled:YES];
+        [pauseLabel setDrawsBackground:YES];
+        [pauseLabel setBackgroundColor: [NSColor whiteColor]];
+        [pauseLabel setEditable:NO];
+        [pauseLabel setSelectable:NO];
+        [pauseLabel setStringValue: @"Paused"];
+        [pauseLabel setFont: [NSFont fontWithName: @"Helvetica" size: 90]];
+        [pauseLabel setTextColor: [NSColor blackColor]];
+        [pauseLabel sizeToFit];
+
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+    COCOA_DEBUG("QemuCocoaView: dealloc\n");
+
+    if (pauseLabel) {
+        [pauseLabel release];
+    }
+
+    if (eventsTap) {
+        CFRelease(eventsTap);
+    }
+
+    [super dealloc];
+}
+
+- (BOOL) isOpaque
+{
+    return YES;
+}
+
+- (void) removeTrackingRect
+{
+    if (trackingArea) {
+        [self removeTrackingArea:trackingArea];
+        [trackingArea release];
+        trackingArea = nil;
+    }
+}
+
+- (void) frameUpdated
+{
+    [self removeTrackingRect];
+
+    if ([self window]) {
+        NSTrackingAreaOptions options = NSTrackingActiveInKeyWindow |
+                                        NSTrackingMouseEnteredAndExited |
+                                        NSTrackingMouseMoved;
+        trackingArea = [[NSTrackingArea alloc] initWithRect:[self frame]
+                                                    options:options
+                                                      owner:self
+                                                   userInfo:nil];
+        [self addTrackingArea:trackingArea];
+        [self updateUIInfo];
+    }
+}
+
+- (void) viewDidMoveToWindow
+{
+    [self resizeWindow];
+    [self frameUpdated];
+}
+
+- (void) viewWillMoveToWindow:(NSWindow *)newWindow
+{
+    [self removeTrackingRect];
+}
+
+- (void) selectConsoleLocked:(unsigned int)index
+{
+    cocoa_listener_select(index);
+    [self updateUIInfo];
+}
+
+- (void) hideCursor
+{
+    if (screen->cursor_show) {
+        return;
+    }
+    [NSCursor hide];
+}
+
+- (void) unhideCursor
+{
+    if (screen->cursor_show) {
+        return;
+    }
+    [NSCursor unhide];
+}
+
+- (CGRect) convertCursorClipRectToDraw:(CGRect)rect
+                          screenHeight:(int)given_screen_height
+                                mouseX:(int)mouse_x
+                                mouseY:(int)mouse_y
+{
+    CGFloat d = [self frame].size.height / (CGFloat)given_screen_height;
+
+    rect.origin.x = (rect.origin.x + mouse_x) * d;
+    rect.origin.y = (given_screen_height - rect.origin.y - mouse_y - rect.size.height) * d;
+    rect.size.width *= d;
+    rect.size.height *= d;
+
+    return rect;
+}
+
+- (void) drawRect:(NSRect) rect
+{
+    COCOA_DEBUG("QemuCocoaView: drawRect\n");
+
+#ifdef CONFIG_OPENGL
+    if (display_opengl) {
+        return;
+    }
+#endif
+
+    // get CoreGraphic context
+    CGContextRef viewContextRef = [[NSGraphicsContext currentContext] CGContext];
+
+    CGContextSetInterpolationQuality (viewContextRef, kCGInterpolationNone);
+    CGContextSetShouldAntialias (viewContextRef, NO);
+
+    qemu_mutex_lock(&screen->draw_mutex);
+
+    // draw screen bitmap directly to Core Graphics context
+    if (!screen->surface) {
+        // Draw request before any guest device has set up a framebuffer:
+        // just draw an opaque black rectangle
+        CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
+        CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
+    } else {
+        int w = surface_width(screen->surface);
+        int h = surface_height(screen->surface);
+        int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(screen->surface));
+        int stride = surface_stride(screen->surface);
+
+        CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
+            NULL,
+            surface_data(screen->surface),
+            stride * h,
+            NULL
+        );
+        CGImageRef imageRef = CGImageCreate(
+            w, //width
+            h, //height
+            DIV_ROUND_UP(bitsPerPixel, 8) * 2, //bitsPerComponent
+            bitsPerPixel, //bitsPerPixel
+            stride, //bytesPerRow
+            CGColorSpaceCreateWithName(kCGColorSpaceSRGB), //colorspace
+            kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipFirst, //bitmapInfo
+            dataProviderRef, //provider
+            NULL, //decode
+            0, //interpolate
+            kCGRenderingIntentDefault //intent
+        );
+        // selective drawing code (draws only dirty rectangles) (OS X >= 10.4)
+        const NSRect *rectList;
+        NSInteger rectCount;
+        int i;
+        CGImageRef clipImageRef;
+        CGRect clipRect;
+        CGFloat d = (CGFloat)h / [self frame].size.height;
+
+        [self getRectsBeingDrawn:&rectList count:&rectCount];
+        for (i = 0; i < rectCount; i++) {
+            clipRect.origin.x = rectList[i].origin.x * d;
+            clipRect.origin.y = (float)h - (rectList[i].origin.y + rectList[i].size.height) * d;
+            clipRect.size.width = rectList[i].size.width * d;
+            clipRect.size.height = rectList[i].size.height * d;
+            clipImageRef = CGImageCreateWithImageInRect(
+                                                        imageRef,
+                                                        clipRect
+                                                        );
+            CGContextDrawImage (viewContextRef, cgrect(rectList[i]), clipImageRef);
+            CGImageRelease (clipImageRef);
+        }
+        CGImageRelease (imageRef);
+        CGDataProviderRelease(dataProviderRef);
+
+        if (screen->active_listener->mouse_on) {
+            size_t cursor_width = CGImageGetWidth(screen->cursor_cgimage);
+            size_t cursor_height = CGImageGetHeight(screen->cursor_cgimage);
+            int mouse_x = screen->active_listener->mouse_x;
+            int mouse_y = screen->active_listener->mouse_y;
+            clipRect = compute_cursor_clip_rect(h, mouse_x, mouse_y,
+                                                cursor_width,
+                                                cursor_height);
+            CGRect drawRect = [self convertCursorClipRectToDraw:clipRect
+                                                   screenHeight:h
+                                                         mouseX:mouse_x
+                                                         mouseY:mouse_y];
+            clipImageRef = CGImageCreateWithImageInRect(
+                                                        screen->cursor_cgimage,
+                                                        clipRect
+                                                        );
+            CGContextDrawImage(viewContextRef, drawRect, clipImageRef);
+            CGImageRelease (clipImageRef);
+        }
+    }
+
+    qemu_mutex_unlock(&screen->draw_mutex);
+}
+
+- (NSSize) computeUnzoomedSize
+{
+    CGFloat width = screen_width / [[self window] backingScaleFactor];
+    CGFloat height = screen_height / [[self window] backingScaleFactor];
+
+    return NSMakeSize(width, height);
+}
+
+- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize
+{
+    NSSize size;
+
+    size.width = (CGFloat)screen_width * proposedSize.height;
+    size.height = (CGFloat)screen_height * proposedSize.width;
+
+    if (size.width < size.height) {
+        size.width /= screen_height;
+        size.height = proposedSize.height;
+    } else {
+        size.width = proposedSize.width;
+        size.height /= screen_width;
+    }
+
+    return size;
+}
+
+- (void) resizeWindow
+{
+    [[self window] setContentAspectRatio:NSMakeSize(screen_width, screen_height)];
+
+    if (([[self window] styleMask] & NSWindowStyleMaskResizable) == 0) {
+        [[self window] setContentSize:[self computeUnzoomedSize]];
+        [[self window] center];
+    } else if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
+        [[self window] setContentSize:[self fixZoomedFullScreenSize:[[[self window] screen] frame].size]];
+        [[self window] center];
+    }
+}
+
+- (void) updateUIInfoLocked
+{
+    /* Must be called with the iothread lock, i.e. via updateUIInfo */
+    NSSize frameSize;
+    QemuUIInfo info = {};
+
+    if ([self window]) {
+        NSDictionary *description = [[[self window] screen] deviceDescription];
+        CGDirectDisplayID display = [[description objectForKey:@"NSScreenNumber"] unsignedIntValue];
+        NSSize screenSize = [[[self window] screen] frame].size;
+        CGSize screenPhysicalSize = CGDisplayScreenSize(display);
+        CVDisplayLinkRef displayLink;
+
+        if (([[self window] styleMask] & NSWindowStyleMaskFullScreen) == 0) {
+            frameSize = [self frame].size;
+        } else {
+            frameSize = screenSize;
+        }
+
+        if (!CVDisplayLinkCreateWithCGDisplay(display, &displayLink)) {
+            CVTime period = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink);
+            CVDisplayLinkRelease(displayLink);
+            if (!(period.flags & kCVTimeIsIndefinite)) {
+                update_displaychangelistener(&screen->active_listener->dcl,
+                                             1000 * period.timeValue / period.timeScale);
+                info.refresh_rate = (int64_t)1000 * period.timeScale / period.timeValue;
+            }
+        }
+
+        info.width_mm = frameSize.width / screenSize.width * screenPhysicalSize.width;
+        info.height_mm = frameSize.height / screenSize.height * screenPhysicalSize.height;
+    } else {
+        frameSize = [self frame].size;
+    }
+
+    NSSize frameBackingSize = [self convertSizeToBacking:frameSize];
+
+    info.width = frameBackingSize.width;
+    info.height = frameBackingSize.height;
+
+    dpy_set_ui_info(screen->active_listener->dcl.con, &info, TRUE);
+}
+
+- (void) updateUIInfo
+{
+    if (!screen->listeners) {
+        /*
+         * Don't try to tell QEMU about UI information in the application
+         * startup phase -- we haven't yet registered dcl with the QEMU UI
+         * layer, and also trying to take the iothread lock would deadlock.
+         * When cocoa_display_init() does register the dcl, the UI layer
+         * will call cocoa_switch(), which will call updateUIInfo, so
+         * we don't lose any information here.
+         */
+        return;
+    }
+
+    with_iothread_lock(^{
+        [self updateUIInfoLocked];
+    });
+}
+
+- (void) updateScreenWidth:(int)w height:(int)h
+{
+    COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
+
+    if (w != screen_width || h != screen_height) {
+        COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
+        screen_width = w;
+        screen_height = h;
+        [self resizeWindow];
+    }
+}
+
+- (void) setFullGrab:(id)sender
+{
+    COCOA_DEBUG("QemuCocoaView: setFullGrab\n");
+
+    CGEventMask mask = CGEventMaskBit(kCGEventKeyDown) | CGEventMaskBit(kCGEventKeyUp) | CGEventMaskBit(kCGEventFlagsChanged);
+    eventsTap = CGEventTapCreate(kCGHIDEventTap, kCGHeadInsertEventTap, kCGEventTapOptionDefault,
+                                 mask, handleTapEvent, self);
+    if (!eventsTap) {
+        warn_report("Could not create event tap, system key combos will not be captured.\n");
+        return;
+    } else {
+        COCOA_DEBUG("Global events tap created! Will capture system key combos.\n");
+    }
+
+    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
+    if (!runLoop) {
+        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
+        return;
+    }
+
+    CFRunLoopSourceRef tapEventsSrc = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventsTap, 0);
+    if (!tapEventsSrc ) {
+        warn_report("Could not obtain current CF RunLoop, system key combos will not be captured.\n");
+        return;
+    }
+
+    CFRunLoopAddSource(runLoop, tapEventsSrc, kCFRunLoopDefaultMode);
+    CFRelease(tapEventsSrc);
+}
+
+- (void) toggleKey: (int)keycode {
+    qkbd_state_key_event(screen->kbd, keycode, !qkbd_state_key_get(screen->kbd, keycode));
+}
+
+// Does the work of sending input to the monitor
+- (void) handleMonitorInput:(NSEvent *)event
+{
+    int keysym = 0;
+    int control_key = 0;
+
+    // if the control key is down
+    if ([event modifierFlags] & NSEventModifierFlagControl) {
+        control_key = 1;
+    }
+
+    /* translates Macintosh keycodes to QEMU's keysym */
+
+    static const int without_control_translation[] = {
+        [0 ... 0xff] = 0,   // invalid key
+
+        [kVK_UpArrow]       = QEMU_KEY_UP,
+        [kVK_DownArrow]     = QEMU_KEY_DOWN,
+        [kVK_RightArrow]    = QEMU_KEY_RIGHT,
+        [kVK_LeftArrow]     = QEMU_KEY_LEFT,
+        [kVK_Home]          = QEMU_KEY_HOME,
+        [kVK_End]           = QEMU_KEY_END,
+        [kVK_PageUp]        = QEMU_KEY_PAGEUP,
+        [kVK_PageDown]      = QEMU_KEY_PAGEDOWN,
+        [kVK_ForwardDelete] = QEMU_KEY_DELETE,
+        [kVK_Delete]        = QEMU_KEY_BACKSPACE,
+    };
+
+    static const int with_control_translation[] = {
+        [0 ... 0xff] = 0,   // invalid key
+
+        [kVK_UpArrow]       = QEMU_KEY_CTRL_UP,
+        [kVK_DownArrow]     = QEMU_KEY_CTRL_DOWN,
+        [kVK_RightArrow]    = QEMU_KEY_CTRL_RIGHT,
+        [kVK_LeftArrow]     = QEMU_KEY_CTRL_LEFT,
+        [kVK_Home]          = QEMU_KEY_CTRL_HOME,
+        [kVK_End]           = QEMU_KEY_CTRL_END,
+        [kVK_PageUp]        = QEMU_KEY_CTRL_PAGEUP,
+        [kVK_PageDown]      = QEMU_KEY_CTRL_PAGEDOWN,
+    };
+
+    if (control_key != 0) { /* If the control key is being used */
+        if ([event keyCode] < ARRAY_SIZE(with_control_translation)) {
+            keysym = with_control_translation[[event keyCode]];
+        }
+    } else {
+        if ([event keyCode] < ARRAY_SIZE(without_control_translation)) {
+            keysym = without_control_translation[[event keyCode]];
+        }
+    }
+
+    // if not a key that needs translating
+    if (keysym == 0) {
+        NSString *ks = [event characters];
+        if ([ks length] > 0) {
+            keysym = [ks characterAtIndex:0];
+        }
+    }
+
+    if (keysym) {
+        kbd_put_keysym_console(screen->active_listener->dcl.con, keysym);
+    }
+}
+
+- (bool) handleEvent:(NSEvent *)event
+{
+    if(!screen->listeners) {
+        return false;
+    }
+
+    return bool_with_iothread_lock(^{
+        return [self handleEventLocked:event];
+    });
+}
+
+- (bool) handleEventLocked:(NSEvent *)event
+{
+    /* Return true if we handled the event, false if it should be given to OSX */
+    COCOA_DEBUG("QemuCocoaView: handleEvent\n");
+    int buttons = 0;
+    int keycode = 0;
+    NSUInteger modifiers = [event modifierFlags];
+
+    /*
+     * Check -[NSEvent modifierFlags] here.
+     *
+     * There is a NSEventType for an event notifying the change of
+     * -[NSEvent modifierFlags], NSEventTypeFlagsChanged but these operations
+     * are performed for any events because a modifier state may change while
+     * the application is inactive (i.e. no events fire) and we don't want to
+     * wait for another modifier state change to detect such a change.
+     *
+     * NSEventModifierFlagCapsLock requires a special treatment. The other flags
+     * are handled in similar manners.
+     *
+     * NSEventModifierFlagCapsLock
+     * ---------------------------
+     *
+     * If CapsLock state is changed, "up" and "down" events will be fired in
+     * sequence, effectively updates CapsLock state on the guest.
+     *
+     * The other flags
+     * ---------------
+     *
+     * If a flag is not set, fire "up" events for all keys which correspond to
+     * the flag. Note that "down" events are not fired here because the flags
+     * checked here do not tell what exact keys are down.
+     *
+     * If one of the keys corresponding to a flag is down, we rely on
+     * -[NSEvent keyCode] of an event whose -[NSEvent type] is
+     * NSEventTypeFlagsChanged to know the exact key which is down, which has
+     * the following two downsides:
+     * - It does not work when the application is inactive as described above.
+     * - It malfactions *after* the modifier state is changed while the
+     *   application is inactive. It is because -[NSEvent keyCode] does not tell
+     *   if the key is up or down, and requires to infer the current state from
+     *   the previous state. It is still possible to fix such a malfanction by
+     *   completely leaving your hands from the keyboard, which hopefully makes
+     *   this implementation usable enough.
+     */
+    if (!!(modifiers & NSEventModifierFlagCapsLock) !=
+        qkbd_state_modifier_get(screen->kbd, QKBD_MOD_CAPSLOCK)) {
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CAPS_LOCK, true);
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CAPS_LOCK, false);
+    }
+
+    if (!(modifiers & NSEventModifierFlagShift)) {
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_SHIFT, false);
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_SHIFT_R, false);
+    }
+    if (!(modifiers & NSEventModifierFlagControl)) {
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CTRL, false);
+        qkbd_state_key_event(screen->kbd, Q_KEY_CODE_CTRL_R, false);
+    }
+    if (!(modifiers & NSEventModifierFlagOption)) {
+        if (screen->swap_opt_cmd) {
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_L, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_R, false);
+        } else {
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT_R, false);
+        }
+    }
+    if (!(modifiers & NSEventModifierFlagCommand)) {
+        if (screen->swap_opt_cmd) {
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_ALT_R, false);
+        } else {
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_L, false);
+            qkbd_state_key_event(screen->kbd, Q_KEY_CODE_META_R, false);
+        }
+    }
+
+    switch ([event type]) {
+        case NSEventTypeFlagsChanged:
+            switch ([event keyCode]) {
+                case kVK_Shift:
+                    if (!!(modifiers & NSEventModifierFlagShift)) {
+                        [self toggleKey:Q_KEY_CODE_SHIFT];
+                    }
+                    return true;
+
+                case kVK_RightShift:
+                    if (!!(modifiers & NSEventModifierFlagShift)) {
+                        [self toggleKey:Q_KEY_CODE_SHIFT_R];
+                    }
+                    return true;
+
+                case kVK_Control:
+                    if (!!(modifiers & NSEventModifierFlagControl)) {
+                        [self toggleKey:Q_KEY_CODE_CTRL];
+                    }
+                    return true;
+
+                case kVK_RightControl:
+                    if (!!(modifiers & NSEventModifierFlagControl)) {
+                        [self toggleKey:Q_KEY_CODE_CTRL_R];
+                    }
+                    return true;
+
+                case kVK_Option:
+                    if (!!(modifiers & NSEventModifierFlagOption)) {
+                        if (screen->swap_opt_cmd) {
+                            [self toggleKey:Q_KEY_CODE_META_L];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_ALT];
+                        }
+                    }
+                    return true;
+
+                case kVK_RightOption:
+                    if (!!(modifiers & NSEventModifierFlagOption)) {
+                        if (screen->swap_opt_cmd) {
+                            [self toggleKey:Q_KEY_CODE_META_R];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_ALT_R];
+                        }
+                    }
+                    return true;
+
+                /* Don't pass command key changes to guest unless mouse is grabbed */
+                case kVK_Command:
+                    if (isMouseGrabbed &&
+                        !!(modifiers & NSEventModifierFlagCommand) &&
+                        !screen->left_command_key_disabled) {
+                        if (screen->swap_opt_cmd) {
+                            [self toggleKey:Q_KEY_CODE_ALT];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_META_L];
+                        }
+                    }
+                    return true;
+
+                case kVK_RightCommand:
+                    if (isMouseGrabbed &&
+                        !!(modifiers & NSEventModifierFlagCommand)) {
+                        if (screen->swap_opt_cmd) {
+                            [self toggleKey:Q_KEY_CODE_ALT_R];
+                        } else {
+                            [self toggleKey:Q_KEY_CODE_META_R];
+                        }
+                    }
+                    return true;
+
+                default:
+                    return true;
+            }
+        case NSEventTypeKeyDown:
+            keycode = cocoa_keycode_to_qemu([event keyCode]);
+
+            // forward command key combos to the host UI unless the mouse is grabbed
+            if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
+                return false;
+            }
+
+            // default
+
+            // handle control + alt Key Combos (ctrl+alt+[1..9,g] is reserved for QEMU)
+            if (([event modifierFlags] & NSEventModifierFlagControl) && ([event modifierFlags] & NSEventModifierFlagOption)) {
+                NSString *keychar = [event charactersIgnoringModifiers];
+                if ([keychar length] == 1) {
+                    char key = [keychar characterAtIndex:0];
+                    switch (key) {
+
+                        // enable graphic console
+                        case '1' ... '9':
+                            [self selectConsoleLocked:key - '0' - 1]; /* ascii math */
+                            return true;
+
+                        // release the mouse grab
+                        case 'g':
+                            [self ungrabMouseLocked];
+                            return true;
+                    }
+                }
+            }
+
+            if (qemu_console_is_graphic(screen->active_listener->dcl.con)) {
+                qkbd_state_key_event(screen->kbd, keycode, true);
+            } else {
+                [self handleMonitorInput: event];
+            }
+            return true;
+        case NSEventTypeKeyUp:
+            keycode = cocoa_keycode_to_qemu([event keyCode]);
+
+            // don't pass the guest a spurious key-up if we treated this
+            // command-key combo as a host UI action
+            if (!isMouseGrabbed && ([event modifierFlags] & NSEventModifierFlagCommand)) {
+                return true;
+            }
+
+            if (qemu_console_is_graphic(screen->active_listener->dcl.con)) {
+                qkbd_state_key_event(screen->kbd, keycode, false);
+            }
+            return true;
+        case NSEventTypeScrollWheel:
+            /*
+             * Send wheel events to the guest regardless of window focus.
+             * This is in-line with standard Mac OS X UI behaviour.
+             */
+
+            /*
+             * We shouldn't have got a scroll event when deltaY and delta Y
+             * are zero, hence no harm in dropping the event
+             */
+            if ([event deltaY] != 0 || [event deltaX] != 0) {
+            /* Determine if this is a scroll up or scroll down event */
+                if ([event deltaY] != 0) {
+                  buttons = ([event deltaY] > 0) ?
+                    INPUT_BUTTON_WHEEL_UP : INPUT_BUTTON_WHEEL_DOWN;
+                } else if ([event deltaX] != 0) {
+                  buttons = ([event deltaX] > 0) ?
+                    INPUT_BUTTON_WHEEL_LEFT : INPUT_BUTTON_WHEEL_RIGHT;
+                }
+
+                qemu_input_queue_btn(screen->active_listener->dcl.con, buttons, true);
+                qemu_input_event_sync();
+                qemu_input_queue_btn(screen->active_listener->dcl.con, buttons, false);
+                qemu_input_event_sync();
+            }
+
+            /*
+             * Since deltaX/deltaY also report scroll wheel events we prevent mouse
+             * movement code from executing.
+             */
+            return true;
+        default:
+            return false;
+    }
+}
+
+- (void) handleMouseEvent:(NSEvent *)event
+{
+    if (!isMouseGrabbed) {
+        return;
+    }
+
+    with_iothread_lock(^{
+        QemuConsole *con = screen->active_listener->dcl.con;
+
+        if (isAbsoluteEnabled) {
+            CGFloat d = (CGFloat)screen_height / [self frame].size.height;
+            NSPoint p = [event locationInWindow];
+            // Note that the origin for Cocoa mouse coords is bottom left, not top left.
+            qemu_input_queue_abs(con, INPUT_AXIS_X, p.x * d, 0, screen_width);
+            qemu_input_queue_abs(con, INPUT_AXIS_Y, screen_height - p.y * d, 0, screen_height);
+        } else {
+            CGFloat d = (CGFloat)screen_height / [self convertSizeToBacking:[self frame].size].height;
+            qemu_input_queue_rel(con, INPUT_AXIS_X, [event deltaX] * d);
+            qemu_input_queue_rel(con, INPUT_AXIS_Y, [event deltaY] * d);
+        }
+
+        qemu_input_event_sync();
+    });
+}
+
+- (void) handleMouseEvent:(NSEvent *)event button:(InputButton)button down:(bool)down
+{
+    if (!isMouseGrabbed) {
+        return;
+    }
+
+    with_iothread_lock(^{
+        qemu_input_queue_btn(screen->active_listener->dcl.con, button, down);
+    });
+
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseExited:(NSEvent *)event
+{
+    if (isAbsoluteEnabled && isMouseGrabbed) {
+        [self ungrabMouse];
+    }
+}
+
+- (void) mouseEntered:(NSEvent *)event
+{
+    if (isAbsoluteEnabled && !isMouseGrabbed) {
+        [self grabMouse];
+    }
+}
+
+- (void) mouseMoved:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:true];
+}
+
+- (void) rightMouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:true];
+}
+
+- (void) otherMouseDown:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:true];
+}
+
+- (void) mouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) rightMouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) otherMouseDragged:(NSEvent *)event
+{
+    [self handleMouseEvent:event];
+}
+
+- (void) mouseUp:(NSEvent *)event
+{
+    if (!isMouseGrabbed) {
+        [self grabMouse];
+    }
+
+    [self handleMouseEvent:event button:INPUT_BUTTON_LEFT down:false];
+}
+
+- (void) rightMouseUp:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_RIGHT down:false];
+}
+
+- (void) otherMouseUp:(NSEvent *)event
+{
+    [self handleMouseEvent:event button:INPUT_BUTTON_MIDDLE down:false];
+}
+
+- (void) grabMouse
+{
+    COCOA_DEBUG("QemuCocoaView: grabMouse\n");
+
+    if (!screen->listeners) {
+        return;
+    }
+
+    if (qemu_name)
+        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt + g to release Mouse)", qemu_name]];
+    else
+        [[self window] setTitle:@"QEMU - (Press ctrl + alt + g to release Mouse)"];
+    [self hideCursor];
+    CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
+    isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
+}
+
+- (void) ungrabMouse
+{
+    with_iothread_lock(^{
+        [self ungrabMouseLocked];
+    });
+}
+
+- (void) ungrabMouseLocked
+{
+    COCOA_DEBUG("QemuCocoaView: ungrabMouseLocked\n");
+
+    if (qemu_name)
+        [[self window] setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
+    else
+        [[self window] setTitle:@"QEMU"];
+    [self unhideCursor];
+    CGAssociateMouseAndMouseCursorPosition(TRUE);
+    isMouseGrabbed = FALSE;
+    [self raiseAllButtonsLocked];
+}
+
+- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {
+    isAbsoluteEnabled = tIsAbsoluteEnabled;
+    if (isMouseGrabbed) {
+        CGAssociateMouseAndMouseCursorPosition(isAbsoluteEnabled);
+    }
+}
+- (BOOL) isMouseGrabbed {return isMouseGrabbed;}
+- (BOOL) isAbsoluteEnabled {return isAbsoluteEnabled;}
+
+- (void) raiseAllButtonsLocked
+{
+    QemuConsole *con = screen->active_listener->dcl.con;
+
+    qemu_input_queue_btn(con, INPUT_BUTTON_LEFT, false);
+    qemu_input_queue_btn(con, INPUT_BUTTON_RIGHT, false);
+    qemu_input_queue_btn(con, INPUT_BUTTON_MIDDLE, false);
+}
+
+- (void) setNeedsDisplayForCursorX:(int)x
+                                 y:(int)y
+                             width:(int)width
+                            height:(int)height
+                      screenHeight:(int)given_screen_height
+{
+    CGRect clip_rect = compute_cursor_clip_rect(given_screen_height, x, y,
+                                                width, height);
+    CGRect draw_rect = [self convertCursorClipRectToDraw:clip_rect
+                                            screenHeight:given_screen_height
+                                                  mouseX:x
+                                                  mouseY:y];
+    [self setNeedsDisplayInRect:draw_rect];
+}
+
+/* Displays the word pause on the screen */
+- (void)displayPause
+{
+    /* Coordinates have to be calculated each time because the window can change its size */
+    int xCoord, yCoord, width, height;
+    xCoord = ([[self window] frame].size.width - [pauseLabel frame].size.width)/2;
+    yCoord = [[self window] frame].size.height - [pauseLabel frame].size.height - ([pauseLabel frame].size.height * .5);
+    width = [pauseLabel frame].size.width;
+    height = [pauseLabel frame].size.height;
+    [pauseLabel setFrame: NSMakeRect(xCoord, yCoord, width, height)];
+    [self addSubview: pauseLabel];
+}
 
+/* Removes the word pause from the screen */
+- (void)removePause
+{
+    [pauseLabel removeFromSuperview];
+}
+@end

From aac64f92861b429336a91a8bc54e2c643e8e5a6d Mon Sep 17 00:00:00 2001
From: Gustavo Noronha Silva <gustavo@noronha.eti.br>
Date: Thu, 6 May 2021 07:04:55 -0300
Subject: [PATCH 164/180] ui/cocoa: handle mouse grab properly on window being
 key changes

Being key is similar to being focused on other platforms. When the
window loses focus at the moment it will still keep the mouse grabbed
unless it is using an absolute pointing device like a USB tablet.

That may happen in several ways as Mac OS does not let Qemu handle some
of the events even when it has a grab. Command-Tab will switch applications
if full-grab is off, and even if it is on you can still switch away from
by using 3-finger gestures on the trackpad to change spaces or open
Mission Control, for instance.

That behaviour is not ideal, as even though Qemu still believes it is
getting all the events, Mac OS has effectively released the mouse.
And it is worse with full-grab turned on, as it will still capture
the key events, making you unable to use the keyboard on the Mac OS
environment.

This change makes Qemu properly release the grab when Mac OS effectively
does it. In addition, it properly automatically regrabs the mouse when
the window becomes key and is fullscreen. While it makes sense to wait
for a click on a non-fullscreen window, as the user may just be moving
the window around, for instance, when it's fullscreen there is no point.

Signed-off-by: Gustavo Noronha Silva <gustavo@noronha.eti.br>
---
 ui/cocoa/app_controller.m | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/ui/cocoa/app_controller.m b/ui/cocoa/app_controller.m
index 0165d041bf0a..364f48abeb3e 100644
--- a/ui/cocoa/app_controller.m
+++ b/ui/cocoa/app_controller.m
@@ -163,6 +163,21 @@ - (void)windowDidResize:(NSNotification *)notification
     [cocoaView frameUpdated];
 }
 
+- (void)windowDidResignKey:(NSNotification *)notification
+{
+    [cocoaView ungrabMouse];
+}
+
+- (void)windowDidBecomeKey:(NSNotification *)notification
+{
+    /* If we became key and are fullscreen there is no point in waiting for
+     * a click to grab the mouse.
+     */
+    if (([[cocoaView window] styleMask] & NSWindowStyleMaskFullScreen) != 0) {
+        [cocoaView grabMouse];
+    }
+}
+
 /* Called when the user clicks on a window's close button */
 - (BOOL)windowShouldClose:(id)sender
 {

From 1716a3f189216b1725276b12cde213048df30940 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sat, 18 Dec 2021 12:13:11 +0900
Subject: [PATCH 165/180] ui/cocoa: Use qemu_add_mouse_change_notifier

This eliminates the polling in cocoa_refresh and implements the
propagation of the mouse mode change from absolute to relative.

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 ui/cocoa/main.m | 37 ++++++++++++++++++++++++++-----------
 1 file changed, 26 insertions(+), 11 deletions(-)

diff --git a/ui/cocoa/main.m b/ui/cocoa/main.m
index 754e32a82f0a..3bc4c352b449 100644
--- a/ui/cocoa/main.m
+++ b/ui/cocoa/main.m
@@ -303,6 +303,29 @@ static void addRemovableDevicesMenuItems(void)
     qapi_free_BlockInfoList(pointerToFree);
 }
 
+static void cocoa_mouse_mode_change_notify(Notifier *notifier, void *data)
+{
+    static bool shared_is_absolute;
+
+    qatomic_set(&shared_is_absolute, qemu_input_is_absolute());
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        bool is_absolute = qatomic_read(&shared_is_absolute);
+        if (is_absolute == [[appController cocoaView] isAbsoluteEnabled]) {
+            return;
+        }
+
+        if (is_absolute && [[appController cocoaView] isMouseGrabbed]) {
+            [[appController cocoaView] ungrabMouse];
+        }
+        [[appController cocoaView] setAbsoluteEnabled:is_absolute];
+    });
+}
+
+static Notifier mouse_mode_change_notifier = {
+    .notify = cocoa_mouse_mode_change_notify
+};
+
 static void cocoa_clipboard_notify(Notifier *notifier, void *data);
 static void cocoa_clipboard_request(QemuClipboardInfo *info,
                                     QemuClipboardType type);
@@ -453,17 +476,6 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
 
     graphic_hw_update(dcl->con);
 
-    if (qemu_input_is_absolute()) {
-        dispatch_async(dispatch_get_main_queue(), ^{
-            if (![[appController cocoaView] isAbsoluteEnabled]) {
-                if ([[appController cocoaView] isMouseGrabbed]) {
-                    [[appController cocoaView] ungrabMouse];
-                }
-            }
-            [[appController cocoaView] setAbsoluteEnabled:YES];
-        });
-    }
-
     if (cbchangecount != [[NSPasteboard generalPasteboard] changeCount]) {
         qemu_clipboard_info_unref(qemucb.info);
         qemucb.info = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
@@ -1034,6 +1046,9 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
         screen.kbd = qkbd_state_init(screen.active_listener->dcl.con);
     }
 
+    qemu_add_mouse_mode_change_notifier(&mouse_mode_change_notifier);
+    [cocoaView setAbsoluteEnabled:qemu_input_is_absolute()];
+
     create_initial_menus();
 
     /*

From 84641e7ceb8fb22d83a03657b8c425b056d7e0f7 Mon Sep 17 00:00:00 2001
From: Akihiko Odaki <akihiko.odaki@gmail.com>
Date: Sat, 26 Feb 2022 14:45:56 +0900
Subject: [PATCH 166/180] coreaudio: Initialize the buffer for device change

Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
---
 audio/audio.c     | 30 ++++++++++++++++++++++++------
 audio/audio_int.h |  2 ++
 audio/coreaudio.m |  1 +
 3 files changed, 27 insertions(+), 6 deletions(-)

diff --git a/audio/audio.c b/audio/audio.c
index 6bc313d9f533..7243a78ce4c5 100644
--- a/audio/audio.c
+++ b/audio/audio.c
@@ -1378,12 +1378,21 @@ void audio_run(AudioState *s, const char *msg)
 #endif
 }
 
+void audio_generic_initialize_buffer_in(HWVoiceIn *hw)
+{
+    if (hw->buf_emul) {
+        g_free(hw->buf_emul);
+    }
+
+    hw->size_emul = hw->samples * hw->info.bytes_per_frame;
+    hw->buf_emul = g_malloc(hw->size_emul);
+    hw->pos_emul = hw->pending_emul = 0;
+}
+
 void audio_generic_run_buffer_in(HWVoiceIn *hw)
 {
     if (unlikely(!hw->buf_emul)) {
-        hw->size_emul = hw->samples * hw->info.bytes_per_frame;
-        hw->buf_emul = g_malloc(hw->size_emul);
-        hw->pos_emul = hw->pending_emul = 0;
+        audio_generic_initialize_buffer_in(hw);
     }
 
     while (hw->pending_emul < hw->size_emul) {
@@ -1417,6 +1426,17 @@ void audio_generic_put_buffer_in(HWVoiceIn *hw, void *buf, size_t size)
     hw->pending_emul -= size;
 }
 
+void audio_generic_initialize_buffer_out(HWVoiceOut *hw)
+{
+    if (hw->buf_emul) {
+        g_free(hw->buf_emul);
+    }
+
+    hw->size_emul = hw->samples * hw->info.bytes_per_frame;
+    hw->buf_emul = g_malloc(hw->size_emul);
+    hw->pos_emul = hw->pending_emul = 0;
+}
+
 size_t audio_generic_buffer_get_free(HWVoiceOut *hw)
 {
     if (hw->buf_emul) {
@@ -1448,9 +1468,7 @@ void audio_generic_run_buffer_out(HWVoiceOut *hw)
 void *audio_generic_get_buffer_out(HWVoiceOut *hw, size_t *size)
 {
     if (unlikely(!hw->buf_emul)) {
-        hw->size_emul = hw->samples * hw->info.bytes_per_frame;
-        hw->buf_emul = g_malloc(hw->size_emul);
-        hw->pos_emul = hw->pending_emul = 0;
+        audio_generic_initialize_buffer_out(hw);
     }
 
     *size = MIN(hw->size_emul - hw->pending_emul,
diff --git a/audio/audio_int.h b/audio/audio_int.h
index 2a6914d2aa65..ba2996d309d2 100644
--- a/audio/audio_int.h
+++ b/audio/audio_int.h
@@ -190,9 +190,11 @@ struct audio_pcm_ops {
     void   (*volume_in)(HWVoiceIn *hw, Volume *vol);
 };
 
+void audio_generic_initialize_buffer_in(HWVoiceIn *hw);
 void audio_generic_run_buffer_in(HWVoiceIn *hw);
 void *audio_generic_get_buffer_in(HWVoiceIn *hw, size_t *size);
 void audio_generic_put_buffer_in(HWVoiceIn *hw, void *buf, size_t size);
+void audio_generic_initialize_buffer_out(HWVoiceOut *hw);
 void audio_generic_run_buffer_out(HWVoiceOut *hw);
 size_t audio_generic_buffer_get_free(HWVoiceOut *hw);
 void *audio_generic_get_buffer_out(HWVoiceOut *hw, size_t *size);
diff --git a/audio/coreaudio.m b/audio/coreaudio.m
index 127a368ac236..ae0464ae6a84 100644
--- a/audio/coreaudio.m
+++ b/audio/coreaudio.m
@@ -471,6 +471,7 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
     core->outputDeviceID = deviceID;
     core->audioDevicePropertyBufferFrameSize = audioDevicePropertyBufferFrameSize;
     core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
+    audio_generic_initialize_buffer_out(&core->hw);
     core->ioprocid = ioprocid;
 
     return 0;

From 25dfefc810e7580422e2ee6470bcaad235b13e1f Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Fri, 29 Apr 2022 10:35:13 -0700
Subject: [PATCH 167/180] hw/arm/virt: revert old behaviour of highmem=off

On < macOS 12.4, a kernel panic is triggered for highmem=on and an error
is shown for highmem=off. We workaround this by inhibiting the error so
older versions of macOS can still use highmem=off.
---
 hw/arm/virt.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index d2e5ecd234a9..c30a13b5e14f 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -1690,7 +1690,11 @@ static void virt_set_memmap(VirtMachineState *vms, int pa_bits)
      * irrespective of the underlying capabilities of the HW.
      */
     if (!vms->highmem) {
+#ifdef CONFIG_DARWIN
+        pa_bits = 36;
+#else
         pa_bits = 32;
+#endif
     }
 
     /*

From 12d182898a4866e4be418e2abac286b497cfa1b2 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Fri, 6 May 2022 20:57:37 -0700
Subject: [PATCH 168/180] usbredir: avoid queuing hello packet on snapshot
 restore

When launching QEMU with "-loadvm", usbredir_create_parser() should avoid
setting up the hello packet (just as with "-incoming". On the latest version
of libusbredir, usbredirparser_unserialize() will return error if the parser
is not "pristine."
---
 hw/usb/redirect.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/hw/usb/redirect.c b/hw/usb/redirect.c
index 8692ea256109..d45165fe6b50 100644
--- a/hw/usb/redirect.c
+++ b/hw/usb/redirect.c
@@ -1280,7 +1280,8 @@ static void usbredir_create_parser(USBRedirDevice *dev)
     }
 #endif
 
-    if (runstate_check(RUN_STATE_INMIGRATE)) {
+    if (runstate_check(RUN_STATE_INMIGRATE) ||
+        runstate_check(RUN_STATE_PRELAUNCH)) {
         flags |= usbredirparser_fl_no_hello;
     }
     usbredirparser_init(dev->parser, VERSION, caps, USB_REDIR_CAPS_SIZE,

From 0fbf6941192c55b7d6afd557b493c4ffe4d00257 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Wed, 11 May 2022 16:34:54 -0700
Subject: [PATCH 169/180] ui/cocoa: fix compile issues after merge

---
 ui/cocoa/main.m | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/ui/cocoa/main.m b/ui/cocoa/main.m
index 3bc4c352b449..11e522e0e91b 100644
--- a/ui/cocoa/main.m
+++ b/ui/cocoa/main.m
@@ -749,7 +749,7 @@ static void cocoa_gl_cursor_render()
     glBindTexture(GL_TEXTURE_2D, cursor_texture);
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    qemu_gl_run_texture_blit(dgc.gls, false);
+    qemu_gl_run_texture_blit(dgc.gls, false, false);
     glDisable(GL_BLEND);
 }
 
@@ -797,7 +797,7 @@ static void cocoa_gl_refresh(DisplayChangeListener *dcl)
                 glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
                 glViewport(0, 0, size.width, size.height);
                 glBindTexture(GL_TEXTURE_2D, texture);
-                qemu_gl_run_texture_blit(dgc.gls, y0_top);
+                qemu_gl_run_texture_blit(dgc.gls, y0_top, false);
             } else {
                 surface_gl_setup_viewport(dgc.gls, screen.surface,
                                           size.width, size.height);
@@ -1035,8 +1035,12 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
             screen.listeners[index].dcl.ops = ops;
 
             if (display_opengl) {
+#ifdef CONFIG_OPENGL
                 qemu_console_set_display_gl_ctx(screen.listeners[index].dcl.con,
                                                 &dgc);
+#else
+                g_assert_not_reached();
+#endif
             }
 
             // register vga output callbacks

From 6626058f225c9c6a402f9ac6f90aa0b7e94d175c Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Tue, 17 May 2022 19:33:01 -0700
Subject: [PATCH 170/180] net/vmnet: use availability check at runtime

MAC_OS_X_VERSION_MIN_REQUIRED is set at compile time so this means that when
we target an older macOS version, it disables the newer features. With a
runtime check, we can selectively disable newer API features.
---
 net/vmnet-bridged.m | 29 ++++++++++---------
 net/vmnet-common.m  |  2 +-
 net/vmnet-host.c    | 70 +++++++++++++++++++++------------------------
 net/vmnet-shared.c  | 32 ++++++++++-----------
 4 files changed, 65 insertions(+), 68 deletions(-)

diff --git a/net/vmnet-bridged.m b/net/vmnet-bridged.m
index 46d22828632b..239d4e64c8ab 100644
--- a/net/vmnet-bridged.m
+++ b/net/vmnet-bridged.m
@@ -88,15 +88,16 @@ static bool validate_options(const Netdev *netdev, Error **errp)
         return false;
     }
 
-#if !defined(MAC_OS_VERSION_11_0) || \
-    MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_VERSION_11_0
-    if (options->has_isolated) {
-        error_setg(errp,
-                   "vmnet-bridged.isolated feature is "
-                   "unavailable: outdated vmnet.framework API");
-        return false;
+    if (__builtin_available(macOS 11, *)) {
+        // clang requires a true branch
+    } else {
+        if (options->has_isolated) {
+            error_setg(errp,
+                       "vmnet-bridged.isolated feature is "
+                       "unavailable: outdated vmnet.framework API");
+            return false;
+        }
     }
-#endif
     return true;
 }
 
@@ -115,12 +116,12 @@ static xpc_object_t build_if_desc(const Netdev *netdev)
                               vmnet_shared_interface_name_key,
                               options->ifname);
 
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
-    xpc_dictionary_set_bool(if_desc,
-                            vmnet_enable_isolation_key,
-                            options->isolated);
-#endif
+    if (__builtin_available(macOS 11, *)) {
+        xpc_dictionary_set_bool(if_desc,
+                                vmnet_enable_isolation_key,
+                                options->isolated);
+    }
+
     return if_desc;
 }
 
diff --git a/net/vmnet-common.m b/net/vmnet-common.m
index 2cb60b9ddde7..ed376483b9f0 100644
--- a/net/vmnet-common.m
+++ b/net/vmnet-common.m
@@ -47,7 +47,7 @@
     case VMNET_TOO_MANY_PACKETS:
         return "packet count exceeds limit";
 #if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
+    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_11_0
     case VMNET_SHARING_SERVICE_BUSY:
         return "conflict, sharing service is in use";
 #endif
diff --git a/net/vmnet-host.c b/net/vmnet-host.c
index 05f8d7886440..400b670a96d9 100644
--- a/net/vmnet-host.c
+++ b/net/vmnet-host.c
@@ -22,31 +22,29 @@ static bool validate_options(const Netdev *netdev, Error **errp)
 {
     const NetdevVmnetHostOptions *options = &(netdev->u.vmnet_host);
 
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
-
-    QemuUUID net_uuid;
-    if (options->has_net_uuid &&
-        qemu_uuid_parse(options->net_uuid, &net_uuid) < 0) {
-        error_setg(errp, "Invalid UUID provided in 'net-uuid'");
-        return false;
-    }
-#else
-    if (options->has_isolated) {
-        error_setg(errp,
-                   "vmnet-host.isolated feature is "
-                   "unavailable: outdated vmnet.framework API");
-        return false;
+    if (__builtin_available(macOS 11, *)) {
+        QemuUUID net_uuid;
+        if (options->has_net_uuid &&
+            qemu_uuid_parse(options->net_uuid, &net_uuid) < 0) {
+            error_setg(errp, "Invalid UUID provided in 'net-uuid'");
+            return false;
+        }
+    } else {
+        if (options->has_isolated) {
+            error_setg(errp,
+                       "vmnet-host.isolated feature is "
+                       "unavailable: outdated vmnet.framework API");
+            return false;
+        }
+
+        if (options->has_net_uuid) {
+            error_setg(errp,
+                       "vmnet-host.net-uuid feature is "
+                       "unavailable: outdated vmnet.framework API");
+            return false;
+        }
     }
 
-    if (options->has_net_uuid) {
-        error_setg(errp,
-                   "vmnet-host.net-uuid feature is "
-                   "unavailable: outdated vmnet.framework API");
-        return false;
-    }
-#endif
-
     if ((options->has_start_address ||
          options->has_end_address ||
          options->has_subnet_mask) &&
@@ -71,21 +69,19 @@ static xpc_object_t build_if_desc(const Netdev *netdev)
                               vmnet_operation_mode_key,
                               VMNET_HOST_MODE);
 
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
-
-    xpc_dictionary_set_bool(if_desc,
-                            vmnet_enable_isolation_key,
-                            options->isolated);
-
-    QemuUUID net_uuid;
-    if (options->has_net_uuid) {
-        qemu_uuid_parse(options->net_uuid, &net_uuid);
-        xpc_dictionary_set_uuid(if_desc,
-                                vmnet_network_identifier_key,
-                                net_uuid.data);
+    if (__builtin_available(macOS 11, *)) {
+        xpc_dictionary_set_bool(if_desc,
+                                vmnet_enable_isolation_key,
+                                options->isolated);
+
+        QemuUUID net_uuid;
+        if (options->has_net_uuid) {
+            qemu_uuid_parse(options->net_uuid, &net_uuid);
+            xpc_dictionary_set_uuid(if_desc,
+                                    vmnet_network_identifier_key,
+                                    net_uuid.data);
+        }
     }
-#endif
 
     if (options->has_start_address) {
         xpc_dictionary_set_string(if_desc,
diff --git a/net/vmnet-shared.c b/net/vmnet-shared.c
index 18cadc72bd18..c39baf9a327c 100644
--- a/net/vmnet-shared.c
+++ b/net/vmnet-shared.c
@@ -21,15 +21,16 @@ static bool validate_options(const Netdev *netdev, Error **errp)
 {
     const NetdevVmnetSharedOptions *options = &(netdev->u.vmnet_shared);
 
-#if !defined(MAC_OS_VERSION_11_0) || \
-    MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_VERSION_11_0
-    if (options->has_isolated) {
-        error_setg(errp,
-                   "vmnet-shared.isolated feature is "
-                   "unavailable: outdated vmnet.framework API");
-        return false;
+    if (__builtin_available(macOS 11, *)) {
+        // clang requires a true branch
+    } else {
+        if (options->has_isolated) {
+            error_setg(errp,
+                       "vmnet-shared.isolated feature is "
+                       "unavailable: outdated vmnet.framework API");
+            return false;
+        }
     }
-#endif
 
     if ((options->has_start_address ||
          options->has_end_address ||
@@ -76,14 +77,13 @@ static xpc_object_t build_if_desc(const Netdev *netdev)
                                   options->subnet_mask);
     }
 
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
-    xpc_dictionary_set_bool(
-        if_desc,
-        vmnet_enable_isolation_key,
-        options->isolated
-    );
-#endif
+    if (__builtin_available(macOS 11, *)) {
+        xpc_dictionary_set_bool(
+            if_desc,
+            vmnet_enable_isolation_key,
+            options->isolated
+        );
+    }
 
     return if_desc;
 }

From 51a16884c30459b8871e5783f2b879b8e52d3554 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 8 Aug 2022 14:44:10 -0700
Subject: [PATCH 171/180] Revert "usbredir: avoid queuing hello packet on
 snapshot restore"

Run state is also in RUN_STATE_PRELAUNCH while "-S" is used.

This reverts commit 12d182898a4866e4be418e2abac286b497cfa1b2.
---
 hw/usb/redirect.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/hw/usb/redirect.c b/hw/usb/redirect.c
index d45165fe6b50..8692ea256109 100644
--- a/hw/usb/redirect.c
+++ b/hw/usb/redirect.c
@@ -1280,8 +1280,7 @@ static void usbredir_create_parser(USBRedirDevice *dev)
     }
 #endif
 
-    if (runstate_check(RUN_STATE_INMIGRATE) ||
-        runstate_check(RUN_STATE_PRELAUNCH)) {
+    if (runstate_check(RUN_STATE_INMIGRATE)) {
         flags |= usbredirparser_fl_no_hello;
     }
     usbredirparser_init(dev->parser, VERSION, caps, USB_REDIR_CAPS_SIZE,

From 6e9f737fcc582d38037c08111d8e1913d418c0ca Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 8 Aug 2022 14:46:41 -0700
Subject: [PATCH 172/180] vl: on -loadvm set run state to "restore-vm"

This allows us to differentiate between a fresh boot and a restore boot.
---
 softmmu/runstate.c | 1 +
 softmmu/vl.c       | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/softmmu/runstate.c b/softmmu/runstate.c
index e0d869b21aa4..f7bb5ef1ebdd 100644
--- a/softmmu/runstate.c
+++ b/softmmu/runstate.c
@@ -77,6 +77,7 @@ typedef struct {
 
 static const RunStateTransition runstate_transitions_def[] = {
     { RUN_STATE_PRELAUNCH, RUN_STATE_INMIGRATE },
+    { RUN_STATE_PRELAUNCH, RUN_STATE_RESTORE_VM },
 
     { RUN_STATE_DEBUG, RUN_STATE_RUNNING },
     { RUN_STATE_DEBUG, RUN_STATE_FINISH_MIGRATE },
diff --git a/softmmu/vl.c b/softmmu/vl.c
index dbcfef10fb28..d779a1537e8e 100644
--- a/softmmu/vl.c
+++ b/softmmu/vl.c
@@ -3291,6 +3291,9 @@ void qemu_init(int argc, char **argv, char **envp)
                 add_device_config(DEV_DEBUGCON, optarg);
                 break;
             case QEMU_OPTION_loadvm:
+                if (!loadvm) {
+                    runstate_set(RUN_STATE_RESTORE_VM);
+                }
                 loadvm = optarg;
                 break;
             case QEMU_OPTION_full_screen:

From f129a2b8db804d5792db351241820299a5717a65 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 8 Aug 2022 16:13:20 -0700
Subject: [PATCH 173/180] usbredir: avoid queuing hello packet on snapshot
 restore

When launching QEMU with "-loadvm", usbredir_create_parser() should avoid
setting up the hello packet (just as with "-incoming". On the latest version
of libusbredir, usbredirparser_unserialize() will return error if the parser
is not "pristine."
---
 hw/usb/redirect.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/hw/usb/redirect.c b/hw/usb/redirect.c
index 8692ea256109..5ee2cc88d52a 100644
--- a/hw/usb/redirect.c
+++ b/hw/usb/redirect.c
@@ -1280,7 +1280,8 @@ static void usbredir_create_parser(USBRedirDevice *dev)
     }
 #endif
 
-    if (runstate_check(RUN_STATE_INMIGRATE)) {
+    if (runstate_check(RUN_STATE_INMIGRATE) ||
+        runstate_check(RUN_STATE_RESTORE_VM)) {
         flags |= usbredirparser_fl_no_hello;
     }
     usbredirparser_init(dev->parser, VERSION, caps, USB_REDIR_CAPS_SIZE,

From 96e76ff0a1fd0d6910261474f37d7ed8926284f9 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sat, 17 Dec 2022 15:04:19 -0800
Subject: [PATCH 174/180] Revert "egl-helpers: update EGL client version to
 3.0"

This reverts commit f357b925b319b83d4cb9a5210cfcece616b09805.
---
 ui/egl-helpers.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index 248663695603..0df9dd8fd55c 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -577,7 +577,7 @@ EGLContext qemu_egl_init_ctx(void)
         EGL_NONE
     };
     static const EGLint ctx_att_gles[] = {
-        EGL_CONTEXT_CLIENT_VERSION, 3,
+        EGL_CONTEXT_CLIENT_VERSION, 2,
         EGL_NONE
     };
     bool gles = (qemu_egl_mode == DISPLAYGL_MODE_ES);

From bb5c41eb13130dada2f3cd766da9a537ef466a4b Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Tue, 20 Dec 2022 15:56:07 -0800
Subject: [PATCH 175/180] spice-display: fix memory leak issues

1) Some of the error cases did not free GL memory.
2) Remove some unneeded logic and simplify the code.
3) Add a `eglMakeCurrent` to `spice_iosurface_destroy` to make sure we are
   freeing objects in the right context.
---
 ui/egl-helpers.c   |  1 +
 ui/spice-display.c | 29 ++++++-----------------------
 2 files changed, 7 insertions(+), 23 deletions(-)

diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index 0df9dd8fd55c..a636e5f2f272 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -389,6 +389,7 @@ EGLSurface qemu_egl_init_buffer_surface(EGLContext ectx,
     b = eglMakeCurrent(qemu_egl_display, esurface, esurface, ectx);
     if (b == EGL_FALSE) {
         error_report("egl: eglMakeCurrent failed");
+        qemu_egl_destroy_surface(esurface);
         return NULL;
     }
 
diff --git a/ui/spice-display.c b/ui/spice-display.c
index 4e4791484ced..c1d2a66fc5c4 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -847,7 +847,7 @@ static int spice_iosurface_create(SimpleSpiceDisplay *ssd, int width, int height
                            EGL_BIND_TO_TEXTURE_TARGET_ANGLE,
                            &target) != EGL_TRUE) {
         error_report("spice_iosurface_create: eglGetConfigAttrib failed");
-        return 0;
+        goto gl_error;
     }
     if (target == EGL_TEXTURE_2D) {
         tex_target = GL_TEXTURE_2D;
@@ -855,7 +855,7 @@ static int spice_iosurface_create(SimpleSpiceDisplay *ssd, int width, int height
         tex_target = GL_TEXTURE_RECTANGLE_ANGLE;
     } else {
         error_report("spice_iosurface_create: unsupported texture target");
-        return 0;
+        goto gl_error;
     }
 
     const EGLint attribs[] = {
@@ -880,6 +880,8 @@ static int spice_iosurface_create(SimpleSpiceDisplay *ssd, int width, int height
 
     egl_fb_setup_new_tex_target(&ssd->iosurface_fb, width, height, tex_target);
 
+    eglBindTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
+
     return 1;
 gl_error:
     CFRelease(ssd->iosurface);
@@ -897,6 +899,8 @@ static void spice_iosurface_destroy(SimpleSpiceDisplay *ssd)
         return;
     }
 #if defined(CONFIG_ANGLE)
+    eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
+    eglReleaseTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
     egl_fb_destroy(&ssd->iosurface_fb);
     qemu_egl_destroy_surface(ssd->esurface);
     ssd->esurface = EGL_NO_SURFACE;
@@ -963,23 +967,10 @@ static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bo
 #if defined(CONFIG_ANGLE)
     eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
     glBindTexture(ssd->iosurface_fb.texture_target, ssd->iosurface_fb.texture);
-    eglBindTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
     egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip, swap);
 #endif
 }
 
-static void spice_iosurface_flush(SimpleSpiceDisplay *ssd)
-{
-    if (!ssd->iosurface) {
-        return;
-    }
-
-#if defined(CONFIG_ANGLE)
-    eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
-    eglReleaseTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
-#endif
-}
-
 #endif
 
 static void qemu_spice_gl_monitor_config(SimpleSpiceDisplay *ssd,
@@ -1043,9 +1034,6 @@ static void spice_gl_refresh(DisplayChangeListener *dcl)
     graphic_hw_update(dcl->con);
     if (ssd->gl_updates && ssd->have_surface) {
         qemu_spice_gl_block(ssd, true);
-#if defined(CONFIG_IOSURFACE)
-        spice_iosurface_flush(ssd);
-#endif
         glFlush();
         cookie = (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_GL_DRAW_DONE, 0);
         spice_qxl_gl_draw_async(&ssd->qxl, 0, 0,
@@ -1079,10 +1067,6 @@ static void spice_gl_switch(DisplayChangeListener *dcl,
     int width = 0, height = 0;
 
     if (ssd->ds) {
-#if defined(CONFIG_IOSURFACE)
-        // need to release texture from surface before destorying it
-        spice_iosurface_flush(ssd);
-#endif
         surface_gl_destroy_texture(ssd->gls, ssd->ds);
     }
     ssd->ds = new_surface;
@@ -1346,7 +1330,6 @@ static void qemu_spice_gl_update(DisplayChangeListener *dcl,
     GLuint tex_id = ssd->backing_borrow(ssd->backing_id, &y_0_top,
                                         NULL, NULL);
     spice_iosurface_blit(ssd, tex_id, !y_0_top, false);
-    spice_iosurface_flush(ssd);
     //TODO: cursor stuff
 #endif
 

From 34b035535eee0f8497a1492ae1d9478dc9c7e7a0 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sat, 24 Dec 2022 17:08:52 -0800
Subject: [PATCH 176/180] spice-display: remove redundant glBindTexture

---
 ui/spice-display.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/ui/spice-display.c b/ui/spice-display.c
index c1d2a66fc5c4..610edaa0896b 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -966,7 +966,6 @@ static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bo
 
 #if defined(CONFIG_ANGLE)
     eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
-    glBindTexture(ssd->iosurface_fb.texture_target, ssd->iosurface_fb.texture);
     egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip, swap);
 #endif
 }

From 531da34587b38c64787cb25b1de1c5d13f75def8 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Wed, 28 Dec 2022 16:50:49 -0800
Subject: [PATCH 177/180] hvf: support TSO mode (private feature)

Apple Silicon supports TSO mode which can be used for emulating strong
memory ordering in the guest. This feature requires the private entitlement
`com.apple.private.hypervisor` as well as a private function to modify
ACTLR_EL1 not exposed by the public Hypervisor framework.
---
 accel/hvf/hvf-accel-ops.c     | 51 ++++++++++++++++++++++++++---------
 include/sysemu/hvf_int.h      | 13 +++++++++
 meson.build                   |  1 +
 meson_options.txt             |  2 ++
 scripts/meson-buildoptions.sh |  3 +++
 target/arm/hvf/hvf.c          | 28 +++++++++++++++++++
 target/i386/hvf/hvf.c         |  5 ++++
 7 files changed, 90 insertions(+), 13 deletions(-)

diff --git a/accel/hvf/hvf-accel-ops.c b/accel/hvf/hvf-accel-ops.c
index 24913ca9c49f..b414e240ec24 100644
--- a/accel/hvf/hvf-accel-ops.c
+++ b/accel/hvf/hvf-accel-ops.c
@@ -57,13 +57,10 @@
 #include "sysemu/hvf_int.h"
 #include "sysemu/runstate.h"
 #include "qemu/guest-random.h"
+#include "hw/boards.h"
 
 HVFState *hvf_state;
 
-#ifdef __aarch64__
-#define HV_VM_DEFAULT NULL
-#endif
-
 /* Memory slots */
 
 hvf_slot *hvf_find_overlap_slot(uint64_t start, uint64_t size)
@@ -319,25 +316,44 @@ bool hvf_allowed;
 
 static int hvf_accel_init(MachineState *ms)
 {
-    int x;
     hv_return_t ret;
-    HVFState *s;
+    HVFState *s = HVF_STATE(ms->accelerator);
 
-    ret = hv_vm_create(HV_VM_DEFAULT);
+    ret = hvf_arch_vm_create(s);
     assert_hvf_ok(ret);
 
-    s = g_new0(HVFState, 1);
+    hvf_state = s;
+    memory_listener_register(&hvf_memory_listener, &address_space_memory);
+
+    return hvf_arch_init();
+}
+
+#if defined(CONFIG_HVF_PRIVATE) && defined(__aarch64__)
+
+static bool hvf_get_tso(Object *obj, Error **errp)
+{
+    HVFState *s = HVF_STATE(obj);
+    return s->tso_mode;
+}
+
+static void hvf_set_tso(Object *obj, bool value, Error **errp)
+{
+    HVFState *s = HVF_STATE(obj);
+    s->tso_mode = value;
+}
+
+#endif
+
+static void hvf_accel_instance_init(Object *obj)
+{
+    int x;
+    HVFState *s = HVF_STATE(obj);
 
     s->num_slots = ARRAY_SIZE(s->slots);
     for (x = 0; x < s->num_slots; ++x) {
         s->slots[x].size = 0;
         s->slots[x].slot_id = x;
     }
-
-    hvf_state = s;
-    memory_listener_register(&hvf_memory_listener, &address_space_memory);
-
-    return hvf_arch_init();
 }
 
 static void hvf_accel_class_init(ObjectClass *oc, void *data)
@@ -346,12 +362,21 @@ static void hvf_accel_class_init(ObjectClass *oc, void *data)
     ac->name = "HVF";
     ac->init_machine = hvf_accel_init;
     ac->allowed = &hvf_allowed;
+
+#if defined(CONFIG_HVF_PRIVATE) && defined(__aarch64__)
+    object_class_property_add_bool(oc, "tso",
+        hvf_get_tso, hvf_set_tso);
+    object_class_property_set_description(oc, "tso",
+        "Set on/off to enable/disable total store ordering mode");
+#endif
 }
 
 static const TypeInfo hvf_accel_type = {
     .name = TYPE_HVF_ACCEL,
     .parent = TYPE_ACCEL,
+    .instance_init = hvf_accel_instance_init,
     .class_init = hvf_accel_class_init,
+    .instance_size = sizeof(HVFState),
 };
 
 static void hvf_type_init(void)
diff --git a/include/sysemu/hvf_int.h b/include/sysemu/hvf_int.h
index 6545f7cd6131..9f550b9f8bab 100644
--- a/include/sysemu/hvf_int.h
+++ b/include/sysemu/hvf_int.h
@@ -17,6 +17,15 @@
 #include <Hypervisor/hv.h>
 #endif
 
+#if defined(CONFIG_HVF_PRIVATE) && defined(__aarch64__)
+extern hv_return_t _hv_vm_config_set_isa(hv_vm_config_t config, uint32_t isa);
+extern hv_return_t _hv_vcpu_get_actlr(hv_vcpu_t vcpu, uint64_t* value);
+extern hv_return_t _hv_vcpu_set_actlr(hv_vcpu_t vcpu, uint64_t value);
+
+#define HV_VM_CONFIG_ISA_PRIVATE (3)
+#define ACTLR_EL1_TSO_ENABLE_MASK ((1 << 1) | (1 << 9))
+#endif
+
 /* hvf_slot flags */
 #define HVF_SLOT_LOG (1 << 0)
 
@@ -45,6 +54,9 @@ struct HVFState {
 
     hvf_vcpu_caps *hvf_caps;
     uint64_t vtimer_offset;
+#if defined(CONFIG_HVF_PRIVATE) && defined(__aarch64__)
+    bool tso_mode;
+#endif
 };
 extern HVFState *hvf_state;
 
@@ -56,6 +68,7 @@ struct hvf_vcpu_state {
 };
 
 void assert_hvf_ok(hv_return_t ret);
+hv_return_t hvf_arch_vm_create(HVFState *s);
 int hvf_arch_init(void);
 int hvf_arch_init_vcpu(CPUState *cpu);
 void hvf_arch_vcpu_destroy(CPUState *cpu);
diff --git a/meson.build b/meson.build
index 00fccfc676eb..ab6a60d1a87e 100644
--- a/meson.build
+++ b/meson.build
@@ -440,6 +440,7 @@ if get_option('hvf').allowed()
                    required: get_option('hvf'))
   if hvf.found()
     accelerators += 'CONFIG_HVF'
+    config_host_data.set('CONFIG_HVF_PRIVATE', get_option('hvf_private'))
   endif
 endif
 if get_option('hax').allowed()
diff --git a/meson_options.txt b/meson_options.txt
index 43916078c8b7..8415d4507156 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -72,6 +72,8 @@ option('whpx', type: 'feature', value: 'auto',
        description: 'WHPX acceleration support')
 option('hvf', type: 'feature', value: 'auto',
        description: 'HVF acceleration support')
+option('hvf_private', type: 'boolean', value: 'false',
+       description: 'HVF private features (entitlements required)')
 option('nvmm', type: 'feature', value: 'auto',
        description: 'NVMM acceleration support')
 option('xen', type: 'feature', value: 'auto',
diff --git a/scripts/meson-buildoptions.sh b/scripts/meson-buildoptions.sh
index 2496991056f2..010515ac98b1 100644
--- a/scripts/meson-buildoptions.sh
+++ b/scripts/meson-buildoptions.sh
@@ -26,6 +26,7 @@ meson_options_help() {
   printf "%s\n" '  --enable-fuzzing         build fuzzing targets'
   printf "%s\n" '  --enable-gcov            Enable coverage tracking.'
   printf "%s\n" '  --enable-gprof           QEMU profiling with gprof'
+  printf "%s\n" '  --enable-hvf-private     HVF private features (entitlements required)'
   printf "%s\n" '  --enable-lto             Use link time optimization'
   printf "%s\n" '  --enable-malloc=CHOICE   choose memory allocator to use [system] (choices:'
   printf "%s\n" '                           jemalloc/system/tcmalloc)'
@@ -289,6 +290,8 @@ _meson_option_parse() {
     --disable-hax) printf "%s" -Dhax=disabled ;;
     --enable-hvf) printf "%s" -Dhvf=enabled ;;
     --disable-hvf) printf "%s" -Dhvf=disabled ;;
+    --enable-hvf-private) printf "%s" -Dhvf_private=true ;;
+    --disable-hvf-private) printf "%s" -Dhvf_private=false ;;
     --iasl=*) quote_sh "-Diasl=$2" ;;
     --enable-iconv) printf "%s" -Diconv=enabled ;;
     --disable-iconv) printf "%s" -Diconv=disabled ;;
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 2c0323fe7fa4..bb7a4d50040c 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -623,6 +623,18 @@ int hvf_arch_init_vcpu(CPUState *cpu)
                               &arm_cpu->isar.id_aa64mmfr0);
     assert_hvf_ok(ret);
 
+#if defined(CONFIG_HVF_PRIVATE)
+    /* enable TSO mode */
+    if (hvf_state->tso_mode) {
+        uint64_t actlr;
+        ret = _hv_vcpu_get_actlr(cpu->hvf->fd, &actlr);
+        assert_hvf_ok(ret);
+        actlr |= ACTLR_EL1_TSO_ENABLE_MASK;
+        ret = _hv_vcpu_set_actlr(cpu->hvf->fd, actlr);
+        assert_hvf_ok(ret);
+    }
+#endif
+
     return 0;
 }
 
@@ -1343,6 +1355,22 @@ static void hvf_vm_state_change(void *opaque, bool running, RunState state)
     }
 }
 
+hv_return_t hvf_arch_vm_create(HVFState *s)
+{
+#if defined(CONFIG_HVF_PRIVATE)
+    hv_return_t ret;
+    hv_vm_config_t config = hv_vm_config_create();
+    if (s->tso_mode) {
+        _hv_vm_config_set_isa(config, HV_VM_CONFIG_ISA_PRIVATE);
+    }
+    ret = hv_vm_create(config);
+    os_release(config);
+    return ret;
+#else
+    return hv_vm_create(NULL);
+#endif
+}
+
 int hvf_arch_init(void)
 {
     hvf_state->vtimer_offset = mach_absolute_time();
diff --git a/target/i386/hvf/hvf.c b/target/i386/hvf/hvf.c
index 8d2248bb3f6f..8283a9b761b4 100644
--- a/target/i386/hvf/hvf.c
+++ b/target/i386/hvf/hvf.c
@@ -212,6 +212,11 @@ void hvf_kick_vcpu_thread(CPUState *cpu)
     cpus_kick_thread(cpu);
 }
 
+hv_return_t hvf_arch_vm_create(HVFState *s)
+{
+    return hv_vm_create(HV_VM_DEFAULT);
+}
+
 int hvf_arch_init(void)
 {
     return 0;

From c874e68e5a1635326f8a2f52320b8dbe82f6be51 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Fri, 30 Dec 2022 20:24:00 -0800
Subject: [PATCH 178/180] tcti: disable TARGET_TB_PCREL for TCTI

It is currently not supported.
---
 target/arm/cpu-param.h  | 2 ++
 target/i386/cpu-param.h | 2 +-
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/target/arm/cpu-param.h b/target/arm/cpu-param.h
index 53cac9c89bf9..6c4af8f0d258 100644
--- a/target/arm/cpu-param.h
+++ b/target/arm/cpu-param.h
@@ -31,7 +31,9 @@
 # define TARGET_PAGE_BITS_VARY
 # define TARGET_PAGE_BITS_MIN  10
 
+#ifndef CONFIG_TCG_THREADED_INTERPRETER
 # define TARGET_TB_PCREL 1
+#endif
 
 /*
  * Cache the attrs and shareability fields from the page table entry.
diff --git a/target/i386/cpu-param.h b/target/i386/cpu-param.h
index f579b16bd279..0975265ff3d1 100644
--- a/target/i386/cpu-param.h
+++ b/target/i386/cpu-param.h
@@ -25,7 +25,7 @@
 #define TARGET_PAGE_BITS 12
 #define NB_MMU_MODES 5
 
-#ifndef CONFIG_USER_ONLY
+#if !defined(CONFIG_USER_ONLY) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 # define TARGET_TB_PCREL 1
 #endif
 

From 80c0e3099fe82b61e7a094f9f24a3c4aa030d5f3 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 1 Jan 2023 16:51:56 -0800
Subject: [PATCH 179/180] vmnet: stop recieving events when VM is stopped

When the VM is stopped using the HMP command "stop", soon the handler will
stop reading from the vmnet interface. This causes a flood of
`VMNET_INTERFACE_PACKETS_AVAILABLE` events to arrive and puts the host CPU
at 100%. We fix this by removing the event handler from vmnet when the VM
is no longer in a running state and restore it when we return to a running
state.
---
 net/vmnet-common.m | 48 +++++++++++++++++++++++++++++++++-------------
 net/vmnet_int.h    |  2 ++
 2 files changed, 37 insertions(+), 13 deletions(-)

diff --git a/net/vmnet-common.m b/net/vmnet-common.m
index 2cb60b9ddde7..295828348501 100644
--- a/net/vmnet-common.m
+++ b/net/vmnet-common.m
@@ -17,6 +17,7 @@
 #include "clients.h"
 #include "qemu/error-report.h"
 #include "qapi/error.h"
+#include "sysemu/runstate.h"
 
 #include <vmnet/vmnet.h>
 #include <dispatch/dispatch.h>
@@ -242,6 +243,35 @@ static void vmnet_bufs_init(VmnetState *s)
     }
 }
 
+/**
+ * Called on state change to un-register/re-register handlers
+ */
+static void vmnet_vm_state_change_cb(void *opaque, bool running, RunState state)
+{
+    VmnetState *s = opaque;
+
+    if (running) {
+        vmnet_interface_set_event_callback(
+            s->vmnet_if,
+            VMNET_INTERFACE_PACKETS_AVAILABLE,
+            s->if_queue,
+            ^(interface_event_t event_id, xpc_object_t event) {
+                assert(event_id == VMNET_INTERFACE_PACKETS_AVAILABLE);
+                /*
+                 * This function is being called from a non qemu thread, so
+                 * we only schedule a BH, and do the rest of the io completion
+                 * handling from vmnet_send_bh() which runs in a qemu context.
+                 */
+                qemu_bh_schedule(s->send_bh);
+            });
+    } else {
+        vmnet_interface_set_event_callback(
+            s->vmnet_if,
+            VMNET_INTERFACE_PACKETS_AVAILABLE,
+            NULL,
+            NULL);
+    }
+}
 
 int vmnet_if_create(NetClientState *nc,
                     xpc_object_t if_desc,
@@ -329,19 +359,9 @@ int vmnet_if_create(NetClientState *nc,
     s->packets_send_current_pos = 0;
     s->packets_send_end_pos = 0;
 
-    vmnet_interface_set_event_callback(
-        s->vmnet_if,
-        VMNET_INTERFACE_PACKETS_AVAILABLE,
-        s->if_queue,
-        ^(interface_event_t event_id, xpc_object_t event) {
-            assert(event_id == VMNET_INTERFACE_PACKETS_AVAILABLE);
-            /*
-             * This function is being called from a non qemu thread, so
-             * we only schedule a BH, and do the rest of the io completion
-             * handling from vmnet_send_bh() which runs in a qemu context.
-             */
-            qemu_bh_schedule(s->send_bh);
-        });
+    vmnet_vm_state_change_cb(s, 1, RUN_STATE_RUNNING);
+
+    s->change = qemu_add_vm_change_state_handler(vmnet_vm_state_change_cb, s);
 
     return 0;
 }
@@ -356,6 +376,8 @@ void vmnet_cleanup_common(NetClientState *nc)
         return;
     }
 
+    vmnet_vm_state_change_cb(s, 0, RUN_STATE_SHUTDOWN);
+    qemu_del_vm_change_state_handler(s->change);
     if_stopped_sem = dispatch_semaphore_create(0);
     vmnet_stop_interface(
         s->vmnet_if,
diff --git a/net/vmnet_int.h b/net/vmnet_int.h
index adf6e8c20d5d..ffba92108fe2 100644
--- a/net/vmnet_int.h
+++ b/net/vmnet_int.h
@@ -46,6 +46,8 @@ typedef struct VmnetState {
     int packets_send_end_pos;
 
     struct iovec iov_buf[VMNET_PACKETS_LIMIT];
+
+    VMChangeStateEntry *change;
 } VmnetState;
 
 const char *vmnet_status_map_str(vmnet_return_t status);

From 550af33ef5b7840c4b3419b1119d844f4725e609 Mon Sep 17 00:00:00 2001
From: Katherine Temkin <k@ktemkin.com>
Date: Fri, 2 Sep 2022 15:40:24 -0600
Subject: [PATCH 180/180] meson tweaks for building with and _without_ JIT

---
 meson.build | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/meson.build b/meson.build
index d87943c90234..47d2f00ff6e2 100644
--- a/meson.build
+++ b/meson.build
@@ -233,6 +233,8 @@ if not get_option('hax').disabled()
   endif
 endif
 
+tcti_gadgets = files()
+
 tcg_arch = config_host['ARCH']
 if not get_option('tcg').disabled()
   if cpu not in supported_cpus
